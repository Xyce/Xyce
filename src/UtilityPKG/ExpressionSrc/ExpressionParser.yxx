/*-------------------------------------------------------------------------
//   Copyright 2002-2020 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------
*/
%skeleton "lalr1.cc"
%require  "3.0.4"
%parse-param {Xyce::Util::ExpressionLexer *theLexer}
%parse-param {Xyce::Util::newExpression & newExp}
%lex-param {Xyce::Util::ExpressionLexer *theLexer}

// This feature throws off "deprecated" warnings in more recent version so of Bison.
// Starting in Bison 3.3, the proper way to define the class name is:  %define api.parser.class {ExpressionParser}
%define parser_class_name "ExpressionParser"
%locations
%defines
%define api.prefix {XyceExpression}

// Variants is an experiment.  the api.token.constructor can go along with it
%define api.value.type variant
// the api.token.constructor changes the number of arguments to yylex from 3 to 1.  So for now, don't do it?
//%define api.token.constructor

// This feature was introduced in Bison 3.5.  It disallows character literals like '+', and makes the parser more efficient.
// ERK: this does not appear to make a huge performance difference.
// %define api.token.raw

%code top {

#include <iostream>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <unordered_map>
#include <map>
#include <vector>
#include <cmath>
#include <complex>

#include <Teuchos_RCP.hpp>

#include "location.hh"
#include "position.hh"
#include <N_ERH_Message.h>
#include "ExpressionType.h"
#include "ast.h"
#include "newExpression.h"

namespace Xyce {
namespace Util {
class ExpressionLexer;
}}

}

%code {
#undef yylex
#include <FlexLexer.h>
#include "ExpressionLexer.h"
#define yylex XyceExpressionlex

int XyceExpressionlex(
    XyceExpression::ExpressionParser::semantic_type *lvalp, 
    XyceExpression::location *locp,
    Xyce::Util::ExpressionLexer *theLexer);
}


//-------------------------------------------------------------------------
// This code block contains functions called directly from the various 
// actions associated with rules, below.  These are not required by the 
// Bison structure in the way that things like "#define yylex" are 
// required.  So, where it appears in the file is probably less 
// restrictive and should be in its own separate block.
//-------------------------------------------------------------------------
%code {
//-------------------------------------------------------------------------
// Function      : checkGroundName
// Purpose       : checks if the name of a voltage node is a synonym for ground
// Special Notes :
// Scope         :
// Creator       : Eric Keiter
// Creation Date : 9/3/2020
//-------------------------------------------------------------------------
bool checkGroundNodeName(std::string & name)
{
  std::string tmpName = name;
  Xyce::Util::toUpper(tmpName);

  if (tmpName == std::string("0")) { return true; }
  if (tmpName == std::string("GND")) { return true; }

  bool thisIsNotGround=true;
  if (tmpName.size() > 1)
  {
    int last = tmpName.size()-1;
    std::string endOfName = tmpName.substr(last-1,last);
    if (endOfName == ":0") { thisIsNotGround=false; }
  }
  if (!thisIsNotGround) { return true; }

  return false;
}

//-------------------------------------------------------------------------
// Function      : createVoltageOp
// Purpose       : Does work required by the rules for voltage operators
// Special Notes : This is a separate function, b/c two rules use it.
// Scope         :
// Creator       : Eric Keiter
// Creation Date : 9/3/2020
//-------------------------------------------------------------------------
Teuchos::RCP<astNode<usedType> > * createVoltageOp(
    Xyce::Util::newExpression & newExp,
    const std::string & prefix, const std::vector<std::string> & nodes)
{
  std::vector<std::string> voltageNodes = nodes;
  Teuchos::RCP<astNode<usedType> > * tmpPtr;
  Teuchos::RCP<astNode<usedType> > * returnPtr;

  std::vector<std::string> & voltNameVec = newExp.getVoltNameVec ();
  std::vector<Teuchos::RCP<astNode<usedType> > > & voltOpVec = newExp.getVoltOpVec();
  std::unordered_map<std::string,std::vector<Teuchos::RCP<astNode<usedType> > > > & voltOpMap = newExp.getLocalVoltOpMap();

  if (voltageNodes.size() == 1)
  {
    if ( !checkGroundNodeName(voltageNodes[0]) )
    {
      // ensure that each voltage has a single, unique astNode allocated for it
      if ( voltOpMap.find( voltageNodes[0] ) == voltOpMap.end() )
      {
        Teuchos::RCP<voltageOp<usedType> > * voltPtr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(voltageNodes));
        tmpPtr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
        newExp.getVoltOpVec ().push_back(*voltPtr);
        voltNameVec.push_back( voltageNodes[0] );

        std::vector<Teuchos::RCP<astNode<usedType> > > vec;
        vec.push_back(*voltPtr);
        voltOpMap[ voltageNodes[0] ] = vec;
        delete voltPtr;
      }
      else
      {
        Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(voltOpMap[voltageNodes[0]][0]);
        tmpPtr = tmpPtr2;
      }
    }
    else
    {
      Teuchos::RCP<astNode<usedType> > *voltPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(0.0));
      tmpPtr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
      delete voltPtr;
    }
    newExp.getMasterNodeVec().push_back(tmpPtr);
  }
  // For the nodal difference use case, V(A,B) is handled as follows.
  // Instead of having the voltageOp class handle the differencing, 
  // create two voltage node objects, one for V(A) and one for V(B) and then
  // pass them as arguments to a binaryMinusOp operator.
  else if (voltageNodes.size() == 2) 
  {
    Teuchos::RCP<astNode<usedType> > * tmp1Ptr;
    Teuchos::RCP<astNode<usedType> > * tmp2Ptr;

    if ( !checkGroundNodeName( voltageNodes[0]) )
    {
      // ensure that each voltage has a single, unique astNode allocated for it
      if ( voltOpMap.find( voltageNodes[0] ) == voltOpMap.end() )
      {
        std::vector<std::string> nodes1;
        nodes1.push_back(voltageNodes[0]);
        Teuchos::RCP<voltageOp<usedType> > * volt1Ptr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(nodes1));
        tmp1Ptr = new Teuchos::RCP<astNode<usedType> >(*volt1Ptr);
        voltOpVec.push_back(*volt1Ptr);
        voltNameVec.push_back( voltageNodes[0] );

        std::vector<Teuchos::RCP<astNode<usedType> > > vec;
        vec.push_back(*volt1Ptr);
        voltOpMap[ voltageNodes[0] ] = vec;
        delete volt1Ptr;
      }
      else
      {
        Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(voltOpMap[voltageNodes[0]][0]);
        tmp1Ptr = tmpPtr2;
      }
    }
    else
    {
      Teuchos::RCP<astNode<usedType> > *voltPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(0.0));
      tmp1Ptr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
      delete voltPtr;
    }

    if ( !checkGroundNodeName( voltageNodes[1]) )
    {
      // ensure that each voltage has a single, unique astNode allocated for it
      if ( voltOpMap.find( voltageNodes[1] ) == voltOpMap.end() )
      {
        std::vector<std::string> nodes2;
        nodes2.push_back(voltageNodes[1]);
        Teuchos::RCP<voltageOp<usedType> > * volt2Ptr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(nodes2));
        tmp2Ptr = new Teuchos::RCP<astNode<usedType> >(*volt2Ptr);
        voltOpVec.push_back(*volt2Ptr);
        voltNameVec.push_back( voltageNodes[1] );

        std::vector<Teuchos::RCP<astNode<usedType> > > vec;
        vec.push_back(*volt2Ptr);
        voltOpMap[ voltageNodes[1] ] = vec;
        delete volt2Ptr;
      }
      else
      {
        Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(voltOpMap[voltageNodes[1]][0]);
        tmp2Ptr = tmpPtr2;
      }
    }
    else
    {
      Teuchos::RCP<astNode<usedType> > *voltPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(0.0));
      tmp2Ptr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
      delete voltPtr;
    }

    tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMinusOp<usedType>  (*tmp1Ptr,*tmp2Ptr));
    newExp.getMasterNodeVec().push_back(tmp1Ptr);
    newExp.getMasterNodeVec().push_back(tmp2Ptr);
    newExp.getMasterNodeVec().push_back(tmpPtr);
  }

  // adjust for complex number variants
  // remove whitespace from the first argument
  std::string firstArg = (prefix);
  firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());
  if (firstArg.size() == 1)
  {
    returnPtr = tmpPtr;
  }
  else if (firstArg.size() == 2)
  {
     if ( firstArg == std::string("VR") )
     {
       returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
       newExp.getMasterNodeVec().push_back(returnPtr);
     }
     else if ( firstArg == std::string("VI") )
     {
       returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
       newExp.getMasterNodeVec().push_back(returnPtr);
     }
     else if ( firstArg == std::string("VM") )
     {
       returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
       newExp.getMasterNodeVec().push_back(returnPtr);
     }
     else if ( firstArg == std::string("VP") )
     {
       returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
       newExp.getMasterNodeVec().push_back(returnPtr);
       newExp.getPhaseOpVec().push_back(*returnPtr);
     }
  }
  else if (firstArg.size() == 3) // do decibels here
  {
    if ( firstArg == std::string("VDB") )
    {
      // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
      Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
      Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
      Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
      returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

      newExp.getMasterNodeVec().push_back(numvalPtr);
      newExp.getMasterNodeVec().push_back(absPtr);
      newExp.getMasterNodeVec().push_back(log10Ptr);
      newExp.getMasterNodeVec().push_back(returnPtr);
    }
  }
  else
  {
    std::cout << "Unrecognized voltage operator " << firstArg << std::endl;
  }

  return returnPtr;
}

//-------------------------------------------------------------------------
// Function      : createCurrentOp
// Purpose       : Does work required by the rules for current operators
// Special Notes : This is a separate function, b/c two rules use it.
// Scope         :
// Creator       : Eric Keiter
// Creation Date : 9/3/2020
//-------------------------------------------------------------------------
Teuchos::RCP<astNode<usedType> > * createCurrentOp(
    Xyce::Util::newExpression & newExp,
    const std::string & prefix, const std::string & device)
{
  Teuchos::RCP<astNode<usedType> > * returnPtr;

  std::string firstArg = prefix;
  firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());

  std::string deviceName = device;
  deviceName.erase(std::remove_if(deviceName.begin(),deviceName.end(), ::isspace), deviceName.end());
  std::string originalDeviceName = deviceName;

  if ( !(deviceName.empty()) && ( deviceName[0] == 'X' ))// inside a subcircuit.  So, for the logic below, need to strip out everything until the last ":"
  {
    std::size_t found = deviceName.find_last_of(":");
    if ( found != std::string::npos) { deviceName = deviceName.substr(found+1); }
  }

  // allocate either a solution variable current object or a lead current object.  
  Teuchos::RCP<astNode<usedType> > * tmpPtr;
  if ( !(deviceName.empty()) && ( 
        deviceName[0] == 'V' ||
        deviceName[0] == 'B' ||  // Bsrc's can be either one, but impossible to tell which at the expression parsing stage
        deviceName[0] == 'E' ||
        deviceName[0] == 'H' ||
        deviceName[0] == 'L' )) // solution variable current
  {
    // ensure that each current has a single, unique astNode allocated for it
    std::vector<std::string> & currentNameVec = newExp.getCurrentNameVec ();
    std::vector<Teuchos::RCP<astNode<usedType> > > & currentOpVec = newExp.getCurrentOpVec ();
    std::unordered_map<std::string,std::vector<Teuchos::RCP<astNode<usedType> > > > & currentOpMap = newExp.getLocalCurrentOpMap ();
    if ( currentOpMap.find(originalDeviceName) == currentOpMap.end() )
    {
      Teuchos::RCP<currentOp<usedType> > * currentPtr = new Teuchos::RCP<currentOp<usedType> >(new currentOp<usedType>(originalDeviceName));
      tmpPtr = new Teuchos::RCP<astNode<usedType> >(*currentPtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      currentOpVec.push_back(*currentPtr);
      if (deviceName[0] == 'B')  
      { 
        (*currentPtr)->setBsrcFlag();
        newExp.getBsrcCurrentOpVec().push_back(*currentPtr);  // this object is necessary because Bsrc's can be either lead or solution var

        std::vector<std::string> & leadCurrentNameVec = newExp.getLeadCurrentNameVec();
        std::vector<std::string>::iterator nameIter = std::find(leadCurrentNameVec.begin(),leadCurrentNameVec.end(), originalDeviceName);
        if ( nameIter == leadCurrentNameVec.end() )
        {
          leadCurrentNameVec.push_back(originalDeviceName);
        }
      }
      currentNameVec.push_back( originalDeviceName );

      std::vector<Teuchos::RCP<astNode<usedType> > > vec;
      vec.push_back(*currentPtr);
      currentOpMap[originalDeviceName] = vec;
      delete currentPtr;
    }
    else
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(currentOpMap[ originalDeviceName  ][0]);
      newExp.getMasterNodeVec().push_back(tmpPtr2);
      tmpPtr = tmpPtr2;
    }
  }
  else // lead current.  Previously, this block was below the "complex variant" block.  
       // Now it is here.  At present, no lead currents are complex numbers, but in theory that will change.
  {
    // lead currents are a little more tricky, so I'm not attempting to ensure uniqueness for now.
    Teuchos::RCP<leadCurrentOp<usedType> > * leadCurrentPtr = new Teuchos::RCP<leadCurrentOp<usedType> >(new leadCurrentOp<usedType>(firstArg,device));
    tmpPtr = new Teuchos::RCP<astNode<usedType> >(*leadCurrentPtr);
    newExp.getLeadCurrentOpVec().push_back(*leadCurrentPtr);
    newExp.getMasterNodeVec().push_back(tmpPtr);
    delete leadCurrentPtr;

    std::vector<std::string> & leadCurrentNameVec = newExp.getLeadCurrentNameVec();
    std::vector<std::string> & leadCurrentExcludeBsrcNameVec = newExp.getLeadCurrentExcludeBsrcNameVec();
    std::vector<std::string>::iterator nameIter = std::find(leadCurrentNameVec.begin(),leadCurrentNameVec.end(), originalDeviceName);
    if ( nameIter == leadCurrentNameVec.end() )
    {
      leadCurrentNameVec.push_back(originalDeviceName);
      leadCurrentExcludeBsrcNameVec.push_back(originalDeviceName);
    }
  }

  {
    // adjust for complex number variants
    if (firstArg.size() == 1)
    {
      returnPtr = tmpPtr;
    }
    else if (firstArg.size() == 2)
    {
       if ( firstArg == std::string("IR") )
       {
         returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
         newExp.getMasterNodeVec().push_back(returnPtr);
       }
       else if ( firstArg == std::string("II") )
       {
         returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
         newExp.getMasterNodeVec().push_back(returnPtr);
       }
       else if ( firstArg == std::string("IM") )
       {
         returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
         newExp.getMasterNodeVec().push_back(returnPtr);
       }
       else if ( firstArg == std::string("IP") )
       {
         returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
         newExp.getMasterNodeVec().push_back(returnPtr);
         newExp.getPhaseOpVec().push_back(*returnPtr);
       }
    }
    else if (firstArg.size() == 3) // do decibels here
    {
      if ( firstArg == std::string("IDB") )
      {
        // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
        Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
        Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
        Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
        returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

        newExp.getMasterNodeVec().push_back(numvalPtr);
        newExp.getMasterNodeVec().push_back(absPtr);
        newExp.getMasterNodeVec().push_back(log10Ptr);
        newExp.getMasterNodeVec().push_back(returnPtr);
      }
    }
    else
    {
      std::cout << "Unrecognized current operator " << firstArg << std::endl;
    }

    return returnPtr;
  }
}

}

// value tokens from the lexer (ExpressionLexer.l)
%token <double> TOK_POLYSIZE	"polysize"
%token <double> TOK_POLYCOEF "polycoef"
%token <double> TOK_NUM	"num"
%token <double> TOK_IMAG_NUM	"imag_num"
%token <std::string *> TOK_WORD "word"
%token <std::string *> TOK_FUNCTION "function"
%token <std::string *> TOK_LEAD "lead"
%token <std::string *> TOK_ONOISE "onoise"
%token <std::string *> TOK_INOISE "inoise"
%token <std::string *> TOK_POWER "power"
%token <std::string *> TOK_VOLTAGE "voltage"
%token <std::string *> TOK_VOLTAGENODE "voltagenode"
%token <std::string *> TOK_POLY_VOLTAGE "poly_voltage"
%token <std::string *> TOK_CURRENT "current"
%token <std::string *> TOK_CURRENTDEV "currentdevice"
%token <std::string *> TOK_POLY_CURRENT "poly_current"
%token <std::string *> TOK_INTERNAL_VAR "internal_variable"
%token <std::string *> TOK_INTERNAL_VAR_DEV "internal_variable_device"
%token <std::string *> TOK_NOISE "noise"
%token <std::string *> TOK_NOISE_DEV_VAR "noise_device_variable"
%token <std::string *> TOK_RFPARAM "rfparam"
%token <int> TOK_RFPARAM_ARG "rf_param_arg"

// non-value tokens from the lexer (ExpressionLexer.l)
%token TOK_SQRT	"sqrt"
%token TOK_MAX	"max"
%token TOK_MIN	"min"
%token TOK_PHASE	"phase"
%token TOK_REAL	"real"
%token TOK_IMAG	"imag"
%token TOK_EXP	"exp"
%token TOK_SIN	"sin"
%token TOK_COS	"cos"
%token TOK_MABS	"m"
%token TOK_ABS	"abs"
%token TOK_ACOS	"acos"
%token TOK_ACOSH	"acosh"
%token TOK_ASIN	"asin"
%token TOK_ASINH	"asinh"
%token TOK_ATAN2	"atan2"
%token TOK_ATAN	"atan"
%token TOK_ATANH	"atanh"
%token TOK_COSH	"cosh"
%token TOK_LN	"ln"
%token TOK_LOG	"log"
%token TOK_LOG10	"log10"
%token TOK_SINH	"sinh"
%token TOK_TAN	"tan"
%token TOK_TANH	"tanh"
%token TOK_IF "if"
%token TOK_EQUALS "equals"
%token TOK_SEMICOLON "semicolon"

%token TOK_AUNIF	"aunif"
%token TOK_UNIF	"unif"
%token TOK_AGAUSS	"agauss"
%token TOK_CEIL	"ceil"
%token TOK_GAUSS	"gauss"
%token TOK_DDT	"ddt"
%token TOK_DDX	"ddx"
%token TOK_FLOOR	"floor"
%token TOK_INT 	"int"
%token TOK_LIMIT 	"limit"
%token TOK_POWSFUNC 	"pwrs"
%token TOK_RAND	"rand"
%token TOK_SDT	"sdt"
%token TOK_SGN	"sgn"
%token TOK_SIGN	"sign"
%token TOK_STP	"stp"
%token TOK_TABLE	"table"
%token TOK_TABLE2	"table2"
%token TOK_TABLE3	"table3"
%token TOK_SCHEDULE	"schedule"
%token TOK_URAMP	"uramp"
 /* %token TOK_POLY	"poly" */
%token TOK_BADPOLY	"bad_poly"

%token TOK_SPICE_PULSE "spice_pulse"
%token TOK_SPICE_SIN "spice_sin"
%token TOK_SPICE_EXP "spice_exp"
%token TOK_SPICE_SFFM "spice_sffm"

%token TOK_TIME  "time"
%token TOK_TEMP  "temp"
%token TOK_VT    "vt"
%token TOK_FREQ  "freq"
%token TOK_GMIN  "gmin"
%token TOK_PI    "pi"
%token TOK_C_TO_K    "CtoK"

%token TOK_RIGHTPAREN "rightparen"
%token TOK_LEFTPAREN  "leftparen"
%token TOK_RIGHTCURLYBRACE "rightcurlybrace"
%token TOK_LEFTCURLYBRACE  "leftcurlybrace"

// types for nonterminal operators
%type  <Teuchos::RCP<astNode<usedType> > *>   exp
%type  <Teuchos::RCP<astNode<usedType> > *>   expression
%type  <Teuchos::RCP<astNode<usedType> > *>   table_threeOrFourArgs 
%type  <Teuchos::RCP<astNode<usedType> > *>   table2_threeOrFourArgs  
%type  <Teuchos::RCP<astNode<usedType> > *>   table3_threeOrFourArgs 
%type  <std::vector< Teuchos::RCP<astNode<usedType> > > *>   nonempty_func_arglist
%type  <std::vector< Teuchos::RCP<astNode<usedType> > > *>   nonempty_func_arglist2
%type  <std::vector< Teuchos::RCP<astNode<usedType> > > *>   two_or_more_arglist
%type  <std::vector< Teuchos::RCP<astNode<usedType> > > *>   nonempty_arg_pairs 
%type  <std::vector< Teuchos::RCP<astNode<usedType> > > *>   poly_coeflist 
%type  <std::vector<std::string> *>  nonempty_voltagenodelist
%type  <std::vector<int> *>  nonempty_rfparam_arg_list
%type  <std::vector<std::string> *>  nonempty_noise_device_list

%type  <Teuchos::RCP<astNode<usedType> > *>   polyarg
%type  <std::pair<double, std::vector< Teuchos::RCP<astNode<usedType> > > > *>   polypair
%type  <double>  paren_polycoef 

// most of these will/should go ....
//%destructor { delete $$; } TOK_WORD
//%destructor { delete $$; } TOK_FUNCTION
//%destructor { delete $$; } TOK_LEAD
//%destructor { delete $$; } TOK_VOLTAGE
//%destructor { delete $$; } TOK_VOLTAGENODE
//%destructor { delete $$; } TOK_POLY_VOLTAGE
//%destructor { delete $$; } TOK_CURRENT
//%destructor { delete $$; } TOK_CURRENTDEV
//%destructor { delete $$; } TOK_POLY_CURRENT
//%destructor { delete $$; } TOK_INTERNAL_VAR
//%destructor { delete $$; } TOK_INTERNAL_VAR_DEV
//%destructor { delete $$; } TOK_NOISE
//%destructor { delete $$; } TOK_NOISE_DEV_VAR
//%destructor { delete $$; } TOK_ONOISE
//%destructor { delete $$; } TOK_INOISE
//%destructor { delete $$; } TOK_POWER
//%destructor { delete $$; } TOK_RFPARAM
//%destructor { delete $$; } nonempty_voltagenodelist
//%destructor { delete $$; } nonempty_rfparam_arg_list
//%destructor { delete $$; } nonempty_noise_device_list


// Operator Precedence tokens
%left   TOK_COMMA ","
%right  TOK_QUESTION_MARK "?"  TOK_COLON ":"
%left  TOK_OR "||" TOK_AND "&&"
%left  TOK_NOT "~" 
  /* %left  TOK_XOR "^" */
%left TOK_CARET "^"
%left  TOK_EQ	"==" TOK_NE	"!=" TOK_LE	"<=" TOK_LT	"<" TOK_GE	">=" TOK_GT	">"
%left TOK_INVALID_OP
%left   TOK_MINUS "-" TOK_PLUS "+"
%left   TOK_MOD "%"
%left   TOK_MULTIPLY "*" TOK_DIVIDE "/"
%left   NEG  /* unary minus */
%right   TOK_POW  TOK_POWFUNC  /* exponentiation */

%%
expression: exp
  {
      if (yynerrs_ != 0)
      {
        YYABORT;
      }
      else
      {
        newExp.setAstPtr(*$1);

        YYACCEPT;
      }
 }

exp:
    TOK_NUM
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($1));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
   | TOK_IMAG_NUM 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(std::complex<basicType>(0.0,$1)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_WORD
      {
        // ensure that each parameter and/or function argument  has a single, unique astNode allocated for it
        //
        // note that maps are not used here, intentionally, so as to preseve the original order of params.
        // using a std::vector for the names and a separate vector for the paramOps keeps them in order user specified.
        std::vector<std::string> & paramNameVec = newExp.getParamNameVec ();
        std::vector<Teuchos::RCP<astNode<usedType> > > & paramOpVec = newExp.getParamOpVec ();
        std::unordered_map<std::string,std::vector<Teuchos::RCP<astNode<usedType> > > > & paramOpMap = newExp.getParamOpMap ();

        //std::vector<std::string>::iterator nameIter = std::find(paramNameVec.begin(),paramNameVec.end(), *$1);
        //if ( nameIter == paramNameVec.end() )
        if ( paramOpMap.find( *$1 ) == paramOpMap.end() )
        {
          Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new paramOp<usedType>(*$1));
          paramOpVec.push_back(*tmpPtr);

          std::vector<Teuchos::RCP<astNode<usedType> > > vec;
          vec.push_back(*tmpPtr);
          paramOpMap[*$1] = vec;

          paramNameVec.push_back(*$1);
          Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(*tmpPtr);
          newExp.getMasterNodeVec().push_back(tmpPtr2);

          $$ = tmpPtr2;
          delete tmpPtr;
        }
        else
        {
          //int index = std::distance(paramNameVec.begin(),nameIter);
          //Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(paramOpVec[index]);

          Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(paramOpMap[*$1][0]);
          newExp.getMasterNodeVec().push_back(tmpPtr2);
          $$ = tmpPtr2;
        }
        delete $1;
    }
  | TOK_TIME
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(timeNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_TEMP
    {
      Teuchos::RCP<astNode<usedType> > tempNode =newExp.getTempNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tempNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTempDependent(true);
    }
  | TOK_VT
    {
      Teuchos::RCP<astNode<usedType> > vtNode = newExp.getVtNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(vtNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setVTDependent(true);
    }
  | TOK_FREQ
    {
      Teuchos::RCP<astNode<usedType> > freqNode = newExp.getFreqNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(freqNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setFreqDependent(true);
    }
  | TOK_GMIN
    {
      Teuchos::RCP<astNode<usedType> > gminNode = newExp.getGminNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(gminNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setGminDependent(true);
    }
  | TOK_PI
    {
      Teuchos::RCP<astNode<usedType> > piNode = newExp.getPiNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(piNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_C_TO_K
    {
      Teuchos::RCP<astNode<usedType> > CtoKNode = newExp.getCtoKNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(CtoKNode);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_PLUS exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryAddOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_MINUS exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMinusOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_MULTIPLY exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_DIVIDE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryDivOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_MOD exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryModOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | exp TOK_POW exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
   | TOK_POWFUNC exp TOK_COMMA exp TOK_RIGHTPAREN 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POWSFUNC exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new pwrsOp<usedType>  (*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LEFTPAREN exp TOK_RIGHTPAREN
    {
       $$ = $2;
    }
  | TOK_LEFTCURLYBRACE exp TOK_RIGHTCURLYBRACE
    {
       $$ = $2;
    }
  | TOK_MINUS exp  %prec NEG
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryMinusOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_PLUS exp 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryPlusOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SGN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sgnOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SIGN exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new signOp<usedType>(*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_FUNCTION nonempty_func_arglist 
     {
        // remove whitespace from the function name
        std::string functionName = (*$1);
        functionName.erase(std::remove_if(functionName.begin(),functionName.end(), ::isspace), functionName.end());

        Teuchos::RCP<funcOp<usedType> > funcPtr = Teuchos::rcp(new funcOp<usedType>(functionName,$2));
        newExp.getFuncOpVec().push_back(funcPtr);

        std::unordered_map<std::string,std::vector<Teuchos::RCP<astNode<usedType> > > > & funcOpMap 
          = newExp.getFuncOpMap();

        Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(funcPtr); // implicit cast
        newExp.getMasterNodeVec().push_back(tmpPtr2);

        if (funcOpMap.find(functionName) == funcOpMap.end())
        {
          std::vector<Teuchos::RCP<astNode<usedType> > > vec;//(1,tmpPtr2);
          vec.push_back(*tmpPtr2);
          funcOpMap[functionName] = vec;
          newExp.getFuncNameVec().push_back(functionName);
        }
        else
        {
          funcOpMap[functionName].push_back(*tmpPtr2);
        }

        $$ = tmpPtr2;
        delete $1;
        delete $2;
    }
  | TOK_VOLTAGE nonempty_voltagenodelist
    {
      $$ = createVoltageOp(newExp,*$1,*$2);
      delete $1;
      delete $2;
    }
  | TOK_CURRENT TOK_CURRENTDEV
    {
      $$ = createCurrentOp(newExp,*$1,*$2);
      delete $1;
      delete $2;
    }
  | TOK_RFPARAM nonempty_rfparam_arg_list
    {
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());

      std::vector<int> sparamIndices = *$2; 
      Teuchos::RCP<astNode<usedType> > * tmpPtr;
      Teuchos::RCP<astNode<usedType> > * returnPtr;
      if (sparamIndices.size() == 2)
      {
        if (firstArg[0] == 'S')
        {
          Teuchos::RCP<sparamOp<usedType> > * sparPtr = new Teuchos::RCP<sparamOp<usedType> >(new sparamOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*sparPtr);
          newExp.getSparamOpVec ().push_back(*sparPtr);
          delete sparPtr;
        }
        else if (firstArg[0] == 'Y')
        {
          Teuchos::RCP<yparamOp<usedType> > * yparPtr = new Teuchos::RCP<yparamOp<usedType> >(new yparamOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*yparPtr);
          newExp.getYparamOpVec ().push_back(*yparPtr);
          delete yparPtr;
        }
        else if (firstArg[0] == 'Z')
        {
          Teuchos::RCP<zparamOp<usedType> > * zparPtr = new Teuchos::RCP<zparamOp<usedType> >(new zparamOp<usedType>(*$2));
          tmpPtr = new Teuchos::RCP<astNode<usedType> >(*zparPtr);
          newExp.getZparamOpVec ().push_back(*zparPtr);
          delete zparPtr;
        }
        else
        {
          std::cout << "Unrecognized RF parameter: " << firstArg <<std::endl;
        }

        newExp.getMasterNodeVec().push_back(tmpPtr);

        // adjust for complex number variants
        // remove whitespace from the first argument
        if (firstArg.size() == 1)
        {
          returnPtr = tmpPtr;
        }
        else if (firstArg.size() == 2)
        {
           if ( firstArg[1] == 'R')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg[1] == 'I')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg[1] == 'M')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
           }
           else if ( firstArg[1] == 'P')
           {
             returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
             newExp.getMasterNodeVec().push_back(returnPtr);
             newExp.getPhaseOpVec().push_back(*returnPtr);
           }
        }
        else if (firstArg.size() == 3) // do decibels here
        {
          if ( firstArg[1] == 'D' && firstArg[2] == 'B')
          {
            // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
            Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
            Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
            Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
            returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

            newExp.getMasterNodeVec().push_back(numvalPtr);
            newExp.getMasterNodeVec().push_back(absPtr);
            newExp.getMasterNodeVec().push_back(log10Ptr);
            newExp.getMasterNodeVec().push_back(returnPtr);
          }
        }
        else
        {
          std::cout << "Unrecognized RF operator " << firstArg << std::endl;
        }
      }
      else
      {
        std::cout << "Wrong number of arguments to S-parameter !" <<std::endl;
      }

      $$ = returnPtr;
      delete $1;
      delete $2;
    }
  | TOK_LEAD TOK_CURRENTDEV
    {
      Teuchos::RCP<leadCurrentOp<usedType> > * leadCurrentPtr = new Teuchos::RCP<leadCurrentOp<usedType> >(new leadCurrentOp<usedType>(*$1,*$2));
      Teuchos::RCP<astNode<usedType> > * returnPtr = new Teuchos::RCP<astNode<usedType> >(*leadCurrentPtr);
      newExp.getLeadCurrentOpVec().push_back(*leadCurrentPtr);
      newExp.getMasterNodeVec().push_back(returnPtr);
      $$ = returnPtr;

      std::vector<std::string> & leadCurrentNameVec = newExp.getLeadCurrentNameVec();
      std::vector<std::string> & leadCurrentExcludeBsrcNameVec = newExp.getLeadCurrentExcludeBsrcNameVec();
      std::vector<std::string>::iterator nameIter = std::find(leadCurrentNameVec.begin(),leadCurrentNameVec.end(), *$2);
      if ( nameIter == leadCurrentNameVec.end() )
      {
        leadCurrentNameVec.push_back(*$2);
        leadCurrentExcludeBsrcNameVec.push_back(*$2);
      }

      delete leadCurrentPtr;
      delete $1;
      delete $2;
    }
  | TOK_INTERNAL_VAR TOK_INTERNAL_VAR_DEV
    {
      Teuchos::RCP<astNode<usedType> > * returnPtr;

      Teuchos::RCP<internalDevVarOp<usedType> > * internalDevVarPtr = new Teuchos::RCP<internalDevVarOp<usedType> >(new internalDevVarOp<usedType>(*$2));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*internalDevVarPtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getInternalDevVarOpVec().push_back(*internalDevVarPtr);

      // adjust for complex number variants
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());
      if (firstArg.size() == 1)
      {
        returnPtr = tmpPtr;
      }
      else if (firstArg.size() == 2)
      {
         if ( firstArg == std::string("NR") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("NI") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("NM") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
         }
         else if ( firstArg == std::string("NP") )
         {
           returnPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*tmpPtr));
           newExp.getMasterNodeVec().push_back(returnPtr);
           newExp.getPhaseOpVec().push_back(*returnPtr);
         }
      }
      else if (firstArg.size() == 3) // do decibels here
      {
        if ( firstArg == std::string("NDB") )
        {
          // this needs to implement 20.0*std::log10(abs(*tmpPtr))  
          Teuchos::RCP<astNode<usedType> > * numvalPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType> (20.0));
          Teuchos::RCP<astNode<usedType> > * absPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*tmpPtr));
          Teuchos::RCP<astNode<usedType> > * log10Ptr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*absPtr));
          returnPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*numvalPtr,*log10Ptr));

          newExp.getMasterNodeVec().push_back(numvalPtr);
          newExp.getMasterNodeVec().push_back(absPtr);
          newExp.getMasterNodeVec().push_back(log10Ptr);
          newExp.getMasterNodeVec().push_back(returnPtr);
        }
      }
      else
      {
        std::cout << "Unrecognized internal variable operator " << firstArg << std::endl;
      }

      $$ = returnPtr;
      delete internalDevVarPtr;
      delete $1;
      delete $2;
    }
  | TOK_NOISE nonempty_noise_device_list
    {
      Teuchos::RCP<astNode<usedType> > * returnPtr;
      std::string firstArg = (*$1);
      firstArg.erase(std::remove_if(firstArg.begin(),firstArg.end(), ::isspace), firstArg.end());

      if ( firstArg == std::string("DNO") )
      {
        Teuchos::RCP<dnoNoiseVarOp<usedType> > * dnoNoiseVarPtr = new Teuchos::RCP<dnoNoiseVarOp<usedType> >(new dnoNoiseVarOp<usedType>(*$2));
        returnPtr = new Teuchos::RCP<astNode<usedType> >(*dnoNoiseVarPtr);
        newExp.getMasterNodeVec().push_back(returnPtr);
        newExp.getDnoNoiseDevVarOpVec().push_back(*dnoNoiseVarPtr);
        delete dnoNoiseVarPtr;
      }
      else if ( firstArg == std::string("DNI") )
      {
        Teuchos::RCP<dniNoiseVarOp<usedType> > * dniNoiseVarPtr = new Teuchos::RCP<dniNoiseVarOp<usedType> >(new dniNoiseVarOp<usedType>(*$2));
        returnPtr = new Teuchos::RCP<astNode<usedType> >(*dniNoiseVarPtr);
        newExp.getMasterNodeVec().push_back(returnPtr);
        newExp.getDniNoiseDevVarOpVec().push_back(*dniNoiseVarPtr);
        delete dniNoiseVarPtr;
      }

      $$ = returnPtr;
      delete $1;
      delete $2;
    }
  | TOK_ONOISE
    {
      Teuchos::RCP<oNoiseOp<usedType> > * onoisePtr = new Teuchos::RCP<oNoiseOp<usedType> >(new oNoiseOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*onoisePtr);
      newExp.getONoiseOpVec().push_back(*onoisePtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      $$ = tmpPtr;
      delete $1;
      delete onoisePtr;
    }
  | TOK_INOISE
    {
      Teuchos::RCP<iNoiseOp<usedType> > * inoisePtr = new Teuchos::RCP<iNoiseOp<usedType> >(new iNoiseOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*inoisePtr);
      newExp.getINoiseOpVec().push_back(*inoisePtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
      $$ = tmpPtr;
      delete $1;
      delete inoisePtr;
    }

  | TOK_MAX  exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new maxOp<usedType>(*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_MIN  exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new minOp<usedType>(*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POWER TOK_CURRENTDEV
    {
      Teuchos::RCP<powerOp<usedType> > * powerPtr = new Teuchos::RCP<powerOp<usedType> >(new powerOp<usedType>(*$1,*$2));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*powerPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getPowerOpVec().push_back(*powerPtr);

      std::vector<std::string> & leadCurrentNameVec = newExp.getLeadCurrentNameVec();
      std::vector<std::string> & leadCurrentExcludeBsrcNameVec = newExp.getLeadCurrentExcludeBsrcNameVec();
      std::vector<std::string>::iterator nameIter = std::find(leadCurrentNameVec.begin(),leadCurrentNameVec.end(), *$2);
      if ( nameIter == leadCurrentNameVec.end() )
      {
        leadCurrentNameVec.push_back(*$2);
        leadCurrentExcludeBsrcNameVec.push_back(*$2);
      }

      delete $1;
      delete $2;
      delete powerPtr;
    }
  | TOK_PHASE exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getPhaseOpVec().push_back(*tmpPtr);
    }
  | TOK_REAL exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_IMAG exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SQRT exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sqrtOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_EXP exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new expOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SIN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sinOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_COS exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new cosOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_MABS exp TOK_RIGHTPAREN 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ABS exp TOK_RIGHTPAREN 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ACOS exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new acosOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ACOSH exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new acoshOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ASIN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new asinOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ASINH exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new asinhOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATAN2 exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atan2Op<usedType>(*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATAN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATANH exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanhOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_COSH exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new coshOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new logOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LOG exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr;
      if (Xyce::Util::useHspiceMath)
      {
        tmpPtr = new Teuchos::RCP<astNode<usedType> >(new logOp<usedType>(*$2));
      }
      else
      {
        tmpPtr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*$2));
      }
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LOG10 exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SINH exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sinhOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_TAN exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tanOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_TANH exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tanhOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_CEIL exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ceilOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_FLOOR exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new floorOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_INT exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new intOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LIMIT exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new twoArgLimitOp<usedType>(*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getTwoArgLimitOpVec ().push_back(*tmpPtr);
      newExp.getLocalTwoArgLimitOpVec ().push_back(*tmpPtr);
    }
  | TOK_LIMIT exp TOK_COMMA exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new limitOp<usedType>(*$2,*$4,*$6));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_STP exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new stpOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getStpNodeVec().push_back(*tmpPtr);
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_URAMP exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new urampOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
   | polypair  poly_coeflist
    {
      // the "pair" contains both the POLYSIZE value as well as a vector of ast nodes (the "args")
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new polyOp<usedType>
          ($1->first, &($1->second), $2));

      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $1;
      delete $2;
    }
  | table3_threeOrFourArgs nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$1,$2)); 
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$1)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $2;
    }
  | table_threeOrFourArgs nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$1,$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$1)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $2;
    }
  | table_threeOrFourArgs nonempty_func_arglist2
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$1,$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$1)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $2;
    }
  | table2_threeOrFourArgs nonempty_arg_pairs 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$1,$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( (*$1)->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $2;
    }

    /* excluding this pattern b/c it causes shift/reduce errors.  
     * But this particular pattern doesn't seem to be used by any existing tests 
  | table2_with_nonempty_arglist 
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>($1->first,&($1->second)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      if ( $1->first->timeSpecialType() )
      {
        newExp.getSrcNodeVec().push_back(*tmpPtr);
        newExp.setTimeDependent(true); 
      }
      delete $1;
    }
    */
  | TOK_SCHEDULE nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new scheduleOp<usedType>($2, timeNode));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $2;
    }
  | TOK_SDT exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > dtNode = newExp.getDtNode();
      Teuchos::RCP<astNode<usedType> > * sdtPtr = new Teuchos::RCP<astNode<usedType> >(new sdtOp<usedType>(*$2, dtNode, timeNode));
      $$ = sdtPtr;
      newExp.getMasterNodeVec().push_back(sdtPtr);
      newExp.getSdtOpVec().push_back(*sdtPtr);
      newExp.getLocalSdtOpVec().push_back(*sdtPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_DDT  exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > dtNode = newExp.getDtNode();
      Teuchos::RCP<astNode<usedType> > * ddtPtr = new Teuchos::RCP<astNode<usedType> >(new ddtOp<usedType>(*$2, dtNode, timeNode));
      $$ = ddtPtr;
      newExp.getMasterNodeVec().push_back(ddtPtr);
      newExp.getDdtOpVec().push_back(*ddtPtr);
      newExp.getLocalDdtOpVec().push_back(*ddtPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_DDX exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ddxOp<usedType>(*$2,*$4));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_AGAUSS exp TOK_COMMA exp TOK_COMMA exp TOK_RIGHTPAREN
    {

      Teuchos::RCP<agaussOp<usedType> > * agaussPtr = new Teuchos::RCP<agaussOp<usedType> >(new agaussOp<usedType> (*$2,*$4,*$6));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*agaussPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getAgaussOpVec ().push_back(*agaussPtr);
      newExp.getLocalAgaussOpVec ().push_back(*agaussPtr);
      delete agaussPtr;
    }
  | TOK_GAUSS exp TOK_COMMA exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<gaussOp<usedType> > * gaussPtr = new Teuchos::RCP<gaussOp<usedType> >(new gaussOp<usedType>(*$2,*$4,*$6));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*gaussPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getGaussOpVec ().push_back(*gaussPtr);
      newExp.getLocalGaussOpVec ().push_back(*gaussPtr);
      delete gaussPtr;
    }
  | TOK_AUNIF exp TOK_COMMA exp  TOK_RIGHTPAREN
    {
      Teuchos::RCP<aunifOp<usedType> > * aunifPtr = new Teuchos::RCP<aunifOp<usedType> >(new aunifOp<usedType>(*$2,*$4));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*aunifPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getAunifOpVec ().push_back(*aunifPtr);
      newExp.getLocalAunifOpVec ().push_back(*aunifPtr);
      delete aunifPtr;
    }
  | TOK_UNIF exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<unifOp<usedType> > * unifPtr = new Teuchos::RCP<unifOp<usedType> >(new unifOp<usedType>(*$2,*$4));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*unifPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getUnifOpVec ().push_back(*unifPtr);
      newExp.getLocalUnifOpVec ().push_back(*unifPtr);
      delete unifPtr;
    }
  | TOK_RAND TOK_RIGHTPAREN
    {
      Teuchos::RCP<randOp<usedType> > * randPtr = new Teuchos::RCP<randOp<usedType> >(new randOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*randPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getRandOpVec ().push_back(*randPtr);
      newExp.getLocalRandOpVec ().push_back(*randPtr);
      delete randPtr;
    }

 /* SPICE time-dependent sources.  These have optional length argument lists */
 /* pulse( v1,v2,td,tr,tf,pw,per) */
  | TOK_SPICE_PULSE nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spicePulseOp<usedType>($2, timeNode ));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $2;
    }
 /* sin (v0,va,frequency,td,theta,phase) */
  | TOK_SPICE_SIN nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceSinOp<usedType>($2, timeNode ));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $2;
    }
 /* exp ( v1,v2,td1,tau1,td2,tau2) */
  | TOK_SPICE_EXP nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceExpOp<usedType>($2,timeNode));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getSrcNodeVec().push_back(*tmpPtr);
      newExp.setTimeDependent(true);
      delete $2;
    }
 /* sffm (v0,va,fc,mdi,fs) */
  | TOK_SPICE_SFFM nonempty_func_arglist 
    {
      Teuchos::RCP<astNode<usedType> > timeNode = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceSffmOp<usedType>($2,timeNode));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
      delete $2;
    }

  | exp TOK_QUESTION_MARK exp TOK_COLON exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ifStatementOp<usedType>((*$1),(*$3),(*$5)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_IF exp TOK_COMMA exp TOK_COMMA exp TOK_RIGHTPAREN
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ifStatementOp<usedType>((*$2),(*$4),(*$6)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | exp TOK_EQ exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new eqOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_NE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new neOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_GT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new gtOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_LT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ltOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_GE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new geOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_LE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new leOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCompNodeVec().push_back(*tmpPtr);
    }
  | exp TOK_OR exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new orOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_AND exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new andOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_CARET exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr;
      if (Xyce::Util::useHspiceMath)
      {
        tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$1,*$3));
      }
      else
      {
        tmpPtr = new Teuchos::RCP<astNode<usedType> >(new xorOp<usedType>(*$1,*$3));
      }
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_NOT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryNotOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
// error condition patterns
   | TOK_BADPOLY 
    {
      Xyce::Report::UserError() << "Syntax error in number of nodes in expression: " << newExp.getOriginalExpressionString() << std::endl;

      // the "rand" operator is allocated here b/c all of these functions need to return a 
      // valid operator or else cause a segfault.  It is not intended to be used, as this function
      // is trapping for an error condition.  randOp is a convenient
      // choice b/c it doens't require any arguments.
      Teuchos::RCP<randOp<usedType> > * randPtr = new Teuchos::RCP<randOp<usedType> >(new randOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*randPtr);
      $$ = tmpPtr;
      delete randPtr;
    }
  | exp TOK_INVALID_OP exp
    {
      Xyce::Report::UserError() << "Invalid operator in expression " << newExp.getOriginalExpressionString() << std::endl;

      // the "rand" operator is allocated here b/c all of these functions need to return a 
      // valid operator or else cause a segfault.  It is not intended to be used, as this function
      // is trapping for an error condition.  randOp is a convenient
      // choice b/c it doens't require any arguments.
      Teuchos::RCP<randOp<usedType> > * randPtr = new Teuchos::RCP<randOp<usedType> >(new randOp<usedType>());
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*randPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete randPtr;
    }
  ;

nonempty_rfparam_arg_list: TOK_RFPARAM_ARG { $$ = new std::vector<int>; $$->push_back($1); }
  | nonempty_rfparam_arg_list  TOK_RFPARAM_ARG  { $1->push_back($2); $$=$1; }

nonempty_noise_device_list: TOK_NOISE_DEV_VAR { $$ = new std::vector< std::string >; $$->push_back(*($1)); delete $1; }
  | nonempty_noise_device_list  TOK_NOISE_DEV_VAR  { $1->push_back(*($2)); delete $2; $$ = $1; }

nonempty_voltagenodelist: TOK_VOLTAGENODE { $$ = new std::vector< std::string >; $$->push_back(*($1)); delete $1; }
  | nonempty_voltagenodelist  TOK_VOLTAGENODE  { $1->push_back(*($2)); delete $2; $$=$1; }

nonempty_func_arglist: exp TOK_RIGHTPAREN  { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1);   }
   |  two_or_more_arglist  TOK_RIGHTPAREN { $$=$1;  }

nonempty_func_arglist2: exp TOK_COMMA TOK_RIGHTPAREN  { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1);   }
   |  two_or_more_arglist  TOK_COMMA TOK_RIGHTPAREN { $$=$1;  }

two_or_more_arglist: exp TOK_COMMA exp         { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1); $$->push_back((*$3)); }
  | two_or_more_arglist TOK_COMMA  exp { $1->push_back((*$3)); $$=$1; }

nonempty_arg_pairs: TOK_LEFTPAREN exp TOK_COMMA exp TOK_RIGHTPAREN  { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$2);  $$->push_back((*$4));  } 
  | nonempty_arg_pairs TOK_LEFTPAREN exp TOK_COMMA exp TOK_RIGHTPAREN  { $1->push_back((*$3)); $1->push_back((*$5)); $$=$1; }


polypair: TOK_POLYSIZE  polyarg 
  {
    std::vector< Teuchos::RCP<astNode<usedType> > > first(1,*$2);
    $$ = new std::pair<double, std::vector< Teuchos::RCP<astNode<usedType> > > >($1,first);
  }
  | polypair polyarg { $1->second.push_back(*$2); $$=$1; }


polyarg: TOK_POLY_VOLTAGE nonempty_voltagenodelist
    {
      $$ = createVoltageOp(newExp,*$1,*$2);
      delete $1;
      delete $2;
    }
  | TOK_POLY_CURRENT TOK_CURRENTDEV
    {
      $$ = createCurrentOp(newExp,*$1,*$2);
      delete $1;
      delete $2;
    }

poly_coeflist:  paren_polycoef         { 
      Teuchos::RCP<astNode<usedType> > *tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($1));
      $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*tmpPtr);  
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  |  poly_coeflist  paren_polycoef{ 
      Teuchos::RCP<astNode<usedType> > *tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($2));
      $1->push_back((*tmpPtr)); 
      $$=$1;
      newExp.getMasterNodeVec().push_back(tmpPtr);
     }

paren_polycoef: TOK_POLYCOEF
     {
       $$ = $1;
     }
  | TOK_LEFTPAREN paren_polycoef TOK_RIGHTPAREN
    {
       $$ = $2;
    }
  | TOK_LEFTCURLYBRACE paren_polycoef TOK_RIGHTCURLYBRACE
    {
       $$ = $2;
    }



    /* excluding this pattern b/c it causes shift/reduce errors.  
     * But this particular pattern doesn't seem to be used by any existing tests */
    /*
table2_with_nonempty_arglist: table2_threeOrFourArgs exp
    {
      std::vector< Teuchos::RCP<astNode<usedType> > > first(1,*$2);
      $$ = new std::pair< Teuchos::RCP<astNode<usedType> >, std::vector< Teuchos::RCP<astNode<usedType> > > >(*$1,first);
    }
    | table2_threeOrFourArgs two_or_more_arglist
    { 
      $$ = new std::pair< Teuchos::RCP<astNode<usedType> >, std::vector< Teuchos::RCP<astNode<usedType> > > >(*$1,*$2);
    }
    */


table_threeOrFourArgs: TOK_TABLE exp TOK_COMMA
    {
       $$ = $2;
    }
  | TOK_TABLE exp TOK_COMMA TOK_EQUALS
    {
       $$ = $2;
    }
table2_threeOrFourArgs: TOK_TABLE2 exp TOK_RIGHTCURLYBRACE
    {
       $$ = $2;
    }
  | TOK_TABLE2 exp TOK_RIGHTCURLYBRACE TOK_EQUALS
    {
       $$ = $2;
    }
table3_threeOrFourArgs: TOK_TABLE3 exp TOK_RIGHTCURLYBRACE
    {
       $$ = $2;
    }
  | TOK_TABLE3 exp TOK_RIGHTCURLYBRACE TOK_EQUALS
    {
       $$ = $2;
    }


%%

int XyceExpressionlex(
    XyceExpression::ExpressionParser::semantic_type *lvalp, 
    XyceExpression::location *locp,
    Xyce::Util::ExpressionLexer *theLexer)
{
  return(theLexer->getToken(lvalp,locp));
}

void
XyceExpression::ExpressionParser::error(
  const XyceExpression::ExpressionParser::location_type & l,
  const std::string &                               message)
{
  //Xyce::Report::UserError().at(theLexer->netlistLocation_)
  Xyce::Report::UserError()
   << message << " in expression " << newExp.getOriginalExpressionString() << std::endl;
}
