
%{

#include <iostream>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <unordered_map>
#include <map>
#include <vector>
#include <cmath>
#include <complex>

//#include <Sacado_No_Kokkos.hpp>
#include <Teuchos_RCP.hpp>

#include "location.hh"
#include "ExpressionType.h"
#include "ast.h"
#include "newExpression.h"

namespace Xyce {
namespace Util {
class ExpressionLexer;
}}

%}

%skeleton "lalr1.cc"
%parse-param {Xyce::Util::ExpressionLexer *theLexer}
%parse-param {Xyce::Util::newExpression & newExp}
%lex-param {Xyce::Util::ExpressionLexer *theLexer}

%define parser_class_name "ExpressionParser"
%locations
%defines

%name-prefix="XyceExpression"
%require "3.2"


%union
{
// comparison ops placeholder
  double cmp; // placeholder

  //astNode<usedType> *astNodePtr;
  //std::vector< astNode<usedType> * > * nodeVecPtr;

  Teuchos::RCP<astNode<usedType> > * astNodePtr;
  std::vector< Teuchos::RCP<astNode<usedType> > > * nodeVecPtr;

  double dval;
  std::string *sval;
  std::vector<std::string> *vecsval;
};

%{
  // WARNING!!!!  The stuff in this block is the "post-prologue" that
  // in versions of Bison prior to 2.3 used to be placed into the .hxx
  // file generated by bison, and which we could therefore just include
  // to get the right stuff.
  // In version 2.3 they stopped doing that and started putting the
  // post-prologue code directly into the generated .cxx file, which means
  // that we need to DUPLICATE this block of code in N_DEV_ReactionNetwork.C.
  // If you change *ANYTHING* in this post-prologue, you MUST edit
  // N_DEV_ReactionNetwork.C and keep it in sync with the changes in this
  // block!
  // Note also that this was absolutely critical to do in Bison 2.3, and
  // somehow didn't seem to matter much just a few releases of bison later.
  // Careless hacking of this block *could* break compatibility of Xyce with
  // older versions of Bison and go unnoticed in testing.  Please be careful.
#undef yyFlexLexer
  /* CAREFUL watch continuations! */
#define YY_DECL \
int ExpressionLexer::getToken(ExpressionParser::semantic_type *lvalp,  \
                            location *llocp)

  // YECH!  Work around very stupid way that multiple parsers/lexers are
  // handled.
  // Bison's "%name-prefix" is implemented as a #define yylex "prefix"lex
  // which BREAKS flex's C++ lexer: it contains a method "yylex" in the
  // yyFlexLexer class.  Unless we do this kludge, that method gets renamed
  // with the define as well, and the result is a broken set of classes
#undef yylex
#include <FlexLexer.h>
#include "ExpressionLexer.h"
  // undo that kludge.  Note that because of this stupidity, if the
  // "%name-prefix" is changed, this line needs to be changed, too.
#define yylex XyceExpressionlex

int XyceExpressionlex(XyceExpression::ExpressionParser::semantic_type *lvalp, XyceExpression::location *locp,
             Xyce::Util::ExpressionLexer *theLexer);

%}

// value tokens from the lexer (ExpressionLexer.l)
%token <dval> TOK_NUM	"num"
%token <sval> TOK_WORD "word"
%token <sval> TOK_VOLTAGENODE "voltagenode"
%token <sval> TOK_CURRENTDEV "currentdevice"

// non-value tokens from the lexer (ExpressionLexer.l)
%token TOK_SQRT	"sqrt"
%token TOK_MAX	"max"
%token TOK_MIN	"min"
%token TOK_PHASE	"phase"
%token TOK_REAL	"real"
%token TOK_IMAG	"imag"
%token TOK_EXP	"exp"
%token TOK_SIN	"sin"
%token TOK_COS	"cos"
%token TOK_ABS	"abs"
%token TOK_ACOS	"acos"
%token TOK_ACOSH	"acosh"
%token TOK_ASIN	"asin"
%token TOK_ASINH	"asinh"
%token TOK_ATAN2	"atan2"
%token TOK_ATAN	"atan"
%token TOK_ATANH	"atanh"
%token TOK_COSH	"cosh"
%token TOK_LN	"ln"
%token TOK_LOG	"log"
%token TOK_LOG10	"log10"
%token TOK_SINH	"sinh"
%token TOK_TAN	"tan"
%token TOK_TANH	"tanh"
%token TOK_IF "if"

%token TOK_AGAUSS	"agauss"
%token TOK_CEIL	"ceil"
%token TOK_GAUSS	"gauss"
%token TOK_DDT	"ddt"
%token TOK_DDX	"ddx"
%token TOK_FLOOR	"floor"
%token TOK_INT 	"int"
%token TOK_LIMIT 	"limit"
%token TOK_POWSFUNC 	"pwrs"
%token TOK_RAND	"rand"
%token TOK_SDT	"sdt"
%token TOK_SGN	"sgn"
%token TOK_SIGN	"sign"
%token TOK_STP	"stp"
%token TOK_TABLE	"table"
%token TOK_URAMP	"uramp"
%token TOK_POLY	"poly"

%token TOK_SPICE_PULSE "spice_pulse"
%token TOK_SPICE_SIN "spice_sin"
%token TOK_SPICE_EXP "spice_exp"
%token TOK_SPICE_SFFM "spice_sffm"

%token TOK_TIME  "time"
%token TOK_TEMP  "temp"
%token TOK_VT    "vt"
%token TOK_FREQ  "freq"
%token TOK_PI    "pi"

// types for nonterminal operators
%type  <astNodePtr>   exp
%type  <astNodePtr>   expression
%type  <nodeVecPtr>   nonempty_arglist
%type  <nodeVecPtr>   no_comma_arglist
%type  <vecsval>  nonempty_voltagenodelist

%destructor { delete $$; } TOK_WORD
%destructor { delete $$; } TOK_VOLTAGENODE
%destructor { delete $$; } TOK_CURRENTDEV
%destructor { delete $$; } nonempty_voltagenodelist


// Operator Precedence tokens
%left   ','
%right  '?' ':'
%left  TOK_OR "||" TOK_AND "&&"
%left  TOK_NOT "~"
%left  TOK_XOR "^"
%left  TOK_EQ	"==" TOK_NE	"!=" TOK_LE	"<=" TOK_LT	"<" TOK_GE	">=" TOK_GT	">"
%left   '-' '+'
%left   '%'
%left   '*' '/'
%left   NEG '!'  /* negation--unary minus, and boolean not */
%right   TOK_POW  TOK_POWFUNC  /* exponentiation */

%%
expression: exp
  {
      if (yynerrs_ != 0)
      {
        YYABORT;
      }
      else
      {
        newExp.setAstPtr(*$1);

        YYACCEPT;
      }
 }

exp:
    TOK_NUM
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>($1));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_NUM 'J'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new numval<usedType>(std::complex<basicType>(0.0,$1)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_WORD
      {
        // ensures that each parameter and/or function argument  has a single, unique astNode allocated for it
        std::unordered_map<std::string,Teuchos::RCP<astNode<usedType> > > & paramOpMap = newExp.getParamOpMap();
        std::unordered_map<std::string,Teuchos::RCP<astNode<usedType> > >::const_iterator got = paramOpMap.find(*$1);
        if ( got == paramOpMap.end() )
        {
          Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new paramOp<usedType>(*$1));
          paramOpMap[*$1] = *tmpPtr;
          Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(*tmpPtr);
          newExp.getMasterNodeVec().push_back(tmpPtr2);

          $$ = tmpPtr2;
          delete tmpPtr;
        }
        else
        {
          Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >((paramOpMap[*$1]));
          newExp.getMasterNodeVec().push_back(tmpPtr2);
          $$ = tmpPtr2;
        }
        delete $1;
    }
  | TOK_TIME
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getTimeNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }
  | TOK_TEMP
    {
      Teuchos::RCP<astNode<usedType> > tmp =newExp.getTempNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTempDependent(true);
    }
  | TOK_VT
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getVtNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setVTDependent(true);
    }
  | TOK_FREQ
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getFreqNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setFreqDependent(true);
    }
  | TOK_PI
    {
      Teuchos::RCP<astNode<usedType> > tmp = newExp.getPiNode ();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(tmp);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '+' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryAddOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '-' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMinusOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '*' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMulOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '/' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryDivOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp '%' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryModOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_POW exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POWFUNC '(' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new powOp<usedType>  (*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POWSFUNC '(' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new pwrsOp<usedType>  (*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | '(' exp ')'
    {
       $$ = $2;
    }
  | '~' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryNotOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | '-' exp  %prec NEG
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryMinusOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | '+' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryPlusOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SGN '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sgnOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SIGN '(' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new signOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_WORD '(' nonempty_arglist ')'
     {
        Teuchos::RCP<funcOp<usedType> > funcPtr = Teuchos::rcp(new funcOp<usedType>(*$1,$3));
        newExp.getFuncOpVec().push_back(funcPtr);

        Teuchos::RCP<astNode<usedType> > * tmpPtr2 = new Teuchos::RCP<astNode<usedType> >(funcPtr); // implicit cast
        newExp.getMasterNodeVec().push_back(tmpPtr2);
        $$ = tmpPtr2;
        delete $1;
        delete $3;
    }
  | TOK_WORD nonempty_voltagenodelist
    {
      std::vector<std::string> voltageNodes = *$2;

      if (voltageNodes.size() == 1)
      {
        Teuchos::RCP<voltageOp<usedType> > * voltPtr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(*$2));
        Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*voltPtr);
        $$ = tmpPtr;
        newExp.getMasterNodeVec().push_back(tmpPtr);
        newExp.getVoltOpVec ().push_back(*voltPtr);
        delete voltPtr;
      }
      // this was not the original plan for V(A,B), but it seemed like the easiest way to 
      // handle derivative indexing. Instead of having the voltageOp class handle the differencing, 
      // I instead create two voltage nodes, one for V(A) and one for V(B) and then
      // pass them as arguments to a binaryMinusOp operator.
      else if (voltageNodes.size() == 2) 
      {
        std::vector<std::string> nodes1;
        std::vector<std::string> nodes2;
        nodes1.push_back(voltageNodes[0]);
        nodes2.push_back(voltageNodes[1]);
        Teuchos::RCP<voltageOp<usedType> > * volt1Ptr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(nodes1));
        Teuchos::RCP<voltageOp<usedType> > * volt2Ptr = new Teuchos::RCP<voltageOp<usedType> >(new voltageOp<usedType>(nodes2));
        Teuchos::RCP<astNode<usedType> > * tmp1Ptr = new Teuchos::RCP<astNode<usedType> >(*volt1Ptr);
        Teuchos::RCP<astNode<usedType> > * tmp2Ptr = new Teuchos::RCP<astNode<usedType> >(*volt2Ptr);
        Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new binaryMinusOp<usedType>  (*tmp1Ptr,*tmp2Ptr));
        $$ = tmpPtr;
        newExp.getMasterNodeVec().push_back(tmp1Ptr);
        newExp.getMasterNodeVec().push_back(tmp2Ptr);
        newExp.getMasterNodeVec().push_back(tmpPtr);
        newExp.getVoltOpVec ().push_back(*volt1Ptr);
        newExp.getVoltOpVec ().push_back(*volt2Ptr);
        delete volt1Ptr;
        delete volt2Ptr;
      }
      delete $1;
      delete $2;
    }
  | TOK_WORD TOK_CURRENTDEV
    {
      Teuchos::RCP<currentOp<usedType> > * currentPtr = new Teuchos::RCP<currentOp<usedType> >(new currentOp<usedType>(*$2));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(*currentPtr);
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.getCurrentOpVec().push_back(*currentPtr);
      delete currentPtr;
      delete $1;
      delete $2;
    }

  | TOK_MAX  '(' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new maxOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_MIN  '(' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new minOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_PHASE '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new phaseOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_REAL '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new realOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_IMAG '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new imagOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SQRT '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sqrtOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_EXP '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new expOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SIN '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sinOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_COS '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new cosOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ABS '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new absOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ACOS '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new acosOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ACOSH '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new acoshOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ASIN '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new asinOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ASINH '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new asinhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATAN2 '(' exp ',' exp ')'
    {
#if 0
      Teuchos::RCP<astNode<usedType> > * divPtr = new Teuchos::RCP<astNode<usedType> >(new binaryDivOp<usedType>(*$3,*$5));
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanOp<usedType>(*divPtr));
#else
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atan2Op<usedType>(*$3,*$5));
#endif
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
#if 0
      newExp.getMasterNodeVec().push_back(divPtr);
#endif
    }
  | TOK_ATAN '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_ATANH '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new atanhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_COSH '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new coshOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LN '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new logOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LOG '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_LOG10 '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new log10Op<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_SINH '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sinhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_TAN '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tanOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_TANH'(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tanhOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_CEIL '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ceilOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_FLOOR '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new floorOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_INT   '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new intOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | TOK_LIMIT '(' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new limitOp<usedType>(*$3,*$5,*$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_STP '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new stpOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_URAMP '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new urampOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_POLY '(' TOK_NUM ')' no_comma_arglist
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new polyOp<usedType>($3,$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $5;
    }
  | TOK_TABLE '(' '{' exp '}' '=' nonempty_arglist ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$4,$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $7;
    }
  | TOK_TABLE '(' '{' exp '}' nonempty_arglist ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$4,$6));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $6;
    }
  | TOK_TABLE '(' exp ',' nonempty_arglist ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $5;
    }
  | TOK_TABLE '(' exp ',' '=' nonempty_arglist ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new tableOp<usedType>(*$3,$6));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      delete $6;
    }
  | TOK_SDT  '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new sdtOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_DDT  '(' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ddtOp<usedType>(*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_DDX  '(' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ddxOp<usedType>(*$3,*$5));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_AGAUSS '(' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new agaussOp<usedType>(*$3,*$5,*$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_GAUSS '(' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new gaussOp<usedType>(*$3,*$5,*$7));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_RAND '('')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new randOp<usedType>());
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

 /* SPICE time-dependent sources.  consider allowing optional length argument lists? */
 /* pulse( v1,v2,td,tr,tf,pw,per) */
  | TOK_SPICE_PULSE '(' exp ',' exp ',' exp ',' exp ',' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      //newExp.getSrcNodeVec().push_back(tmp);
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spicePulseOp<usedType>(*$3, *$5, *$7, *$9, *$11, *$13, *$15, tmpPtr2 ));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }
 /* sin (v0,va,frequency,td,theta,phase) */
  | TOK_SPICE_SIN   '(' exp ',' exp ',' exp ',' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceSinOp<usedType>(*$3,*$5,*$7,*$9,*$11,*$13,tmpPtr2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }
 /* exp ( v1,v2,td1,tau1,td2,tau2) */
  | TOK_SPICE_EXP   '(' exp ',' exp ',' exp ',' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceExpOp<usedType>(*$3,*$5,*$7,*$9,*$11,*$13,tmpPtr2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }
 /* sffm (v0,va,fc,mdi,fs) */
  | TOK_SPICE_SFFM   '(' exp ',' exp ',' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > tmpPtr2 = newExp.getTimeNode();
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new spiceSffmOp<usedType>(*$3,*$5,*$7,*$9,*$11,tmpPtr2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
      newExp.setTimeDependent(true);
    }

  | exp '?' exp ':' exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ifStatementOp<usedType>((*$1),(*$3),(*$5)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_IF '(' exp ',' exp ',' exp ')'
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ifStatementOp<usedType>((*$3),(*$5),(*$7)));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }

  | exp TOK_EQ exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new eqOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_NE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new neOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_GT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new gtOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_LT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new ltOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_GE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new geOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_LE exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new leOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_OR exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new orOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_AND exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new andOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | exp TOK_XOR exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new xorOp<usedType>(*$1,*$3));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  | TOK_NOT exp
    {
      Teuchos::RCP<astNode<usedType> > * tmpPtr = new Teuchos::RCP<astNode<usedType> >(new unaryNotOp<usedType>(*$2));
      $$ = tmpPtr;
      newExp.getMasterNodeVec().push_back(tmpPtr);
    }
  ;

nonempty_voltagenodelist: TOK_VOLTAGENODE { $$ = new std::vector< std::string >; $$->push_back(*($1)); delete $1; }
  | nonempty_voltagenodelist  TOK_VOLTAGENODE  { $$->push_back(*($2)); delete $2; }

nonempty_arglist: exp         { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1);  }
  | nonempty_arglist ','  exp { $$->push_back((*$3)); }

no_comma_arglist: exp         { $$ = new std::vector< Teuchos::RCP<astNode<usedType> > >(1,*$1);  }
  | no_comma_arglist  exp { $$->push_back((*$2)); }

%%

int XyceExpressionlex(XyceExpression::ExpressionParser::semantic_type *lvalp, XyceExpression::location *locp,
                  Xyce::Util::ExpressionLexer *theLexer)
{
        return(theLexer->getToken(lvalp,locp));
}

void
XyceExpression::ExpressionParser::error(
  const XyceExpression::ExpressionParser::location_type & l,
  const std::string &                               message)
{
  //Xyce::Report::UserError().at(theLexer->netlistLocation_)
 std::cout << "ERROR!!! " << message << std::endl;
}
