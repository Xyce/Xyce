/*-------------------------------------------------------------------------
//   Copyright 2002-2019 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------
*/


%{

#include <Xyce_config.h>

#include <iostream>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <map>
#include <vector>
#include "location.hh"
#include "position.hh"
#include <N_ERH_Message.h>
#include <N_DEV_Specie.h>
#include <N_DEV_ReactionNetwork.h>

namespace Xyce {
namespace Device {
class ReactionLexer;
}}
%}

%skeleton "lalr1.cc"
%parse-param {Xyce::Device::ReactionLexer *theLexer}
%parse-param {std::map<std::string, int> &theSpeciesIDs}
%parse-param {Xyce::Device::ReactionNetwork &theReactionNetwork}
%lex-param {ReactionLexer *theLexer}
%lex-param {std::map<std::string, int> &theSpeciesIDs}

%define parser_class_name "ReactionParser"
%locations
%defines

%name-prefix="XyceDevice"

%union
{
  int ival;
  double dval;
  std::string *sval;
  Xyce::Device::Specie *specievalp;
  std::pair<std::string,double> *spe_p;  
  std::vector<std::pair<std::string,double> > *spev_p;  
};

%{
  // WARNING!!!!  The stuff in this block is the "post-prologue" that
  // in versions of Bison prior to 2.3 used to be placed into the .hxx
  // file generated by bison, and which we could therefore just include
  // to get the right stuff.
  // In version 2.3 they stopped doing that and started putting the
  // post-prologue code directly into the generated .cxx file, which means
  // that we need to DUPLICATE this block of code in N_DEV_ReactionNetwork.C.
  // If you change *ANYTHING* in this post-prologue, you MUST edit
  // N_DEV_ReactionNetwork.C and keep it in sync with the changes in this
  // block!
  // Note also that this was absolutely critical to do in Bison 2.3, and
  // somehow didn't seem to matter much just a few releases of bison later.
  // Careless hacking of this block *could* break compatibility of Xyce with
  // older versions of Bison and go unnoticed in testing.  Please be careful.
#undef yyFlexLexer
  /* CAREFUL watch continuations! */
#define YY_DECL \
int ReactionLexer::getToken(ReactionParser::semantic_type *lvalp,  \
                            location *llocp, \
                            std::map<std::string, int> &theSpeciesIDs)

  // YECH!  Work around very stupid way that multiple parsers/lexers are 
  // handled.
  // Bison's "%name-prefix" is implemented as a #define yylex "prefix"lex
  // which BREAKS flex's C++ lexer: it contains a method "yylex" in the
  // yyFlexLexer class.  Unless we do this kludge, that method gets renamed
  // with the define as well, and the result is a broken set of classes
#undef yylex
#include <FlexLexer.h>
#include <N_DEV_ReactionLexer.h>
  // undo that kludge.  Note that because of this stupidity, if the 
  // "%name-prefix" is changed, this line needs to be changed, too.
#define yylex XyceDevicelex


int XyceDevicelex(XyceDevice::ReactionParser::semantic_type *lvalp, XyceDevice::location *locp,
             Xyce::Device::ReactionLexer *theLexer, std::map<std::string, int> &theSpeciesIDs);

%}
%token <ival> RXN_INT
%token ARROW "->"
%token <dval> RXN_FLOAT "float"
%token <sval> SPECIE "specie"
%token <sval> IDENTIFIER "identifier"
%token <sval> XYCE_EXPRESSION "xyce_expression"
%token SPECIES_BEGIN "species" 
%token REACTIONS_BEGIN "reactions"
%token SOURCES_BEGIN "sources"
%token ICS_BEGIN "initial_conditions"
%token ENHANCEMENTS_BEGIN "enhancements"
%token KEY_END "end"
%token KEY_SIMPLE "simple"
%token KEY_CAPTURE "capture"
%token KEY_EMISSION "emission"
%token KEY_ECAPTURE "electron_capture"
%token KEY_EEMISSION "electron_emission"
%token KEY_FDEEMISSION "fdelectron_emission"
%token KEY_HCAPTURE "hole_capture"
%token KEY_HEMISSION "hole_emission"
%token KEY_FDHEMISSION "fdhole_emission"
%token KEY_COMPLEX "complex"
%token KEY_DECOMPLEX "decomplex"
%token KEY_BCHOLE "bourgoin_corbett_hole"
%token KEY_BCELECTRON "bourgoin_corbett_electron"
%token KEY_BC "bourgoin_corbett"
%token KEY_CONST "const"
%token KEY_COMPLEXMULTIPLIER "complexmultiplier"

%type <specievalp> simple_specie_spec
%type <spe_p> specie_expr
%type <spev_p> species_expr
/* Reactions return a string for later use*/
%type <sval> reaction
%type <sval> enhancement
%destructor {delete $$;} "specie"
%destructor {delete $$;} "identifier"

%%

network_spec:  species_spec sources_spec initial_conditions_spec
             | species_spec reaction_net_spec sources_spec initial_conditions_spec
             | species_spec enhancement_net_spec reaction_net_spec sources_spec initial_conditions_spec
                    { 
                      if (yynerrs_ != 0)
                      {
                        YYABORT;
                      }
                      else
                      {
                        YYACCEPT;
                      }
                    }
               ;

species_spec: SPECIES_BEGIN species_list KEY_END
               ;

species_list: /* EMPTY */
              | species_list specie_spec
              | species_list error
                    {
                      error(@1, "Invalid specie specification");
                    }
              ;

specie_spec: variable_specie_spec
             | constant_specie_spec
             ;

variable_specie_spec: simple_specie_spec
             {
               theReactionNetwork.addSpecie(*($1));
               delete $1;
             }
             ;

constant_specie_spec: simple_specie_spec "const"
             {
               theReactionNetwork.addConstant(*($1));
               delete $1;
             }
             ;

simple_specie_spec: SPECIE RXN_FLOAT RXN_FLOAT RXN_INT 
                                /* diffusion prefactor, E, and charge state */
             {
               theSpeciesIDs[*($1)]=theSpeciesIDs.size();
               $$ = new Xyce::Device::Specie(*($1),$2,$3,$4,theSpeciesIDs.size());
               delete $1;
             }
             ;

reaction_net_spec: REACTIONS_BEGIN reaction_network KEY_END
               ;

reaction_network: reaction_spec 
                  | reaction_network reaction_spec
                  ;

reaction_spec: reaction "simple" '(' RXN_FLOAT ')'
               {
                 theReactionNetwork.setSimpleCalc(*$1,$4);
                 delete $1;
               }
             | reaction "capture" '(' RXN_FLOAT ',' RXN_FLOAT ')'
               { 
                 theReactionNetwork.setCaptureCalc(*$1,$4,$6);
                 delete $1;
               }
             | reaction "electron_capture" '(' RXN_FLOAT  ')'
               { 
                 theReactionNetwork.setElectronCaptureCalc(*$1,$4);
                 delete $1;
               }
             | reaction "hole_capture" '(' RXN_FLOAT  ')'
               { 
                 theReactionNetwork.setHoleCaptureCalc(*$1,$4);
                 delete $1;
               }
             | reaction "emission" '(' RXN_FLOAT ',' RXN_FLOAT ',' RXN_FLOAT ',' RXN_FLOAT ')'
               { 
                 theReactionNetwork.setEmissionCalc(*$1,$4,$6,$8,$10);
                 delete $1;
               }
             | reaction "electron_emission" '('  RXN_FLOAT ',' RXN_FLOAT ')'
               { 
                 theReactionNetwork.setElectronEmissionCalc(*$1,$4,$6);
                 delete $1;
               }
             | reaction "fdelectron_emission" '('  RXN_FLOAT ',' RXN_FLOAT ')'
               { 
                 theReactionNetwork.setFDElectronEmissionCalc(*$1,$4,$6);
                 delete $1;
               }
             | reaction "hole_emission" '('  RXN_FLOAT ',' RXN_FLOAT ')'
               { 
                 theReactionNetwork.setHoleEmissionCalc(*$1,$4,$6);
                 delete $1;
               }
             | reaction "fdhole_emission" '('  RXN_FLOAT ',' RXN_FLOAT ')'
               { 
                 theReactionNetwork.setFDHoleEmissionCalc(*$1,$4,$6);
                 delete $1;
               }
             | reaction "complex" 
               {
                 theReactionNetwork.setComplexCalc(*$1);
                 delete $1;
               }
             | reaction "complexmultiplier" '(' RXN_FLOAT ')'
               {
                 theReactionNetwork.setComplexMultiplierCalc(*$1,$4);
                 delete $1;
               }
             | reaction "decomplex" '(' RXN_FLOAT ',' RXN_FLOAT ',' RXN_FLOAT ',' RXN_FLOAT ',' RXN_FLOAT ')'
               {
                 theReactionNetwork.setDecomplexCalc(*$1,$4,$6,$8,$10,$12);
                 delete $1;
               }       
             | reaction "bourgoin_corbett_hole"  '(' RXN_FLOAT  ')'
               {
                 theReactionNetwork.setBourgoinCorbettHoleCalc(*$1,$4);
                 delete $1;
               }
           | reaction IDENTIFIER '(' num_list ')' 
             { 
               error(@2, std::string("Invalid rate type \"")+ *$2 +"\"");
               delete $1;
               delete $2;
               YYERROR;
             }
           | reaction error  
             {
               error(@1, "Invalid rate spec");
               delete $1;
             }
        
          ;

reaction: species_expr "->" species_expr ';'
        { 
          std::ostringstream ost;
          bool electron_react=false;
          bool electron_prod=false;
          bool hole_react=false;
          bool hole_prod=false;
          int nl=$1->size();
          int nr=$3->size();

          {
            int i;
            for (i=0;i<nl;i++)
            {
              if (i>0)
              {
                ost << "+";
              }
              if (((*$1)[i].second!=1.0))
              {
                ost << (int)(*$1)[i].second;
              }
              ost << (*$1)[i].first;
              if ((*$1)[i].first == "E") 
                electron_react=true;
              else if ((*$1)[i].first == "H") 
                hole_react=true;
            }
            ost << "->";
            for (i=0;i<nr;i++)
            {
              if (i>0)
              {
                ost << "+";
              }
              if (((*$3)[i].second!=1.0))
              {
                ost << (int)(*$3)[i].second;
              }
              ost << (*$3)[i].first;
              if ((*$3)[i].first == "E") 
                electron_prod=true;
              else if ((*$3)[i].first == "H") 
                hole_prod=true;
            }
          }

          if (nl == 2 && nr==1 && electron_react)
            ost << "_ELECTRON_CAPTURE";
          else if (nl == 2 && nr==1 && hole_react)
            ost << "_HOLE_CAPTURE";
          else  if (nl == 1 && nr==2 && electron_prod)
            ost << "_ELECTRON_EMISSION";
          else if (nl == 1 && nr==2 && hole_prod)
            ost << "_HOLE_EMISSION";



          $$ = new std::string(ost.str());

          // now go through it again and make the reaction object:
          theReactionNetwork.addReaction(*$$);
          {
            int i;
            for (i=0;i<nl;i++)
            {
              theReactionNetwork.addReactant(*$$,(*$1)[i].first,
                                       (*$1)[i].second);
            }
            for (i=0;i<nr;i++)
            {
              theReactionNetwork.addProduct(*$$,(*$3)[i].first,
                                       (*$3)[i].second);
            }
          }
          delete $1;
          delete $3;
        }
          ;


enhancement_net_spec: ENHANCEMENTS_BEGIN enhancement_network KEY_END
               ;

enhancement_network: enhancement_spec
                  | enhancement_network enhancement_spec
                  ;

enhancement_spec: enhancement "bourgoin_corbett" '(' SPECIE ',' RXN_FLOAT ',' RXN_FLOAT ')'
                  {
                    theReactionNetwork.setBourgoinCorbettCalc(*$1,*$4,$6,$8);
                    delete $1;
                    delete $4;
                  }
                | enhancement IDENTIFIER '(' num_list ')' 
                  { 
                    error(@2, std::string("Invalid enhancement type \"")+ *$2 +"\"");
                    delete $1;
                    delete $2;
                    YYERROR;
                  }
                | enhancement error  
                  {
                    error(@1, "Invalid enhancement spec");
                    delete $1;
                  }
          ;

enhancement: SPECIE ';'
        { 
/*
THIS ISN'T NECESSARY FOR BOURGOIN CORBETT ENHANCED DIFFUSION, BUT I'M LEAVING A 
PLACEHOLDER FOR ENHANCEMENTS THAT MAY BE ADDED LATER.  --LCM
*/
        }
        | IDENTIFIER ';'
        {
          error(@1, std::string("Invalid specie \"")+*$1+"\"");
          delete $1;
          YYERROR;
        }         
          ;

num_list: num
          | num_list ',' num
          ;

num: RXN_FLOAT|RXN_INT
          ;

species_expr: /* EMPTY */ 
                {
                  $$ = new std::vector< std::pair<std::string,double> >;
                }
              | specie_expr 
                { 
                  $$ = new std::vector< std::pair<std::string,double> >;
                  $$->push_back(*($1));
                  delete $1;
                }

              | species_expr '+' specie_expr
               { 
                 $1->push_back(*($3));
                 $$=$1;
                 delete $3;
               }
              | species_expr IDENTIFIER
               {
                 error(@2,std::string("Unrecognized species \"") + *$2 + "\"");
                 YYERROR;
               }
              | species_expr error
             { 
               error(@1, " Invalid species expression");
               $$=$1;
             }
              ;

specie_expr: SPECIE
              {
                $$ = new std::pair<std::string,double>(*($1),1.0);
                delete $1;
              }
             | RXN_INT SPECIE
              { 
                $$ = new std::pair<std::string,double>(*($2),(double)$1);
                delete $2;
              }

             ;

sources_spec: /*empty */
              | SOURCES_BEGIN source_list KEY_END
              ;

source_list: /* empty */
              | source_list source_expr
              ;

source_expr:SPECIE XYCE_EXPRESSION
                       {
                         theReactionNetwork.addSourceTerm(*$1,*$2);
                         delete $1;
                         delete $2;
                           }
            | IDENTIFIER XYCE_EXPRESSION
                       { 
                         error(@1,std::string("Unrecognized species \"") + *$1 + "\" in source specification");
                         delete $1;
                         delete $2;
                         YYERROR;
                       }
            | SPECIE error
                       { 
                         error(@1, "Invalid expression in source specification --- missing braces?");
                         delete $1;
                         YYERROR;
                       }
            | IDENTIFIER error
                       { 
                         error(@1, "Invalid expression and unrecognized specie (" + *$1 + ") in source specification?");
                         delete $1;
                         YYERROR;
                       }

               ;

initial_conditions_spec: /*empty */
              | ICS_BEGIN ics_list KEY_END
              ;

ics_list: /* empty */
              | ics_list ics_expr
              ;

ics_expr: SPECIE RXN_FLOAT
          {
              theReactionNetwork.addInitialCondition(*$1,$2);
              delete $1;
          }
          | IDENTIFIER RXN_FLOAT
          { 
              error(@1,std::string("Unrecognized species \"") + *$1 + "\" in initial condition specification");
              delete $1;
              YYERROR;
          }

          ;
%%


int XyceDevicelex(XyceDevice::ReactionParser::semantic_type *lvalp, XyceDevice::location *locp, 
                  Xyce::Device::ReactionLexer *theLexer, 
                  std::map<std::string, int> &theSpeciesIDs)
{
        return(theLexer->getToken(lvalp,locp,theSpeciesIDs));
}

void
XyceDevice::ReactionParser::error(
  const XyceDevice::ReactionParser::location_type & l,
  const std::string &                               message)
{
  Xyce::Report::UserError().at(theLexer->netlistLocation_)
    << "in file " << theLexer->reactionFilename_ << " at line " << l << "\n"
    << message;
}
