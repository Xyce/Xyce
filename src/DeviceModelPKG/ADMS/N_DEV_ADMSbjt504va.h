
// -*-c++-*-
//-------------------------------------------------------------------------
//   Copyright 2002-2024 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file bjt504.va with ADMS
//                  interface for Xyce 7.9.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.7
//
// Creation Date  : Thu, 23 May 2024 20:30:18
//
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMSbjt504va_h
#define Xyce_N_DEV_ADMSbjt504va_h


#include <N_DEV_Configuration.h>
#include <N_DEV_Const.h>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>
#include <N_DEV_BJT.h>


// Xyce_config.h contains a VERSION macro from autoconf, and some
// Verilog-A models like to define a variable of that name.  This can be
// a serious problem, and we don't need the VERSION macro.  Get rid of it.
// This must happen *after* all the includes of Xyce headers, each of which
// includes Xyce_config.h.  The implementation file must do this all again
// because it includes more Xyce headers *after* including this one.
#ifdef VERSION
#undef VERSION
#endif

namespace Xyce {
namespace Device {
namespace ADMSbjt504va {

class Model;
class Instance;
class InstanceSensitivity;

#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Class         : InstanceSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class InstanceSensitivity : public baseSensitivity
{
public:
InstanceSensitivity() :
baseSensitivity() {};

virtual ~InstanceSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static InstanceSensitivity instSens;


//-----------------------------------------------------------------------------
// Class         : ModelSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class ModelSensitivity : public baseSensitivity
{
public:
ModelSensitivity() :
baseSensitivity() {};

virtual ~ModelSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static ModelSensitivity modSens;
#endif // Xyce_ADMS_SENSITIVITIES

// general purpose free functions
// thermal voltage at kelvin temperature temp)
static inline double adms_vt(const double temp) {return(CONSTKoverQ*temp);};


#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// "structs" to hold instance and model param/variable copies
//-----------------------------------------------------------------------------
class instanceSensStruct
{
public:
// instance parameters
// reals
double instancePar_MULT;
double d_instancePar_MULT_dX;
bool instancePar_given_MULT;
// instance variables
// reals
double instanceVar_An;
double instanceVar_Tk;
double d_instanceVar_Tk_dX;
double instanceVar_Vt;
double d_instanceVar_Vt_dX;
double instanceVar_VtINV;
double d_instanceVar_VtINV_dX;
double instanceVar_VDE_T;
double d_instanceVar_VDE_T_dX;
double instanceVar_VDC_T;
double d_instanceVar_VDC_T_dX;
double instanceVar_XP_T;
double d_instanceVar_XP_T_dX;
double instanceVar_BF_T;
double d_instanceVar_BF_T_dX;
double instanceVar_BRI_T;
double d_instanceVar_BRI_T_dX;
double instanceVar_IS_T;
double d_instanceVar_IS_T_dX;
double instanceVar_VEF_T;
double d_instanceVar_VEF_T_dX;
double instanceVar_VER_T;
double d_instanceVar_VER_T_dX;
double instanceVar_nZEB_T;
double d_instanceVar_nZEB_T_dX;
double instanceVar_pow2_2mPE;
double d_instanceVar_pow2_2mPE_dX;
double instanceVar_pow2_PEm2;
double d_instanceVar_pow2_PEm2_dX;
double instanceVar_inv_VDE_T;
double d_instanceVar_inv_VDE_T_dX;
double instanceVar_VGZEB_T;
double d_instanceVar_VGZEB_T_dX;
double instanceVar_TAUE_T;
double d_instanceVar_TAUE_T_dX;
double instanceVar_TAUB_T;
double d_instanceVar_TAUB_T_dX;
double instanceVar_TEPI_T;
double d_instanceVar_TEPI_T_dX;
double instanceVar_TAUR_T;
double d_instanceVar_TAUR_T_dX;
double instanceVar_BnT;
double d_instanceVar_BnT_dX;
double instanceVar_DEG_T;
double d_instanceVar_DEG_T_dX;
double instanceVar_VDS_T;
double d_instanceVar_VDS_T_dX;
double instanceVar_IKS_T;
double d_instanceVar_IKS_T_dX;
double instanceVar_IS_TM;
double d_instanceVar_IS_TM_dX;
double instanceVar_IK_TM;
double d_instanceVar_IK_TM_dX;
double instanceVar_IBF_TM;
double d_instanceVar_IBF_TM_dX;
double instanceVar_IBR_TM;
double d_instanceVar_IBR_TM_dX;
double instanceVar_IHC_M;
double d_instanceVar_IHC_M_dX;
double instanceVar_IZEB_TM;
double d_instanceVar_IZEB_TM_dX;
double instanceVar_CJE_TM;
double d_instanceVar_CJE_TM_dX;
double instanceVar_CJC_TM;
double d_instanceVar_CJC_TM_dX;
double instanceVar_RE_TM;
double d_instanceVar_RE_TM_dX;
double instanceVar_RBC_TM;
double d_instanceVar_RBC_TM_dX;
double instanceVar_RBV_TM;
double d_instanceVar_RBV_TM_dX;
double instanceVar_RCV_TM;
double d_instanceVar_RCV_TM_dX;
double instanceVar_SCRCV_M;
double d_instanceVar_SCRCV_M_dX;
double instanceVar_RCCxx_TM;
double d_instanceVar_RCCxx_TM_dX;
double instanceVar_RCCex_TM;
double d_instanceVar_RCCex_TM_dX;
double instanceVar_RCCin_TM;
double d_instanceVar_RCCin_TM_dX;
double instanceVar_GCCxx_TM;
double d_instanceVar_GCCxx_TM_dX;
double instanceVar_GCCex_TM;
double d_instanceVar_GCCex_TM_dX;
double instanceVar_GCCin_TM;
double d_instanceVar_GCCin_TM_dX;
double instanceVar_KF_M;
double d_instanceVar_KF_M_dX;
double instanceVar_KFN_M;
double d_instanceVar_KFN_M_dX;
double instanceVar_ISS_TM;
double d_instanceVar_ISS_TM_dX;
double instanceVar_ICSS_TM;
double d_instanceVar_ICSS_TM_dX;
double instanceVar_IKS_TM;
double d_instanceVar_IKS_TM_dX;
double instanceVar_CJS_TM;
double d_instanceVar_CJS_TM_dX;
double instanceVar_Xext1;
double d_instanceVar_Xext1_dX;
double instanceVar_CBEO_M;
double d_instanceVar_CBEO_M_dX;
double instanceVar_CBCO_M;
double d_instanceVar_CBCO_M_dX;
double instanceVar_dxa;
double d_instanceVar_dxa_dX;
};

class modelSensStruct
{
public:
// model parameters
// reals
double modelPar_TREF;
double d_modelPar_TREF_dX;
bool modelPar_given_TREF;
double modelPar_DTA;
double d_modelPar_DTA_dX;
bool modelPar_given_DTA;
double modelPar_IS;
double d_modelPar_IS_dX;
bool modelPar_given_IS;
double modelPar_IK;
double d_modelPar_IK_dX;
bool modelPar_given_IK;
double modelPar_VER;
double d_modelPar_VER_dX;
bool modelPar_given_VER;
double modelPar_VEF;
double d_modelPar_VEF_dX;
bool modelPar_given_VEF;
double modelPar_BF;
double d_modelPar_BF_dX;
bool modelPar_given_BF;
double modelPar_IBF;
double d_modelPar_IBF_dX;
bool modelPar_given_IBF;
double modelPar_MLF;
double d_modelPar_MLF_dX;
bool modelPar_given_MLF;
double modelPar_XIBI;
double d_modelPar_XIBI_dX;
bool modelPar_given_XIBI;
double modelPar_IZEB;
double d_modelPar_IZEB_dX;
bool modelPar_given_IZEB;
double modelPar_NZEB;
double d_modelPar_NZEB_dX;
bool modelPar_given_NZEB;
double modelPar_BRI;
double d_modelPar_BRI_dX;
bool modelPar_given_BRI;
double modelPar_IBR;
double d_modelPar_IBR_dX;
bool modelPar_given_IBR;
double modelPar_VLR;
double d_modelPar_VLR_dX;
bool modelPar_given_VLR;
double modelPar_XEXT;
double d_modelPar_XEXT_dX;
bool modelPar_given_XEXT;
double modelPar_WAVL;
double d_modelPar_WAVL_dX;
bool modelPar_given_WAVL;
double modelPar_VAVL;
double d_modelPar_VAVL_dX;
bool modelPar_given_VAVL;
double modelPar_SFH;
double d_modelPar_SFH_dX;
bool modelPar_given_SFH;
double modelPar_RE;
double d_modelPar_RE_dX;
bool modelPar_given_RE;
double modelPar_RBC;
double d_modelPar_RBC_dX;
bool modelPar_given_RBC;
double modelPar_RBV;
double d_modelPar_RBV_dX;
bool modelPar_given_RBV;
double modelPar_RCC;
double d_modelPar_RCC_dX;
bool modelPar_given_RCC;
double modelPar_RCV;
double d_modelPar_RCV_dX;
bool modelPar_given_RCV;
double modelPar_SCRCV;
double d_modelPar_SCRCV_dX;
bool modelPar_given_SCRCV;
double modelPar_IHC;
double d_modelPar_IHC_dX;
bool modelPar_given_IHC;
double modelPar_AXI;
double d_modelPar_AXI_dX;
bool modelPar_given_AXI;
double modelPar_CJE;
double d_modelPar_CJE_dX;
bool modelPar_given_CJE;
double modelPar_VDE;
double d_modelPar_VDE_dX;
bool modelPar_given_VDE;
double modelPar_PE;
double d_modelPar_PE_dX;
bool modelPar_given_PE;
double modelPar_XCJE;
double d_modelPar_XCJE_dX;
bool modelPar_given_XCJE;
double modelPar_CBEO;
double d_modelPar_CBEO_dX;
bool modelPar_given_CBEO;
double modelPar_CJC;
double d_modelPar_CJC_dX;
bool modelPar_given_CJC;
double modelPar_VDC;
double d_modelPar_VDC_dX;
bool modelPar_given_VDC;
double modelPar_PC;
double d_modelPar_PC_dX;
bool modelPar_given_PC;
double modelPar_XP;
double d_modelPar_XP_dX;
bool modelPar_given_XP;
double modelPar_MC;
double d_modelPar_MC_dX;
bool modelPar_given_MC;
double modelPar_XCJC;
double d_modelPar_XCJC_dX;
bool modelPar_given_XCJC;
double modelPar_RCBLX;
double d_modelPar_RCBLX_dX;
bool modelPar_given_RCBLX;
double modelPar_RCBLI;
double d_modelPar_RCBLI_dX;
bool modelPar_given_RCBLI;
double modelPar_CBCO;
double d_modelPar_CBCO_dX;
bool modelPar_given_CBCO;
double modelPar_MTAU;
double d_modelPar_MTAU_dX;
bool modelPar_given_MTAU;
double modelPar_TAUE;
double d_modelPar_TAUE_dX;
bool modelPar_given_TAUE;
double modelPar_TAUB;
double d_modelPar_TAUB_dX;
bool modelPar_given_TAUB;
double modelPar_TEPI;
double d_modelPar_TEPI_dX;
bool modelPar_given_TEPI;
double modelPar_TAUR;
double d_modelPar_TAUR_dX;
bool modelPar_given_TAUR;
double modelPar_DEG;
double d_modelPar_DEG_dX;
bool modelPar_given_DEG;
double modelPar_XREC;
double d_modelPar_XREC_dX;
bool modelPar_given_XREC;
double modelPar_XQB;
double d_modelPar_XQB_dX;
bool modelPar_given_XQB;
double modelPar_AQBO;
double d_modelPar_AQBO_dX;
bool modelPar_given_AQBO;
double modelPar_AE;
double d_modelPar_AE_dX;
bool modelPar_given_AE;
double modelPar_AB;
double d_modelPar_AB_dX;
bool modelPar_given_AB;
double modelPar_AEPI;
double d_modelPar_AEPI_dX;
bool modelPar_given_AEPI;
double modelPar_AEX;
double d_modelPar_AEX_dX;
bool modelPar_given_AEX;
double modelPar_AC;
double d_modelPar_AC_dX;
bool modelPar_given_AC;
double modelPar_ACBL;
double d_modelPar_ACBL_dX;
bool modelPar_given_ACBL;
double modelPar_DVGBF;
double d_modelPar_DVGBF_dX;
bool modelPar_given_DVGBF;
double modelPar_DVGBR;
double d_modelPar_DVGBR_dX;
bool modelPar_given_DVGBR;
double modelPar_VGB;
double d_modelPar_VGB_dX;
bool modelPar_given_VGB;
double modelPar_VGC;
double d_modelPar_VGC_dX;
bool modelPar_given_VGC;
double modelPar_VGJ;
double d_modelPar_VGJ_dX;
bool modelPar_given_VGJ;
double modelPar_VGZEB;
double d_modelPar_VGZEB_dX;
bool modelPar_given_VGZEB;
double modelPar_AVGEB;
double d_modelPar_AVGEB_dX;
bool modelPar_given_AVGEB;
double modelPar_TVGEB;
double d_modelPar_TVGEB_dX;
bool modelPar_given_TVGEB;
double modelPar_DVGTE;
double d_modelPar_DVGTE_dX;
bool modelPar_given_DVGTE;
double modelPar_DAIS;
double d_modelPar_DAIS_dX;
bool modelPar_given_DAIS;
double modelPar_AF;
double d_modelPar_AF_dX;
bool modelPar_given_AF;
double modelPar_KF;
double d_modelPar_KF_dX;
bool modelPar_given_KF;
double modelPar_KFN;
double d_modelPar_KFN_dX;
bool modelPar_given_KFN;
double modelPar_KE;
double d_modelPar_KE_dX;
bool modelPar_given_KE;
double modelPar_FTAUN;
double d_modelPar_FTAUN_dX;
bool modelPar_given_FTAUN;
double modelPar_ISS;
double d_modelPar_ISS_dX;
bool modelPar_given_ISS;
double modelPar_ICSS;
double d_modelPar_ICSS_dX;
bool modelPar_given_ICSS;
double modelPar_IKS;
double d_modelPar_IKS_dX;
bool modelPar_given_IKS;
double modelPar_CJS;
double d_modelPar_CJS_dX;
bool modelPar_given_CJS;
double modelPar_VDS;
double d_modelPar_VDS_dX;
bool modelPar_given_VDS;
double modelPar_PS;
double d_modelPar_PS_dX;
bool modelPar_given_PS;
double modelPar_VGS;
double d_modelPar_VGS_dX;
bool modelPar_given_VGS;
double modelPar_AS;
double d_modelPar_AS_dX;
bool modelPar_given_AS;
double modelPar_ASUB;
double d_modelPar_ASUB_dX;
bool modelPar_given_ASUB;
double modelPar_MULT;
double d_modelPar_MULT_dX;
bool modelPar_given_MULT;
double modelPar_GMIN;
double d_modelPar_GMIN_dX;
bool modelPar_given_GMIN;
// non-reals (including hidden)
int modelPar_LEVEL;
bool modelPar_given_LEVEL;
int modelPar_EXMOD;
bool modelPar_given_EXMOD;
int modelPar_EXPHI;
bool modelPar_given_EXPHI;
int modelPar_EXAVL;
bool modelPar_given_EXAVL;
int modelPar_EXSUB;
bool modelPar_given_EXSUB;
int modelPar_KAVL;
bool modelPar_given_KAVL;
int modelPar_KC;
bool modelPar_given_KC;
int modelPar_TYPE;
bool modelPar_given_TYPE;
};



//-----------------------------------------------------------------------------
// Free functions used by sensitivity
//
//-----------------------------------------------------------------------------
void evaluateModelEquations(
std::vector <double> & probeVars,
// probe constants
const int admsProbeID_V_s_GND,
const int admsProbeID_V_b_GND,
const int admsProbeID_V_b2_GND,
const int admsProbeID_V_b1_GND,
const int admsProbeID_V_e_GND,
const int admsProbeID_V_c1_GND,
const int admsProbeID_V_c2_GND,
const int admsProbeID_V_e1_GND,
const int admsProbeID_V_s_c,
const int admsProbeID_V_b_s,
const int admsProbeID_V_s_e,
const int admsProbeID_V_c_e,
const int admsProbeID_V_noi_GND,
const int admsProbeID_V_c3_c1,
const int admsProbeID_V_c3_c4,
const int admsProbeID_V_c4_c1,
const int admsProbeID_V_b_c,
const int admsProbeID_V_b_e,
const int admsProbeID_V_b_b1,
const int admsProbeID_V_e_e1,
const int admsProbeID_V_c1_c2,
const int admsProbeID_V_s_c1,
const int admsProbeID_V_b1_b2,
const int admsProbeID_V_b1_e1,
const int admsProbeID_V_b2_e1,
const int admsProbeID_V_b2_c2,
const int admsProbeID_V_b2_c1,
// node constants
const int admsNodeID_c,
const int admsNodeID_b,
const int admsNodeID_e,
const int admsNodeID_s,
const int admsNodeID_e1,
const int admsNodeID_b1,
const int admsNodeID_b2,
const int admsNodeID_c1,
const int admsNodeID_c2,
const int admsNodeID_c3,
const int admsNodeID_c4,
const int admsNodeID_noi,
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
// basic variables
 double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, std::vector <double> & d_staticContributions_dX, std::vector <double> & d_dynamicContributions_dX, const Instance & theInstance);

void evaluateInitialInstance(
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
 double admsTemperature,double adms_vt_nom, double ADMSgmin_arg, const Instance & theInstance);

void evaluateInitialModel(
modelSensStruct & modelStruct,
 double admsTemperature, double ADMSgmin_arg, const Instance & theInstance);

#endif // Xyce_ADMS_SENSITIVITIES


// Limited exponential --- NOT what verilog LRM says, but what qucs,
// ng-spice, and zspice do.

template <typename T>
T limexp(const T &x)
{
  if ((x) < 80.0)
  return (exp(x));
  else
  return (exp(80.0)*(x-79.0));
}


struct Traits: public DeviceTraits<Model, Instance, BJT::Traits>
{
  static const char *name() {return "MEXTRAM 504.12.1";}
  static const char *deviceTypeName() {return "Q level 504";}

  static int numNodes() {return 4;}


  static bool modelRequired() {return true;}
  static bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &configuration, const FactoryBlock &factory_block);
  static void loadModelParameters(ParametricData<Model> &model_parameters);
  static void loadInstanceParameters(ParametricData<Instance> &instance_parameters);
};

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;
#ifdef Xyce_ADMS_SENSITIVITIES
  friend class InstanceSensitivity;
  friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
  friend struct Traits;

  public:
    Instance(
      const Configuration &       configuration,
      const InstanceBlock &       instance_block,
      Model &                     model,
      const FactoryBlock &        factory_block);

    ~Instance();

private:
    Instance(const Instance &);
    Instance &operator=(const Instance &);

public:
    void registerLIDs( const LocalIdVector & intLIDVecRef,
                       const LocalIdVector & extLIDVecRef );
    void registerStoreLIDs( const LocalIdVector & stoLIDVecRef );
    void setupPointers();

    void loadNodeSymbols(Util::SymbolTable &symbol_table) const;

    const JacobianStamp & jacobianStamp() const;
    void registerJacLIDs( const JacobianStamp & jacLIDVec );

    void registerBranchDataLIDs(const std::vector<int> & branchLIDVecRef);

    bool processParams();
    bool updateTemperature ( const double & temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

      void collapseNodes();
      int getNumNoiseSources () const;  // 26
      void setupNoiseSources (Xyce::Analysis::NoiseData & noiseData);
      void getNoiseSources (Xyce::Analysis::NoiseData & noiseData);

  private:

  public:
    // iterator reference to the bjt504va model which owns this instance.
    // Getters and setters
    Model &getModel()
    {
      return model_;
    }

  private:

    Model & model_;   //< Owning Model
    // Begin verilog Instance Variables
    //   Instance Parameters
    double MULT;
    //  Variables of global_instance scope
    double An;
    double Tk;
    double Vt;
    double VtINV;
    double VDE_T;
    double VDC_T;
    double XP_T;
    double BF_T;
    double BRI_T;
    double IS_T;
    double VEF_T;
    double VER_T;
    double nZEB_T;
    double pow2_2mPE;
    double pow2_PEm2;
    double inv_VDE_T;
    double VGZEB_T;
    double TAUE_T;
    double TAUB_T;
    double TEPI_T;
    double TAUR_T;
    double BnT;
    double DEG_T;
    double VDS_T;
    double IKS_T;
    double IS_TM;
    double IK_TM;
    double IBF_TM;
    double IBR_TM;
    double IHC_M;
    double IZEB_TM;
    double CJE_TM;
    double CJC_TM;
    double RE_TM;
    double RBC_TM;
    double RBV_TM;
    double RCV_TM;
    double SCRCV_M;
    double RCCxx_TM;
    double RCCex_TM;
    double RCCin_TM;
    double GCCxx_TM;
    double GCCex_TM;
    double GCCin_TM;
    double KF_M;
    double KFN_M;
    double ISS_TM;
    double ICSS_TM;
    double IKS_TM;
    double CJS_TM;
    double Xext1;
    double CBEO_M;
    double CBCO_M;
    double dxa;
     double d_dxa_dV_s_c1;
     double d_dxa_dV_b_c;
     double d_dxa_dV_b_b1;
     double d_dxa_dV_c3_c1;
     double d_dxa_dV_c3_c4;
     double d_dxa_dV_b1_b2;
     double d_dxa_dV_c4_c1;
     double d_dxa_dV_b1_e1;
     double d_dxa_dV_b2_e1;
     double d_dxa_dV_b2_c2;
     double d_dxa_dV_b2_c1;
     double d_dxa_dV_c1_c2;
    double OP_ic;
    double OP_ib;
    double OP_betadc;
    double OP_ie;
    double OP_vbe;
    double OP_vce;
    double OP_vbc;
    double OP_is;
    double OP_vse;
    double OP_vbs;
    double OP_vsc;
    double OP_vb2e1;
    double OP_vb2c2;
    double OP_vb2c1;
    double OP_vb1c1;
    double OP_vc4c1;
    double OP_vc3c4;
    double OP_ve1e;
    double OP_in;
    double OP_ic1c2;
    double OP_ib1b2;
    double OP_ib1;
    double OP_sib1;
    double OP_izteb;
    double OP_ib2;
    double OP_ib3;
    double OP_iavl;
    double OP_iex;
    double OP_xiex;
    double OP_isub;
    double OP_xisub;
    double OP_isf;
    double OP_ire;
    double OP_irbc;
    double OP_ircblx;
    double OP_ircbli;
    double OP_ircc;
    double OP_qe;
    double OP_qte;
    double OP_sqte;
    double OP_qbe;
    double OP_qbc;
    double OP_qtc;
    double OP_qepi;
    double OP_qb1b2;
    double OP_qtex;
    double OP_xqtex;
    double OP_qex;
    double OP_xqex;
    double OP_qts;
    double OP_gx;
    double OP_gy;
    double OP_gz;
    double OP_sgpi;
    double OP_gpix;
    double OP_gpiy;
    double OP_gpiz;
    double OP_gmux;
    double OP_gmuy;
    double OP_gmuz;
    double OP_gmuex;
    double OP_xgmuex;
    double OP_grcvy;
    double OP_grcvz;
    double OP_rbv;
    double OP_grbvx;
    double OP_grbvy;
    double OP_grbvz;
    double OP_re;
    double OP_rbc;
    double OP_rcc;
    double OP_rcblx;
    double OP_rcbli;
    double OP_gs;
    double OP_xgs;
    double OP_gsf;
    double OP_scbe;
    double OP_cbex;
    double OP_cbey;
    double OP_cbez;
    double OP_cbcx;
    double OP_cbcy;
    double OP_cbcz;
    double OP_cbcex;
    double OP_xcbcex;
    double OP_cb1b2;
    double OP_cb1b2x;
    double OP_cb1b2y;
    double OP_cb1b2z;
    double OP_cts;
    double OP_gm;
    double OP_beta;
    double OP_gout;
    double OP_gmu;
    double OP_rb;
    double OP_rc;
    double OP_cbe;
    double OP_cbc;
    double OP_ft;
    double OP_iqs;
    double OP_xiwepi;
    double OP_vb2c2star;
    double OP_tk;
    // end verilog Instance Variables=====
    // Nodal LID Variables
    int li_c;
    int li_b;
    int li_e;
    int li_s;
    int li_e1;
    int li_b1;
    int li_b2;
    int li_c1;
    int li_c2;
    int li_c3;
    int li_c4;
    int li_noi;
    // end Nodal LID Variables
    // Branch LID Variables
    // end Branch LID Variables
    // Lead (branch) LID Variables
    int li_branch_ic;
    int li_branch_ib;
    int li_branch_ie;
    int li_branch_is;
    // end Lead (branch) LID Variables
    // Jacobian  pointers
    double * f_c1_Equ_c1_Node_Ptr;
    double * f_c1_Equ_c2_Node_Ptr;
    double * f_c2_Equ_c1_Node_Ptr;
    double * f_c2_Equ_c2_Node_Ptr;
    double * f_c1_Equ_b2_Node_Ptr;
    double * f_c2_Equ_b2_Node_Ptr;
    double * f_e1_Equ_c1_Node_Ptr;
    double * f_e1_Equ_c2_Node_Ptr;
    double * f_e1_Equ_b2_Node_Ptr;
    double * f_c2_Equ_e1_Node_Ptr;
    double * f_e1_Equ_e1_Node_Ptr;
    double * f_b1_Equ_b1_Node_Ptr;
    double * f_b1_Equ_e1_Node_Ptr;
    double * f_e1_Equ_b1_Node_Ptr;
    double * f_b2_Equ_b2_Node_Ptr;
    double * f_b2_Equ_e1_Node_Ptr;
    double * f_b2_Equ_c1_Node_Ptr;
    double * f_b2_Equ_c2_Node_Ptr;
    double * f_b1_Equ_s_Node_Ptr;
    double * f_b1_Equ_c1_Node_Ptr;
    double * f_s_Equ_s_Node_Ptr;
    double * f_s_Equ_c1_Node_Ptr;
    double * f_b1_Equ_c4_Node_Ptr;
    double * f_s_Equ_c4_Node_Ptr;
    double * f_b1_Equ_c2_Node_Ptr;
    double * f_s_Equ_c2_Node_Ptr;
    double * f_b1_Equ_b2_Node_Ptr;
    double * f_s_Equ_b2_Node_Ptr;
    double * f_s_Equ_b1_Node_Ptr;
    double * f_b_Equ_s_Node_Ptr;
    double * f_b_Equ_c1_Node_Ptr;
    double * f_b_Equ_c2_Node_Ptr;
    double * f_b_Equ_b2_Node_Ptr;
    double * f_b_Equ_e1_Node_Ptr;
    double * f_s_Equ_e1_Node_Ptr;
    double * f_b_Equ_c3_Node_Ptr;
    double * f_b_Equ_c4_Node_Ptr;
    double * f_s_Equ_c3_Node_Ptr;
    double * f_b_Equ_b1_Node_Ptr;
    double * f_b_Equ_b_Node_Ptr;
    double * f_s_Equ_b_Node_Ptr;
    double * f_b_Equ_c_Node_Ptr;
    double * f_s_Equ_c_Node_Ptr;
    double * f_c1_Equ_s_Node_Ptr;
    double * f_b1_Equ_c3_Node_Ptr;
    double * f_b2_Equ_c3_Node_Ptr;
    double * f_b2_Equ_c4_Node_Ptr;
    double * f_b1_Equ_b_Node_Ptr;
    double * f_b2_Equ_b_Node_Ptr;
    double * f_b2_Equ_b1_Node_Ptr;
    double * f_b1_Equ_c_Node_Ptr;
    double * f_b2_Equ_c_Node_Ptr;
    double * f_c2_Equ_c3_Node_Ptr;
    double * f_c2_Equ_c4_Node_Ptr;
    double * f_c2_Equ_b1_Node_Ptr;
    double * f_c2_Equ_b_Node_Ptr;
    double * f_c2_Equ_c_Node_Ptr;
    double * f_e_Equ_e_Node_Ptr;
    double * f_e_Equ_e1_Node_Ptr;
    double * f_e1_Equ_e_Node_Ptr;
    double * f_e1_Equ_c3_Node_Ptr;
    double * f_e1_Equ_c4_Node_Ptr;
    double * f_e1_Equ_b_Node_Ptr;
    double * f_e1_Equ_c_Node_Ptr;
    double * f_c1_Equ_e1_Node_Ptr;
    double * f_c1_Equ_b1_Node_Ptr;
    double * f_c1_Equ_c4_Node_Ptr;
    double * f_c1_Equ_c3_Node_Ptr;
    double * f_c1_Equ_b_Node_Ptr;
    double * f_c1_Equ_c_Node_Ptr;
    double * f_b_Equ_e_Node_Ptr;
    double * f_e_Equ_b_Node_Ptr;
    double * f_c_Equ_b_Node_Ptr;
    double * f_c_Equ_c_Node_Ptr;
    double * f_c3_Equ_s_Node_Ptr;
    double * f_c3_Equ_c1_Node_Ptr;
    double * f_c3_Equ_c2_Node_Ptr;
    double * f_c3_Equ_b2_Node_Ptr;
    double * f_c3_Equ_e1_Node_Ptr;
    double * f_c3_Equ_c3_Node_Ptr;
    double * f_c3_Equ_c4_Node_Ptr;
    double * f_c3_Equ_b1_Node_Ptr;
    double * f_c3_Equ_b_Node_Ptr;
    double * f_c3_Equ_c_Node_Ptr;
    double * f_c_Equ_c3_Node_Ptr;
    double * f_c_Equ_c4_Node_Ptr;
    double * f_c_Equ_c1_Node_Ptr;
    double * f_c_Equ_c2_Node_Ptr;
    double * f_c_Equ_b2_Node_Ptr;
    double * f_c_Equ_b1_Node_Ptr;
    double * f_c4_Equ_c4_Node_Ptr;
    double * f_c4_Equ_c1_Node_Ptr;
    double * f_c4_Equ_b2_Node_Ptr;
    double * f_c4_Equ_e1_Node_Ptr;
    double * f_c4_Equ_c2_Node_Ptr;
    double * f_c4_Equ_b1_Node_Ptr;
    double * f_c4_Equ_c3_Node_Ptr;
    double * f_c4_Equ_s_Node_Ptr;
    double * f_c4_Equ_b_Node_Ptr;
    double * f_c4_Equ_c_Node_Ptr;
    double * f_noi_Equ_c1_Node_Ptr;
    double * f_noi_Equ_c2_Node_Ptr;
    double * f_noi_Equ_b2_Node_Ptr;
    double * f_noi_Equ_e1_Node_Ptr;
    double * f_noi_Equ_noi_Node_Ptr;
    double * f_b2_Equ_noi_Node_Ptr;
    double * f_e1_Equ_noi_Node_Ptr;
    double * f_c2_Equ_noi_Node_Ptr;
    double * q_c1_Equ_c1_Node_Ptr;
    double * q_c1_Equ_c2_Node_Ptr;
    double * q_c2_Equ_c1_Node_Ptr;
    double * q_c2_Equ_c2_Node_Ptr;
    double * q_c1_Equ_b2_Node_Ptr;
    double * q_c2_Equ_b2_Node_Ptr;
    double * q_e1_Equ_c1_Node_Ptr;
    double * q_e1_Equ_c2_Node_Ptr;
    double * q_e1_Equ_b2_Node_Ptr;
    double * q_c2_Equ_e1_Node_Ptr;
    double * q_e1_Equ_e1_Node_Ptr;
    double * q_b1_Equ_b1_Node_Ptr;
    double * q_b1_Equ_e1_Node_Ptr;
    double * q_e1_Equ_b1_Node_Ptr;
    double * q_b2_Equ_b2_Node_Ptr;
    double * q_b2_Equ_e1_Node_Ptr;
    double * q_b2_Equ_c1_Node_Ptr;
    double * q_b2_Equ_c2_Node_Ptr;
    double * q_b1_Equ_s_Node_Ptr;
    double * q_b1_Equ_c1_Node_Ptr;
    double * q_s_Equ_s_Node_Ptr;
    double * q_s_Equ_c1_Node_Ptr;
    double * q_b1_Equ_c4_Node_Ptr;
    double * q_s_Equ_c4_Node_Ptr;
    double * q_b1_Equ_c2_Node_Ptr;
    double * q_s_Equ_c2_Node_Ptr;
    double * q_b1_Equ_b2_Node_Ptr;
    double * q_s_Equ_b2_Node_Ptr;
    double * q_s_Equ_b1_Node_Ptr;
    double * q_b_Equ_s_Node_Ptr;
    double * q_b_Equ_c1_Node_Ptr;
    double * q_b_Equ_c2_Node_Ptr;
    double * q_b_Equ_b2_Node_Ptr;
    double * q_b_Equ_e1_Node_Ptr;
    double * q_s_Equ_e1_Node_Ptr;
    double * q_b_Equ_c3_Node_Ptr;
    double * q_b_Equ_c4_Node_Ptr;
    double * q_s_Equ_c3_Node_Ptr;
    double * q_b_Equ_b1_Node_Ptr;
    double * q_b_Equ_b_Node_Ptr;
    double * q_s_Equ_b_Node_Ptr;
    double * q_b_Equ_c_Node_Ptr;
    double * q_s_Equ_c_Node_Ptr;
    double * q_c1_Equ_s_Node_Ptr;
    double * q_b1_Equ_c3_Node_Ptr;
    double * q_b2_Equ_c3_Node_Ptr;
    double * q_b2_Equ_c4_Node_Ptr;
    double * q_b1_Equ_b_Node_Ptr;
    double * q_b2_Equ_b_Node_Ptr;
    double * q_b2_Equ_b1_Node_Ptr;
    double * q_b1_Equ_c_Node_Ptr;
    double * q_b2_Equ_c_Node_Ptr;
    double * q_c2_Equ_c3_Node_Ptr;
    double * q_c2_Equ_c4_Node_Ptr;
    double * q_c2_Equ_b1_Node_Ptr;
    double * q_c2_Equ_b_Node_Ptr;
    double * q_c2_Equ_c_Node_Ptr;
    double * q_e_Equ_e_Node_Ptr;
    double * q_e_Equ_e1_Node_Ptr;
    double * q_e1_Equ_e_Node_Ptr;
    double * q_e1_Equ_c3_Node_Ptr;
    double * q_e1_Equ_c4_Node_Ptr;
    double * q_e1_Equ_b_Node_Ptr;
    double * q_e1_Equ_c_Node_Ptr;
    double * q_c1_Equ_e1_Node_Ptr;
    double * q_c1_Equ_b1_Node_Ptr;
    double * q_c1_Equ_c4_Node_Ptr;
    double * q_c1_Equ_c3_Node_Ptr;
    double * q_c1_Equ_b_Node_Ptr;
    double * q_c1_Equ_c_Node_Ptr;
    double * q_b_Equ_e_Node_Ptr;
    double * q_e_Equ_b_Node_Ptr;
    double * q_c_Equ_b_Node_Ptr;
    double * q_c_Equ_c_Node_Ptr;
    double * q_c3_Equ_s_Node_Ptr;
    double * q_c3_Equ_c1_Node_Ptr;
    double * q_c3_Equ_c2_Node_Ptr;
    double * q_c3_Equ_b2_Node_Ptr;
    double * q_c3_Equ_e1_Node_Ptr;
    double * q_c3_Equ_c3_Node_Ptr;
    double * q_c3_Equ_c4_Node_Ptr;
    double * q_c3_Equ_b1_Node_Ptr;
    double * q_c3_Equ_b_Node_Ptr;
    double * q_c3_Equ_c_Node_Ptr;
    double * q_c_Equ_c3_Node_Ptr;
    double * q_c_Equ_c4_Node_Ptr;
    double * q_c_Equ_c1_Node_Ptr;
    double * q_c_Equ_c2_Node_Ptr;
    double * q_c_Equ_b2_Node_Ptr;
    double * q_c_Equ_b1_Node_Ptr;
    double * q_c4_Equ_c4_Node_Ptr;
    double * q_c4_Equ_c1_Node_Ptr;
    double * q_c4_Equ_b2_Node_Ptr;
    double * q_c4_Equ_e1_Node_Ptr;
    double * q_c4_Equ_c2_Node_Ptr;
    double * q_c4_Equ_b1_Node_Ptr;
    double * q_c4_Equ_c3_Node_Ptr;
    double * q_c4_Equ_s_Node_Ptr;
    double * q_c4_Equ_b_Node_Ptr;
    double * q_c4_Equ_c_Node_Ptr;
    double * q_noi_Equ_c1_Node_Ptr;
    double * q_noi_Equ_c2_Node_Ptr;
    double * q_noi_Equ_b2_Node_Ptr;
    double * q_noi_Equ_e1_Node_Ptr;
    double * q_noi_Equ_noi_Node_Ptr;
    double * q_b2_Equ_noi_Node_Ptr;
    double * q_e1_Equ_noi_Node_Ptr;
    double * q_c2_Equ_noi_Node_Ptr;
    // Jacobian offsets
    int A_c1_Equ_c1_NodeOffset;
    int A_c1_Equ_c2_NodeOffset;
    int A_c2_Equ_c1_NodeOffset;
    int A_c2_Equ_c2_NodeOffset;
    int A_c1_Equ_b2_NodeOffset;
    int A_c2_Equ_b2_NodeOffset;
    int A_e1_Equ_c1_NodeOffset;
    int A_e1_Equ_c2_NodeOffset;
    int A_e1_Equ_b2_NodeOffset;
    int A_c2_Equ_e1_NodeOffset;
    int A_e1_Equ_e1_NodeOffset;
    int A_b1_Equ_b1_NodeOffset;
    int A_b1_Equ_e1_NodeOffset;
    int A_e1_Equ_b1_NodeOffset;
    int A_b2_Equ_b2_NodeOffset;
    int A_b2_Equ_e1_NodeOffset;
    int A_b2_Equ_c1_NodeOffset;
    int A_b2_Equ_c2_NodeOffset;
    int A_b1_Equ_s_NodeOffset;
    int A_b1_Equ_c1_NodeOffset;
    int A_s_Equ_s_NodeOffset;
    int A_s_Equ_c1_NodeOffset;
    int A_b1_Equ_c4_NodeOffset;
    int A_s_Equ_c4_NodeOffset;
    int A_b1_Equ_c2_NodeOffset;
    int A_s_Equ_c2_NodeOffset;
    int A_b1_Equ_b2_NodeOffset;
    int A_s_Equ_b2_NodeOffset;
    int A_s_Equ_b1_NodeOffset;
    int A_b_Equ_s_NodeOffset;
    int A_b_Equ_c1_NodeOffset;
    int A_b_Equ_c2_NodeOffset;
    int A_b_Equ_b2_NodeOffset;
    int A_b_Equ_e1_NodeOffset;
    int A_s_Equ_e1_NodeOffset;
    int A_b_Equ_c3_NodeOffset;
    int A_b_Equ_c4_NodeOffset;
    int A_s_Equ_c3_NodeOffset;
    int A_b_Equ_b1_NodeOffset;
    int A_b_Equ_b_NodeOffset;
    int A_s_Equ_b_NodeOffset;
    int A_b_Equ_c_NodeOffset;
    int A_s_Equ_c_NodeOffset;
    int A_c1_Equ_s_NodeOffset;
    int A_b1_Equ_c3_NodeOffset;
    int A_b2_Equ_c3_NodeOffset;
    int A_b2_Equ_c4_NodeOffset;
    int A_b1_Equ_b_NodeOffset;
    int A_b2_Equ_b_NodeOffset;
    int A_b2_Equ_b1_NodeOffset;
    int A_b1_Equ_c_NodeOffset;
    int A_b2_Equ_c_NodeOffset;
    int A_c2_Equ_c3_NodeOffset;
    int A_c2_Equ_c4_NodeOffset;
    int A_c2_Equ_b1_NodeOffset;
    int A_c2_Equ_b_NodeOffset;
    int A_c2_Equ_c_NodeOffset;
    int A_e_Equ_e_NodeOffset;
    int A_e_Equ_e1_NodeOffset;
    int A_e1_Equ_e_NodeOffset;
    int A_e1_Equ_c3_NodeOffset;
    int A_e1_Equ_c4_NodeOffset;
    int A_e1_Equ_b_NodeOffset;
    int A_e1_Equ_c_NodeOffset;
    int A_c1_Equ_e1_NodeOffset;
    int A_c1_Equ_b1_NodeOffset;
    int A_c1_Equ_c4_NodeOffset;
    int A_c1_Equ_c3_NodeOffset;
    int A_c1_Equ_b_NodeOffset;
    int A_c1_Equ_c_NodeOffset;
    int A_b_Equ_e_NodeOffset;
    int A_e_Equ_b_NodeOffset;
    int A_c_Equ_b_NodeOffset;
    int A_c_Equ_c_NodeOffset;
    int A_c3_Equ_s_NodeOffset;
    int A_c3_Equ_c1_NodeOffset;
    int A_c3_Equ_c2_NodeOffset;
    int A_c3_Equ_b2_NodeOffset;
    int A_c3_Equ_e1_NodeOffset;
    int A_c3_Equ_c3_NodeOffset;
    int A_c3_Equ_c4_NodeOffset;
    int A_c3_Equ_b1_NodeOffset;
    int A_c3_Equ_b_NodeOffset;
    int A_c3_Equ_c_NodeOffset;
    int A_c_Equ_c3_NodeOffset;
    int A_c_Equ_c4_NodeOffset;
    int A_c_Equ_c1_NodeOffset;
    int A_c_Equ_c2_NodeOffset;
    int A_c_Equ_b2_NodeOffset;
    int A_c_Equ_b1_NodeOffset;
    int A_c4_Equ_c4_NodeOffset;
    int A_c4_Equ_c1_NodeOffset;
    int A_c4_Equ_b2_NodeOffset;
    int A_c4_Equ_e1_NodeOffset;
    int A_c4_Equ_c2_NodeOffset;
    int A_c4_Equ_b1_NodeOffset;
    int A_c4_Equ_c3_NodeOffset;
    int A_c4_Equ_s_NodeOffset;
    int A_c4_Equ_b_NodeOffset;
    int A_c4_Equ_c_NodeOffset;
    int A_noi_Equ_c1_NodeOffset;
    int A_noi_Equ_c2_NodeOffset;
    int A_noi_Equ_b2_NodeOffset;
    int A_noi_Equ_e1_NodeOffset;
    int A_noi_Equ_noi_NodeOffset;
    int A_b2_Equ_noi_NodeOffset;
    int A_e1_Equ_noi_NodeOffset;
    int A_c2_Equ_noi_NodeOffset;
    // end of Jacobian and pointers
   // node numbers
    static const int admsNodeID_c = 0;
    static const int admsNodeID_b = 1;
    static const int admsNodeID_e = 2;
    static const int admsNodeID_s = 3;
    static const int admsNodeID_e1 = 0+4;
    static const int admsNodeID_b1 = 1+4;
    static const int admsNodeID_b2 = 2+4;
    static const int admsNodeID_c1 = 3+4;
    static const int admsNodeID_c2 = 4+4;
    static const int admsNodeID_c3 = 5+4;
    static const int admsNodeID_c4 = 6+4;
    static const int admsNodeID_noi = 7+4;
    static const int admsNodeID_GND = -1;
   // end node numbers
   // Additional IDs for branch equations
   // end branch numbers
   // Probe numbers
    static const int admsProbeID_V_s_GND = 0;
    static const int admsProbeID_V_b_GND = 1;
    static const int admsProbeID_V_b2_GND = 2;
    static const int admsProbeID_V_b1_GND = 3;
    static const int admsProbeID_V_e_GND = 4;
    static const int admsProbeID_V_c1_GND = 5;
    static const int admsProbeID_V_c2_GND = 6;
    static const int admsProbeID_V_e1_GND = 7;
    static const int admsProbeID_V_s_c = 8;
    static const int admsProbeID_V_b_s = 9;
    static const int admsProbeID_V_s_e = 10;
    static const int admsProbeID_V_c_e = 11;
    static const int admsProbeID_V_noi_GND = 12;
    static const int admsProbeID_V_c3_c1 = 13;
    static const int admsProbeID_V_c3_c4 = 14;
    static const int admsProbeID_V_c4_c1 = 15;
    static const int admsProbeID_V_b_c = 16;
    static const int admsProbeID_V_b_e = 17;
    static const int admsProbeID_V_b_b1 = 18;
    static const int admsProbeID_V_e_e1 = 19;
    static const int admsProbeID_V_c1_c2 = 20;
    static const int admsProbeID_V_s_c1 = 21;
    static const int admsProbeID_V_b1_b2 = 22;
    static const int admsProbeID_V_b1_e1 = 23;
    static const int admsProbeID_V_b2_e1 = 24;
    static const int admsProbeID_V_b2_c2 = 25;
    static const int admsProbeID_V_b2_c1 = 26;
   // end probe numbers
   // Store LIDs
    int li_store_admsProbeID_V_b2_c1;
    int li_store_admsProbeID_V_b2_c2;
    int li_store_admsProbeID_V_b1_e1;
    int li_store_admsProbeID_V_b1_b2;
   // end store LIDs
   // Store LIDs for output vars
    int li_store_OP_ic;
    int li_store_OP_ib;
    int li_store_OP_betadc;
    int li_store_OP_ie;
    int li_store_OP_vbe;
    int li_store_OP_vce;
    int li_store_OP_vbc;
    int li_store_OP_is;
    int li_store_OP_vse;
    int li_store_OP_vbs;
    int li_store_OP_vsc;
    int li_store_OP_vb2e1;
    int li_store_OP_vb2c2;
    int li_store_OP_vb2c1;
    int li_store_OP_vb1c1;
    int li_store_OP_vc4c1;
    int li_store_OP_vc3c4;
    int li_store_OP_ve1e;
    int li_store_OP_in;
    int li_store_OP_ic1c2;
    int li_store_OP_ib1b2;
    int li_store_OP_ib1;
    int li_store_OP_sib1;
    int li_store_OP_izteb;
    int li_store_OP_ib2;
    int li_store_OP_ib3;
    int li_store_OP_iavl;
    int li_store_OP_iex;
    int li_store_OP_xiex;
    int li_store_OP_isub;
    int li_store_OP_xisub;
    int li_store_OP_isf;
    int li_store_OP_ire;
    int li_store_OP_irbc;
    int li_store_OP_ircblx;
    int li_store_OP_ircbli;
    int li_store_OP_ircc;
    int li_store_OP_qe;
    int li_store_OP_qte;
    int li_store_OP_sqte;
    int li_store_OP_qbe;
    int li_store_OP_qbc;
    int li_store_OP_qtc;
    int li_store_OP_qepi;
    int li_store_OP_qb1b2;
    int li_store_OP_qtex;
    int li_store_OP_xqtex;
    int li_store_OP_qex;
    int li_store_OP_xqex;
    int li_store_OP_qts;
    int li_store_OP_gx;
    int li_store_OP_gy;
    int li_store_OP_gz;
    int li_store_OP_sgpi;
    int li_store_OP_gpix;
    int li_store_OP_gpiy;
    int li_store_OP_gpiz;
    int li_store_OP_gmux;
    int li_store_OP_gmuy;
    int li_store_OP_gmuz;
    int li_store_OP_gmuex;
    int li_store_OP_xgmuex;
    int li_store_OP_grcvy;
    int li_store_OP_grcvz;
    int li_store_OP_rbv;
    int li_store_OP_grbvx;
    int li_store_OP_grbvy;
    int li_store_OP_grbvz;
    int li_store_OP_re;
    int li_store_OP_rbc;
    int li_store_OP_rcc;
    int li_store_OP_rcblx;
    int li_store_OP_rcbli;
    int li_store_OP_gs;
    int li_store_OP_xgs;
    int li_store_OP_gsf;
    int li_store_OP_scbe;
    int li_store_OP_cbex;
    int li_store_OP_cbey;
    int li_store_OP_cbez;
    int li_store_OP_cbcx;
    int li_store_OP_cbcy;
    int li_store_OP_cbcz;
    int li_store_OP_cbcex;
    int li_store_OP_xcbcex;
    int li_store_OP_cb1b2;
    int li_store_OP_cb1b2x;
    int li_store_OP_cb1b2y;
    int li_store_OP_cb1b2z;
    int li_store_OP_cts;
    int li_store_OP_gm;
    int li_store_OP_beta;
    int li_store_OP_gout;
    int li_store_OP_gmu;
    int li_store_OP_rb;
    int li_store_OP_rc;
    int li_store_OP_cbe;
    int li_store_OP_cbc;
    int li_store_OP_ft;
    int li_store_OP_iqs;
    int li_store_OP_xiwepi;
    int li_store_OP_vb2c2star;
    int li_store_OP_tk;
   // end store LIDs for output vars
     // bools for collapsing nodes
     bool collapseNode_c1;
     bool collapseNode_c4;
 // Arrays to hold probes
 std::vector < double > probeVars;
 std::vector < std::vector < double > > d_probeVars;
 // Arrays to hold contributions
 // dynamic contributions are differentiated w.r.t time
 std::vector < double > staticContributions;
 std::vector < std::vector < double > > d_staticContributions;
 std::vector < double > dynamicContributions;
 std::vector < std::vector < double > > d_dynamicContributions;
//vectors to hold noise information for communication between methods
std::vector<double> noiseContribsPower;
std::vector<double> noiseContribsExponent;

    // This array stores the differences between original and limited variables.
    std::vector<double> probeDiffs;
    // These store the Jdxp's for F and Q, respectively
    std::vector<double> Jdxp_static;
    std::vector<double> Jdxp_dynamic;

    // this is what we'll use when any model uses $temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at $temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;


    JacobianStamp jacStamp;
    IdVector nodeMap;
    PairMap pairToJacStampMap;

    // These instance-owned vectors are for storage of lead current data
    std::vector<double> leadCurrentF;
    std::vector<double> leadCurrentQ;


    };



namespace AnalogFunctions
{

      // Analog Function trunc_ev
double trunc_ev(double Val, double Vprev, double Vmin, double Vmax);
// Derivative of Analog Function trunc_ev
double d_trunc_ev(double Val , double Vprev , double Vmin , double Vmax  , double d_Val  , double d_Vprev  , double d_Vmin  , double d_Vmax  );
// Evaluator class for Analog Function trunc_ev
class trunc_evEvaluator
{
  struct returnType
  {
     double value;
     double deriv_WRT_Val;
     double deriv_WRT_Vprev;
     double deriv_WRT_Vmin;
     double deriv_WRT_Vmax;
  };
public:
  // constructor takes all same arguments as regular templated function,
  // even though it doesn't USE the output args
  trunc_evEvaluator(double Val, double Vprev, double Vmin, double Vmax);
  // function that returns the precomputed values.  This, too, takes
  // all the same arguments as the regular function, though it ONLY
  // uses the output arguments
  double getValues(double  Val, double  Vprev, double  Vmin, double  Vmax);
  // function that returns the total derivative of the function and its
  // output arguments with respect to some variable.  We pass in the
  // normal arguments(none of which are used) and the derivatives of those
  // arguments with respect to the desired variable.  We compute the
  // derivatives using the chain rule and our precomputed derivatives
  // with respect to input variables
double getDerivs(double Val , double Vprev , double Vmin , double Vmax  , double d_Val, double d_Vprev, double d_Vmin, double d_Vmax);
private:
  returnType trunc_evReturn_;
  returnType evaluator_(double Val, double Vprev, double Vmin, double Vmax);
};

}


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
    typedef std::vector<Instance *> InstanceVector;

    friend class ParametricData<Model>;
    friend class Instance;
#ifdef Xyce_ADMS_SENSITIVITIES
    friend class InstanceSensitivity;
    friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
    friend struct Traits;

  public:
    Model(
      const Configuration &       configuration,
      const ModelBlock &          model_block,
      const FactoryBlock &        factory_block);

    ~Model();

private:
    Model(const Model &);
    Model &operator=(const Model &);

public:
    virtual void forEachInstance(DeviceInstanceOp &op) const /* override */;
    virtual std::ostream &printOutInstances(std::ostream &os) const;
    bool processParams();
    bool processInstanceParams();

  private:

  public:
    void addInstance(Instance *instance)
    {
      instanceContainer.push_back(instance);
    }

    void setupBaseInstanceContainer()
    {
      std::vector<Instance*>::iterator iter = instanceContainer.begin();
      std::vector<Instance*>::iterator end   = instanceContainer.end();
      for ( ; iter!=end; ++iter)
      {
      Xyce::Device::DeviceModel::baseInstanceContainer.push_back( static_cast<Xyce::Device::DeviceInstance *>(*iter) );
    }
  }

  private:
    std::vector<Instance*> instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;
// Begin verilog Model Variables
//   Model Parameters
    int LEVEL;
    double TREF;
    double DTA;
    int EXMOD;
    int EXPHI;
    int EXAVL;
    int EXSUB;
    double IS;
    double IK;
    double VER;
    double VEF;
    double BF;
    double IBF;
    double MLF;
    double XIBI;
    double IZEB;
    double NZEB;
    double BRI;
    double IBR;
    double VLR;
    double XEXT;
    double WAVL;
    double VAVL;
    double SFH;
    double RE;
    double RBC;
    double RBV;
    double RCC;
    double RCV;
    double SCRCV;
    double IHC;
    double AXI;
    double CJE;
    double VDE;
    double PE;
    double XCJE;
    double CBEO;
    double CJC;
    double VDC;
    double PC;
    double XP;
    double MC;
    double XCJC;
    double RCBLX;
    double RCBLI;
    double CBCO;
    double MTAU;
    double TAUE;
    double TAUB;
    double TEPI;
    double TAUR;
    double DEG;
    double XREC;
    double XQB;
    double AQBO;
    double AE;
    double AB;
    double AEPI;
    double AEX;
    double AC;
    double ACBL;
    double DVGBF;
    double DVGBR;
    double VGB;
    double VGC;
    double VGJ;
    double VGZEB;
    double AVGEB;
    double TVGEB;
    double DVGTE;
    double DAIS;
    double AF;
    double KF;
    double KFN;
    int KAVL;
    int KC;
    double KE;
    double FTAUN;
    double ISS;
    double ICSS;
    double IKS;
    double CJS;
    double VDS;
    double PS;
    double VGS;
    double AS;
    double ASUB;
    double MULT;
    int TYPE;
    double GMIN;
    //  Variables of global_model scope
    // end verilog model variables=====
};

void registerDevice(const DeviceCountMap& deviceMap = DeviceCountMap(),
                    const std::set<int>& levelSet = std::set<int>());

} // namespace ADMSbjt504va
} // namespace Device
} // namespace Xyce
#endif //Xyce_N_DEV_ADMSbjt504va_h
