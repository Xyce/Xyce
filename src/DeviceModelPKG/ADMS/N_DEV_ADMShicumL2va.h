
// -*-c++-*-
//-------------------------------------------------------------------------
//   Copyright 2002-2024 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file hicumL2V2p4p0.va with ADMS
//                  interface for Xyce 7.9.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.7
//
// Creation Date  : Thu, 23 May 2024 20:30:06
//
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMShicumL2va_h
#define Xyce_N_DEV_ADMShicumL2va_h


#include <N_DEV_Configuration.h>
#include <N_DEV_Const.h>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>
#include <N_DEV_BJT.h>


// Xyce_config.h contains a VERSION macro from autoconf, and some
// Verilog-A models like to define a variable of that name.  This can be
// a serious problem, and we don't need the VERSION macro.  Get rid of it.
// This must happen *after* all the includes of Xyce headers, each of which
// includes Xyce_config.h.  The implementation file must do this all again
// because it includes more Xyce headers *after* including this one.
#ifdef VERSION
#undef VERSION
#endif

namespace Xyce {
namespace Device {
namespace ADMShicumL2va {

class Model;
class Instance;
class InstanceSensitivity;

#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Class         : InstanceSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class InstanceSensitivity : public baseSensitivity
{
public:
InstanceSensitivity() :
baseSensitivity() {};

virtual ~InstanceSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static InstanceSensitivity instSens;


//-----------------------------------------------------------------------------
// Class         : ModelSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class ModelSensitivity : public baseSensitivity
{
public:
ModelSensitivity() :
baseSensitivity() {};

virtual ~ModelSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static ModelSensitivity modSens;
#endif // Xyce_ADMS_SENSITIVITIES

// general purpose free functions
// thermal voltage at kelvin temperature temp)
static inline double adms_vt(const double temp) {return(CONSTKoverQ*temp);};


#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// "structs" to hold instance and model param/variable copies
//-----------------------------------------------------------------------------
class instanceSensStruct
{
public:
// instance variables
// reals
double instanceVar_VT;
double d_instanceVar_VT_dX;
double instanceVar_Tdev;
double d_instanceVar_Tdev_dX;
double instanceVar_qtt0;
double d_instanceVar_qtt0_dX;
double instanceVar_ln_qtt0;
double d_instanceVar_ln_qtt0_dX;
double instanceVar_r_VgVT;
double d_instanceVar_r_VgVT_dX;
double instanceVar_V_gT;
double d_instanceVar_V_gT_dX;
double instanceVar_dT;
double d_instanceVar_dT_dX;
double instanceVar_k;
double d_instanceVar_k_dX;
double instanceVar_ireis_t;
double d_instanceVar_ireis_t_dX;
double instanceVar_ibeis_t;
double d_instanceVar_ibeis_t_dX;
double instanceVar_ibcxs_t;
double d_instanceVar_ibcxs_t_dX;
double instanceVar_ibcis_t;
double d_instanceVar_ibcis_t_dX;
double instanceVar_iscs_t;
double d_instanceVar_iscs_t_dX;
double instanceVar_cjci0_t;
double d_instanceVar_cjci0_t_dX;
double instanceVar_cjs0_t;
double d_instanceVar_cjs0_t_dX;
double instanceVar_cscp0_t;
double d_instanceVar_cscp0_t_dX;
double instanceVar_rci0_t;
double d_instanceVar_rci0_t_dX;
double instanceVar_vlim_t;
double d_instanceVar_vlim_t_dX;
double instanceVar_vces_t;
double d_instanceVar_vces_t_dX;
double instanceVar_thcs_t;
double d_instanceVar_thcs_t_dX;
double instanceVar_tef0_t;
double d_instanceVar_tef0_t_dX;
double instanceVar_rbi0_t;
double d_instanceVar_rbi0_t_dX;
double instanceVar_t0_t;
double d_instanceVar_t0_t_dX;
double instanceVar_vdei_t;
double d_instanceVar_vdei_t_dX;
double instanceVar_vdci_t;
double d_instanceVar_vdci_t_dX;
double instanceVar_vpts_t;
double d_instanceVar_vpts_t_dX;
double instanceVar_vptsp_t;
double d_instanceVar_vptsp_t_dX;
double instanceVar_itss_t;
double d_instanceVar_itss_t_dX;
double instanceVar_tsf_t;
double d_instanceVar_tsf_t_dX;
double instanceVar_c10_t;
double d_instanceVar_c10_t_dX;
double instanceVar_cjei0_t;
double d_instanceVar_cjei0_t_dX;
double instanceVar_qp0_t;
double d_instanceVar_qp0_t_dX;
double instanceVar_vdcx_t;
double d_instanceVar_vdcx_t_dX;
double instanceVar_vptcx_t;
double d_instanceVar_vptcx_t_dX;
double instanceVar_cjcx01_t;
double d_instanceVar_cjcx01_t_dX;
double instanceVar_cjcx02_t;
double d_instanceVar_cjcx02_t_dX;
double instanceVar_cratio_t;
double d_instanceVar_cratio_t_dX;
double instanceVar_ibeps_t;
double d_instanceVar_ibeps_t_dX;
double instanceVar_ireps_t;
double d_instanceVar_ireps_t_dX;
double instanceVar_cjep0_t;
double d_instanceVar_cjep0_t_dX;
double instanceVar_ajei_t;
double d_instanceVar_ajei_t_dX;
double instanceVar_qavl_t;
double d_instanceVar_qavl_t_dX;
double instanceVar_favl_t;
double d_instanceVar_favl_t_dX;
double instanceVar_kavl_t;
double d_instanceVar_kavl_t_dX;
double instanceVar_ibets_t;
double d_instanceVar_ibets_t_dX;
double instanceVar_abet_t;
double d_instanceVar_abet_t_dX;
double instanceVar_vptci_t;
double d_instanceVar_vptci_t_dX;
double instanceVar_vdep_t;
double d_instanceVar_vdep_t_dX;
double instanceVar_ajep_t;
double d_instanceVar_ajep_t_dX;
double instanceVar_zetatef;
double d_instanceVar_zetatef_dX;
double instanceVar_k1;
double d_instanceVar_k1_dX;
double instanceVar_k2;
double d_instanceVar_k2_dX;
double instanceVar_dvg0;
double d_instanceVar_dvg0_dX;
double instanceVar_vge_t;
double d_instanceVar_vge_t_dX;
double instanceVar_vgb_t;
double d_instanceVar_vgb_t_dX;
double instanceVar_vgbe_t;
double d_instanceVar_vgbe_t_dX;
double instanceVar_vds_t;
double d_instanceVar_vds_t_dX;
double instanceVar_vdsp_t;
double d_instanceVar_vdsp_t_dX;
double instanceVar_vt0;
double d_instanceVar_vt0_dX;
double instanceVar_Tnom;
double d_instanceVar_Tnom_dX;
double instanceVar_Tamb;
double instanceVar_a;
double d_instanceVar_a_dX;
double instanceVar_avs;
double d_instanceVar_avs_dX;
double instanceVar_zetabci;
double d_instanceVar_zetabci_dX;
double instanceVar_zetabcxt;
double d_instanceVar_zetabcxt_dX;
double instanceVar_zetasct;
double d_instanceVar_zetasct_dX;
double instanceVar_vgbe0;
double d_instanceVar_vgbe0_dX;
double instanceVar_mg;
double d_instanceVar_mg_dX;
double instanceVar_vgbe_t0;
double d_instanceVar_vgbe_t0_dX;
double instanceVar_vgbc0;
double d_instanceVar_vgbc0_dX;
double instanceVar_vgsc0;
double d_instanceVar_vgsc0_dX;
double instanceVar_cbcpar1;
double d_instanceVar_cbcpar1_dX;
double instanceVar_cbcpar2;
double d_instanceVar_cbcpar2_dX;
double instanceVar_cbepar2;
double d_instanceVar_cbepar2_dX;
double instanceVar_cbepar1;
double d_instanceVar_cbepar1_dX;
double instanceVar_Oich;
double d_instanceVar_Oich_dX;
double instanceVar_Otbhrec;
double d_instanceVar_Otbhrec_dX;
double instanceVar_it;
double d_instanceVar_it_dX;
double instanceVar_ibei;
double d_instanceVar_ibei_dX;
double instanceVar_ibci;
double d_instanceVar_ibci_dX;
double instanceVar_ibep;
double d_instanceVar_ibep_dX;
double instanceVar_iavl;
double d_instanceVar_iavl_dX;
double instanceVar_ijbcx;
double d_instanceVar_ijbcx_dX;
double instanceVar_ijsc;
double d_instanceVar_ijsc_dX;
double instanceVar_rth_t;
double d_instanceVar_rth_t_dX;
double instanceVar_vdj0;
double d_instanceVar_vdj0_dX;
double instanceVar_vdjt;
double d_instanceVar_vdjt_dX;
double instanceVar_vdt;
double d_instanceVar_vdt_dX;
double instanceVar_Tf;
double d_instanceVar_Tf_dX;
double instanceVar_cjcx01;
double d_instanceVar_cjcx01_dX;
double instanceVar_cjcx02;
double d_instanceVar_cjcx02_dX;
double instanceVar_betadc;
double d_instanceVar_betadc_dX;
double instanceVar_hjei0_t;
double d_instanceVar_hjei0_t_dX;
double instanceVar_ahjei_t;
double d_instanceVar_ahjei_t_dX;
double instanceVar_hf0_t;
double d_instanceVar_hf0_t_dX;
double instanceVar_hfe_t;
double d_instanceVar_hfe_t_dX;
double instanceVar_hfc_t;
double d_instanceVar_hfc_t_dX;
double instanceVar_rbx_t;
double d_instanceVar_rbx_t_dX;
double instanceVar_rcx_t;
double d_instanceVar_rcx_t_dX;
double instanceVar_re_t;
double d_instanceVar_re_t_dX;
double instanceVar_rbi;
double d_instanceVar_rbi_dX;
// non-reals
int instanceVar_use_aval;
};

class modelSensStruct
{
public:
// model parameters
// reals
double modelPar_c10;
double d_modelPar_c10_dX;
bool modelPar_given_c10;
double modelPar_qp0;
double d_modelPar_qp0_dX;
bool modelPar_given_qp0;
double modelPar_ich;
double d_modelPar_ich_dX;
bool modelPar_given_ich;
double modelPar_hf0;
double d_modelPar_hf0_dX;
bool modelPar_given_hf0;
double modelPar_hfe;
double d_modelPar_hfe_dX;
bool modelPar_given_hfe;
double modelPar_hfc;
double d_modelPar_hfc_dX;
bool modelPar_given_hfc;
double modelPar_hjei;
double d_modelPar_hjei_dX;
bool modelPar_given_hjei;
double modelPar_ahjei;
double d_modelPar_ahjei_dX;
bool modelPar_given_ahjei;
double modelPar_rhjei;
double d_modelPar_rhjei_dX;
bool modelPar_given_rhjei;
double modelPar_hjci;
double d_modelPar_hjci_dX;
bool modelPar_given_hjci;
double modelPar_ibeis;
double d_modelPar_ibeis_dX;
bool modelPar_given_ibeis;
double modelPar_mbei;
double d_modelPar_mbei_dX;
bool modelPar_given_mbei;
double modelPar_ireis;
double d_modelPar_ireis_dX;
bool modelPar_given_ireis;
double modelPar_mrei;
double d_modelPar_mrei_dX;
bool modelPar_given_mrei;
double modelPar_ibeps;
double d_modelPar_ibeps_dX;
bool modelPar_given_ibeps;
double modelPar_mbep;
double d_modelPar_mbep_dX;
bool modelPar_given_mbep;
double modelPar_ireps;
double d_modelPar_ireps_dX;
bool modelPar_given_ireps;
double modelPar_mrep;
double d_modelPar_mrep_dX;
bool modelPar_given_mrep;
double modelPar_mcf;
double d_modelPar_mcf_dX;
bool modelPar_given_mcf;
double modelPar_tbhrec;
double d_modelPar_tbhrec_dX;
bool modelPar_given_tbhrec;
double modelPar_ibcis;
double d_modelPar_ibcis_dX;
bool modelPar_given_ibcis;
double modelPar_mbci;
double d_modelPar_mbci_dX;
bool modelPar_given_mbci;
double modelPar_ibcxs;
double d_modelPar_ibcxs_dX;
bool modelPar_given_ibcxs;
double modelPar_mbcx;
double d_modelPar_mbcx_dX;
bool modelPar_given_mbcx;
double modelPar_ibets;
double d_modelPar_ibets_dX;
bool modelPar_given_ibets;
double modelPar_abet;
double d_modelPar_abet_dX;
bool modelPar_given_abet;
double modelPar_favl;
double d_modelPar_favl_dX;
bool modelPar_given_favl;
double modelPar_qavl;
double d_modelPar_qavl_dX;
bool modelPar_given_qavl;
double modelPar_kavl;
double d_modelPar_kavl_dX;
bool modelPar_given_kavl;
double modelPar_alfav;
double d_modelPar_alfav_dX;
bool modelPar_given_alfav;
double modelPar_alqav;
double d_modelPar_alqav_dX;
bool modelPar_given_alqav;
double modelPar_alkav;
double d_modelPar_alkav_dX;
bool modelPar_given_alkav;
double modelPar_rbi0;
double d_modelPar_rbi0_dX;
bool modelPar_given_rbi0;
double modelPar_rbx;
double d_modelPar_rbx_dX;
bool modelPar_given_rbx;
double modelPar_fgeo;
double d_modelPar_fgeo_dX;
bool modelPar_given_fgeo;
double modelPar_fdqr0;
double d_modelPar_fdqr0_dX;
bool modelPar_given_fdqr0;
double modelPar_fcrbi;
double d_modelPar_fcrbi_dX;
bool modelPar_given_fcrbi;
double modelPar_fqi;
double d_modelPar_fqi_dX;
bool modelPar_given_fqi;
double modelPar_re;
double d_modelPar_re_dX;
bool modelPar_given_re;
double modelPar_rcx;
double d_modelPar_rcx_dX;
bool modelPar_given_rcx;
double modelPar_itss;
double d_modelPar_itss_dX;
bool modelPar_given_itss;
double modelPar_msf;
double d_modelPar_msf_dX;
bool modelPar_given_msf;
double modelPar_iscs;
double d_modelPar_iscs_dX;
bool modelPar_given_iscs;
double modelPar_msc;
double d_modelPar_msc_dX;
bool modelPar_given_msc;
double modelPar_tsf;
double d_modelPar_tsf_dX;
bool modelPar_given_tsf;
double modelPar_rsu;
double d_modelPar_rsu_dX;
bool modelPar_given_rsu;
double modelPar_csu;
double d_modelPar_csu_dX;
bool modelPar_given_csu;
double modelPar_cjei0;
double d_modelPar_cjei0_dX;
bool modelPar_given_cjei0;
double modelPar_vdei;
double d_modelPar_vdei_dX;
bool modelPar_given_vdei;
double modelPar_zei;
double d_modelPar_zei_dX;
bool modelPar_given_zei;
double modelPar_ajei;
double d_modelPar_ajei_dX;
bool modelPar_given_ajei;
double modelPar_cjep0;
double d_modelPar_cjep0_dX;
bool modelPar_given_cjep0;
double modelPar_vdep;
double d_modelPar_vdep_dX;
bool modelPar_given_vdep;
double modelPar_zep;
double d_modelPar_zep_dX;
bool modelPar_given_zep;
double modelPar_ajep;
double d_modelPar_ajep_dX;
bool modelPar_given_ajep;
double modelPar_cjci0;
double d_modelPar_cjci0_dX;
bool modelPar_given_cjci0;
double modelPar_vdci;
double d_modelPar_vdci_dX;
bool modelPar_given_vdci;
double modelPar_zci;
double d_modelPar_zci_dX;
bool modelPar_given_zci;
double modelPar_vptci;
double d_modelPar_vptci_dX;
bool modelPar_given_vptci;
double modelPar_cjcx0;
double d_modelPar_cjcx0_dX;
bool modelPar_given_cjcx0;
double modelPar_vdcx;
double d_modelPar_vdcx_dX;
bool modelPar_given_vdcx;
double modelPar_zcx;
double d_modelPar_zcx_dX;
bool modelPar_given_zcx;
double modelPar_vptcx;
double d_modelPar_vptcx_dX;
bool modelPar_given_vptcx;
double modelPar_fbcpar;
double d_modelPar_fbcpar_dX;
bool modelPar_given_fbcpar;
double modelPar_fbepar;
double d_modelPar_fbepar_dX;
bool modelPar_given_fbepar;
double modelPar_cjs0;
double d_modelPar_cjs0_dX;
bool modelPar_given_cjs0;
double modelPar_vds;
double d_modelPar_vds_dX;
bool modelPar_given_vds;
double modelPar_zs;
double d_modelPar_zs_dX;
bool modelPar_given_zs;
double modelPar_vpts;
double d_modelPar_vpts_dX;
bool modelPar_given_vpts;
double modelPar_cscp0;
double d_modelPar_cscp0_dX;
bool modelPar_given_cscp0;
double modelPar_vdsp;
double d_modelPar_vdsp_dX;
bool modelPar_given_vdsp;
double modelPar_zsp;
double d_modelPar_zsp_dX;
bool modelPar_given_zsp;
double modelPar_vptsp;
double d_modelPar_vptsp_dX;
bool modelPar_given_vptsp;
double modelPar_t0;
double d_modelPar_t0_dX;
bool modelPar_given_t0;
double modelPar_dt0h;
double d_modelPar_dt0h_dX;
bool modelPar_given_dt0h;
double modelPar_tbvl;
double d_modelPar_tbvl_dX;
bool modelPar_given_tbvl;
double modelPar_tef0;
double d_modelPar_tef0_dX;
bool modelPar_given_tef0;
double modelPar_gtfe;
double d_modelPar_gtfe_dX;
bool modelPar_given_gtfe;
double modelPar_thcs;
double d_modelPar_thcs_dX;
bool modelPar_given_thcs;
double modelPar_ahc;
double d_modelPar_ahc_dX;
bool modelPar_given_ahc;
double modelPar_fthc;
double d_modelPar_fthc_dX;
bool modelPar_given_fthc;
double modelPar_rci0;
double d_modelPar_rci0_dX;
bool modelPar_given_rci0;
double modelPar_vlim;
double d_modelPar_vlim_dX;
bool modelPar_given_vlim;
double modelPar_vces;
double d_modelPar_vces_dX;
bool modelPar_given_vces;
double modelPar_vpt;
double d_modelPar_vpt_dX;
bool modelPar_given_vpt;
double modelPar_aick;
double d_modelPar_aick_dX;
bool modelPar_given_aick;
double modelPar_delck;
double d_modelPar_delck_dX;
bool modelPar_given_delck;
double modelPar_tr;
double d_modelPar_tr_dX;
bool modelPar_given_tr;
double modelPar_vcbar;
double d_modelPar_vcbar_dX;
bool modelPar_given_vcbar;
double modelPar_icbar;
double d_modelPar_icbar_dX;
bool modelPar_given_icbar;
double modelPar_acbar;
double d_modelPar_acbar_dX;
bool modelPar_given_acbar;
double modelPar_cbepar;
double d_modelPar_cbepar_dX;
bool modelPar_given_cbepar;
double modelPar_cbcpar;
double d_modelPar_cbcpar_dX;
bool modelPar_given_cbcpar;
double modelPar_alqf;
double d_modelPar_alqf_dX;
bool modelPar_given_alqf;
double modelPar_alit;
double d_modelPar_alit_dX;
bool modelPar_given_alit;
double modelPar_kf;
double d_modelPar_kf_dX;
bool modelPar_given_kf;
double modelPar_af;
double d_modelPar_af_dX;
bool modelPar_given_af;
double modelPar_kfre;
double d_modelPar_kfre_dX;
bool modelPar_given_kfre;
double modelPar_afre;
double d_modelPar_afre_dX;
bool modelPar_given_afre;
double modelPar_latb;
double d_modelPar_latb_dX;
bool modelPar_given_latb;
double modelPar_latl;
double d_modelPar_latl_dX;
bool modelPar_given_latl;
double modelPar_vgb;
double d_modelPar_vgb_dX;
bool modelPar_given_vgb;
double modelPar_alt0;
double d_modelPar_alt0_dX;
bool modelPar_given_alt0;
double modelPar_kt0;
double d_modelPar_kt0_dX;
bool modelPar_given_kt0;
double modelPar_zetaci;
double d_modelPar_zetaci_dX;
bool modelPar_given_zetaci;
double modelPar_alvs;
double d_modelPar_alvs_dX;
bool modelPar_given_alvs;
double modelPar_alces;
double d_modelPar_alces_dX;
bool modelPar_given_alces;
double modelPar_zetarbi;
double d_modelPar_zetarbi_dX;
bool modelPar_given_zetarbi;
double modelPar_zetarbx;
double d_modelPar_zetarbx_dX;
bool modelPar_given_zetarbx;
double modelPar_zetarcx;
double d_modelPar_zetarcx_dX;
bool modelPar_given_zetarcx;
double modelPar_zetare;
double d_modelPar_zetare_dX;
bool modelPar_given_zetare;
double modelPar_zetacx;
double d_modelPar_zetacx_dX;
bool modelPar_given_zetacx;
double modelPar_vge;
double d_modelPar_vge_dX;
bool modelPar_given_vge;
double modelPar_vgc;
double d_modelPar_vgc_dX;
bool modelPar_given_vgc;
double modelPar_vgs;
double d_modelPar_vgs_dX;
bool modelPar_given_vgs;
double modelPar_f1vg;
double d_modelPar_f1vg_dX;
bool modelPar_given_f1vg;
double modelPar_f2vg;
double d_modelPar_f2vg_dX;
bool modelPar_given_f2vg;
double modelPar_zetact;
double d_modelPar_zetact_dX;
bool modelPar_given_zetact;
double modelPar_zetabet;
double d_modelPar_zetabet_dX;
bool modelPar_given_zetabet;
double modelPar_alb;
double d_modelPar_alb_dX;
bool modelPar_given_alb;
double modelPar_dvgbe;
double d_modelPar_dvgbe_dX;
bool modelPar_given_dvgbe;
double modelPar_zetahjei;
double d_modelPar_zetahjei_dX;
bool modelPar_given_zetahjei;
double modelPar_zetavgbe;
double d_modelPar_zetavgbe_dX;
bool modelPar_given_zetavgbe;
double modelPar_rth;
double d_modelPar_rth_dX;
bool modelPar_given_rth;
double modelPar_zetarth;
double d_modelPar_zetarth_dX;
bool modelPar_given_zetarth;
double modelPar_alrth;
double d_modelPar_alrth_dX;
bool modelPar_given_alrth;
double modelPar_cth;
double d_modelPar_cth_dX;
bool modelPar_given_cth;
double modelPar_flcomp;
double d_modelPar_flcomp_dX;
bool modelPar_given_flcomp;
double modelPar_tnom;
double d_modelPar_tnom_dX;
bool modelPar_given_tnom;
double modelPar_dt;
double d_modelPar_dt_dX;
bool modelPar_given_dt;
// non-reals (including hidden)
int modelPar_tunode;
bool modelPar_given_tunode;
int modelPar_flnqs;
bool modelPar_given_flnqs;
int modelPar_cfbe;
bool modelPar_given_cfbe;
int modelPar_flcono;
bool modelPar_given_flcono;
int modelPar_flsh;
bool modelPar_given_flsh;
int modelPar_type;
bool modelPar_given_type;
};



//-----------------------------------------------------------------------------
// Free functions used by sensitivity
//
//-----------------------------------------------------------------------------
void evaluateModelEquations(
std::vector <double> & probeVars,
// probe constants
const int admsProbeID_V_ei_GND,
const int admsProbeID_V_bp_GND,
const int admsProbeID_V_ci_GND,
const int admsProbeID_V_bi_GND,
const int admsProbeID_V_c_e,
const int admsProbeID_V_b_c,
const int admsProbeID_V_n2_GND,
const int admsProbeID_V_n1_GND,
const int admsProbeID_V_si_s,
const int admsProbeID_V_bp_e,
const int admsProbeID_V_b_e,
const int admsProbeID_V_ci_ei,
const int admsProbeID_V_xf_GND,
const int admsProbeID_V_xf2_GND,
const int admsProbeID_V_xf1_GND,
const int admsProbeID_V_b_bp,
const int admsProbeID_V_ci_c,
const int admsProbeID_V_ei_e,
const int admsProbeID_V_bp_bi,
const int admsProbeID_V_tnode_GND,
const int admsProbeID_V_s_c,
const int admsProbeID_V_si_ci,
const int admsProbeID_V_b_ci,
const int admsProbeID_V_bp_ci,
const int admsProbeID_V_bp_ei,
const int admsProbeID_V_bi_ci,
const int admsProbeID_V_bi_ei,
// node constants
const int admsNodeID_c,
const int admsNodeID_b,
const int admsNodeID_e,
const int admsNodeID_s,
const int admsNodeID_tnode,
const int admsNodeID_ci,
const int admsNodeID_ei,
const int admsNodeID_bp,
const int admsNodeID_bi,
const int admsNodeID_si,
const int admsNodeID_xf1,
const int admsNodeID_xf2,
const int admsNodeID_xf,
const int admsNodeID_n1,
const int admsNodeID_n2,
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
// basic variables
 double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, std::vector <double> & d_staticContributions_dX, std::vector <double> & d_dynamicContributions_dX, const Instance & theInstance);

void evaluateInitialInstance(
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
 double admsTemperature,double adms_vt_nom, double ADMSgmin_arg, const Instance & theInstance);

void evaluateInitialModel(
modelSensStruct & modelStruct,
 double admsTemperature, double ADMSgmin_arg, const Instance & theInstance);

#endif // Xyce_ADMS_SENSITIVITIES


// Limited exponential --- NOT what verilog LRM says, but what qucs,
// ng-spice, and zspice do.

template <typename T>
T limexp(const T &x)
{
  if ((x) < 80.0)
  return (exp(x));
  else
  return (exp(80.0)*(x-79.0));
}


struct Traits: public DeviceTraits<Model, Instance, BJT::Traits>
{
  static const char *name() {return "HICUM v2.4.0";}
  static const char *deviceTypeName() {return "Q level 234";}

  static int numNodes() {return 5;}


  static bool modelRequired() {return true;}
  static bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &configuration, const FactoryBlock &factory_block);
  static void loadModelParameters(ParametricData<Model> &model_parameters);
  static void loadInstanceParameters(ParametricData<Instance> &instance_parameters);
};

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;
#ifdef Xyce_ADMS_SENSITIVITIES
  friend class InstanceSensitivity;
  friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
  friend struct Traits;

  public:
    Instance(
      const Configuration &       configuration,
      const InstanceBlock &       instance_block,
      Model &                     model,
      const FactoryBlock &        factory_block);

    ~Instance();

private:
    Instance(const Instance &);
    Instance &operator=(const Instance &);

public:
    void registerLIDs( const LocalIdVector & intLIDVecRef,
                       const LocalIdVector & extLIDVecRef );
    void registerStoreLIDs( const LocalIdVector & stoLIDVecRef );
    void setupPointers();

    void loadNodeSymbols(Util::SymbolTable &symbol_table) const;

    const JacobianStamp & jacobianStamp() const;
    void registerJacLIDs( const JacobianStamp & jacLIDVec );

    void registerBranchDataLIDs(const std::vector<int> & branchLIDVecRef);

    bool processParams();
    bool updateTemperature ( const double & temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

      void collapseNodes();
      int getNumNoiseSources () const;  // 17
      void setupNoiseSources (Xyce::Analysis::NoiseData & noiseData);
      void getNoiseSources (Xyce::Analysis::NoiseData & noiseData);

  private:

  public:
    // iterator reference to the hicumL2va model which owns this instance.
    // Getters and setters
    Model &getModel()
    {
      return model_;
    }

  private:

    Model & model_;   //< Owning Model
    // Begin verilog Instance Variables
    //   Instance Parameters
    //  Variables of global_instance scope
    double VT;
     double d_VT_dV_tnode_GND;
    double Tdev;
     double d_Tdev_dV_tnode_GND;
    double qtt0;
     double d_qtt0_dV_tnode_GND;
    double ln_qtt0;
     double d_ln_qtt0_dV_tnode_GND;
    double r_VgVT;
     double d_r_VgVT_dV_tnode_GND;
    double V_gT;
     double d_V_gT_dV_tnode_GND;
    double dT;
     double d_dT_dV_tnode_GND;
    double k;
     double d_k_dV_tnode_GND;
    double ireis_t;
     double d_ireis_t_dV_tnode_GND;
    double ibeis_t;
     double d_ibeis_t_dV_tnode_GND;
    double ibcxs_t;
     double d_ibcxs_t_dV_tnode_GND;
    double ibcis_t;
     double d_ibcis_t_dV_tnode_GND;
    double iscs_t;
     double d_iscs_t_dV_tnode_GND;
    double cjci0_t;
     double d_cjci0_t_dV_tnode_GND;
    double cjs0_t;
     double d_cjs0_t_dV_tnode_GND;
    double cscp0_t;
     double d_cscp0_t_dV_tnode_GND;
    double rci0_t;
     double d_rci0_t_dV_tnode_GND;
    double vlim_t;
     double d_vlim_t_dV_tnode_GND;
    double vces_t;
     double d_vces_t_dV_tnode_GND;
    double thcs_t;
     double d_thcs_t_dV_tnode_GND;
    double tef0_t;
     double d_tef0_t_dV_tnode_GND;
    double rbi0_t;
     double d_rbi0_t_dV_tnode_GND;
    double t0_t;
     double d_t0_t_dV_tnode_GND;
    double vdei_t;
     double d_vdei_t_dV_tnode_GND;
    double vdci_t;
     double d_vdci_t_dV_tnode_GND;
    double vpts_t;
     double d_vpts_t_dV_tnode_GND;
    double vptsp_t;
     double d_vptsp_t_dV_tnode_GND;
    double itss_t;
     double d_itss_t_dV_tnode_GND;
    double tsf_t;
     double d_tsf_t_dV_tnode_GND;
    double c10_t;
     double d_c10_t_dV_tnode_GND;
    double cjei0_t;
     double d_cjei0_t_dV_tnode_GND;
    double qp0_t;
     double d_qp0_t_dV_tnode_GND;
    double vdcx_t;
     double d_vdcx_t_dV_tnode_GND;
    double vptcx_t;
     double d_vptcx_t_dV_tnode_GND;
    double cjcx01_t;
     double d_cjcx01_t_dV_tnode_GND;
    double cjcx02_t;
     double d_cjcx02_t_dV_tnode_GND;
    double cratio_t;
     double d_cratio_t_dV_tnode_GND;
    double ibeps_t;
     double d_ibeps_t_dV_tnode_GND;
    double ireps_t;
     double d_ireps_t_dV_tnode_GND;
    double cjep0_t;
     double d_cjep0_t_dV_tnode_GND;
    double ajei_t;
     double d_ajei_t_dV_tnode_GND;
    double qavl_t;
     double d_qavl_t_dV_tnode_GND;
    double favl_t;
     double d_favl_t_dV_tnode_GND;
    double kavl_t;
     double d_kavl_t_dV_tnode_GND;
    double ibets_t;
     double d_ibets_t_dV_tnode_GND;
    double abet_t;
     double d_abet_t_dV_tnode_GND;
    double vptci_t;
     double d_vptci_t_dV_tnode_GND;
    double vdep_t;
     double d_vdep_t_dV_tnode_GND;
    double ajep_t;
     double d_ajep_t_dV_tnode_GND;
    double zetatef;
    double k1;
     double d_k1_dV_tnode_GND;
    double k2;
     double d_k2_dV_tnode_GND;
    double dvg0;
    double vge_t;
     double d_vge_t_dV_tnode_GND;
    double vgb_t;
     double d_vgb_t_dV_tnode_GND;
    double vgbe_t;
     double d_vgbe_t_dV_tnode_GND;
    double vds_t;
     double d_vds_t_dV_tnode_GND;
    double vdsp_t;
     double d_vdsp_t_dV_tnode_GND;
    double vt0;
    double Tnom;
    double Tamb;
    double a;
     double d_a_dV_bi_ei;
     double d_a_dV_bi_ci;
     double d_a_dV_tnode_GND;
    double avs;
    double zetabci;
    double zetabcxt;
    double zetasct;
    double vgbe0;
    double mg;
    double vgbe_t0;
    double vgbc0;
    double vgsc0;
    double cbcpar1;
    double cbcpar2;
    double cbepar2;
    double cbepar1;
    double Oich;
    double Otbhrec;
    double it;
     double d_it_dV_tnode_GND;
     double d_it_dV_bi_ei;
     double d_it_dV_bi_ci;
    double ibei;
     double d_ibei_dV_tnode_GND;
     double d_ibei_dV_bi_ei;
    double ibci;
     double d_ibci_dV_tnode_GND;
     double d_ibci_dV_bi_ci;
     double d_ibci_dV_bi_ei;
    double ibep;
     double d_ibep_dV_tnode_GND;
     double d_ibep_dV_bp_ei;
     double d_ibep_dV_bi_ci;
     double d_ibep_dV_bi_ei;
    double iavl;
     double d_iavl_dV_tnode_GND;
     double d_iavl_dV_bi_ei;
     double d_iavl_dV_bi_ci;
    double ijbcx;
     double d_ijbcx_dV_tnode_GND;
     double d_ijbcx_dV_bp_ci;
     double d_ijbcx_dV_bp_ei;
     double d_ijbcx_dV_bi_ci;
     double d_ijbcx_dV_bi_ei;
    double ijsc;
     double d_ijsc_dV_tnode_GND;
     double d_ijsc_dV_si_ci;
     double d_ijsc_dV_bp_ci;
     double d_ijsc_dV_bp_ei;
     double d_ijsc_dV_bi_ci;
     double d_ijsc_dV_bi_ei;
    double rth_t;
     double d_rth_t_dV_tnode_GND;
    double vdj0;
    double vdjt;
     double d_vdjt_dV_tnode_GND;
    double vdt;
     double d_vdt_dV_tnode_GND;
    double Tf;
     double d_Tf_dV_bi_ei;
     double d_Tf_dV_tnode_GND;
     double d_Tf_dV_bi_ci;
    double cjcx01;
    double cjcx02;
    double betadc;
     double d_betadc_dV_tnode_GND;
     double d_betadc_dV_bi_ei;
     double d_betadc_dV_bi_ci;
    double hjei0_t;
     double d_hjei0_t_dV_tnode_GND;
    double ahjei_t;
     double d_ahjei_t_dV_tnode_GND;
    double hf0_t;
     double d_hf0_t_dV_tnode_GND;
    double hfe_t;
     double d_hfe_t_dV_tnode_GND;
    double hfc_t;
     double d_hfc_t_dV_tnode_GND;
    int use_aval;
    double rbx_t;
     double d_rbx_t_dV_tnode_GND;
    double rcx_t;
     double d_rcx_t_dV_tnode_GND;
    double re_t;
     double d_re_t_dV_tnode_GND;
    double rbi;
     double d_rbi_dV_tnode_GND;
     double d_rbi_dV_bi_ei;
     double d_rbi_dV_bi_ci;
    double rb;
    double IAVL;
    double VBE;
    double VBC;
    double VCE;
    double VSC;
    double GMi;
    double GMS;
    double RPIi;
    double RPIx;
    double RMUi;
    double RMUx;
    double ROi;
    double CPIi;
    double CPIx;
    double CMUi;
    double CMUx;
    double CCS;
    double BETAAC;
    double CRBI;
    double TF;
    double FT;
    double TK;
    double DTSH;
    // end verilog Instance Variables=====
    // Nodal LID Variables
    int li_c;
    int li_b;
    int li_e;
    int li_s;
    int li_tnode;
    int li_ci;
    int li_ei;
    int li_bp;
    int li_bi;
    int li_si;
    int li_xf1;
    int li_xf2;
    int li_xf;
    int li_n1;
    int li_n2;
    // end Nodal LID Variables
    // Branch LID Variables
    // end Branch LID Variables
    // Lead (branch) LID Variables
    int li_branch_ic;
    int li_branch_ib;
    int li_branch_ie;
    int li_branch_is;
    int li_branch_itnode;
    // end Lead (branch) LID Variables
    // Jacobian  pointers
    double * f_bi_Equ_bi_Node_Ptr;
    double * f_bi_Equ_ei_Node_Ptr;
    double * f_ei_Equ_bi_Node_Ptr;
    double * f_ei_Equ_ei_Node_Ptr;
    double * f_bi_Equ_ci_Node_Ptr;
    double * f_ci_Equ_bi_Node_Ptr;
    double * f_ci_Equ_ci_Node_Ptr;
    double * f_ci_Equ_ei_Node_Ptr;
    double * f_ei_Equ_ci_Node_Ptr;
    double * f_b_Equ_bi_Node_Ptr;
    double * f_b_Equ_ci_Node_Ptr;
    double * f_b_Equ_tnode_Node_Ptr;
    double * f_ci_Equ_tnode_Node_Ptr;
    double * f_b_Equ_bp_Node_Ptr;
    double * f_ci_Equ_bp_Node_Ptr;
    double * f_b_Equ_b_Node_Ptr;
    double * f_ci_Equ_b_Node_Ptr;
    double * f_b_Equ_ei_Node_Ptr;
    double * f_bp_Equ_bp_Node_Ptr;
    double * f_bp_Equ_ci_Node_Ptr;
    double * f_bp_Equ_tnode_Node_Ptr;
    double * f_bp_Equ_b_Node_Ptr;
    double * f_bp_Equ_bi_Node_Ptr;
    double * f_bp_Equ_ei_Node_Ptr;
    double * f_bi_Equ_tnode_Node_Ptr;
    double * f_bi_Equ_bp_Node_Ptr;
    double * f_ei_Equ_tnode_Node_Ptr;
    double * f_ei_Equ_bp_Node_Ptr;
    double * f_bi_Equ_xf_Node_Ptr;
    double * f_ei_Equ_xf_Node_Ptr;
    double * f_bp_Equ_si_Node_Ptr;
    double * f_si_Equ_si_Node_Ptr;
    double * f_si_Equ_ci_Node_Ptr;
    double * f_si_Equ_bp_Node_Ptr;
    double * f_si_Equ_tnode_Node_Ptr;
    double * f_b_Equ_e_Node_Ptr;
    double * f_e_Equ_b_Node_Ptr;
    double * f_e_Equ_e_Node_Ptr;
    double * f_bp_Equ_e_Node_Ptr;
    double * f_e_Equ_bp_Node_Ptr;
    double * f_si_Equ_bi_Node_Ptr;
    double * f_si_Equ_ei_Node_Ptr;
    double * f_ci_Equ_si_Node_Ptr;
    double * f_si_Equ_b_Node_Ptr;
    double * f_s_Equ_bi_Node_Ptr;
    double * f_s_Equ_ci_Node_Ptr;
    double * f_c_Equ_bi_Node_Ptr;
    double * f_c_Equ_ci_Node_Ptr;
    double * f_s_Equ_tnode_Node_Ptr;
    double * f_c_Equ_tnode_Node_Ptr;
    double * f_s_Equ_bp_Node_Ptr;
    double * f_c_Equ_bp_Node_Ptr;
    double * f_s_Equ_b_Node_Ptr;
    double * f_c_Equ_b_Node_Ptr;
    double * f_s_Equ_si_Node_Ptr;
    double * f_c_Equ_si_Node_Ptr;
    double * f_s_Equ_s_Node_Ptr;
    double * f_s_Equ_c_Node_Ptr;
    double * f_c_Equ_s_Node_Ptr;
    double * f_c_Equ_c_Node_Ptr;
    double * f_s_Equ_ei_Node_Ptr;
    double * f_c_Equ_ei_Node_Ptr;
    double * f_ci_Equ_xf2_Node_Ptr;
    double * f_ei_Equ_xf2_Node_Ptr;
    double * f_ci_Equ_c_Node_Ptr;
    double * f_e_Equ_tnode_Node_Ptr;
    double * f_ei_Equ_e_Node_Ptr;
    double * f_e_Equ_ei_Node_Ptr;
    double * f_si_Equ_s_Node_Ptr;
    double * f_tnode_Equ_tnode_Node_Ptr;
    double * f_tnode_Equ_bi_Node_Ptr;
    double * f_tnode_Equ_ci_Node_Ptr;
    double * f_tnode_Equ_ei_Node_Ptr;
    double * f_tnode_Equ_si_Node_Ptr;
    double * f_tnode_Equ_bp_Node_Ptr;
    double * f_tnode_Equ_e_Node_Ptr;
    double * f_tnode_Equ_c_Node_Ptr;
    double * f_tnode_Equ_b_Node_Ptr;
    double * f_xf1_Equ_bi_Node_Ptr;
    double * f_xf1_Equ_ci_Node_Ptr;
    double * f_xf1_Equ_ei_Node_Ptr;
    double * f_xf1_Equ_tnode_Node_Ptr;
    double * f_xf1_Equ_xf2_Node_Ptr;
    double * f_xf1_Equ_xf1_Node_Ptr;
    double * f_xf2_Equ_bi_Node_Ptr;
    double * f_xf2_Equ_ci_Node_Ptr;
    double * f_xf2_Equ_tnode_Node_Ptr;
    double * f_xf2_Equ_ei_Node_Ptr;
    double * f_xf2_Equ_xf1_Node_Ptr;
    double * f_xf2_Equ_xf2_Node_Ptr;
    double * f_xf_Equ_bi_Node_Ptr;
    double * f_xf_Equ_ei_Node_Ptr;
    double * f_xf_Equ_ci_Node_Ptr;
    double * f_xf_Equ_tnode_Node_Ptr;
    double * f_xf_Equ_xf_Node_Ptr;
    double * f_e_Equ_bi_Node_Ptr;
    double * f_e_Equ_ci_Node_Ptr;
    double * f_n1_Equ_bi_Node_Ptr;
    double * f_n1_Equ_ei_Node_Ptr;
    double * f_n1_Equ_tnode_Node_Ptr;
    double * f_n1_Equ_n1_Node_Ptr;
    double * f_bi_Equ_n1_Node_Ptr;
    double * f_ei_Equ_n1_Node_Ptr;
    double * f_bi_Equ_n2_Node_Ptr;
    double * f_ei_Equ_n2_Node_Ptr;
    double * f_n2_Equ_bi_Node_Ptr;
    double * f_n2_Equ_ci_Node_Ptr;
    double * f_n2_Equ_ei_Node_Ptr;
    double * f_n2_Equ_tnode_Node_Ptr;
    double * f_n2_Equ_n2_Node_Ptr;
    double * f_ci_Equ_n2_Node_Ptr;
    double * q_bi_Equ_bi_Node_Ptr;
    double * q_bi_Equ_ei_Node_Ptr;
    double * q_ei_Equ_bi_Node_Ptr;
    double * q_ei_Equ_ei_Node_Ptr;
    double * q_bi_Equ_ci_Node_Ptr;
    double * q_ci_Equ_bi_Node_Ptr;
    double * q_ci_Equ_ci_Node_Ptr;
    double * q_ci_Equ_ei_Node_Ptr;
    double * q_ei_Equ_ci_Node_Ptr;
    double * q_b_Equ_bi_Node_Ptr;
    double * q_b_Equ_ci_Node_Ptr;
    double * q_b_Equ_tnode_Node_Ptr;
    double * q_ci_Equ_tnode_Node_Ptr;
    double * q_b_Equ_bp_Node_Ptr;
    double * q_ci_Equ_bp_Node_Ptr;
    double * q_b_Equ_b_Node_Ptr;
    double * q_ci_Equ_b_Node_Ptr;
    double * q_b_Equ_ei_Node_Ptr;
    double * q_bp_Equ_bp_Node_Ptr;
    double * q_bp_Equ_ci_Node_Ptr;
    double * q_bp_Equ_tnode_Node_Ptr;
    double * q_bp_Equ_b_Node_Ptr;
    double * q_bp_Equ_bi_Node_Ptr;
    double * q_bp_Equ_ei_Node_Ptr;
    double * q_bi_Equ_tnode_Node_Ptr;
    double * q_bi_Equ_bp_Node_Ptr;
    double * q_ei_Equ_tnode_Node_Ptr;
    double * q_ei_Equ_bp_Node_Ptr;
    double * q_bi_Equ_xf_Node_Ptr;
    double * q_ei_Equ_xf_Node_Ptr;
    double * q_bp_Equ_si_Node_Ptr;
    double * q_si_Equ_si_Node_Ptr;
    double * q_si_Equ_ci_Node_Ptr;
    double * q_si_Equ_bp_Node_Ptr;
    double * q_si_Equ_tnode_Node_Ptr;
    double * q_b_Equ_e_Node_Ptr;
    double * q_e_Equ_b_Node_Ptr;
    double * q_e_Equ_e_Node_Ptr;
    double * q_bp_Equ_e_Node_Ptr;
    double * q_e_Equ_bp_Node_Ptr;
    double * q_si_Equ_bi_Node_Ptr;
    double * q_si_Equ_ei_Node_Ptr;
    double * q_ci_Equ_si_Node_Ptr;
    double * q_si_Equ_b_Node_Ptr;
    double * q_s_Equ_bi_Node_Ptr;
    double * q_s_Equ_ci_Node_Ptr;
    double * q_c_Equ_bi_Node_Ptr;
    double * q_c_Equ_ci_Node_Ptr;
    double * q_s_Equ_tnode_Node_Ptr;
    double * q_c_Equ_tnode_Node_Ptr;
    double * q_s_Equ_bp_Node_Ptr;
    double * q_c_Equ_bp_Node_Ptr;
    double * q_s_Equ_b_Node_Ptr;
    double * q_c_Equ_b_Node_Ptr;
    double * q_s_Equ_si_Node_Ptr;
    double * q_c_Equ_si_Node_Ptr;
    double * q_s_Equ_s_Node_Ptr;
    double * q_s_Equ_c_Node_Ptr;
    double * q_c_Equ_s_Node_Ptr;
    double * q_c_Equ_c_Node_Ptr;
    double * q_s_Equ_ei_Node_Ptr;
    double * q_c_Equ_ei_Node_Ptr;
    double * q_ci_Equ_xf2_Node_Ptr;
    double * q_ei_Equ_xf2_Node_Ptr;
    double * q_ci_Equ_c_Node_Ptr;
    double * q_e_Equ_tnode_Node_Ptr;
    double * q_ei_Equ_e_Node_Ptr;
    double * q_e_Equ_ei_Node_Ptr;
    double * q_si_Equ_s_Node_Ptr;
    double * q_tnode_Equ_tnode_Node_Ptr;
    double * q_tnode_Equ_bi_Node_Ptr;
    double * q_tnode_Equ_ci_Node_Ptr;
    double * q_tnode_Equ_ei_Node_Ptr;
    double * q_tnode_Equ_si_Node_Ptr;
    double * q_tnode_Equ_bp_Node_Ptr;
    double * q_tnode_Equ_e_Node_Ptr;
    double * q_tnode_Equ_c_Node_Ptr;
    double * q_tnode_Equ_b_Node_Ptr;
    double * q_xf1_Equ_bi_Node_Ptr;
    double * q_xf1_Equ_ci_Node_Ptr;
    double * q_xf1_Equ_ei_Node_Ptr;
    double * q_xf1_Equ_tnode_Node_Ptr;
    double * q_xf1_Equ_xf2_Node_Ptr;
    double * q_xf1_Equ_xf1_Node_Ptr;
    double * q_xf2_Equ_bi_Node_Ptr;
    double * q_xf2_Equ_ci_Node_Ptr;
    double * q_xf2_Equ_tnode_Node_Ptr;
    double * q_xf2_Equ_ei_Node_Ptr;
    double * q_xf2_Equ_xf1_Node_Ptr;
    double * q_xf2_Equ_xf2_Node_Ptr;
    double * q_xf_Equ_bi_Node_Ptr;
    double * q_xf_Equ_ei_Node_Ptr;
    double * q_xf_Equ_ci_Node_Ptr;
    double * q_xf_Equ_tnode_Node_Ptr;
    double * q_xf_Equ_xf_Node_Ptr;
    double * q_e_Equ_bi_Node_Ptr;
    double * q_e_Equ_ci_Node_Ptr;
    double * q_n1_Equ_bi_Node_Ptr;
    double * q_n1_Equ_ei_Node_Ptr;
    double * q_n1_Equ_tnode_Node_Ptr;
    double * q_n1_Equ_n1_Node_Ptr;
    double * q_bi_Equ_n1_Node_Ptr;
    double * q_ei_Equ_n1_Node_Ptr;
    double * q_bi_Equ_n2_Node_Ptr;
    double * q_ei_Equ_n2_Node_Ptr;
    double * q_n2_Equ_bi_Node_Ptr;
    double * q_n2_Equ_ci_Node_Ptr;
    double * q_n2_Equ_ei_Node_Ptr;
    double * q_n2_Equ_tnode_Node_Ptr;
    double * q_n2_Equ_n2_Node_Ptr;
    double * q_ci_Equ_n2_Node_Ptr;
    // Jacobian offsets
    int A_bi_Equ_bi_NodeOffset;
    int A_bi_Equ_ei_NodeOffset;
    int A_ei_Equ_bi_NodeOffset;
    int A_ei_Equ_ei_NodeOffset;
    int A_bi_Equ_ci_NodeOffset;
    int A_ci_Equ_bi_NodeOffset;
    int A_ci_Equ_ci_NodeOffset;
    int A_ci_Equ_ei_NodeOffset;
    int A_ei_Equ_ci_NodeOffset;
    int A_b_Equ_bi_NodeOffset;
    int A_b_Equ_ci_NodeOffset;
    int A_b_Equ_tnode_NodeOffset;
    int A_ci_Equ_tnode_NodeOffset;
    int A_b_Equ_bp_NodeOffset;
    int A_ci_Equ_bp_NodeOffset;
    int A_b_Equ_b_NodeOffset;
    int A_ci_Equ_b_NodeOffset;
    int A_b_Equ_ei_NodeOffset;
    int A_bp_Equ_bp_NodeOffset;
    int A_bp_Equ_ci_NodeOffset;
    int A_bp_Equ_tnode_NodeOffset;
    int A_bp_Equ_b_NodeOffset;
    int A_bp_Equ_bi_NodeOffset;
    int A_bp_Equ_ei_NodeOffset;
    int A_bi_Equ_tnode_NodeOffset;
    int A_bi_Equ_bp_NodeOffset;
    int A_ei_Equ_tnode_NodeOffset;
    int A_ei_Equ_bp_NodeOffset;
    int A_bi_Equ_xf_NodeOffset;
    int A_ei_Equ_xf_NodeOffset;
    int A_bp_Equ_si_NodeOffset;
    int A_si_Equ_si_NodeOffset;
    int A_si_Equ_ci_NodeOffset;
    int A_si_Equ_bp_NodeOffset;
    int A_si_Equ_tnode_NodeOffset;
    int A_b_Equ_e_NodeOffset;
    int A_e_Equ_b_NodeOffset;
    int A_e_Equ_e_NodeOffset;
    int A_bp_Equ_e_NodeOffset;
    int A_e_Equ_bp_NodeOffset;
    int A_si_Equ_bi_NodeOffset;
    int A_si_Equ_ei_NodeOffset;
    int A_ci_Equ_si_NodeOffset;
    int A_si_Equ_b_NodeOffset;
    int A_s_Equ_bi_NodeOffset;
    int A_s_Equ_ci_NodeOffset;
    int A_c_Equ_bi_NodeOffset;
    int A_c_Equ_ci_NodeOffset;
    int A_s_Equ_tnode_NodeOffset;
    int A_c_Equ_tnode_NodeOffset;
    int A_s_Equ_bp_NodeOffset;
    int A_c_Equ_bp_NodeOffset;
    int A_s_Equ_b_NodeOffset;
    int A_c_Equ_b_NodeOffset;
    int A_s_Equ_si_NodeOffset;
    int A_c_Equ_si_NodeOffset;
    int A_s_Equ_s_NodeOffset;
    int A_s_Equ_c_NodeOffset;
    int A_c_Equ_s_NodeOffset;
    int A_c_Equ_c_NodeOffset;
    int A_s_Equ_ei_NodeOffset;
    int A_c_Equ_ei_NodeOffset;
    int A_ci_Equ_xf2_NodeOffset;
    int A_ei_Equ_xf2_NodeOffset;
    int A_ci_Equ_c_NodeOffset;
    int A_e_Equ_tnode_NodeOffset;
    int A_ei_Equ_e_NodeOffset;
    int A_e_Equ_ei_NodeOffset;
    int A_si_Equ_s_NodeOffset;
    int A_tnode_Equ_tnode_NodeOffset;
    int A_tnode_Equ_bi_NodeOffset;
    int A_tnode_Equ_ci_NodeOffset;
    int A_tnode_Equ_ei_NodeOffset;
    int A_tnode_Equ_si_NodeOffset;
    int A_tnode_Equ_bp_NodeOffset;
    int A_tnode_Equ_e_NodeOffset;
    int A_tnode_Equ_c_NodeOffset;
    int A_tnode_Equ_b_NodeOffset;
    int A_xf1_Equ_bi_NodeOffset;
    int A_xf1_Equ_ci_NodeOffset;
    int A_xf1_Equ_ei_NodeOffset;
    int A_xf1_Equ_tnode_NodeOffset;
    int A_xf1_Equ_xf2_NodeOffset;
    int A_xf1_Equ_xf1_NodeOffset;
    int A_xf2_Equ_bi_NodeOffset;
    int A_xf2_Equ_ci_NodeOffset;
    int A_xf2_Equ_tnode_NodeOffset;
    int A_xf2_Equ_ei_NodeOffset;
    int A_xf2_Equ_xf1_NodeOffset;
    int A_xf2_Equ_xf2_NodeOffset;
    int A_xf_Equ_bi_NodeOffset;
    int A_xf_Equ_ei_NodeOffset;
    int A_xf_Equ_ci_NodeOffset;
    int A_xf_Equ_tnode_NodeOffset;
    int A_xf_Equ_xf_NodeOffset;
    int A_e_Equ_bi_NodeOffset;
    int A_e_Equ_ci_NodeOffset;
    int A_n1_Equ_bi_NodeOffset;
    int A_n1_Equ_ei_NodeOffset;
    int A_n1_Equ_tnode_NodeOffset;
    int A_n1_Equ_n1_NodeOffset;
    int A_bi_Equ_n1_NodeOffset;
    int A_ei_Equ_n1_NodeOffset;
    int A_bi_Equ_n2_NodeOffset;
    int A_ei_Equ_n2_NodeOffset;
    int A_n2_Equ_bi_NodeOffset;
    int A_n2_Equ_ci_NodeOffset;
    int A_n2_Equ_ei_NodeOffset;
    int A_n2_Equ_tnode_NodeOffset;
    int A_n2_Equ_n2_NodeOffset;
    int A_ci_Equ_n2_NodeOffset;
    // end of Jacobian and pointers
   // node numbers
    static const int admsNodeID_c = 0;
    static const int admsNodeID_b = 1;
    static const int admsNodeID_e = 2;
    static const int admsNodeID_s = 3;
    static const int admsNodeID_tnode = 4;
    static const int admsNodeID_ci = 0+5;
    static const int admsNodeID_ei = 1+5;
    static const int admsNodeID_bp = 2+5;
    static const int admsNodeID_bi = 3+5;
    static const int admsNodeID_si = 4+5;
    static const int admsNodeID_xf1 = 5+5;
    static const int admsNodeID_xf2 = 6+5;
    static const int admsNodeID_xf = 7+5;
    static const int admsNodeID_n1 = 8+5;
    static const int admsNodeID_n2 = 9+5;
    static const int admsNodeID_GND = -1;
   // end node numbers
   // Additional IDs for branch equations
   // end branch numbers
   // Probe numbers
    static const int admsProbeID_V_ei_GND = 0;
    static const int admsProbeID_V_bp_GND = 1;
    static const int admsProbeID_V_ci_GND = 2;
    static const int admsProbeID_V_bi_GND = 3;
    static const int admsProbeID_V_c_e = 4;
    static const int admsProbeID_V_b_c = 5;
    static const int admsProbeID_V_n2_GND = 6;
    static const int admsProbeID_V_n1_GND = 7;
    static const int admsProbeID_V_si_s = 8;
    static const int admsProbeID_V_bp_e = 9;
    static const int admsProbeID_V_b_e = 10;
    static const int admsProbeID_V_ci_ei = 11;
    static const int admsProbeID_V_xf_GND = 12;
    static const int admsProbeID_V_xf2_GND = 13;
    static const int admsProbeID_V_xf1_GND = 14;
    static const int admsProbeID_V_b_bp = 15;
    static const int admsProbeID_V_ci_c = 16;
    static const int admsProbeID_V_ei_e = 17;
    static const int admsProbeID_V_bp_bi = 18;
    static const int admsProbeID_V_tnode_GND = 19;
    static const int admsProbeID_V_s_c = 20;
    static const int admsProbeID_V_si_ci = 21;
    static const int admsProbeID_V_b_ci = 22;
    static const int admsProbeID_V_bp_ci = 23;
    static const int admsProbeID_V_bp_ei = 24;
    static const int admsProbeID_V_bi_ci = 25;
    static const int admsProbeID_V_bi_ei = 26;
   // end probe numbers
   // Store LIDs
   // end store LIDs
   // Store LIDs for output vars
    int li_store_rcx_t;
    int li_store_re_t;
    int li_store_rbi;
    int li_store_rb;
    int li_store_IAVL;
    int li_store_VBE;
    int li_store_VBC;
    int li_store_VCE;
    int li_store_VSC;
    int li_store_GMi;
    int li_store_GMS;
    int li_store_RPIi;
    int li_store_RPIx;
    int li_store_RMUi;
    int li_store_RMUx;
    int li_store_ROi;
    int li_store_CPIi;
    int li_store_CPIx;
    int li_store_CMUi;
    int li_store_CMUx;
    int li_store_CCS;
    int li_store_BETAAC;
    int li_store_CRBI;
    int li_store_TF;
    int li_store_FT;
    int li_store_TK;
    int li_store_DTSH;
   // end store LIDs for output vars
     // bools for collapsing nodes
     bool collapseNode_ci;
     bool collapseNode_ei;
     bool collapseNode_bp;
     bool collapseNode_bi;
     bool collapseNode_si;
 // Arrays to hold probes
 std::vector < double > probeVars;
 std::vector < std::vector < double > > d_probeVars;
 // Arrays to hold contributions
 // dynamic contributions are differentiated w.r.t time
 std::vector < double > staticContributions;
 std::vector < std::vector < double > > d_staticContributions;
 std::vector < double > dynamicContributions;
 std::vector < std::vector < double > > d_dynamicContributions;
//vectors to hold noise information for communication between methods
std::vector<double> noiseContribsPower;
std::vector<double> noiseContribsExponent;


    // this is what we'll use when any model uses $temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at $temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;


    JacobianStamp jacStamp;
    IdVector nodeMap;
    PairMap pairToJacStampMap;

    // These instance-owned vectors are for storage of lead current data
    std::vector<double> leadCurrentF;
    std::vector<double> leadCurrentQ;


    };


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
    typedef std::vector<Instance *> InstanceVector;

    friend class ParametricData<Model>;
    friend class Instance;
#ifdef Xyce_ADMS_SENSITIVITIES
    friend class InstanceSensitivity;
    friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
    friend struct Traits;

  public:
    Model(
      const Configuration &       configuration,
      const ModelBlock &          model_block,
      const FactoryBlock &        factory_block);

    ~Model();

private:
    Model(const Model &);
    Model &operator=(const Model &);

public:
    virtual void forEachInstance(DeviceInstanceOp &op) const /* override */;
    virtual std::ostream &printOutInstances(std::ostream &os) const;
    bool processParams();
    bool processInstanceParams();

  private:

  public:
    void addInstance(Instance *instance)
    {
      instanceContainer.push_back(instance);
    }

    void setupBaseInstanceContainer()
    {
      std::vector<Instance*>::iterator iter = instanceContainer.begin();
      std::vector<Instance*>::iterator end   = instanceContainer.end();
      for ( ; iter!=end; ++iter)
      {
      Xyce::Device::DeviceModel::baseInstanceContainer.push_back( static_cast<Xyce::Device::DeviceInstance *>(*iter) );
    }
  }

  private:
    std::vector<Instance*> instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;
// Begin verilog Model Variables
//   Model Parameters
    double c10;
    double qp0;
    double ich;
    double hf0;
    double hfe;
    double hfc;
    double hjei;
    double ahjei;
    double rhjei;
    double hjci;
    double ibeis;
    double mbei;
    double ireis;
    double mrei;
    double ibeps;
    double mbep;
    double ireps;
    double mrep;
    double mcf;
    double tbhrec;
    double ibcis;
    double mbci;
    double ibcxs;
    double mbcx;
    double ibets;
    double abet;
    int tunode;
    double favl;
    double qavl;
    double kavl;
    double alfav;
    double alqav;
    double alkav;
    double rbi0;
    double rbx;
    double fgeo;
    double fdqr0;
    double fcrbi;
    double fqi;
    double re;
    double rcx;
    double itss;
    double msf;
    double iscs;
    double msc;
    double tsf;
    double rsu;
    double csu;
    double cjei0;
    double vdei;
    double zei;
    double ajei;
    double cjep0;
    double vdep;
    double zep;
    double ajep;
    double cjci0;
    double vdci;
    double zci;
    double vptci;
    double cjcx0;
    double vdcx;
    double zcx;
    double vptcx;
    double fbcpar;
    double fbepar;
    double cjs0;
    double vds;
    double zs;
    double vpts;
    double cscp0;
    double vdsp;
    double zsp;
    double vptsp;
    double t0;
    double dt0h;
    double tbvl;
    double tef0;
    double gtfe;
    double thcs;
    double ahc;
    double fthc;
    double rci0;
    double vlim;
    double vces;
    double vpt;
    double aick;
    double delck;
    double tr;
    double vcbar;
    double icbar;
    double acbar;
    double cbepar;
    double cbcpar;
    double alqf;
    double alit;
    int flnqs;
    double kf;
    double af;
    int cfbe;
    int flcono;
    double kfre;
    double afre;
    double latb;
    double latl;
    double vgb;
    double alt0;
    double kt0;
    double zetaci;
    double alvs;
    double alces;
    double zetarbi;
    double zetarbx;
    double zetarcx;
    double zetare;
    double zetacx;
    double vge;
    double vgc;
    double vgs;
    double f1vg;
    double f2vg;
    double zetact;
    double zetabet;
    double alb;
    double dvgbe;
    double zetahjei;
    double zetavgbe;
    int flsh;
    double rth;
    double zetarth;
    double alrth;
    double cth;
    double flcomp;
    double tnom;
    double dt;
    int type;
    //  Variables of global_model scope
    // end verilog model variables=====
};

void registerDevice(const DeviceCountMap& deviceMap = DeviceCountMap(),
                    const std::set<int>& levelSet = std::set<int>());

} // namespace ADMShicumL2va
} // namespace Device
} // namespace Xyce
#endif //Xyce_N_DEV_ADMShicumL2va_h
