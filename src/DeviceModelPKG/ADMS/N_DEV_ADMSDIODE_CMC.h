
// -*-c++-*-
//-------------------------------------------------------------------------
//   Copyright 2002-2020 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file diode_cmc.va with ADMS
//                  interface for Xyce 7.2.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.6
//
// Creation Date  : Mon, 10 Aug 2020 09:40:21
//
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMSDIODE_CMC_h
#define Xyce_N_DEV_ADMSDIODE_CMC_h


#include <N_DEV_Configuration.h>
#include <N_DEV_Const.h>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>
#include <N_DEV_Diode.h>


namespace Xyce {
namespace Device {
namespace ADMSDIODE_CMC {

class Model;
class Instance;
class InstanceSensitivity;

#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Class         : InstanceSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class InstanceSensitivity : public baseSensitivity
{
public:
InstanceSensitivity() :
baseSensitivity() {};

virtual ~InstanceSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static InstanceSensitivity instSens;


//-----------------------------------------------------------------------------
// Class         : ModelSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class ModelSensitivity : public baseSensitivity
{
public:
ModelSensitivity() :
baseSensitivity() {};

virtual ~ModelSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static ModelSensitivity modSens;
#endif // Xyce_ADMS_SENSITIVITIES

// general purpose free functions
// thermal voltage at kelvin temperature temp)
template <typename T> static inline T adms_vt(const T temp) {return(CONSTKoverQ*temp);};

// Figure out how to template this shiznit!
//-----------------------------------------------------------------------------


template<typename Tin>
static Tin adms_ternary_op(const bool cond, const Tin &ifTrue, const Tin &ifFalse)
{
if (cond)
return ifTrue;
else
return ifFalse;
}

template<typename Tin>
static Tin adms_ternary_op(const bool cond, const Tin &ifTrue, const double &ifFalse)
{
if (cond)
return ifTrue;
else
return Tin(ifFalse);
}

template<typename Tin>
static Tin adms_ternary_op(const bool cond, const double &ifTrue, const Tin &ifFalse)
{
if (cond)
return Tin(ifTrue);
else
return ifFalse;
}




#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// "structs" to hold instance and model param/variable copies
//-----------------------------------------------------------------------------
class instanceSensStruct
{
public:
// instance parameters
// reals
double instancePar_AB;
double d_instancePar_AB_dX;
bool instancePar_given_AB;
double instancePar_LS;
double d_instancePar_LS_dX;
bool instancePar_given_LS;
double instancePar_LG;
double d_instancePar_LG_dX;
bool instancePar_given_LG;
double instancePar_MULT;
double d_instancePar_MULT_dX;
bool instancePar_given_MULT;
// instance variables
// reals
double instanceVar_MULT_i;
double d_instanceVar_MULT_i_dX;
double instanceVar_tmpv;
double d_instanceVar_tmpv_dX;
double instanceVar_vjv;
double d_instanceVar_vjv_dX;
double instanceVar_AB_i;
double d_instanceVar_AB_i_dX;
double instanceVar_LS_i;
double d_instanceVar_LS_i_dX;
double instanceVar_LG_i;
double d_instanceVar_LG_i_dX;
double instanceVar_zflagbot;
double instanceVar_zflagsti;
double instanceVar_zflaggat;
double instanceVar_VMAX;
double d_instanceVar_VMAX_dX;
double instanceVar_exp_VMAX_over_phitd;
double d_instanceVar_exp_VMAX_over_phitd_dX;
double instanceVar_vbimin;
double d_instanceVar_vbimin_dX;
double instanceVar_vch;
double d_instanceVar_vch_dX;
double instanceVar_vfmin;
double d_instanceVar_vfmin_dX;
double instanceVar_vbbtlim;
double d_instanceVar_vbbtlim_dX;
double instanceVar_ijunbot;
double d_instanceVar_ijunbot_dX;
double instanceVar_qjunbot;
double d_instanceVar_qjunbot_dX;
double instanceVar_ijunsti;
double d_instanceVar_ijunsti_dX;
double instanceVar_qjunsti;
double d_instanceVar_qjunsti_dX;
double instanceVar_ijungat;
double d_instanceVar_ijungat_dX;
double instanceVar_qjungat;
double d_instanceVar_qjungat_dX;
double instanceVar_ijun;
double d_instanceVar_ijun_dX;
double instanceVar_jnoise;
double d_instanceVar_jnoise_dX;
double instanceVar_VAK;
double instanceVar_DQAbot;
double d_instanceVar_DQAbot_dX;
double instanceVar_DQAsti;
double d_instanceVar_DQAsti_dX;
double instanceVar_DQAgat;
double d_instanceVar_DQAgat_dX;
double instanceVar_exp_VMAX_over_phitd_bot;
double d_instanceVar_exp_VMAX_over_phitd_bot_dX;
double instanceVar_exp_VMAX_over_phitd_sti;
double d_instanceVar_exp_VMAX_over_phitd_sti_dX;
double instanceVar_exp_VMAX_over_phitd_gat;
double d_instanceVar_exp_VMAX_over_phitd_gat_dX;
double instanceVar_conducts;
double d_instanceVar_conducts_dX;
double instanceVar_jfnoise;
double d_instanceVar_jfnoise_dX;
double instanceVar_jtnoise;
double d_instanceVar_jtnoise_dX;
double instanceVar_isattotal;
double d_instanceVar_isattotal_dX;
double instanceVar_ijnon;
double d_instanceVar_ijnon_dX;
double instanceVar_ijnonbot;
double d_instanceVar_ijnonbot_dX;
double instanceVar_ijnonsti;
double d_instanceVar_ijnonsti_dX;
double instanceVar_ijnongat;
double d_instanceVar_ijnongat_dX;
double instanceVar_xhighf1;
double d_instanceVar_xhighf1_dX;
double instanceVar_expxhf1;
double d_instanceVar_expxhf1_dX;
double instanceVar_xhighf2;
double d_instanceVar_xhighf2_dX;
double instanceVar_expxhf2;
double d_instanceVar_expxhf2_dX;
double instanceVar_xhighr;
double d_instanceVar_xhighr_dX;
double instanceVar_expxhr;
double d_instanceVar_expxhr_dX;
double instanceVar_ISATFOR1;
double d_instanceVar_ISATFOR1_dX;
double instanceVar_MFOR1;
double d_instanceVar_MFOR1_dX;
double instanceVar_ISATFOR2;
double d_instanceVar_ISATFOR2_dX;
double instanceVar_MFOR2;
double d_instanceVar_MFOR2_dX;
double instanceVar_ISATREV;
double d_instanceVar_ISATREV_dX;
double instanceVar_MREV;
double d_instanceVar_MREV_dX;
double instanceVar_m0flag;
double instanceVar_TMF1;
double d_instanceVar_TMF1_dX;
double instanceVar_TMF2;
double d_instanceVar_TMF2_dX;
double instanceVar_Q_nqs_A;
double d_instanceVar_Q_nqs_A_dX;
double instanceVar_Q_nqs_K;
double d_instanceVar_Q_nqs_K_dX;
double instanceVar_Inqs0_A;
double d_instanceVar_Inqs0_A_dX;
double instanceVar_Inqs0_K;
double d_instanceVar_Inqs0_K_dX;
double instanceVar_W_nqs_A;
double d_instanceVar_W_nqs_A_dX;
double instanceVar_IWnqs0_A;
double d_instanceVar_IWnqs0_A_dX;
double instanceVar_nj1;
double d_instanceVar_nj1_dX;
double instanceVar_nja10;
double d_instanceVar_nja10_dX;
double instanceVar_nja11;
double d_instanceVar_nja11_dX;
double instanceVar_vha1;
double d_instanceVar_vha1_dX;
double instanceVar_pnn0;
double d_instanceVar_pnn0_dX;
double instanceVar_dFn_SU;
double d_instanceVar_dFn_SU_dX;
double instanceVar_dFn_SL;
double d_instanceVar_dFn_SL_dX;
double instanceVar_dnj1_dV;
double d_instanceVar_dnj1_dV_dX;
double instanceVar_dVMAX_over_phitd_dV;
double d_instanceVar_dVMAX_over_phitd_dV_dX;
double instanceVar_idmultbot;
double d_instanceVar_idmultbot_dX;
double instanceVar_idmultsti;
double d_instanceVar_idmultsti_dX;
double instanceVar_idmultgat;
double d_instanceVar_idmultgat_dX;
// non-reals
int instanceVar_rnode;
};

class modelSensStruct
{
public:
// model parameters
// reals
double modelPar_VERSION;
double d_modelPar_VERSION_dX;
bool modelPar_given_VERSION;
double modelPar_SUBVERSION;
double d_modelPar_SUBVERSION_dX;
bool modelPar_given_SUBVERSION;
double modelPar_REVISION;
double d_modelPar_REVISION_dX;
bool modelPar_given_REVISION;
double modelPar_TYPE;
double d_modelPar_TYPE_dX;
bool modelPar_given_TYPE;
double modelPar_DTA;
double d_modelPar_DTA_dX;
bool modelPar_given_DTA;
double modelPar_IMAX;
double d_modelPar_IMAX_dX;
bool modelPar_given_IMAX;
double modelPar_TRJ;
double d_modelPar_TRJ_dX;
bool modelPar_given_TRJ;
double modelPar_CJORBOT;
double d_modelPar_CJORBOT_dX;
bool modelPar_given_CJORBOT;
double modelPar_CJORSTI;
double d_modelPar_CJORSTI_dX;
bool modelPar_given_CJORSTI;
double modelPar_CJORGAT;
double d_modelPar_CJORGAT_dX;
bool modelPar_given_CJORGAT;
double modelPar_VBIRBOT;
double d_modelPar_VBIRBOT_dX;
bool modelPar_given_VBIRBOT;
double modelPar_VBIRSTI;
double d_modelPar_VBIRSTI_dX;
bool modelPar_given_VBIRSTI;
double modelPar_VBIRGAT;
double d_modelPar_VBIRGAT_dX;
bool modelPar_given_VBIRGAT;
double modelPar_PBOT;
double d_modelPar_PBOT_dX;
bool modelPar_given_PBOT;
double modelPar_PSTI;
double d_modelPar_PSTI_dX;
bool modelPar_given_PSTI;
double modelPar_PGAT;
double d_modelPar_PGAT_dX;
bool modelPar_given_PGAT;
double modelPar_PHIGBOT;
double d_modelPar_PHIGBOT_dX;
bool modelPar_given_PHIGBOT;
double modelPar_PHIGSTI;
double d_modelPar_PHIGSTI_dX;
bool modelPar_given_PHIGSTI;
double modelPar_PHIGGAT;
double d_modelPar_PHIGGAT_dX;
bool modelPar_given_PHIGGAT;
double modelPar_IDSATRBOT;
double d_modelPar_IDSATRBOT_dX;
bool modelPar_given_IDSATRBOT;
double modelPar_IDSATRSTI;
double d_modelPar_IDSATRSTI_dX;
bool modelPar_given_IDSATRSTI;
double modelPar_IDSATRGAT;
double d_modelPar_IDSATRGAT_dX;
bool modelPar_given_IDSATRGAT;
double modelPar_CSRHBOT;
double d_modelPar_CSRHBOT_dX;
bool modelPar_given_CSRHBOT;
double modelPar_CSRHSTI;
double d_modelPar_CSRHSTI_dX;
bool modelPar_given_CSRHSTI;
double modelPar_CSRHGAT;
double d_modelPar_CSRHGAT_dX;
bool modelPar_given_CSRHGAT;
double modelPar_XJUNSTI;
double d_modelPar_XJUNSTI_dX;
bool modelPar_given_XJUNSTI;
double modelPar_XJUNGAT;
double d_modelPar_XJUNGAT_dX;
bool modelPar_given_XJUNGAT;
double modelPar_CTATBOT;
double d_modelPar_CTATBOT_dX;
bool modelPar_given_CTATBOT;
double modelPar_CTATSTI;
double d_modelPar_CTATSTI_dX;
bool modelPar_given_CTATSTI;
double modelPar_CTATGAT;
double d_modelPar_CTATGAT_dX;
bool modelPar_given_CTATGAT;
double modelPar_MEFFTATBOT;
double d_modelPar_MEFFTATBOT_dX;
bool modelPar_given_MEFFTATBOT;
double modelPar_MEFFTATSTI;
double d_modelPar_MEFFTATSTI_dX;
bool modelPar_given_MEFFTATSTI;
double modelPar_MEFFTATGAT;
double d_modelPar_MEFFTATGAT_dX;
bool modelPar_given_MEFFTATGAT;
double modelPar_CBBTBOT;
double d_modelPar_CBBTBOT_dX;
bool modelPar_given_CBBTBOT;
double modelPar_CBBTSTI;
double d_modelPar_CBBTSTI_dX;
bool modelPar_given_CBBTSTI;
double modelPar_CBBTGAT;
double d_modelPar_CBBTGAT_dX;
bool modelPar_given_CBBTGAT;
double modelPar_FBBTRBOT;
double d_modelPar_FBBTRBOT_dX;
bool modelPar_given_FBBTRBOT;
double modelPar_FBBTRSTI;
double d_modelPar_FBBTRSTI_dX;
bool modelPar_given_FBBTRSTI;
double modelPar_FBBTRGAT;
double d_modelPar_FBBTRGAT_dX;
bool modelPar_given_FBBTRGAT;
double modelPar_STFBBTBOT;
double d_modelPar_STFBBTBOT_dX;
bool modelPar_given_STFBBTBOT;
double modelPar_STFBBTSTI;
double d_modelPar_STFBBTSTI_dX;
bool modelPar_given_STFBBTSTI;
double modelPar_STFBBTGAT;
double d_modelPar_STFBBTGAT_dX;
bool modelPar_given_STFBBTGAT;
double modelPar_VBRBOT;
double d_modelPar_VBRBOT_dX;
bool modelPar_given_VBRBOT;
double modelPar_VBRSTI;
double d_modelPar_VBRSTI_dX;
bool modelPar_given_VBRSTI;
double modelPar_VBRGAT;
double d_modelPar_VBRGAT_dX;
bool modelPar_given_VBRGAT;
double modelPar_PBRBOT;
double d_modelPar_PBRBOT_dX;
bool modelPar_given_PBRBOT;
double modelPar_PBRSTI;
double d_modelPar_PBRSTI_dX;
bool modelPar_given_PBRSTI;
double modelPar_PBRGAT;
double d_modelPar_PBRGAT_dX;
bool modelPar_given_PBRGAT;
double modelPar_FREV;
double d_modelPar_FREV_dX;
bool modelPar_given_FREV;
double modelPar_RSBOT;
double d_modelPar_RSBOT_dX;
bool modelPar_given_RSBOT;
double modelPar_RSSTI;
double d_modelPar_RSSTI_dX;
bool modelPar_given_RSSTI;
double modelPar_RSGAT;
double d_modelPar_RSGAT_dX;
bool modelPar_given_RSGAT;
double modelPar_RSCOM;
double d_modelPar_RSCOM_dX;
bool modelPar_given_RSCOM;
double modelPar_STRS;
double d_modelPar_STRS_dX;
bool modelPar_given_STRS;
double modelPar_KF;
double d_modelPar_KF_dX;
bool modelPar_given_KF;
double modelPar_AF;
double d_modelPar_AF_dX;
bool modelPar_given_AF;
double modelPar_TT;
double d_modelPar_TT_dX;
bool modelPar_given_TT;
double modelPar_STVBRBOT1;
double d_modelPar_STVBRBOT1_dX;
bool modelPar_given_STVBRBOT1;
double modelPar_STVBRBOT2;
double d_modelPar_STVBRBOT2_dX;
bool modelPar_given_STVBRBOT2;
double modelPar_STVBRSTI1;
double d_modelPar_STVBRSTI1_dX;
bool modelPar_given_STVBRSTI1;
double modelPar_STVBRSTI2;
double d_modelPar_STVBRSTI2_dX;
bool modelPar_given_STVBRSTI2;
double modelPar_STVBRGAT1;
double d_modelPar_STVBRGAT1_dX;
bool modelPar_given_STVBRGAT1;
double modelPar_STVBRGAT2;
double d_modelPar_STVBRGAT2_dX;
bool modelPar_given_STVBRGAT2;
double modelPar_NFABOT;
double d_modelPar_NFABOT_dX;
bool modelPar_given_NFABOT;
double modelPar_NFASTI;
double d_modelPar_NFASTI_dX;
bool modelPar_given_NFASTI;
double modelPar_NFAGAT;
double d_modelPar_NFAGAT_dX;
bool modelPar_given_NFAGAT;
double modelPar_ABMIN;
double d_modelPar_ABMIN_dX;
bool modelPar_given_ABMIN;
double modelPar_ABMAX;
double d_modelPar_ABMAX_dX;
bool modelPar_given_ABMAX;
double modelPar_LSMIN;
double d_modelPar_LSMIN_dX;
bool modelPar_given_LSMIN;
double modelPar_LSMAX;
double d_modelPar_LSMAX_dX;
bool modelPar_given_LSMAX;
double modelPar_LGMIN;
double d_modelPar_LGMIN_dX;
bool modelPar_given_LGMIN;
double modelPar_LGMAX;
double d_modelPar_LGMAX_dX;
bool modelPar_given_LGMAX;
double modelPar_TEMPMIN;
double d_modelPar_TEMPMIN_dX;
bool modelPar_given_TEMPMIN;
double modelPar_TEMPMAX;
double d_modelPar_TEMPMAX_dX;
bool modelPar_given_TEMPMAX;
double modelPar_VFMAX;
double d_modelPar_VFMAX_dX;
bool modelPar_given_VFMAX;
double modelPar_VRMAX;
double d_modelPar_VRMAX_dX;
bool modelPar_given_VRMAX;
double modelPar_XTI;
double d_modelPar_XTI_dX;
bool modelPar_given_XTI;
double modelPar_SCALE;
double d_modelPar_SCALE_dX;
bool modelPar_given_SCALE;
double modelPar_SHRINK;
double d_modelPar_SHRINK_dX;
bool modelPar_given_SHRINK;
double modelPar_SWJUNEXP;
double d_modelPar_SWJUNEXP_dX;
bool modelPar_given_SWJUNEXP;
double modelPar_VJUNREF;
double d_modelPar_VJUNREF_dX;
bool modelPar_given_VJUNREF;
double modelPar_FJUNQ;
double d_modelPar_FJUNQ_dX;
bool modelPar_given_FJUNQ;
double modelPar_CORECOVERY;
double d_modelPar_CORECOVERY_dX;
bool modelPar_given_CORECOVERY;
double modelPar_NJH;
double d_modelPar_NJH_dX;
bool modelPar_given_NJH;
double modelPar_NJDV;
double d_modelPar_NJDV_dX;
bool modelPar_given_NJDV;
double modelPar_NDIBOT;
double d_modelPar_NDIBOT_dX;
bool modelPar_given_NDIBOT;
double modelPar_NDIGAT;
double d_modelPar_NDIGAT_dX;
bool modelPar_given_NDIGAT;
double modelPar_NDISTI;
double d_modelPar_NDISTI_dX;
bool modelPar_given_NDISTI;
double modelPar_INJ1;
double d_modelPar_INJ1_dX;
bool modelPar_given_INJ1;
double modelPar_INJ2;
double d_modelPar_INJ2_dX;
bool modelPar_given_INJ2;
double modelPar_NQS;
double d_modelPar_NQS_dX;
bool modelPar_given_NQS;
double modelPar_TAU;
double d_modelPar_TAU_dX;
bool modelPar_given_TAU;
double modelPar_WI;
double d_modelPar_WI_dX;
bool modelPar_given_WI;
double modelPar_DEPNQS;
double d_modelPar_DEPNQS_dX;
bool modelPar_given_DEPNQS;
double modelPar_TNOM;
double d_modelPar_TNOM_dX;
bool modelPar_given_TNOM;
double modelPar_TAUT;
double d_modelPar_TAUT_dX;
bool modelPar_given_TAUT;
double modelPar_INJT;
double d_modelPar_INJT_dX;
bool modelPar_given_INJT;
// model variables
// reals
double modelVar_IMAX_i;
double d_modelVar_IMAX_i_dX;double modelVar_VBIRBOT_i;
double d_modelVar_VBIRBOT_i_dX;double modelVar_VBIRSTI_i;
double d_modelVar_VBIRSTI_i_dX;double modelVar_VBIRGAT_i;
double d_modelVar_VBIRGAT_i_dX;double modelVar_PBOT_i;
double d_modelVar_PBOT_i_dX;double modelVar_PSTI_i;
double d_modelVar_PSTI_i_dX;double modelVar_PGAT_i;
double d_modelVar_PGAT_i_dX;double modelVar_CSRHBOT_i;
double d_modelVar_CSRHBOT_i_dX;double modelVar_CSRHSTI_i;
double d_modelVar_CSRHSTI_i_dX;double modelVar_CSRHGAT_i;
double d_modelVar_CSRHGAT_i_dX;double modelVar_CTATBOT_i;
double d_modelVar_CTATBOT_i_dX;double modelVar_CTATSTI_i;
double d_modelVar_CTATSTI_i_dX;double modelVar_CTATGAT_i;
double d_modelVar_CTATGAT_i_dX;double modelVar_CBBTBOT_i;
double d_modelVar_CBBTBOT_i_dX;double modelVar_CBBTSTI_i;
double d_modelVar_CBBTSTI_i_dX;double modelVar_CBBTGAT_i;
double d_modelVar_CBBTGAT_i_dX;double modelVar_VBRBOT_i;
double d_modelVar_VBRBOT_i_dX;double modelVar_VBRSTI_i;
double d_modelVar_VBRSTI_i_dX;double modelVar_VBRGAT_i;
double d_modelVar_VBRGAT_i_dX;double modelVar_PBRBOT_i;
double d_modelVar_PBRBOT_i_dX;double modelVar_PBRSTI_i;
double d_modelVar_PBRSTI_i_dX;double modelVar_PBRGAT_i;
double d_modelVar_PBRGAT_i_dX;double modelVar_SWJUNEXP_i;
double modelVar_VJUNREF_i;
double d_modelVar_VJUNREF_i_dX;double modelVar_FJUNQ_i;
double d_modelVar_FJUNQ_i_dX;double modelVar_KF_i;
double d_modelVar_KF_i_dX;double modelVar_AF_i;
double d_modelVar_AF_i_dX;double modelVar_TT_i;
double d_modelVar_TT_i_dX;double modelVar_NFABOT_i;
double d_modelVar_NFABOT_i_dX;double modelVar_NFAGAT_i;
double d_modelVar_NFAGAT_i_dX;double modelVar_NFASTI_i;
double d_modelVar_NFASTI_i_dX;double modelVar_ABMIN_i;
double d_modelVar_ABMIN_i_dX;double modelVar_ABMAX_i;
double d_modelVar_ABMAX_i_dX;double modelVar_LGMAX_i;
double d_modelVar_LGMAX_i_dX;double modelVar_LGMIN_i;
double d_modelVar_LGMIN_i_dX;double modelVar_LSMAX_i;
double d_modelVar_LSMAX_i_dX;double modelVar_LSMIN_i;
double d_modelVar_LSMIN_i_dX;double modelVar_TEMPMIN_i;
double d_modelVar_TEMPMIN_i_dX;double modelVar_TEMPMAX_i;
double d_modelVar_TEMPMAX_i_dX;double modelVar_VFMAX_i;
double d_modelVar_VFMAX_i_dX;double modelVar_VRMAX_i;
double d_modelVar_VRMAX_i_dX;double modelVar_SCALE_i;
double d_modelVar_SCALE_i_dX;double modelVar_tkr;
double d_modelVar_tkr_dX;double modelVar_tkd;
double d_modelVar_tkd_dX;double modelVar_phitr;
double d_modelVar_phitr_dX;double modelVar_phitd;
double d_modelVar_phitd_dX;double modelVar_phitdinv;
double d_modelVar_phitdinv_dX;double modelVar_perfc;
double modelVar_berfc;
double modelVar_cerfc;
double modelVar_ftdbot;
double d_modelVar_ftdbot_dX;double modelVar_ftdsti;
double d_modelVar_ftdsti_dX;double modelVar_ftdgat;
double d_modelVar_ftdgat_dX;double modelVar_idsatbot;
double d_modelVar_idsatbot_dX;double modelVar_idsatsti;
double d_modelVar_idsatsti_dX;double modelVar_idsatgat;
double d_modelVar_idsatgat_dX;double modelVar_vbibot;
double d_modelVar_vbibot_dX;double modelVar_vbisti;
double d_modelVar_vbisti_dX;double modelVar_vbigat;
double d_modelVar_vbigat_dX;double modelVar_vbiinvbot;
double d_modelVar_vbiinvbot_dX;double modelVar_vbiinvsti;
double d_modelVar_vbiinvsti_dX;double modelVar_vbiinvgat;
double d_modelVar_vbiinvgat_dX;double modelVar_one_minus_PBOT;
double d_modelVar_one_minus_PBOT_dX;double modelVar_one_minus_PSTI;
double d_modelVar_one_minus_PSTI_dX;double modelVar_one_minus_PGAT;
double d_modelVar_one_minus_PGAT_dX;double modelVar_one_over_one_minus_PBOT;
double d_modelVar_one_over_one_minus_PBOT_dX;double modelVar_one_over_one_minus_PSTI;
double d_modelVar_one_over_one_minus_PSTI_dX;double modelVar_one_over_one_minus_PGAT;
double d_modelVar_one_over_one_minus_PGAT_dX;double modelVar_cjobot;
double d_modelVar_cjobot_dX;double modelVar_cjosti;
double d_modelVar_cjosti_dX;double modelVar_cjogat;
double d_modelVar_cjogat_dX;double modelVar_qprefbot;
double d_modelVar_qprefbot_dX;double modelVar_qprefsti;
double d_modelVar_qprefsti_dX;double modelVar_qprefgat;
double d_modelVar_qprefgat_dX;double modelVar_qpref2bot;
double d_modelVar_qpref2bot_dX;double modelVar_qpref2sti;
double d_modelVar_qpref2sti_dX;double modelVar_qpref2gat;
double d_modelVar_qpref2gat_dX;double modelVar_wdepnulrbot;
double d_modelVar_wdepnulrbot_dX;double modelVar_wdepnulrsti;
double d_modelVar_wdepnulrsti_dX;double modelVar_wdepnulrgat;
double d_modelVar_wdepnulrgat_dX;double modelVar_wdepnulrinvbot;
double d_modelVar_wdepnulrinvbot_dX;double modelVar_wdepnulrinvsti;
double d_modelVar_wdepnulrinvsti_dX;double modelVar_wdepnulrinvgat;
double d_modelVar_wdepnulrinvgat_dX;double modelVar_VBIRBOTinv;
double d_modelVar_VBIRBOTinv_dX;double modelVar_VBIRSTIinv;
double d_modelVar_VBIRSTIinv_dX;double modelVar_VBIRGATinv;
double d_modelVar_VBIRGATinv_dX;double modelVar_atatbot;
double d_modelVar_atatbot_dX;double modelVar_atatsti;
double d_modelVar_atatsti_dX;double modelVar_atatgat;
double d_modelVar_atatgat_dX;double modelVar_btatpartbot;
double d_modelVar_btatpartbot_dX;double modelVar_btatpartsti;
double d_modelVar_btatpartsti_dX;double modelVar_btatpartgat;
double d_modelVar_btatpartgat_dX;double modelVar_fbbtbot;
double d_modelVar_fbbtbot_dX;double modelVar_fbbtsti;
double d_modelVar_fbbtsti_dX;double modelVar_fbbtgat;
double d_modelVar_fbbtgat_dX;double modelVar_alphaav;
double d_modelVar_alphaav_dX;double modelVar_fstopbot;
double d_modelVar_fstopbot_dX;double modelVar_fstopsti;
double d_modelVar_fstopsti_dX;double modelVar_fstopgat;
double d_modelVar_fstopgat_dX;double modelVar_VBRinvbot;
double d_modelVar_VBRinvbot_dX;double modelVar_VBRinvsti;
double d_modelVar_VBRinvsti_dX;double modelVar_VBRinvgat;
double d_modelVar_VBRinvgat_dX;double modelVar_slopebot;
double d_modelVar_slopebot_dX;double modelVar_slopesti;
double d_modelVar_slopesti_dX;double modelVar_slopegat;
double d_modelVar_slopegat_dX;double modelVar_rescom;
double d_modelVar_rescom_dX;double modelVar_resbot;
double d_modelVar_resbot_dX;double modelVar_ressti;
double d_modelVar_ressti_dX;double modelVar_resgat;
double d_modelVar_resgat_dX;double modelVar_shrinkL;
double d_modelVar_shrinkL_dX;double modelVar_NDI_i;
double d_modelVar_NDI_i_dX;double modelVar_NDIBOT_i;
double d_modelVar_NDIBOT_i_dX;double modelVar_NDIGAT_i;
double d_modelVar_NDIGAT_i_dX;double modelVar_NDISTI_i;
double d_modelVar_NDISTI_i_dX;double modelVar_NJL;
double d_modelVar_NJL_dX;double modelVar_Nin;
double d_modelVar_Nin_dX;double modelVar_Pn0;
double d_modelVar_Pn0_dX;double modelVar_La;
double d_modelVar_La_dX;double modelVar_V_HA;
double d_modelVar_V_HA_dX;double modelVar_V_HK;
double d_modelVar_V_HK_dX;double modelVar_PB;
double modelVar_JUNCDLT;
};



//-----------------------------------------------------------------------------
// Free functions used by sensitivity
//
//-----------------------------------------------------------------------------
void evaluateModelEquations(
std::vector <double> & probeVars,
// probe constants
const int admsProbeID_V_A_GND,
const int admsProbeID_V_depl_A_GND,
const int admsProbeID_V_charge_K_GND,
const int admsProbeID_V_charge_A_GND,
const int admsProbeID_V_A_K,
const int admsProbeID_V_AIK_K,
const int admsProbeID_V_A_AIK,
// node constants
const int admsNodeID_A,
const int admsNodeID_K,
const int admsNodeID_AIK,
const int admsNodeID_charge_A,
const int admsNodeID_charge_K,
const int admsNodeID_depl_A,
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
// basic variables
 double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, std::vector <double> & d_staticContributions_dX, std::vector <double> & d_dynamicContributions_dX, const Instance & theInstance);

void evaluateInitialInstance(
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
 double admsTemperature,double adms_vt_nom, double ADMSgmin_arg, const Instance & theInstance);

void evaluateInitialModel(
modelSensStruct & modelStruct,
 double admsTemperature, double ADMSgmin_arg, const Instance & theInstance);

#endif // Xyce_ADMS_SENSITIVITIES


// Limited exponential --- NOT what verilog LRM says, but what qucs,
// ng-spice, and zspice do.

template <typename T>
T limexp(const T &x)
{
  if ((x) < 80.0)
  return (exp(x));
  else
  return (exp(80.0)*(x-79.0));
}


struct Traits: public DeviceTraits<Model, Instance, Diode::Traits>
{
  static const char *name() {return "ADMS DIODE_CMC";}
  static const char *deviceTypeName() {return "d level 2002";}

  static int numNodes() {return 2;}


  static bool modelRequired() {return true;}
  static bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &configuration, const FactoryBlock &factory_block);
  static void loadModelParameters(ParametricData<Model> &model_parameters);
  static void loadInstanceParameters(ParametricData<Instance> &instance_parameters);
};

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;
#ifdef Xyce_ADMS_SENSITIVITIES
  friend class InstanceSensitivity;
  friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
  friend struct Traits;

  public:
    Instance(
      const Configuration &       configuration,
      const InstanceBlock &       instance_block,
      Model &                     model,
      const FactoryBlock &        factory_block);

    ~Instance();

private:
    Instance(const Instance &);
    Instance &operator=(const Instance &);

public:
    void registerLIDs( const LocalIdVector & intLIDVecRef,
                       const LocalIdVector & extLIDVecRef );
    void registerStoreLIDs( const LocalIdVector & stoLIDVecRef );
    void setupPointers();

    void loadNodeSymbols(Util::SymbolTable &symbol_table) const;

    const JacobianStamp & jacobianStamp() const;
    void registerJacLIDs( const JacobianStamp & jacLIDVec );

    void registerBranchDataLIDs(const std::vector<int> & branchLIDVecRef);

    bool processParams();
    bool updateTemperature ( const double & temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

      void collapseNodes();
      int getNumNoiseSources () const;  // 3
      void setupNoiseSources (Xyce::Analysis::NoiseData & noiseData);
      void getNoiseSources (Xyce::Analysis::NoiseData & noiseData);

  private:

  public:
    // iterator reference to the DIODE_CMC model which owns this instance.
    // Getters and setters
    Model &getModel()
    {
      return model_;
    }

  private:

    Model & model_;   //< Owning Model
    // Begin verilog Instance Variables
    //   Instance Parameters
    double AB;
    double LS;
    double LG;
    double MULT;
    //  Variables of global_instance scope
    double MULT_i;
    int rnode;
    double tmpv;
     double d_tmpv_dV_A_AIK;
    double vjv;
     double d_vjv_dV_A_AIK;
    double AB_i;
    double LS_i;
    double LG_i;
    double zflagbot;
    double zflagsti;
    double zflaggat;
    double VMAX;
    double exp_VMAX_over_phitd;
    double vbimin;
    double vch;
    double vfmin;
    double vbbtlim;
    double ijunbot;
     double d_ijunbot_dV_A_AIK;
    double qjunbot;
     double d_qjunbot_dV_A_AIK;
    double ijunsti;
     double d_ijunsti_dV_A_AIK;
    double qjunsti;
     double d_qjunsti_dV_A_AIK;
    double ijungat;
     double d_ijungat_dV_A_AIK;
    double qjungat;
     double d_qjungat_dV_A_AIK;
    double ijun;
     double d_ijun_dV_A_AIK;
    double jnoise;
    double VAK;
     double d_VAK_dV_A_AIK;
    double DQAbot;
    double DQAsti;
    double DQAgat;
    double exp_VMAX_over_phitd_bot;
     double d_exp_VMAX_over_phitd_bot_dV_A_AIK;
    double exp_VMAX_over_phitd_sti;
     double d_exp_VMAX_over_phitd_sti_dV_A_AIK;
    double exp_VMAX_over_phitd_gat;
     double d_exp_VMAX_over_phitd_gat_dV_A_AIK;
    double conducts;
    double jfnoise;
    double jtnoise;
    double isattotal;
    double ijnon;
     double d_ijnon_dV_A_AIK;
    double ijnonbot;
     double d_ijnonbot_dV_A_AIK;
    double ijnonsti;
     double d_ijnonsti_dV_A_AIK;
    double ijnongat;
     double d_ijnongat_dV_A_AIK;
    double xhighf1;
    double expxhf1;
    double xhighf2;
    double expxhf2;
    double xhighr;
    double expxhr;
    double ISATFOR1;
    double MFOR1;
    double ISATFOR2;
    double MFOR2;
    double ISATREV;
    double MREV;
    double m0flag;
    double TMF1;
     double d_TMF1_dV_A_AIK;
    double TMF2;
     double d_TMF2_dV_A_AIK;
    double Q_nqs_A;
     double d_Q_nqs_A_dV_charge_A_GND;
    double Q_nqs_K;
     double d_Q_nqs_K_dV_charge_K_GND;
    double Inqs0_A;
     double d_Inqs0_A_dV_charge_A_GND;
     double d_Inqs0_A_dV_A_AIK;
    double Inqs0_K;
     double d_Inqs0_K_dV_charge_K_GND;
     double d_Inqs0_K_dV_A_AIK;
    double W_nqs_A;
     double d_W_nqs_A_dV_depl_A_GND;
    double IWnqs0_A;
     double d_IWnqs0_A_dV_depl_A_GND;
     double d_IWnqs0_A_dV_A_AIK;
    double nj1;
     double d_nj1_dV_A_AIK;
    double nja10;
     double d_nja10_dV_A_AIK;
    double nja11;
     double d_nja11_dV_A_AIK;
    double vha1;
    double pnn0;
    double dFn_SU;
     double d_dFn_SU_dV_A_AIK;
    double dFn_SL;
     double d_dFn_SL_dV_A_AIK;
    double dnj1_dV;
     double d_dnj1_dV_dV_A_AIK;
    double dVMAX_over_phitd_dV;
     double d_dVMAX_over_phitd_dV_dV_A_AIK;
    double idmultbot;
     double d_idmultbot_dV_A_AIK;
    double idmultsti;
     double d_idmultsti_dV_A_AIK;
    double idmultgat;
     double d_idmultgat_dV_A_AIK;
    double vak;
    double cj;
    double cjbot;
    double cjgat;
    double cjsti;
    double ij;
    double ijbot;
    double ijgat;
    double ijsti;
    double si;
    double vrs;
    double sf;
    double sr;
    double rseries;
    double qrr;
    // end verilog Instance Variables=====
    // Nodal LID Variables
    int li_A;
    int li_K;
    int li_AIK;
    int li_charge_A;
    int li_charge_K;
    int li_depl_A;
    // end Nodal LID Variables
    // Branch LID Variables
    // end Branch LID Variables
    // Lead (branch) LID Variables
    int li_branch_iA;
    // end Lead (branch) LID Variables
    // Jacobian  pointers
    double * f_A_Equ_A_Node_Ptr;
    double * f_A_Equ_AIK_Node_Ptr;
    double * f_AIK_Equ_A_Node_Ptr;
    double * f_AIK_Equ_AIK_Node_Ptr;
    double * f_AIK_Equ_K_Node_Ptr;
    double * f_K_Equ_AIK_Node_Ptr;
    double * f_K_Equ_K_Node_Ptr;
    double * f_charge_A_Equ_A_Node_Ptr;
    double * f_charge_A_Equ_AIK_Node_Ptr;
    double * f_charge_A_Equ_charge_A_Node_Ptr;
    double * f_charge_K_Equ_A_Node_Ptr;
    double * f_charge_K_Equ_AIK_Node_Ptr;
    double * f_charge_K_Equ_charge_K_Node_Ptr;
    double * f_depl_A_Equ_A_Node_Ptr;
    double * f_depl_A_Equ_AIK_Node_Ptr;
    double * f_depl_A_Equ_depl_A_Node_Ptr;
    double * f_A_Equ_charge_K_Node_Ptr;
    double * f_AIK_Equ_charge_K_Node_Ptr;
    double * f_A_Equ_depl_A_Node_Ptr;
    double * f_AIK_Equ_depl_A_Node_Ptr;
    double * f_A_Equ_charge_A_Node_Ptr;
    double * f_AIK_Equ_charge_A_Node_Ptr;
    double * q_A_Equ_A_Node_Ptr;
    double * q_A_Equ_AIK_Node_Ptr;
    double * q_AIK_Equ_A_Node_Ptr;
    double * q_AIK_Equ_AIK_Node_Ptr;
    double * q_AIK_Equ_K_Node_Ptr;
    double * q_K_Equ_AIK_Node_Ptr;
    double * q_K_Equ_K_Node_Ptr;
    double * q_charge_A_Equ_A_Node_Ptr;
    double * q_charge_A_Equ_AIK_Node_Ptr;
    double * q_charge_A_Equ_charge_A_Node_Ptr;
    double * q_charge_K_Equ_A_Node_Ptr;
    double * q_charge_K_Equ_AIK_Node_Ptr;
    double * q_charge_K_Equ_charge_K_Node_Ptr;
    double * q_depl_A_Equ_A_Node_Ptr;
    double * q_depl_A_Equ_AIK_Node_Ptr;
    double * q_depl_A_Equ_depl_A_Node_Ptr;
    double * q_A_Equ_charge_K_Node_Ptr;
    double * q_AIK_Equ_charge_K_Node_Ptr;
    double * q_A_Equ_depl_A_Node_Ptr;
    double * q_AIK_Equ_depl_A_Node_Ptr;
    double * q_A_Equ_charge_A_Node_Ptr;
    double * q_AIK_Equ_charge_A_Node_Ptr;
    // Jacobian offsets
    int A_A_Equ_A_NodeOffset;
    int A_A_Equ_AIK_NodeOffset;
    int A_AIK_Equ_A_NodeOffset;
    int A_AIK_Equ_AIK_NodeOffset;
    int A_AIK_Equ_K_NodeOffset;
    int A_K_Equ_AIK_NodeOffset;
    int A_K_Equ_K_NodeOffset;
    int A_charge_A_Equ_A_NodeOffset;
    int A_charge_A_Equ_AIK_NodeOffset;
    int A_charge_A_Equ_charge_A_NodeOffset;
    int A_charge_K_Equ_A_NodeOffset;
    int A_charge_K_Equ_AIK_NodeOffset;
    int A_charge_K_Equ_charge_K_NodeOffset;
    int A_depl_A_Equ_A_NodeOffset;
    int A_depl_A_Equ_AIK_NodeOffset;
    int A_depl_A_Equ_depl_A_NodeOffset;
    int A_A_Equ_charge_K_NodeOffset;
    int A_AIK_Equ_charge_K_NodeOffset;
    int A_A_Equ_depl_A_NodeOffset;
    int A_AIK_Equ_depl_A_NodeOffset;
    int A_A_Equ_charge_A_NodeOffset;
    int A_AIK_Equ_charge_A_NodeOffset;
    // end of Jacobian and pointers
   // node numbers
    static const int admsNodeID_A = 0;
    static const int admsNodeID_K = 1;
    static const int admsNodeID_AIK = 0+2;
    static const int admsNodeID_charge_A = 1+2;
    static const int admsNodeID_charge_K = 2+2;
    static const int admsNodeID_depl_A = 3+2;
    static const int admsNodeID_GND = -1;
   // end node numbers
   // Additional IDs for branch equations
   // end branch numbers
   // Probe numbers
    static const int admsProbeID_V_A_GND = 0;
    static const int admsProbeID_V_depl_A_GND = 1;
    static const int admsProbeID_V_charge_K_GND = 2;
    static const int admsProbeID_V_charge_A_GND = 3;
    static const int admsProbeID_V_A_K = 4;
    static const int admsProbeID_V_AIK_K = 5;
    static const int admsProbeID_V_A_AIK = 6;
   // end probe numbers
   // Store LIDs
   // end store LIDs
   // Store LIDs for output vars
    int li_store_vak;
    int li_store_cj;
    int li_store_cjbot;
    int li_store_cjgat;
    int li_store_cjsti;
    int li_store_ij;
    int li_store_ijbot;
    int li_store_ijgat;
    int li_store_ijsti;
    int li_store_si;
    int li_store_vrs;
    int li_store_sf;
    int li_store_sr;
    int li_store_rseries;
    int li_store_qrr;
   // end store LIDs for output vars
     // bools for collapsing nodes
     bool collapseNode_AIK;
     bool collapseNode_charge_A;
     bool collapseNode_charge_K;
     bool collapseNode_depl_A;
 // Arrays to hold probes
 std::vector < double > probeVars;
 std::vector < std::vector < double > > d_probeVars;
 // Arrays to hold contributions
 // dynamic contributions are differentiated w.r.t time
 std::vector < double > staticContributions;
 std::vector < std::vector < double > > d_staticContributions;
 std::vector < double > dynamicContributions;
 std::vector < std::vector < double > > d_dynamicContributions;
//vectors to hold noise information for communication between methods
std::vector<double> noiseContribsPower;
std::vector<double> noiseContribsExponent;


    // this is what we'll use when any model uses $temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at $temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;


    JacobianStamp jacStamp;
    IdVector nodeMap;
    PairMap pairToJacStampMap;

    // These instance-owned vectors are for storage of lead current data
    std::vector<double> leadCurrentF;
    std::vector<double> leadCurrentQ;


    };


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
    typedef std::vector<Instance *> InstanceVector;

    friend class ParametricData<Model>;
    friend class Instance;
#ifdef Xyce_ADMS_SENSITIVITIES
    friend class InstanceSensitivity;
    friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
    friend struct Traits;

  public:
    Model(
      const Configuration &       configuration,
      const ModelBlock &          model_block,
      const FactoryBlock &        factory_block);

    ~Model();

private:
    Model(const Model &);
    Model &operator=(const Model &);

public:
    virtual void forEachInstance(DeviceInstanceOp &op) const /* override */;
    virtual std::ostream &printOutInstances(std::ostream &os) const;
    bool processParams();
    bool processInstanceParams();

  private:

  public:
    void addInstance(Instance *instance)
    {
      instanceContainer.push_back(instance);
    }

    void setupBaseInstanceContainer()
    {
      std::vector<Instance*>::iterator iter = instanceContainer.begin();
      std::vector<Instance*>::iterator end   = instanceContainer.end();
      for ( ; iter!=end; ++iter)
      {
      Xyce::Device::DeviceModel::baseInstanceContainer.push_back( static_cast<Xyce::Device::DeviceInstance *>(*iter) );
    }
  }

  private:
    std::vector<Instance*> instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;
// Begin verilog Model Variables
//   Model Parameters
    double VERSION;
    double SUBVERSION;
    double REVISION;
    double TYPE;
    double DTA;
    double IMAX;
    double TRJ;
    double CJORBOT;
    double CJORSTI;
    double CJORGAT;
    double VBIRBOT;
    double VBIRSTI;
    double VBIRGAT;
    double PBOT;
    double PSTI;
    double PGAT;
    double PHIGBOT;
    double PHIGSTI;
    double PHIGGAT;
    double IDSATRBOT;
    double IDSATRSTI;
    double IDSATRGAT;
    double CSRHBOT;
    double CSRHSTI;
    double CSRHGAT;
    double XJUNSTI;
    double XJUNGAT;
    double CTATBOT;
    double CTATSTI;
    double CTATGAT;
    double MEFFTATBOT;
    double MEFFTATSTI;
    double MEFFTATGAT;
    double CBBTBOT;
    double CBBTSTI;
    double CBBTGAT;
    double FBBTRBOT;
    double FBBTRSTI;
    double FBBTRGAT;
    double STFBBTBOT;
    double STFBBTSTI;
    double STFBBTGAT;
    double VBRBOT;
    double VBRSTI;
    double VBRGAT;
    double PBRBOT;
    double PBRSTI;
    double PBRGAT;
    double FREV;
    double RSBOT;
    double RSSTI;
    double RSGAT;
    double RSCOM;
    double STRS;
    double KF;
    double AF;
    double TT;
    double STVBRBOT1;
    double STVBRBOT2;
    double STVBRSTI1;
    double STVBRSTI2;
    double STVBRGAT1;
    double STVBRGAT2;
    double NFABOT;
    double NFASTI;
    double NFAGAT;
    double ABMIN;
    double ABMAX;
    double LSMIN;
    double LSMAX;
    double LGMIN;
    double LGMAX;
    double TEMPMIN;
    double TEMPMAX;
    double VFMAX;
    double VRMAX;
    double XTI;
    double SCALE;
    double SHRINK;
    double SWJUNEXP;
    double VJUNREF;
    double FJUNQ;
    double CORECOVERY;
    double NJH;
    double NJDV;
    double NDIBOT;
    double NDIGAT;
    double NDISTI;
    double INJ1;
    double INJ2;
    double NQS;
    double TAU;
    double WI;
    double DEPNQS;
    double TNOM;
    double TAUT;
    double INJT;
    //  Variables of global_model scope
    double IMAX_i;
    double VBIRBOT_i;
    double VBIRSTI_i;
    double VBIRGAT_i;
    double PBOT_i;
    double PSTI_i;
    double PGAT_i;
    double CSRHBOT_i;
    double CSRHSTI_i;
    double CSRHGAT_i;
    double CTATBOT_i;
    double CTATSTI_i;
    double CTATGAT_i;
    double CBBTBOT_i;
    double CBBTSTI_i;
    double CBBTGAT_i;
    double VBRBOT_i;
    double VBRSTI_i;
    double VBRGAT_i;
    double PBRBOT_i;
    double PBRSTI_i;
    double PBRGAT_i;
    double SWJUNEXP_i;
    double VJUNREF_i;
    double FJUNQ_i;
    double KF_i;
    double AF_i;
    double TT_i;
    double NFABOT_i;
    double NFAGAT_i;
    double NFASTI_i;
    double ABMIN_i;
    double ABMAX_i;
    double LGMAX_i;
    double LGMIN_i;
    double LSMAX_i;
    double LSMIN_i;
    double TEMPMIN_i;
    double TEMPMAX_i;
    double VFMAX_i;
    double VRMAX_i;
    double SCALE_i;
    double tkr;
    double tkd;
    double phitr;
    double phitd;
    double phitdinv;
    double perfc;
    double berfc;
    double cerfc;
    double ftdbot;
    double ftdsti;
    double ftdgat;
    double idsatbot;
    double idsatsti;
    double idsatgat;
    double vbibot;
    double vbisti;
    double vbigat;
    double vbiinvbot;
    double vbiinvsti;
    double vbiinvgat;
    double one_minus_PBOT;
    double one_minus_PSTI;
    double one_minus_PGAT;
    double one_over_one_minus_PBOT;
    double one_over_one_minus_PSTI;
    double one_over_one_minus_PGAT;
    double cjobot;
    double cjosti;
    double cjogat;
    double qprefbot;
    double qprefsti;
    double qprefgat;
    double qpref2bot;
    double qpref2sti;
    double qpref2gat;
    double wdepnulrbot;
    double wdepnulrsti;
    double wdepnulrgat;
    double wdepnulrinvbot;
    double wdepnulrinvsti;
    double wdepnulrinvgat;
    double VBIRBOTinv;
    double VBIRSTIinv;
    double VBIRGATinv;
    double atatbot;
    double atatsti;
    double atatgat;
    double btatpartbot;
    double btatpartsti;
    double btatpartgat;
    double fbbtbot;
    double fbbtsti;
    double fbbtgat;
    double alphaav;
    double fstopbot;
    double fstopsti;
    double fstopgat;
    double VBRinvbot;
    double VBRinvsti;
    double VBRinvgat;
    double slopebot;
    double slopesti;
    double slopegat;
    double rescom;
    double resbot;
    double ressti;
    double resgat;
    double shrinkL;
    double NDI_i;
    double NDIBOT_i;
    double NDIGAT_i;
    double NDISTI_i;
    double NJL;
    double Nin;
    double Pn0;
    double La;
    double V_HA;
    double V_HK;
    double PB;
    double JUNCDLT;
    // end verilog model variables=====
};

void registerDevice(const DeviceCountMap& deviceMap = DeviceCountMap(),
                    const std::set<int>& levelSet = std::set<int>());

} // namespace ADMSDIODE_CMC
} // namespace Device
} // namespace Xyce
#endif //Xyce_N_DEV_ADMSDIODE_CMC_h
