
// -*-c++-*-
//-------------------------------------------------------------------------
//   Copyright 2002-2024 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file ekv26_SDext_Verilog-A.va with ADMS
//                  interface for Xyce 7.9.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.7
//
// Creation Date  : Thu, 23 May 2024 20:30:06
//
//-----------------------------------------------------------------------------
#ifndef Xyce_N_DEV_ADMSekv_va_h
#define Xyce_N_DEV_ADMSekv_va_h


#include <N_DEV_Configuration.h>
#include <N_DEV_Const.h>
#include <N_DEV_DeviceBlock.h>
#include <N_DEV_DeviceInstance.h>
#include <N_DEV_DeviceModel.h>
#include <N_DEV_MOSFET1.h>


// Xyce_config.h contains a VERSION macro from autoconf, and some
// Verilog-A models like to define a variable of that name.  This can be
// a serious problem, and we don't need the VERSION macro.  Get rid of it.
// This must happen *after* all the includes of Xyce headers, each of which
// includes Xyce_config.h.  The implementation file must do this all again
// because it includes more Xyce headers *after* including this one.
#ifdef VERSION
#undef VERSION
#endif

namespace Xyce {
namespace Device {
namespace ADMSekv_va {

class Model;
class Instance;
class InstanceSensitivity;

#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Class         : InstanceSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class InstanceSensitivity : public baseSensitivity
{
public:
InstanceSensitivity() :
baseSensitivity() {};

virtual ~InstanceSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static InstanceSensitivity instSens;


//-----------------------------------------------------------------------------
// Class         : ModelSensitivity
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class ModelSensitivity : public baseSensitivity
{
public:
ModelSensitivity() :
baseSensitivity() {};

virtual ~ModelSensitivity() {};

virtual void operator()(
const ParameterBase &entity,
const std::string &param,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const ;
};

static ModelSensitivity modSens;
#endif // Xyce_ADMS_SENSITIVITIES

// general purpose free functions
// thermal voltage at kelvin temperature temp)
static inline double adms_vt(const double temp) {return(CONSTKoverQ*temp);};


#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// "structs" to hold instance and model param/variable copies
//-----------------------------------------------------------------------------
class instanceSensStruct
{
public:
// instance parameters
// reals
double instancePar_L;
double d_instancePar_L_dX;
bool instancePar_given_L;
double instancePar_W;
double d_instancePar_W_dX;
bool instancePar_given_W;
double instancePar_M;
double d_instancePar_M_dX;
bool instancePar_given_M;
double instancePar_NS;
double d_instancePar_NS_dX;
bool instancePar_given_NS;
double instancePar_AS;
double d_instancePar_AS_dX;
bool instancePar_given_AS;
double instancePar_AD;
double d_instancePar_AD_dX;
bool instancePar_given_AD;
double instancePar_PS;
double d_instancePar_PS_dX;
bool instancePar_given_PS;
double instancePar_PD;
double d_instancePar_PD_dX;
bool instancePar_given_PD;
};

class modelSensStruct
{
public:
// model parameters
// reals
double modelPar_Trise;
double d_modelPar_Trise_dX;
bool modelPar_given_Trise;
double modelPar_TEMP;
double d_modelPar_TEMP_dX;
bool modelPar_given_TEMP;
double modelPar_TNOM;
double d_modelPar_TNOM_dX;
bool modelPar_given_TNOM;
double modelPar_L;
double d_modelPar_L_dX;
bool modelPar_given_L;
double modelPar_W;
double d_modelPar_W_dX;
bool modelPar_given_W;
double modelPar_M;
double d_modelPar_M_dX;
bool modelPar_given_M;
double modelPar_NS;
double d_modelPar_NS_dX;
bool modelPar_given_NS;
double modelPar_AS;
double d_modelPar_AS_dX;
bool modelPar_given_AS;
double modelPar_AD;
double d_modelPar_AD_dX;
bool modelPar_given_AD;
double modelPar_PS;
double d_modelPar_PS_dX;
bool modelPar_given_PS;
double modelPar_PD;
double d_modelPar_PD_dX;
bool modelPar_given_PD;
double modelPar_COX;
double d_modelPar_COX_dX;
bool modelPar_given_COX;
double modelPar_XJ;
double d_modelPar_XJ_dX;
bool modelPar_given_XJ;
double modelPar_VTO;
double d_modelPar_VTO_dX;
bool modelPar_given_VTO;
double modelPar_TCV;
double d_modelPar_TCV_dX;
bool modelPar_given_TCV;
double modelPar_GAMMA;
double d_modelPar_GAMMA_dX;
bool modelPar_given_GAMMA;
double modelPar_PHI;
double d_modelPar_PHI_dX;
bool modelPar_given_PHI;
double modelPar_KP;
double d_modelPar_KP_dX;
bool modelPar_given_KP;
double modelPar_BEX;
double d_modelPar_BEX_dX;
bool modelPar_given_BEX;
double modelPar_THETA;
double d_modelPar_THETA_dX;
bool modelPar_given_THETA;
double modelPar_E0;
double d_modelPar_E0_dX;
bool modelPar_given_E0;
double modelPar_UCRIT;
double d_modelPar_UCRIT_dX;
bool modelPar_given_UCRIT;
double modelPar_UCEX;
double d_modelPar_UCEX_dX;
bool modelPar_given_UCEX;
double modelPar_LAMBDA;
double d_modelPar_LAMBDA_dX;
bool modelPar_given_LAMBDA;
double modelPar_DL;
double d_modelPar_DL_dX;
bool modelPar_given_DL;
double modelPar_DW;
double d_modelPar_DW_dX;
bool modelPar_given_DW;
double modelPar_WETA;
double d_modelPar_WETA_dX;
bool modelPar_given_WETA;
double modelPar_LETA;
double d_modelPar_LETA_dX;
bool modelPar_given_LETA;
double modelPar_Q0;
double d_modelPar_Q0_dX;
bool modelPar_given_Q0;
double modelPar_LK;
double d_modelPar_LK_dX;
bool modelPar_given_LK;
double modelPar_IBA;
double d_modelPar_IBA_dX;
bool modelPar_given_IBA;
double modelPar_IBB;
double d_modelPar_IBB_dX;
bool modelPar_given_IBB;
double modelPar_IBBT;
double d_modelPar_IBBT_dX;
bool modelPar_given_IBBT;
double modelPar_IBN;
double d_modelPar_IBN_dX;
bool modelPar_given_IBN;
double modelPar_RSH;
double d_modelPar_RSH_dX;
bool modelPar_given_RSH;
double modelPar_HDIF;
double d_modelPar_HDIF_dX;
bool modelPar_given_HDIF;
double modelPar_AVTO;
double d_modelPar_AVTO_dX;
bool modelPar_given_AVTO;
double modelPar_AKP;
double d_modelPar_AKP_dX;
bool modelPar_given_AKP;
double modelPar_AGAMMA;
double d_modelPar_AGAMMA_dX;
bool modelPar_given_AGAMMA;
double modelPar_AF;
double d_modelPar_AF_dX;
bool modelPar_given_AF;
double modelPar_KF;
double d_modelPar_KF_dX;
bool modelPar_given_KF;
double modelPar_xd_n;
double d_modelPar_xd_n_dX;
bool modelPar_given_xd_n;
double modelPar_xd_js;
double d_modelPar_xd_js_dX;
bool modelPar_given_xd_js;
double modelPar_xd_jsw;
double d_modelPar_xd_jsw_dX;
bool modelPar_given_xd_jsw;
double modelPar_xd_jswg;
double d_modelPar_xd_jswg_dX;
bool modelPar_given_xd_jswg;
double modelPar_xd_mj;
double d_modelPar_xd_mj_dX;
bool modelPar_given_xd_mj;
double modelPar_xd_mjsw;
double d_modelPar_xd_mjsw_dX;
bool modelPar_given_xd_mjsw;
double modelPar_xd_mjswg;
double d_modelPar_xd_mjswg_dX;
bool modelPar_given_xd_mjswg;
double modelPar_xd_pb;
double d_modelPar_xd_pb_dX;
bool modelPar_given_xd_pb;
double modelPar_xd_pbsw;
double d_modelPar_xd_pbsw_dX;
bool modelPar_given_xd_pbsw;
double modelPar_xd_pbswg;
double d_modelPar_xd_pbswg_dX;
bool modelPar_given_xd_pbswg;
double modelPar_xd_cj;
double d_modelPar_xd_cj_dX;
bool modelPar_given_xd_cj;
double modelPar_xd_cjsw;
double d_modelPar_xd_cjsw_dX;
bool modelPar_given_xd_cjsw;
double modelPar_xd_cjswg;
double d_modelPar_xd_cjswg_dX;
bool modelPar_given_xd_cjswg;
double modelPar_xd_gmin;
double d_modelPar_xd_gmin_dX;
bool modelPar_given_xd_gmin;
double modelPar_xd_xjbv;
double d_modelPar_xd_xjbv_dX;
bool modelPar_given_xd_xjbv;
double modelPar_xd_bv;
double d_modelPar_xd_bv_dX;
bool modelPar_given_xd_bv;
double modelPar_xd_njts;
double d_modelPar_xd_njts_dX;
bool modelPar_given_xd_njts;
double modelPar_xd_njtssw;
double d_modelPar_xd_njtssw_dX;
bool modelPar_given_xd_njtssw;
double modelPar_xd_njtsswg;
double d_modelPar_xd_njtsswg_dX;
bool modelPar_given_xd_njtsswg;
double modelPar_xd_vts;
double d_modelPar_xd_vts_dX;
bool modelPar_given_xd_vts;
double modelPar_xd_vtssw;
double d_modelPar_xd_vtssw_dX;
bool modelPar_given_xd_vtssw;
double modelPar_xd_vtsswg;
double d_modelPar_xd_vtsswg_dX;
bool modelPar_given_xd_vtsswg;
double modelPar_tp_xti;
double d_modelPar_tp_xti_dX;
bool modelPar_given_tp_xti;
double modelPar_tp_cj;
double d_modelPar_tp_cj_dX;
bool modelPar_given_tp_cj;
double modelPar_tp_cjsw;
double d_modelPar_tp_cjsw_dX;
bool modelPar_given_tp_cjsw;
double modelPar_tp_cjswg;
double d_modelPar_tp_cjswg_dX;
bool modelPar_given_tp_cjswg;
double modelPar_tp_pb;
double d_modelPar_tp_pb_dX;
bool modelPar_given_tp_pb;
double modelPar_tp_pbsw;
double d_modelPar_tp_pbsw_dX;
bool modelPar_given_tp_pbsw;
double modelPar_tp_pbswg;
double d_modelPar_tp_pbswg_dX;
bool modelPar_given_tp_pbswg;
double modelPar_tp_njts;
double d_modelPar_tp_njts_dX;
bool modelPar_given_tp_njts;
double modelPar_tp_njtssw;
double d_modelPar_tp_njtssw_dX;
bool modelPar_given_tp_njtssw;
double modelPar_tp_njtsswg;
double d_modelPar_tp_njtsswg_dX;
bool modelPar_given_tp_njtsswg;
double modelPar_LMIN;
double d_modelPar_LMIN_dX;
bool modelPar_given_LMIN;
double modelPar_LMAX;
double d_modelPar_LMAX_dX;
bool modelPar_given_LMAX;
double modelPar_WMIN;
double d_modelPar_WMIN_dX;
bool modelPar_given_WMIN;
double modelPar_WMAX;
double d_modelPar_WMAX_dX;
bool modelPar_given_WMAX;
// non-reals (including hidden)
int modelPar_TYPE;
bool modelPar_given_TYPE;
int modelPar_Noise;
bool modelPar_given_Noise;
};



//-----------------------------------------------------------------------------
// Free functions used by sensitivity
//
//-----------------------------------------------------------------------------
void evaluateModelEquations(
std::vector <double> & probeVars,
// probe constants
const int admsProbeID_V_d_b,
const int admsProbeID_V_s_b,
const int admsProbeID_V_g_b,
// node constants
const int admsNodeID_d,
const int admsNodeID_g,
const int admsNodeID_s,
const int admsNodeID_b,
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
// basic variables
 double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, std::vector <double> & d_staticContributions_dX, std::vector <double> & d_dynamicContributions_dX, const Instance & theInstance);

void evaluateInitialInstance(
instanceSensStruct & instanceStruct,
modelSensStruct & modelStruct,
 double admsTemperature,double adms_vt_nom, double ADMSgmin_arg, const Instance & theInstance);

void evaluateInitialModel(
modelSensStruct & modelStruct,
 double admsTemperature, double ADMSgmin_arg, const Instance & theInstance);

#endif // Xyce_ADMS_SENSITIVITIES


// Limited exponential --- NOT what verilog LRM says, but what qucs,
// ng-spice, and zspice do.

template <typename T>
T limexp(const T &x)
{
  if ((x) < 80.0)
  return (exp(x));
  else
  return (exp(80.0)*(x-79.0));
}


struct Traits: public DeviceTraits<Model, Instance, MOSFET1::Traits>
{
  static const char *name() {return "EKV MOSFET version 2.6";}
  static const char *deviceTypeName() {return "M level 260";}

  static int numNodes() {return 4;}


  static bool modelRequired() {return true;}
  static bool isLinearDevice() {return false;}

  static Device *factory(const Configuration &configuration, const FactoryBlock &factory_block);
  static void loadModelParameters(ParametricData<Model> &model_parameters);
  static void loadInstanceParameters(ParametricData<Instance> &instance_parameters);
};

//-----------------------------------------------------------------------------
// Class         : Instance

//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Instance : public DeviceInstance
{
  friend class ParametricData<Instance>;
  friend class Model;
#ifdef Xyce_ADMS_SENSITIVITIES
  friend class InstanceSensitivity;
  friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
  friend struct Traits;

  public:
    Instance(
      const Configuration &       configuration,
      const InstanceBlock &       instance_block,
      Model &                     model,
      const FactoryBlock &        factory_block);

    ~Instance();

private:
    Instance(const Instance &);
    Instance &operator=(const Instance &);

public:
    void registerLIDs( const LocalIdVector & intLIDVecRef,
                       const LocalIdVector & extLIDVecRef );
    void registerStoreLIDs( const LocalIdVector & stoLIDVecRef );
    void setupPointers();

    void loadNodeSymbols(Util::SymbolTable &symbol_table) const;

    const JacobianStamp & jacobianStamp() const;
    void registerJacLIDs( const JacobianStamp & jacLIDVec );

    void registerBranchDataLIDs(const std::vector<int> & branchLIDVecRef);

    bool processParams();
    bool updateTemperature ( const double & temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

      int getNumNoiseSources () const;  // 2
      void setupNoiseSources (Xyce::Analysis::NoiseData & noiseData);
      void getNoiseSources (Xyce::Analysis::NoiseData & noiseData);

  private:

  public:
    // iterator reference to the ekv_va model which owns this instance.
    // Getters and setters
    Model &getModel()
    {
      return model_;
    }

  private:

    Model & model_;   //< Owning Model
    // Begin verilog Instance Variables
    //   Instance Parameters
    double L;
    double W;
    double M;
    double NS;
    double AS;
    double AD;
    double PS;
    double PD;
    //  Variables of global_instance scope
    // end verilog Instance Variables=====
    // Nodal LID Variables
    int li_d;
    int li_g;
    int li_s;
    int li_b;
    // end Nodal LID Variables
    // Branch LID Variables
    // end Branch LID Variables
    // Lead (branch) LID Variables
    int li_branch_id;
    int li_branch_ig;
    int li_branch_is;
    int li_branch_ib;
    // end Lead (branch) LID Variables
    // Jacobian  pointers
    double * f_d_Equ_s_Node_Ptr;
    double * f_d_Equ_b_Node_Ptr;
    double * f_s_Equ_s_Node_Ptr;
    double * f_s_Equ_b_Node_Ptr;
    double * f_d_Equ_d_Node_Ptr;
    double * f_s_Equ_d_Node_Ptr;
    double * f_d_Equ_g_Node_Ptr;
    double * f_s_Equ_g_Node_Ptr;
    double * f_b_Equ_g_Node_Ptr;
    double * f_b_Equ_b_Node_Ptr;
    double * f_b_Equ_s_Node_Ptr;
    double * f_b_Equ_d_Node_Ptr;
    double * f_g_Equ_g_Node_Ptr;
    double * f_g_Equ_b_Node_Ptr;
    double * f_g_Equ_s_Node_Ptr;
    double * f_g_Equ_d_Node_Ptr;
    double * q_d_Equ_s_Node_Ptr;
    double * q_d_Equ_b_Node_Ptr;
    double * q_s_Equ_s_Node_Ptr;
    double * q_s_Equ_b_Node_Ptr;
    double * q_d_Equ_d_Node_Ptr;
    double * q_s_Equ_d_Node_Ptr;
    double * q_d_Equ_g_Node_Ptr;
    double * q_s_Equ_g_Node_Ptr;
    double * q_b_Equ_g_Node_Ptr;
    double * q_b_Equ_b_Node_Ptr;
    double * q_b_Equ_s_Node_Ptr;
    double * q_b_Equ_d_Node_Ptr;
    double * q_g_Equ_g_Node_Ptr;
    double * q_g_Equ_b_Node_Ptr;
    double * q_g_Equ_s_Node_Ptr;
    double * q_g_Equ_d_Node_Ptr;
    // Jacobian offsets
    int A_d_Equ_s_NodeOffset;
    int A_d_Equ_b_NodeOffset;
    int A_s_Equ_s_NodeOffset;
    int A_s_Equ_b_NodeOffset;
    int A_d_Equ_d_NodeOffset;
    int A_s_Equ_d_NodeOffset;
    int A_d_Equ_g_NodeOffset;
    int A_s_Equ_g_NodeOffset;
    int A_b_Equ_g_NodeOffset;
    int A_b_Equ_b_NodeOffset;
    int A_b_Equ_s_NodeOffset;
    int A_b_Equ_d_NodeOffset;
    int A_g_Equ_g_NodeOffset;
    int A_g_Equ_b_NodeOffset;
    int A_g_Equ_s_NodeOffset;
    int A_g_Equ_d_NodeOffset;
    // end of Jacobian and pointers
   // node numbers
    static const int admsNodeID_d = 0;
    static const int admsNodeID_g = 1;
    static const int admsNodeID_s = 2;
    static const int admsNodeID_b = 3;
    static const int admsNodeID_GND = -1;
   // end node numbers
   // Additional IDs for branch equations
   // end branch numbers
   // Probe numbers
    static const int admsProbeID_V_d_b = 0;
    static const int admsProbeID_V_s_b = 1;
    static const int admsProbeID_V_g_b = 2;
   // end probe numbers
   // Store LIDs
   // end store LIDs
   // Store LIDs for output vars
   // end store LIDs for output vars
 // Arrays to hold probes
 std::vector < double > probeVars;
 std::vector < std::vector < double > > d_probeVars;
 // Arrays to hold contributions
 // dynamic contributions are differentiated w.r.t time
 std::vector < double > staticContributions;
 std::vector < std::vector < double > > d_staticContributions;
 std::vector < double > dynamicContributions;
 std::vector < std::vector < double > > d_dynamicContributions;
//vectors to hold noise information for communication between methods
std::vector<double> noiseContribsPower;
std::vector<double> noiseContribsExponent;


    // this is what we'll use when any model uses $temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at $temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;


    static JacobianStamp jacStamp;
    static IdVector nodeMap;
    static PairMap pairToJacStampMap;

    // These instance-owned vectors are for storage of lead current data
    std::vector<double> leadCurrentF;
    std::vector<double> leadCurrentQ;


    };


//-----------------------------------------------------------------------------
// Class         : Model

// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
class Model : public DeviceModel
{
    typedef std::vector<Instance *> InstanceVector;

    friend class ParametricData<Model>;
    friend class Instance;
#ifdef Xyce_ADMS_SENSITIVITIES
    friend class InstanceSensitivity;
    friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
    friend struct Traits;

  public:
    Model(
      const Configuration &       configuration,
      const ModelBlock &          model_block,
      const FactoryBlock &        factory_block);

    ~Model();

private:
    Model(const Model &);
    Model &operator=(const Model &);

public:
    virtual void forEachInstance(DeviceInstanceOp &op) const /* override */;
    virtual std::ostream &printOutInstances(std::ostream &os) const;
    bool processParams();
    bool processInstanceParams();

  private:

  public:
    void addInstance(Instance *instance)
    {
      instanceContainer.push_back(instance);
    }

    void setupBaseInstanceContainer()
    {
      std::vector<Instance*>::iterator iter = instanceContainer.begin();
      std::vector<Instance*>::iterator end   = instanceContainer.end();
      for ( ; iter!=end; ++iter)
      {
      Xyce::Device::DeviceModel::baseInstanceContainer.push_back( static_cast<Xyce::Device::DeviceInstance *>(*iter) );
    }
  }

  private:
    std::vector<Instance*> instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;
// Begin verilog Model Variables
//   Model Parameters
    int TYPE;
    int Noise;
    double Trise;
    double TEMP;
    double TNOM;
    double L;
    double W;
    double M;
    double NS;
    double AS;
    double AD;
    double PS;
    double PD;
    double COX;
    double XJ;
    double VTO;
    double TCV;
    double GAMMA;
    double PHI;
    double KP;
    double BEX;
    double THETA;
    double E0;
    double UCRIT;
    double UCEX;
    double LAMBDA;
    double DL;
    double DW;
    double WETA;
    double LETA;
    double Q0;
    double LK;
    double IBA;
    double IBB;
    double IBBT;
    double IBN;
    double RSH;
    double HDIF;
    double AVTO;
    double AKP;
    double AGAMMA;
    double AF;
    double KF;
    double xd_n;
    double xd_js;
    double xd_jsw;
    double xd_jswg;
    double xd_mj;
    double xd_mjsw;
    double xd_mjswg;
    double xd_pb;
    double xd_pbsw;
    double xd_pbswg;
    double xd_cj;
    double xd_cjsw;
    double xd_cjswg;
    double xd_gmin;
    double xd_xjbv;
    double xd_bv;
    double xd_njts;
    double xd_njtssw;
    double xd_njtsswg;
    double xd_vts;
    double xd_vtssw;
    double xd_vtsswg;
    double tp_xti;
    double tp_cj;
    double tp_cjsw;
    double tp_cjswg;
    double tp_pb;
    double tp_pbsw;
    double tp_pbswg;
    double tp_njts;
    double tp_njtssw;
    double tp_njtsswg;
    double LMIN;
    double LMAX;
    double WMIN;
    double WMAX;
    //  Variables of global_model scope
    // end verilog model variables=====
};

void registerDevice(const DeviceCountMap& deviceMap = DeviceCountMap(),
                    const std::set<int>& levelSet = std::set<int>());

} // namespace ADMSekv_va
} // namespace Device
} // namespace Xyce
#endif //Xyce_N_DEV_ADMSekv_va_h
