
//-------------------------------------------------------------------------
//   Copyright 2002-2020 National Technology & Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see <http://www.gnu.org/licenses/>.
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file mvs_2_0_0_hemt.va with ADMS
//                  interface for Xyce 6.12.0
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : admsXml-2.3.6
//
// Creation Date  : Thu, 26 Mar 2020 13:35:06
//
//-------------------------------------------------------------------------
// Shut up clang's warnings about extraneous parentheses
#ifdef __clang__
#  pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include <Xyce_config.h>
#include <N_DEV_ADMSmvs_2_0_0_hemt.h>


#include <N_DEV_Const.h>
#include <N_DEV_DeviceOptions.h>
#include <N_DEV_DeviceMaster.h>
#include <N_DEV_ExternData.h>
#include <N_DEV_SolverState.h>
#include <N_DEV_Message.h>

#include <N_LAS_Matrix.h>
#include <N_LAS_Vector.h>


#include <N_UTL_FeatureTest.h>
#if defined(HAVE_UNORDERED_MAP)
#include <unordered_map>
using std::unordered_map;
#elif defined(HAVE_TR1_UNORDERED_MAP)
#include <tr1/unordered_map>
using std::tr1::unordered_map;
#else
#error neither unordered_map or tr1/unordered_map found
#endif

#include <algorithm>

namespace Xyce {
namespace Device {
namespace ADMSmvs_2_0_0_hemt {
JacobianStamp Instance::jacStamp;
IdVector Instance::nodeMap;
PairMap Instance::pairToJacStampMap;


//This is necessary because the IntPair usage can trip undefined references
    const int Instance::admsNodeID_d;
    const int Instance::admsNodeID_g;
    const int Instance::admsNodeID_s;
    const int Instance::admsNodeID_di;
    const int Instance::admsNodeID_si;
    const int Instance::admsNodeID_sf;
     const int Instance::admsNodeID_GND;
   // Additional IDs for branch equations
    const int Instance::admsBRA_ID_sf_GND;


void
Traits::loadInstanceParameters(ParametricData<ADMSmvs_2_0_0_hemt::Instance> &p)
{
  // Set up each parameter directly, using the up-cased variable name
  // as the tag.

  // This kludge is to force us always to have an instance parameter
  // that the device manager can set to the temperature, even if we have
  // no "TEMP".
  p.addPar("XYCEADMSINSTTEMP", 0.0, &ADMSmvs_2_0_0_hemt::Instance::admsInstTemp)
    .setExpressionAccess(NO_DOC)
    .setUnit(U_DEGK)
    .setCategory(CAT_TEMP)
    .setDescription("Internal-use parameter for setting device instance temperature");


}

void Traits::loadModelParameters(ParametricData<ADMSmvs_2_0_0_hemt::Model> &p)
{
  // Set up each parameter directly, using the up-cased variable name
  // as the tag.

  // This kludge is to force us always to have a model parameter
  // that the device manager can set to the temperature, even if we have
  // no "TEMP".
  p.addPar("XYCEADMSMODTEMP", 0.0, &ADMSmvs_2_0_0_hemt::Model::admsModTemp)
    .setExpressionAccess(NO_DOC)
    .setUnit(U_DEGK)
    .setCategory(CAT_TEMP)
    .setDescription("Internal-use parameter for setting device model temperature");
  p.addPar("VERSION", static_cast<double>(2.00), &ADMSmvs_2_0_0_hemt::Model::version)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("TYPE", static_cast<int>(1), &ADMSmvs_2_0_0_hemt::Model::type);
  p.addPar("W", static_cast<double>(1.0e-6), &ADMSmvs_2_0_0_hemt::Model::W)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("LGDR", static_cast<double>(80.0e-9), &ADMSmvs_2_0_0_hemt::Model::Lgdr)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("DLG", static_cast<double>(10.5e-9), &ADMSmvs_2_0_0_hemt::Model::dLg)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("CINS", static_cast<double>(3.17e-2), &ADMSmvs_2_0_0_hemt::Model::Cins)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("TJUN", static_cast<double>(300.0), &ADMSmvs_2_0_0_hemt::Model::Tjun)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("ENERGY_DIFF_VOLT", static_cast<double>(0.153), &ADMSmvs_2_0_0_hemt::Model::energy_diff_volt)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("DELTA", static_cast<double>(0.120), &ADMSmvs_2_0_0_hemt::Model::delta)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("N0", static_cast<double>(1.35), &ADMSmvs_2_0_0_hemt::Model::n0)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("RC0", static_cast<double>(160.0e-6), &ADMSmvs_2_0_0_hemt::Model::Rc0)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("NACC", static_cast<double>(2.25e16), &ADMSmvs_2_0_0_hemt::Model::nacc)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("MEFF", static_cast<double>(0.041), &ADMSmvs_2_0_0_hemt::Model::meff)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("NP_MASS", static_cast<double>(9.0), &ADMSmvs_2_0_0_hemt::Model::np_mass)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("MU_EFF", static_cast<double>(1.0), &ADMSmvs_2_0_0_hemt::Model::mu_eff)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("KSEE", static_cast<double>(0.1), &ADMSmvs_2_0_0_hemt::Model::ksee)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("B", static_cast<double>(6.8e-9), &ADMSmvs_2_0_0_hemt::Model::B)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("DQM0", static_cast<double>(4.6e-9), &ADMSmvs_2_0_0_hemt::Model::dqm0)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("EPS", static_cast<double>(13.6), &ADMSmvs_2_0_0_hemt::Model::eps)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("THETA", static_cast<double>(2.5), &ADMSmvs_2_0_0_hemt::Model::theta)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("BETA", static_cast<double>(1.55), &ADMSmvs_2_0_0_hemt::Model::beta)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;
  p.addPar("ND", static_cast<double>(0.0), &ADMSmvs_2_0_0_hemt::Model::nd)
#ifdef Xyce_ADMS_SENSITIVITIES
    .setAnalyticSensitivityAvailable(true)
    .setSensitivityFunctor(&modSens)
#endif // Xyce_ADMS_SENSITIVITIES
;

}

//-----------------------------------------------------------------------------
// Function      : Instance::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::processParams()
{
  // set any non-constant parameter defaults

  // copy any model variables that have associated instance variables, but
  // are only given in the model card:



  // Set any parameters that were not given and whose defaults depend on other
  // parameters:


// Now we need to check that any parameters are within their ranges as
  // specified in the verilog:


  // this seems a little stupid, but verilog models that use $temperature
  // don't also use a defined parameter "Temp", and count on $temperature
  // to be the one the simulator wants:

  updateTemperature(admsInstTemp);

  // and of course, this routine is where we should put the initial_instance
  // stuff


  return true;
}

//-----------------------------------------------------------------------------
// Function      : Instance::Instance
// Purpose       : "instance block" constructor
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------

Instance::Instance(
  const Configuration & configuration,
  const InstanceBlock & instance_block,
  Model &               model,
  const FactoryBlock &  factory_block)
  : DeviceInstance(instance_block, configuration.getInstanceParameters(), factory_block),
    model_(model),
    li_d(-1),
    li_g(-1),
    li_s(-1),
    li_di(-1),
    li_si(-1),
    li_sf(-1),
    li_BRA_sf_GND(-1),
    li_branch_id(-1),
    li_branch_ig(-1),
    li_branch_is(-1),
    f_di_Equ_si_Node_Ptr(0),
    f_si_Equ_si_Node_Ptr(0),
    f_di_Equ_di_Node_Ptr(0),
    f_si_Equ_di_Node_Ptr(0),
    f_di_Equ_sf_Node_Ptr(0),
    f_si_Equ_sf_Node_Ptr(0),
    f_d_Equ_si_Node_Ptr(0),
    f_d_Equ_sf_Node_Ptr(0),
    f_d_Equ_di_Node_Ptr(0),
    f_d_Equ_d_Node_Ptr(0),
    f_di_Equ_d_Node_Ptr(0),
    f_s_Equ_di_Node_Ptr(0),
    f_s_Equ_sf_Node_Ptr(0),
    f_si_Equ_s_Node_Ptr(0),
    f_s_Equ_s_Node_Ptr(0),
    f_s_Equ_si_Node_Ptr(0),
    f_sf_Equ_BRA_sf_GND_Var_Ptr(0),
    f_BRA_sf_GND_Equ_sf_Node_Ptr(0),
    f_BRA_sf_GND_Equ_si_Node_Ptr(0),
    f_BRA_sf_GND_Equ_g_Node_Ptr(0),
    f_BRA_sf_GND_Equ_di_Node_Ptr(0),
    q_di_Equ_si_Node_Ptr(0),
    q_si_Equ_si_Node_Ptr(0),
    q_di_Equ_di_Node_Ptr(0),
    q_si_Equ_di_Node_Ptr(0),
    q_di_Equ_sf_Node_Ptr(0),
    q_si_Equ_sf_Node_Ptr(0),
    q_d_Equ_si_Node_Ptr(0),
    q_d_Equ_sf_Node_Ptr(0),
    q_d_Equ_di_Node_Ptr(0),
    q_d_Equ_d_Node_Ptr(0),
    q_di_Equ_d_Node_Ptr(0),
    q_s_Equ_di_Node_Ptr(0),
    q_s_Equ_sf_Node_Ptr(0),
    q_si_Equ_s_Node_Ptr(0),
    q_s_Equ_s_Node_Ptr(0),
    q_s_Equ_si_Node_Ptr(0),
    q_sf_Equ_BRA_sf_GND_Var_Ptr(0),
    q_BRA_sf_GND_Equ_sf_Node_Ptr(0),
    q_BRA_sf_GND_Equ_si_Node_Ptr(0),
    q_BRA_sf_GND_Equ_g_Node_Ptr(0),
    q_BRA_sf_GND_Equ_di_Node_Ptr(0),
    A_di_Equ_si_NodeOffset(-1),
    A_si_Equ_si_NodeOffset(-1),
    A_di_Equ_di_NodeOffset(-1),
    A_si_Equ_di_NodeOffset(-1),
    A_di_Equ_sf_NodeOffset(-1),
    A_si_Equ_sf_NodeOffset(-1),
    A_d_Equ_si_NodeOffset(-1),
    A_d_Equ_sf_NodeOffset(-1),
    A_d_Equ_di_NodeOffset(-1),
    A_d_Equ_d_NodeOffset(-1),
    A_di_Equ_d_NodeOffset(-1),
    A_s_Equ_di_NodeOffset(-1),
    A_s_Equ_sf_NodeOffset(-1),
    A_si_Equ_s_NodeOffset(-1),
    A_s_Equ_s_NodeOffset(-1),
    A_s_Equ_si_NodeOffset(-1),
    A_sf_Equ_BRA_sf_GND_Var_Offset(-1),
    A_BRA_sf_GND_Equ_sf_Node_Offset(-1),
    A_BRA_sf_GND_Equ_si_Node_Offset(-1),
    A_BRA_sf_GND_Equ_g_Node_Offset(-1),
    A_BRA_sf_GND_Equ_di_Node_Offset(-1),
    admsTemperature(getDeviceOptions().temp.getImmutableValue<double>())

{
    numIntVars = 3 + 1;
    numExtVars = 3;


  // Right now, we only have store for limited probes...
  setNumStoreVars(0);

  // Do not allocate "branch" (lead current) vectors by default
  setNumBranchDataVars(0);
  numBranchDataVarsIfAllocated = 3;

  leadCurrentF.resize(3);
  leadCurrentQ.resize(3);

  // Set up jacobian stamp:
  // Create a vector of the non-zero elements of the stamp
PairVector jacobianElements;
    jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_si));
    jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_sf));
    jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_di));
    jacobianElements.push_back(IntPair(admsNodeID_d,admsNodeID_d));
    jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_di));
    jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_sf));
    jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_s));
    jacobianElements.push_back(IntPair(admsNodeID_s,admsNodeID_si));
    jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_si));
    jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_di));
    jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_sf));
    jacobianElements.push_back(IntPair(admsNodeID_di,admsNodeID_d));
    jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_si));
    jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_di));
    jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_sf));
    jacobianElements.push_back(IntPair(admsNodeID_si,admsNodeID_s));
    // Extra columns for dependence on branches
    jacobianElements.push_back(IntPair(admsNodeID_sf,admsBRA_ID_sf_GND));
    // Jacobian rows for branch equations
jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_sf));   // Branch eqn sf,GND - node sf
jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_si));   // Branch eqn sf,GND - node si
jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_g));   // Branch eqn sf,GND - node g
jacobianElements.push_back(IntPair(admsBRA_ID_sf_GND,admsNodeID_di));   // Branch eqn sf,GND - node di



  setDefaultParams();
  setParams(instance_block.params);

  // Real bogosity here...
  if (!given("XYCEADMSINSTTEMP"))
    admsInstTemp=getDeviceOptions().temp.getImmutableValue<double>();

  //calculate any parameters specified as expressions
  updateDependentParameters();

  // calculate dependent (i.e. computed params) and check for errors.
  processParams();

  PairVector collapsedNodes;

// Now generate the jacstamp from what we already have.
// This jacstamp will have all the correct node mapping.  map will be the nodal mapping of original
// node IDs to row/column ids in the reduced (non-sparse) representation of the jacobian.
// (for devices that have no collapsibles, this will be static, so check that it hasn't already
// been filled in)
if (jacStamp.empty())
{
int originalSize = 6+1;
computeJacStampAndMaps(jacobianElements,collapsedNodes,jacStamp,nodeMap,pairToJacStampMap,originalSize);
}

}

//-----------------------------------------------------------------------------
// Function      : Instance::~Instance
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
Instance::~Instance()
{
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerLIDs
// Purpose       : function for registering, and setting up, local ID's.
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::registerLIDs( const LocalIdVector & intLIDVecRef,
                             const LocalIdVector & extLIDVecRef)
{
  AssertLIDs(intLIDVecRef.size() == numIntVars);
  AssertLIDs(extLIDVecRef.size() == numExtVars);

  LocalIdVector localLIDVec;

  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS))
  {
    Xyce::dout() << std::endl << section_divider << std::endl
                 << "In ADMSmvs_2_0_0_hemt::Instance::register LIDs\n\n"
                 << "name             = " << getName() << std::endl
                 << "number of internal variables: " << numIntVars << std::endl
                 << "number of external variables: " << numExtVars << std::endl;
  }

  // copy over the global ID lists into a local array.
  // The end result of this is an array of LIDs corresponding to all the
  // nodes we actually have, in the order that topology thinks of them
  intLIDVec = intLIDVecRef;
  extLIDVec = extLIDVecRef;
  localLIDVec.resize(numExtVars+numIntVars);
  for (int localNodeIndex=0;localNodeIndex<numExtVars;++localNodeIndex)
  {
    localLIDVec[localNodeIndex]=extLIDVec[localNodeIndex];
  }
  for (int localNodeIndex=numExtVars;localNodeIndex<numExtVars+numIntVars;++localNodeIndex)
  {
    localLIDVec[localNodeIndex]=intLIDVec[localNodeIndex-numExtVars];
    }

  // Now pull the LIDs for each of our nodes out of the local array.
  // Use the node mapping created by createJacStampAndMaps to handle
  // all the node collapse complications.
  li_d = localLIDVec[nodeMap[admsNodeID_d]];
  li_g = localLIDVec[nodeMap[admsNodeID_g]];
  li_s = localLIDVec[nodeMap[admsNodeID_s]];
  li_di = localLIDVec[nodeMap[admsNodeID_di]];
  li_si = localLIDVec[nodeMap[admsNodeID_si]];
  li_sf = localLIDVec[nodeMap[admsNodeID_sf]];
  li_BRA_sf_GND = localLIDVec[nodeMap[admsBRA_ID_sf_GND]];


  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS))
  {
    Xyce::dout() << "\nSolution and RHS variables:\n";
      Xyce::dout() << "\nli_d = " << li_d << std::endl;
      Xyce::dout() << "\nli_g = " << li_g << std::endl;
      Xyce::dout() << "\nli_s = " << li_s << std::endl;
      Xyce::dout() << "\nli_di = " << li_di << std::endl;
      Xyce::dout() << "\nli_si = " << li_si << std::endl;
      Xyce::dout() << "\nli_sf = " << li_sf << std::endl;
      Xyce::dout() << "\nli_BRA_sf_GND = " << li_BRA_sf_GND << std::endl;

    Xyce::dout() << "\nEnd of ADMSmvs_2_0_0_hemt::Instance::register LIDs\n";
    Xyce::dout() << section_divider << std::endl;
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadNodeSymbols
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::loadNodeSymbols(Util::SymbolTable &symbol_table) const
{
    addInternalNode(symbol_table, li_di, getName(), "di");
    addInternalNode(symbol_table, li_si, getName(), "si");
    addInternalNode(symbol_table, li_sf, getName(), "sf");
    addInternalNode(symbol_table, li_BRA_sf_GND, getName(), "sf_GND_branch");

  if (loadLeadCurrent)
  {
              addBranchDataNode( symbol_table, li_branch_id, getName(), "BRANCH_DD");
              addBranchDataNode( symbol_table, li_branch_ig, getName(), "BRANCH_DG");
              addBranchDataNode( symbol_table, li_branch_is, getName(), "BRANCH_DS");
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerStoreLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::registerStoreLIDs( const LocalIdVector & stoLIDVecRef)
{
  AssertLIDs(stoLIDVecRef.size() == getNumStoreVars());
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerBranchDataLIDs
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : Eric Keiter, SNL
// Creation Date : 12/09/11
//-----------------------------------------------------------------------------
void Instance::registerBranchDataLIDs(const std::vector<int> & branchLIDVecRef)
{
  AssertLIDs(branchLIDVecRef.size() == getNumBranchDataVars());

  if (loadLeadCurrent)
  {
        int i = 0;
          li_branch_id = branchLIDVecRef[i++];
          li_branch_ig = branchLIDVecRef[i++];
          li_branch_is = branchLIDVecRef[i++];
  }
}

//-----------------------------------------------------------------------------
// Function      : Instance::jacobianStamp
// Purpose       :
// Special Notes : In initial version, we won't support mapping away nodes
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
const JacobianStamp & Instance::jacobianStamp() const
{
    return jacStamp;
}

//-----------------------------------------------------------------------------
// Function      : Instance::registerJacLIDs
// Purpose       : Create Offset variables used for referencing jacobian
//                 elements
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::registerJacLIDs( const JacobianStamp & jacLIDVec)
{
  DeviceInstance::registerJacLIDs(jacLIDVec);  IntPair jacLoc;
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_si)];
    A_d_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_sf)];
    A_d_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_di)];
    A_d_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_d,admsNodeID_d)];
    A_d_Equ_d_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_di)];
    A_s_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_sf)];
    A_s_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_s)];
    A_s_Equ_s_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_s,admsNodeID_si)];
    A_s_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_si)];
    A_di_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_di)];
    A_di_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_sf)];
    A_di_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_di,admsNodeID_d)];
    A_di_Equ_d_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_si)];
    A_si_Equ_si_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_di)];
    A_si_Equ_di_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_sf)];
    A_si_Equ_sf_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsNodeID_si,admsNodeID_s)];
    A_si_Equ_s_NodeOffset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc=pairToJacStampMap[IntPair(admsNodeID_sf,admsBRA_ID_sf_GND)];
    A_sf_Equ_BRA_sf_GND_Var_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_sf)];
    A_BRA_sf_GND_Equ_sf_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_si)];
    A_BRA_sf_GND_Equ_si_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_g)];
    A_BRA_sf_GND_Equ_g_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];
    jacLoc = pairToJacStampMap[IntPair(admsBRA_ID_sf_GND,admsNodeID_di)];
    A_BRA_sf_GND_Equ_di_Node_Offset = jacLIDVec[jacLoc.first][jacLoc.second];


}

//-----------------------------------------------------------------------------
// Function      : Instance::setupPointers
// Purpose       : Create pointer variables used for referencing jacobian
//                 elements
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void Instance::setupPointers( )
{

  Linear::Matrix & dFdx = *(extData.dFdxMatrixPtr);
  Linear::Matrix & dQdx = *(extData.dQdxMatrixPtr);
    f_d_Equ_si_Node_Ptr = &(dFdx[li_d][A_d_Equ_si_NodeOffset]);
    q_d_Equ_si_Node_Ptr = &(dQdx[li_d][A_d_Equ_si_NodeOffset]);
    f_d_Equ_sf_Node_Ptr = &(dFdx[li_d][A_d_Equ_sf_NodeOffset]);
    q_d_Equ_sf_Node_Ptr = &(dQdx[li_d][A_d_Equ_sf_NodeOffset]);
    f_d_Equ_di_Node_Ptr = &(dFdx[li_d][A_d_Equ_di_NodeOffset]);
    q_d_Equ_di_Node_Ptr = &(dQdx[li_d][A_d_Equ_di_NodeOffset]);
    f_d_Equ_d_Node_Ptr = &(dFdx[li_d][A_d_Equ_d_NodeOffset]);
    q_d_Equ_d_Node_Ptr = &(dQdx[li_d][A_d_Equ_d_NodeOffset]);
    f_s_Equ_di_Node_Ptr = &(dFdx[li_s][A_s_Equ_di_NodeOffset]);
    q_s_Equ_di_Node_Ptr = &(dQdx[li_s][A_s_Equ_di_NodeOffset]);
    f_s_Equ_sf_Node_Ptr = &(dFdx[li_s][A_s_Equ_sf_NodeOffset]);
    q_s_Equ_sf_Node_Ptr = &(dQdx[li_s][A_s_Equ_sf_NodeOffset]);
    f_s_Equ_s_Node_Ptr = &(dFdx[li_s][A_s_Equ_s_NodeOffset]);
    q_s_Equ_s_Node_Ptr = &(dQdx[li_s][A_s_Equ_s_NodeOffset]);
    f_s_Equ_si_Node_Ptr = &(dFdx[li_s][A_s_Equ_si_NodeOffset]);
    q_s_Equ_si_Node_Ptr = &(dQdx[li_s][A_s_Equ_si_NodeOffset]);
    f_di_Equ_si_Node_Ptr = &(dFdx[li_di][A_di_Equ_si_NodeOffset]);
    q_di_Equ_si_Node_Ptr = &(dQdx[li_di][A_di_Equ_si_NodeOffset]);
    f_di_Equ_di_Node_Ptr = &(dFdx[li_di][A_di_Equ_di_NodeOffset]);
    q_di_Equ_di_Node_Ptr = &(dQdx[li_di][A_di_Equ_di_NodeOffset]);
    f_di_Equ_sf_Node_Ptr = &(dFdx[li_di][A_di_Equ_sf_NodeOffset]);
    q_di_Equ_sf_Node_Ptr = &(dQdx[li_di][A_di_Equ_sf_NodeOffset]);
    f_di_Equ_d_Node_Ptr = &(dFdx[li_di][A_di_Equ_d_NodeOffset]);
    q_di_Equ_d_Node_Ptr = &(dQdx[li_di][A_di_Equ_d_NodeOffset]);
    f_si_Equ_si_Node_Ptr = &(dFdx[li_si][A_si_Equ_si_NodeOffset]);
    q_si_Equ_si_Node_Ptr = &(dQdx[li_si][A_si_Equ_si_NodeOffset]);
    f_si_Equ_di_Node_Ptr = &(dFdx[li_si][A_si_Equ_di_NodeOffset]);
    q_si_Equ_di_Node_Ptr = &(dQdx[li_si][A_si_Equ_di_NodeOffset]);
    f_si_Equ_sf_Node_Ptr = &(dFdx[li_si][A_si_Equ_sf_NodeOffset]);
    q_si_Equ_sf_Node_Ptr = &(dQdx[li_si][A_si_Equ_sf_NodeOffset]);
    f_si_Equ_s_Node_Ptr = &(dFdx[li_si][A_si_Equ_s_NodeOffset]);
    q_si_Equ_s_Node_Ptr = &(dQdx[li_si][A_si_Equ_s_NodeOffset]);
    f_sf_Equ_BRA_sf_GND_Var_Ptr = &(dFdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset]);
    q_sf_Equ_BRA_sf_GND_Var_Ptr = &(dQdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset]);
    f_BRA_sf_GND_Equ_sf_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_sf_Node_Offset]);
    q_BRA_sf_GND_Equ_sf_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_sf_Node_Offset]);
    f_BRA_sf_GND_Equ_si_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_si_Node_Offset]);
    q_BRA_sf_GND_Equ_si_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_si_Node_Offset]);
    f_BRA_sf_GND_Equ_g_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_g_Node_Offset]);
    q_BRA_sf_GND_Equ_g_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_g_Node_Offset]);
    f_BRA_sf_GND_Equ_di_Node_Ptr = &(dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_di_Node_Offset]);
    q_BRA_sf_GND_Equ_di_Node_Ptr =  &(dQdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_di_Node_Offset]);


}

// RHS load functions

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEFVector
// Purpose       : load F vector (static contributions) for one instance for
//                 NEW DAE formulation
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEFVector()
{

  bool bsuccess=true;
(*extData.daeFVectorPtr)[li_d] += staticContributions[admsNodeID_d];
(*extData.daeFVectorPtr)[li_g] += staticContributions[admsNodeID_g];
(*extData.daeFVectorPtr)[li_s] += staticContributions[admsNodeID_s];
(*extData.daeFVectorPtr)[li_di] += staticContributions[admsNodeID_di];
(*extData.daeFVectorPtr)[li_si] += staticContributions[admsNodeID_si];
(*extData.daeFVectorPtr)[li_sf] += staticContributions[admsNodeID_sf];

    (*extData.daeFVectorPtr)[li_BRA_sf_GND] += staticContributions[admsBRA_ID_sf_GND];

  if (loadLeadCurrent)
  {
    double * leadF = extData.nextLeadCurrFCompRawPtr;

          leadF[li_branch_id] = leadCurrentF[admsNodeID_d];
          leadF[li_branch_ig] = leadCurrentF[admsNodeID_g];
          leadF[li_branch_is] = leadCurrentF[admsNodeID_s];

    // here we have to do special things for BJTs, MOSFETs and 2-terminal
    // devices for power computation.

        double * solVec = extData.nextSolVectorRawPtr;
        double * junctionV = extData.nextJunctionVCompRawPtr;
        junctionV[li_branch_id] = solVec[li_d] - solVec[li_s];
        junctionV[li_branch_ig] = solVec[li_g] - solVec[li_s];

  }
  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEQVector
// Purpose       : load Q vector (dynamic contributions) for one instance for
//                 NEW DAE formulation
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEQVector()
{
(*extData.daeQVectorPtr)[li_d] += dynamicContributions[admsNodeID_d];
(*extData.daeQVectorPtr)[li_g] += dynamicContributions[admsNodeID_g];
(*extData.daeQVectorPtr)[li_s] += dynamicContributions[admsNodeID_s];
(*extData.daeQVectorPtr)[li_di] += dynamicContributions[admsNodeID_di];
(*extData.daeQVectorPtr)[li_si] += dynamicContributions[admsNodeID_si];
(*extData.daeQVectorPtr)[li_sf] += dynamicContributions[admsNodeID_sf];

    (*extData.daeQVectorPtr)[li_BRA_sf_GND] += dynamicContributions[admsBRA_ID_sf_GND];

  if (loadLeadCurrent)
  {
    double * leadQ = extData.nextLeadCurrQCompRawPtr;

          leadQ[li_branch_id] = leadCurrentQ[admsNodeID_d];
          leadQ[li_branch_ig] = leadCurrentQ[admsNodeID_g];
          leadQ[li_branch_is] = leadCurrentQ[admsNodeID_s];
  }
  return true;
}


//-----------------------------------------------------------------------------
// Function      : Instance::updatePrimaryState
// Purpose       :
// Special Notes : In this initial implementation, does little more than
//                 call updateIntermediateVars()
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updatePrimaryState()
{
  bool bsuccess = true;

  bsuccess = updateIntermediateVars();

  // if old DAE were implemented, we'd save dynamic contributions as state
  // here.


  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateSecondaryState
// Purpose       :
// Special Notes : In this initial implementation, does nothing
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updateSecondaryState()
{
  bool bsuccess = true;

  // were old DAE implemented, we'd pull dynamic contribution derivatives
  // out of state.

  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateIntermediateVars
// Purpose       : update intermediate variables for one mvs_2_0_0_hemt instance
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updateIntermediateVars()
{

  bool bsuccess=true;
  Linear::Vector * solVectorPtr = extData.nextSolVectorPtr;

  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS) && getSolverState().debugTimeFlag)
  {
    Xyce::dout() << std::endl << subsection_divider << std::endl;
    Xyce::dout() << "  In ADMSmvs_2_0_0_hemt::Instance::updateIntermediateVars\n\n";
    Xyce::dout() << "  name = " << getName() << std::endl;
  }

  // Local variables
  double Rd;
     double d_Rd_dV_sf_GND;
     double d_Rd_dV_di_GND;
     double d_Rd_dV_si_GND;
  double Rs;
     double d_Rs_dV_sf_GND;
     double d_Rs_dV_di_GND;
     double d_Rs_dV_si_GND;
  double Idsatbeta;
     double d_Idsatbeta_dV_sf_GND;
     double d_Idsatbeta_dV_di_GND;
     double d_Idsatbeta_dV_si_GND;
  double Id_sat;
  double Qacc;
  double Id;
     double d_Id_dV_sf_GND;
     double d_Id_dV_di_GND;
     double d_Id_dV_si_GND;
  double vx0;
     double d_vx0_dV_sf_GND;
  double Fsat;
     double d_Fsat_dV_di_GND;
     double d_Fsat_dV_si_GND;
     double d_Fsat_dV_sf_GND;
  double Vdsatbeta;
     double d_Vdsatbeta_dV_di_GND;
     double d_Vdsatbeta_dV_si_GND;
     double d_Vdsatbeta_dV_sf_GND;
  double Vdsat;
     double d_Vdsat_dV_sf_GND;
     double d_Vdsat_dV_di_GND;
     double d_Vdsat_dV_si_GND;
  double f1;
     double d_f1_dV_sf_GND;
     double d_f1_dV_di_GND;
     double d_f1_dV_si_GND;
  double n;
     double d_n_dV_di_GND;
     double d_n_dV_si_GND;
  double Cgc;
     double d_Cgc_dV_sf_GND;
     double d_Cgc_dV_di_GND;
     double d_Cgc_dV_si_GND;
  double Cstern;
     double d_Cstern_dV_sf_GND;
     double d_Cstern_dV_di_GND;
     double d_Cstern_dV_si_GND;
  double xav;
     double d_xav_dV_sf_GND;
     double d_xav_dV_di_GND;
     double d_xav_dV_si_GND;
  double QB;
  double Qx0;
     double d_Qx0_dV_sf_GND;
     double d_Qx0_dV_di_GND;
     double d_Qx0_dV_si_GND;
  double Tx;
     double d_Tx_dV_sf_GND;
     double d_Tx_dV_di_GND;
     double d_Tx_dV_si_GND;
  double Lcrit;
     double d_Lcrit_dV_di_GND;
     double d_Lcrit_dV_si_GND;
  double Lcrit_sat;
  double Lcrit_lin;
  double f2;
     double d_f2_dV_di_GND;
     double d_f2_dV_si_GND;
  double Vdsatbeta2;
     double d_Vdsatbeta2_dV_di_GND;
     double d_Vdsatbeta2_dV_si_GND;
  double Vdsat2;
  double vT_acc;
  double extr_coef_acc;
  double FDhalfs_acc;
  double c1_acc;
  double den1_acc;
  double A1_acc;
  double expMeta_acc;
  double expu_acc;
  double exp_eta_acc;
  double eta_acc;
  double vT;
     double d_vT_dV_sf_GND;
  double lambda;
     double d_lambda_dV_sf_GND;
  double dgen_lambda;
     double d_dgen_lambda_dV_sf_GND;
  double FDminushalfs;
     double d_FDminushalfs_dV_sf_GND;
  double t2_fd1;
     double d_t2_fd1_dV_sf_GND;
  double den_t1_fd1;
     double d_den_t1_fd1_dV_sf_GND;
  double aterm1;
     double d_aterm1_dV_sf_GND;
  double num_t1_fd1;
  double c_pow1;
  double b_pow1;
  double a_pow1;
  double j_pow1;
  double u1;
     double d_u1_dV_sf_GND;
  double extr_coef;
     double d_extr_coef_dV_sf_GND;
  double FDhalfs;
     double d_FDhalfs_dV_sf_GND;
  double c1;
     double d_c1_dV_sf_GND;
  double den1;
     double d_den1_dV_sf_GND;
  double A1;
     double d_A1_dV_sf_GND;
  double expMeta;
     double d_expMeta_dV_sf_GND;
  double NP_fac_velocity;
     double d_NP_fac_velocity_dV_sf_GND;
  double NP_fac_lambda;
     double d_NP_fac_lambda_dV_sf_GND;
  double meff_np;
     double d_meff_np_dV_sf_GND;
  double Fd;
     double d_Fd_dV_sf_GND;
     double d_Fd_dV_di_GND;
     double d_Fd_dV_si_GND;
  double Ed_sq;
     double d_Ed_sq_dV_sf_GND;
     double d_Ed_sq_dV_di_GND;
     double d_Ed_sq_dV_si_GND;
  double ffd;
     double d_ffd_dV_sf_GND;
     double d_ffd_dV_di_GND;
     double d_ffd_dV_si_GND;
  double expEd;
     double d_expEd_dV_sf_GND;
     double d_expEd_dV_di_GND;
     double d_expEd_dV_si_GND;
  double sign_Ed;
  double Ed;
     double d_Ed_dV_sf_GND;
     double d_Ed_dV_di_GND;
     double d_Ed_dV_si_GND;
  double Fs;
     double d_Fs_dV_sf_GND;
  double Es_sq;
     double d_Es_sq_dV_sf_GND;
  double ffs;
     double d_ffs_dV_sf_GND;
  double expEs;
     double d_expEs_dV_sf_GND;
  double sign_Es;
  double Es;
     double d_Es_dV_sf_GND;
  double N2D;
  double lambda_int;
  double vT_int;
  double mD0;
  double sqrt_pi;
  double hbar;
  double kT;
  double phit;
  double Rc;
  double Leff;
  double dir;
  double Vgsi;
     double d_Vgsi_dV_di_GND;
     double d_Vgsi_dV_g_GND;
     double d_Vgsi_dV_si_GND;
  double Vdsi;
     double d_Vdsi_dV_di_GND;
     double d_Vdsi_dV_si_GND;
  double Vgs;
  double Vds;
  double Vgdraw;
     double d_Vgdraw_dV_g_GND;
     double d_Vgdraw_dV_di_GND;
  double Vgsraw;
     double d_Vgsraw_dV_g_GND;
     double d_Vgsraw_dV_si_GND;


  // set the sizes of the Fad arrays:

  if (probeVars.size() != (7))
  {
    probeVars.resize(7);
    d_probeVars.resize(7);
    for (int i=0;i<7;i++)
    {
      d_probeVars[i].resize(7);
      for (int j=0;j<7;j++)
        d_probeVars[i][j]=0.0;
    }
    staticContributions.resize(6+1);
    d_staticContributions.resize(6+1);
    for (int i=0;i<6+1;i++)
      d_staticContributions[i].resize(7);
    dynamicContributions.resize(6+1);
    d_dynamicContributions.resize(6+1);
    for (int i=0;i<6+1;i++)
      d_dynamicContributions[i].resize(7);
  }


  // initialize contributions to zero (automatically sets derivatives to zero)
  for (int i=0; i < 6+1 ; ++i)
  {
     staticContributions[i]=0;
     for (int j=0;j<7;j++)
        d_staticContributions[i][j] = 0.0;
     dynamicContributions[i]=0;
     for (int j=0;j<7;j++)
        d_dynamicContributions[i][j] = 0.0;
  }

  // extract solution variables and set as Fad independent variables.
probeVars[admsProbeID_V_sf_GND] = (*solVectorPtr)[li_sf];
d_probeVars[admsProbeID_V_sf_GND][admsProbeID_V_sf_GND] = 1.0;
probeVars[admsProbeID_V_s_GND] = (*solVectorPtr)[li_s];
d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND] = 1.0;
probeVars[admsProbeID_V_d_GND] = (*solVectorPtr)[li_d];
d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND] = 1.0;
probeVars[admsProbeID_V_di_GND] = (*solVectorPtr)[li_di];
d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND] = 1.0;
probeVars[admsProbeID_V_si_GND] = (*solVectorPtr)[li_si];
d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND] = 1.0;
probeVars[admsProbeID_V_g_GND] = (*solVectorPtr)[li_g];
d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND] = 1.0;
probeVars[admsProbeID_I_sf_GND] = (*solVectorPtr)[li_BRA_sf_GND];
d_probeVars[admsProbeID_I_sf_GND][admsProbeID_I_sf_GND] = 1.0;
// -- code converted from analog/code block

d_Vgsraw_dV_si_GND = (model_.type)*(-d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]);
d_Vgsraw_dV_g_GND = (model_.type)*d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND];
Vgsraw = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_si_GND])));

d_Vgdraw_dV_di_GND = (model_.type)*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND]);
d_Vgdraw_dV_g_GND = (model_.type)*d_probeVars[admsProbeID_V_g_GND][admsProbeID_V_g_GND];
Vgdraw = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_di_GND])));
if ((Vgsraw>=Vgdraw))
{
Vds = ((model_.type)*((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_s_GND])));
Vgs = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_s_GND])));

d_Vdsi_dV_si_GND = (model_.type)*(-d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]);
d_Vdsi_dV_di_GND = (model_.type)*d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND];
Vdsi = ((model_.type)*((probeVars[admsProbeID_V_di_GND])-(probeVars[admsProbeID_V_si_GND])));

d_Vgsi_dV_di_GND =  0.0;
d_Vgsi_dV_si_GND = d_Vgsraw_dV_si_GND;
d_Vgsi_dV_g_GND = d_Vgsraw_dV_g_GND;
Vgsi = Vgsraw;
dir = 1;
}
else
{
Vds = ((model_.type)*((probeVars[admsProbeID_V_s_GND])-(probeVars[admsProbeID_V_d_GND])));
Vgs = ((model_.type)*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_d_GND])));

d_Vdsi_dV_di_GND = (model_.type)*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND]);
d_Vdsi_dV_si_GND = (model_.type)*d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND];
Vdsi = ((model_.type)*((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_di_GND])));

d_Vgsi_dV_si_GND =  0.0;
d_Vgsi_dV_di_GND = d_Vgdraw_dV_di_GND;
d_Vgsi_dV_g_GND = d_Vgdraw_dV_g_GND;
Vgsi = Vgdraw;
dir = (-1);
}
Leff = ((model_.Lgdr)-(model_.dLg));
Rc = ((model_.Rc0)/(model_.W));
phit = ((1.3806503e-23*(model_.Tjun))/1.6021766208e-19);
kT = (1.3806503e-23*(model_.Tjun));
hbar = (6.62607004081e-34/(2.0*3.14159265358979323846));
{
double value_sqrt_0 = sqrt(static_cast<double>(3.14159265358979323846));
sqrt_pi = value_sqrt_0;
}
mD0 = ((model_.meff)*9.10938215e-31);
{
double value_sqrt_0 = sqrt(((((2.0*kT)/3.14159265358979323846)*1.0)/mD0));
vT_int = value_sqrt_0;
}
lambda_int = (((2.0*phit)*(model_.mu_eff))/vT_int);
N2D = ((mD0/((3.14159265358979323846*hbar)*hbar))*kT);

d_Es_dV_sf_GND = (d_probeVars[admsProbeID_V_sf_GND][admsProbeID_V_sf_GND]/phit);
Es = (((model_.energy_diff_volt)+(probeVars[admsProbeID_V_sf_GND]))/phit);
if ((Es>0))
{
sign_Es = 1.0;
}
else
{
if ((Es==0))
{
sign_Es = 0;
}
else
{
if ((Es<0))
{
sign_Es = (-1.0);
}
}
}
{
double value_exp_0 = exp(Es);
double  deriv_exp_0_d0 = value_exp_0;

d_expEs_dV_sf_GND = (deriv_exp_0_d0*(d_Es_dV_sf_GND));
expEs = value_exp_0;
}
if ((Es>=40))
{

d_ffs_dV_sf_GND =  0.0;
ffs = 0;
}
else
{

d_ffs_dV_sf_GND = (-d_expEs_dV_sf_GND*0.6/(1.0+(expEs*0.6))/(1.0+(expEs*0.6)));
ffs = (1.0/(1.0+(expEs*0.6)));
}

d_Es_sq_dV_sf_GND = ((((1.0+sign_Es)*Es)*d_Es_dV_sf_GND+(1.0+sign_Es)*d_Es_dV_sf_GND*Es)/4.0);
Es_sq = ((((1.0+sign_Es)*Es)*Es)/4.0);
{
double value_log_0 = log((1.0+expEs));
double  deriv_log_0_d0 = (1.0/(1.0+expEs));

d_Fs_dV_sf_GND = ((deriv_log_0_d0*(d_expEs_dV_sf_GND))+((model_.np_mass)*phit)*((ffs*d_expEs_dV_sf_GND+d_ffs_dV_sf_GND*expEs)+((1-ffs)*d_Es_sq_dV_sf_GND+(-d_ffs_dV_sf_GND)*Es_sq)));
Fs = (value_log_0+(((model_.np_mass)*phit)*((ffs*expEs)+((1-ffs)*Es_sq))));
}

d_Ed_dV_si_GND = ((-d_Vdsi_dV_si_GND)/phit);
d_Ed_dV_di_GND = ((-d_Vdsi_dV_di_GND)/phit);
d_Ed_dV_sf_GND = (d_probeVars[admsProbeID_V_sf_GND][admsProbeID_V_sf_GND]/phit);
Ed = ((((model_.energy_diff_volt)+(probeVars[admsProbeID_V_sf_GND]))-Vdsi)/phit);
if ((Ed>0))
{
sign_Ed = 1.0;
}
else
{
if ((Ed==0))
{
sign_Ed = 0;
}
else
{
if ((Ed<0))
{
sign_Ed = (-1.0);
}
}
}
{
double value_exp_0 = exp(Ed);
double  deriv_exp_0_d0 = value_exp_0;

d_expEd_dV_si_GND = (deriv_exp_0_d0*(d_Ed_dV_si_GND));
d_expEd_dV_di_GND = (deriv_exp_0_d0*(d_Ed_dV_di_GND));
d_expEd_dV_sf_GND = (deriv_exp_0_d0*(d_Ed_dV_sf_GND));
expEd = value_exp_0;
}
if ((Ed>=40))
{

d_ffd_dV_sf_GND = d_ffd_dV_di_GND = d_ffd_dV_si_GND =  0.0;
ffd = 0;
}
else
{

d_ffd_dV_si_GND = (-d_expEd_dV_si_GND*0.6/(1.0+(expEd*0.6))/(1.0+(expEd*0.6)));
d_ffd_dV_di_GND = (-d_expEd_dV_di_GND*0.6/(1.0+(expEd*0.6))/(1.0+(expEd*0.6)));
d_ffd_dV_sf_GND = (-d_expEd_dV_sf_GND*0.6/(1.0+(expEd*0.6))/(1.0+(expEd*0.6)));
ffd = (1.0/(1.0+(expEd*0.6)));
}

d_Ed_sq_dV_si_GND = ((((1.0+sign_Ed)*Ed)*d_Ed_dV_si_GND+(1.0+sign_Ed)*d_Ed_dV_si_GND*Ed)/4.0);
d_Ed_sq_dV_di_GND = ((((1.0+sign_Ed)*Ed)*d_Ed_dV_di_GND+(1.0+sign_Ed)*d_Ed_dV_di_GND*Ed)/4.0);
d_Ed_sq_dV_sf_GND = ((((1.0+sign_Ed)*Ed)*d_Ed_dV_sf_GND+(1.0+sign_Ed)*d_Ed_dV_sf_GND*Ed)/4.0);
Ed_sq = ((((1.0+sign_Ed)*Ed)*Ed)/4.0);
{
double value_log_0 = log((1.0+expEd));
double  deriv_log_0_d0 = (1.0/(1.0+expEd));

d_Fd_dV_si_GND = ((deriv_log_0_d0*(d_expEd_dV_si_GND))+((model_.np_mass)*phit)*((ffd*d_expEd_dV_si_GND+d_ffd_dV_si_GND*expEd)+((1.0-ffd)*d_Ed_sq_dV_si_GND+(-d_ffd_dV_si_GND)*Ed_sq)));
d_Fd_dV_di_GND = ((deriv_log_0_d0*(d_expEd_dV_di_GND))+((model_.np_mass)*phit)*((ffd*d_expEd_dV_di_GND+d_ffd_dV_di_GND*expEd)+((1.0-ffd)*d_Ed_sq_dV_di_GND+(-d_ffd_dV_di_GND)*Ed_sq)));
d_Fd_dV_sf_GND = ((deriv_log_0_d0*(d_expEd_dV_sf_GND))+((model_.np_mass)*phit)*((ffd*d_expEd_dV_sf_GND+d_ffd_dV_sf_GND*expEd)+((1.0-ffd)*d_Ed_sq_dV_sf_GND+(-d_ffd_dV_sf_GND)*Ed_sq)));
Fd = (value_log_0+(((model_.np_mass)*phit)*((ffd*expEd)+((1.0-ffd)*Ed_sq))));
}
if ((Es>=40))
{

d_meff_np_dV_sf_GND = ((expEs*d_Fs_dV_sf_GND-Fs*d_expEs_dV_sf_GND)/expEs/expEs);
meff_np = (Fs/expEs);
}
else
{
{
double value_log_0 = log((1.0+expEs));
double  deriv_log_0_d0 = (1.0/(1.0+expEs));

d_meff_np_dV_sf_GND = ((value_log_0*d_Fs_dV_sf_GND-Fs*(deriv_log_0_d0*(d_expEs_dV_sf_GND)))/value_log_0/value_log_0);
meff_np = (Fs/value_log_0);
}
}
{
double value_sqrt_0 = sqrt(meff_np);
double  deriv_sqrt_0_d0 = (0.5/value_sqrt_0);

d_NP_fac_lambda_dV_sf_GND = (deriv_sqrt_0_d0*(d_meff_np_dV_sf_GND));
NP_fac_lambda = value_sqrt_0;
}

d_NP_fac_velocity_dV_sf_GND = (-d_NP_fac_lambda_dV_sf_GND/NP_fac_lambda/NP_fac_lambda);
NP_fac_velocity = (1.0/NP_fac_lambda);

d_expMeta_dV_sf_GND = (-d_expEs_dV_sf_GND/expEs/expEs);
expMeta = (1.0/expEs);
{
double value_pow_0 = pow(Es,4.0);
double value_exp_1 = exp((((-0.17)*(1.0+Es))*(1.0+Es)));
double  deriv_pow_0_d0 = ((Es == 0.0)?0.0:(value_pow_0*4.0/Es));
double  deriv_exp_1_d0 = value_exp_1;

d_A1_dV_sf_GND = ((deriv_pow_0_d0*(d_Es_dV_sf_GND))+((33.6*Es)*(-0.68*(deriv_exp_1_d0*((((-0.17)*(1.0+Es))*d_Es_dV_sf_GND+(-0.17)*d_Es_dV_sf_GND*(1.0+Es)))))+33.6*d_Es_dV_sf_GND*(1-(0.68*value_exp_1))));
A1 = ((50.0+value_pow_0)+((33.6*Es)*(1-(0.68*value_exp_1))));
}
{
double value_pow_0 = pow(A1,(3.0/8.0));
double  deriv_pow_0_d0 = ((A1 == 0.0)?0.0:(value_pow_0*(3.0/8.0)/A1));

d_den1_dV_sf_GND = (deriv_pow_0_d0*(d_A1_dV_sf_GND));
den1 = value_pow_0;
}

d_c1_dV_sf_GND = (-((3.0/4.0)*sqrt_pi)*d_den1_dV_sf_GND/den1/den1);
c1 = (((3.0/4.0)*sqrt_pi)/den1);

d_FDhalfs_dV_sf_GND = (-(d_c1_dV_sf_GND+d_expMeta_dV_sf_GND)/(c1+expMeta)/(c1+expMeta));
FDhalfs = (1.0/(c1+expMeta));
{
double value_log_0 = log((1.0+expEs));
double  deriv_log_0_d0 = (1.0/(1.0+expEs));

d_extr_coef_dV_sf_GND = ((value_log_0*d_FDhalfs_dV_sf_GND-FDhalfs*(deriv_log_0_d0*(d_expEs_dV_sf_GND)))/value_log_0/value_log_0);
extr_coef = (FDhalfs/value_log_0);
}

d_u1_dV_sf_GND = d_Es_dV_sf_GND;
u1 = Es;
j_pow1 = (-0.5);
{
double value_sqrt_0 = sqrt(((1.0+((15.0/4.0)*(j_pow1+1.0)))+(((1.0/40.0)*(j_pow1+1.0))*(j_pow1+1.0))));
a_pow1 = value_sqrt_0;
}
b_pow1 = (1.8+(0.61*j_pow1));
{
double value_sqrt_0 = sqrt(static_cast<double>(2.0));
double value_pow_1 = pow(2.0,(-j_pow1));
c_pow1 = (2.0+((2.0-value_sqrt_0)*value_pow_1));
}
{
double value_pow_0 = pow(2.0,(1.0+j_pow1));
num_t1_fd1 = ((j_pow1+1.0)*value_pow_0);
}
{
double value_pow_0 = pow(a_pow1,c_pow1);
double value_fabs_1 = fabs((u1-b_pow1));
double value_pow_2 = pow(value_fabs_1,c_pow1);
double value_pow_3 = pow((((b_pow1+u1)+value_pow_0)+value_pow_2),(1.0/c_pow1));
double  deriv_fabs_1_d0 = ((((u1-b_pow1))>=0)?(+1.0):(-1.0));
double  deriv_pow_2_d0 = ((value_fabs_1 == 0.0)?0.0:(value_pow_2*c_pow1/value_fabs_1));
double  deriv_pow_3_d0 = (((((b_pow1+u1)+value_pow_0)+value_pow_2) == 0.0)?0.0:(value_pow_3*(1.0/c_pow1)/(((b_pow1+u1)+value_pow_0)+value_pow_2)));

d_aterm1_dV_sf_GND = (deriv_pow_3_d0*((d_u1_dV_sf_GND+(deriv_pow_2_d0*((deriv_fabs_1_d0*(d_u1_dV_sf_GND)))))));
aterm1 = value_pow_3;
}
{
double value_pow_0 = pow(aterm1,(1.0+j_pow1));
double  deriv_pow_0_d0 = ((aterm1 == 0.0)?0.0:(value_pow_0*(1.0+j_pow1)/aterm1));

d_den_t1_fd1_dV_sf_GND = (deriv_pow_0_d0*(d_aterm1_dV_sf_GND));
den_t1_fd1 = value_pow_0;
}
{
double value_exp_0 = exp((-u1));
double value_sqrt_1 = sqrt(static_cast<double>(3.14159265358979323846));
double  deriv_exp_0_d0 = value_exp_0;

d_t2_fd1_dV_sf_GND = ((deriv_exp_0_d0*((-d_u1_dV_sf_GND)))/value_sqrt_1);
t2_fd1 = (value_exp_0/value_sqrt_1);
}
{
double value_sqrt_0 = sqrt(static_cast<double>(3.14159265358979323846));
double value_pow_1 = pow(((num_t1_fd1/den_t1_fd1)+t2_fd1),(-1.0));
double  deriv_pow_1_d0 = ((((num_t1_fd1/den_t1_fd1)+t2_fd1) == 0.0)?0.0:(value_pow_1*(-1.0)/((num_t1_fd1/den_t1_fd1)+t2_fd1)));

d_FDminushalfs_dV_sf_GND = (1.0/value_sqrt_0)*(deriv_pow_1_d0*(((-num_t1_fd1*d_den_t1_fd1_dV_sf_GND/den_t1_fd1/den_t1_fd1)+d_t2_fd1_dV_sf_GND)));
FDminushalfs = ((1.0/value_sqrt_0)*value_pow_1);
}
{
double value_log_0 = log((1.0+expEs));
double  deriv_log_0_d0 = (1.0/(1.0+expEs));

d_dgen_lambda_dV_sf_GND = ((FDminushalfs*(deriv_log_0_d0*(d_expEs_dV_sf_GND))-value_log_0*d_FDminushalfs_dV_sf_GND)/FDminushalfs/FDminushalfs);
dgen_lambda = (value_log_0/FDminushalfs);
}

d_lambda_dV_sf_GND = ((lambda_int*NP_fac_lambda)*d_dgen_lambda_dV_sf_GND+lambda_int*d_NP_fac_lambda_dV_sf_GND*dgen_lambda);
lambda = ((lambda_int*NP_fac_lambda)*dgen_lambda);

d_vT_dV_sf_GND = ((vT_int*NP_fac_velocity)*d_extr_coef_dV_sf_GND+vT_int*d_NP_fac_velocity_dV_sf_GND*extr_coef);
vT = ((vT_int*NP_fac_velocity)*extr_coef);
{
double value_exp_0 = exp(((model_.nacc)/N2D));
double value_log_1 = log((value_exp_0-1.0));
eta_acc = value_log_1;
}
{
double value_exp_0 = exp(((model_.nacc)/N2D));
exp_eta_acc = (value_exp_0-1.0);
}
expu_acc = exp_eta_acc;
expMeta_acc = (1.0/expu_acc);
{
double value_pow_0 = pow(eta_acc,4.0);
double value_exp_1 = exp((((-0.17)*(1.0+eta_acc))*(1.0+eta_acc)));
A1_acc = ((50.0+value_pow_0)+((33.6*eta_acc)*(1-(0.68*value_exp_1))));
}
{
double value_pow_0 = pow(A1_acc,(3.0/8.0));
den1_acc = value_pow_0;
}
c1_acc = (((3.0/4.0)*sqrt_pi)/den1_acc);
FDhalfs_acc = (1.0/(c1_acc+expMeta_acc));
{
double value_log_0 = log((1.0+exp_eta_acc));
extr_coef_acc = (FDhalfs_acc/value_log_0);
}
vT_acc = (vT_int*extr_coef_acc);
Vdsat2 = ((model_.theta)*phit);
{
double value_fabs_0 = fabs((Vdsi/Vdsat2));
double value_pow_1 = pow(value_fabs_0,(model_.beta));
double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat2))>=0)?(+1.0):(-1.0));
double  deriv_pow_1_d0 = ((value_fabs_0 == 0.0)?0.0:(value_pow_1*(model_.beta)/value_fabs_0));

d_Vdsatbeta2_dV_si_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Vdsi_dV_si_GND/Vdsat2)))));
d_Vdsatbeta2_dV_di_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Vdsi_dV_di_GND/Vdsat2)))));
Vdsatbeta2 = value_pow_1;
}
{
double value_fabs_0 = fabs((Vdsi/Vdsat2));
double value_pow_1 = pow((1.0+Vdsatbeta2),(1.0/(model_.beta)));
double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat2))>=0)?(+1.0):(-1.0));
double  deriv_pow_1_d0 = (((1.0+Vdsatbeta2) == 0.0)?0.0:(value_pow_1*(1.0/(model_.beta))/(1.0+Vdsatbeta2)));

d_f2_dV_si_GND = ((value_pow_1*(deriv_fabs_0_d0*((d_Vdsi_dV_si_GND/Vdsat2)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta2_dV_si_GND)))/value_pow_1/value_pow_1);
d_f2_dV_di_GND = ((value_pow_1*(deriv_fabs_0_d0*((d_Vdsi_dV_di_GND/Vdsat2)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta2_dV_di_GND)))/value_pow_1/value_pow_1);
f2 = (value_fabs_0/value_pow_1);
}
Lcrit_lin = Leff;
Lcrit_sat = ((model_.ksee)*Leff);

d_Lcrit_dV_si_GND = ((-d_f2_dV_si_GND)*Lcrit_lin+d_f2_dV_si_GND*Lcrit_sat);
d_Lcrit_dV_di_GND = ((-d_f2_dV_di_GND)*Lcrit_lin+d_f2_dV_di_GND*Lcrit_sat);
Lcrit = (((1.0-f2)*Lcrit_lin)+(f2*Lcrit_sat));

d_Tx_dV_si_GND = (-lambda*d_Lcrit_dV_si_GND/(lambda+Lcrit)/(lambda+Lcrit));
d_Tx_dV_di_GND = (-lambda*d_Lcrit_dV_di_GND/(lambda+Lcrit)/(lambda+Lcrit));
d_Tx_dV_sf_GND = (((lambda+Lcrit)*d_lambda_dV_sf_GND-lambda*d_lambda_dV_sf_GND)/(lambda+Lcrit)/(lambda+Lcrit));
Tx = (lambda/(lambda+Lcrit));

d_Qx0_dV_si_GND = (((-1.6021766208e-19)*N2D)/2.0)*(Fs*(-d_Tx_dV_si_GND)+(Fd*d_Tx_dV_si_GND+d_Fd_dV_si_GND*Tx));
d_Qx0_dV_di_GND = (((-1.6021766208e-19)*N2D)/2.0)*(Fs*(-d_Tx_dV_di_GND)+(Fd*d_Tx_dV_di_GND+d_Fd_dV_di_GND*Tx));
d_Qx0_dV_sf_GND = (((-1.6021766208e-19)*N2D)/2.0)*((Fs*(-d_Tx_dV_sf_GND)+d_Fs_dV_sf_GND*(2.0-Tx))+(Fd*d_Tx_dV_sf_GND+d_Fd_dV_sf_GND*Tx));
Qx0 = ((((-1.6021766208e-19)*N2D)/2.0)*((Fs*(2.0-Tx))+(Fd*Tx)));
{
double value_fabs_0 = fabs(((model_.B)/(model_.dqm0)));
double value_pow_1 = pow(value_fabs_0,3.0);
QB = value_pow_1;
}
{
double value_fabs_0 = fabs(Qx0);
double value_pow_1 = pow((QB+((11.0/32.0)*value_fabs_0)),(1/3.0));
double  deriv_fabs_0_d0 = (((Qx0)>=0)?(+1.0):(-1.0));
double  deriv_pow_1_d0 = (((QB+((11.0/32.0)*value_fabs_0)) == 0.0)?0.0:(value_pow_1*(1/3.0)/(QB+((11.0/32.0)*value_fabs_0))));

d_xav_dV_si_GND = (-(model_.B)*(deriv_pow_1_d0*((11.0/32.0)*(deriv_fabs_0_d0*(d_Qx0_dV_si_GND))))/value_pow_1/value_pow_1);
d_xav_dV_di_GND = (-(model_.B)*(deriv_pow_1_d0*((11.0/32.0)*(deriv_fabs_0_d0*(d_Qx0_dV_di_GND))))/value_pow_1/value_pow_1);
d_xav_dV_sf_GND = (-(model_.B)*(deriv_pow_1_d0*((11.0/32.0)*(deriv_fabs_0_d0*(d_Qx0_dV_sf_GND))))/value_pow_1/value_pow_1);
xav = ((model_.B)/value_pow_1);
}

d_Cstern_dV_si_GND = (-((model_.eps)*8.854187817e-12)*d_xav_dV_si_GND/xav/xav);
d_Cstern_dV_di_GND = (-((model_.eps)*8.854187817e-12)*d_xav_dV_di_GND/xav/xav);
d_Cstern_dV_sf_GND = (-((model_.eps)*8.854187817e-12)*d_xav_dV_sf_GND/xav/xav);
Cstern = (((model_.eps)*8.854187817e-12)/xav);

d_Cgc_dV_si_GND = ((((model_.Cins)+Cstern)*(model_.Cins)*d_Cstern_dV_si_GND-((model_.Cins)*Cstern)*d_Cstern_dV_si_GND)/((model_.Cins)+Cstern)/((model_.Cins)+Cstern));
d_Cgc_dV_di_GND = ((((model_.Cins)+Cstern)*(model_.Cins)*d_Cstern_dV_di_GND-((model_.Cins)*Cstern)*d_Cstern_dV_di_GND)/((model_.Cins)+Cstern)/((model_.Cins)+Cstern));
d_Cgc_dV_sf_GND = ((((model_.Cins)+Cstern)*(model_.Cins)*d_Cstern_dV_sf_GND-((model_.Cins)*Cstern)*d_Cstern_dV_sf_GND)/((model_.Cins)+Cstern)/((model_.Cins)+Cstern));
Cgc = (((model_.Cins)*Cstern)/((model_.Cins)+Cstern));
{
double value_fabs_0 = fabs(((model_.nd)*Vdsi));
double  deriv_fabs_0_d0 = (((((model_.nd)*Vdsi))>=0)?(+1.0):(-1.0));

d_n_dV_si_GND = (deriv_fabs_0_d0*((model_.nd)*d_Vdsi_dV_si_GND));
d_n_dV_di_GND = (deriv_fabs_0_d0*((model_.nd)*d_Vdsi_dV_di_GND));
n = ((model_.n0)+value_fabs_0);
}
// V(sf,GND) <+ ((((Vgsi+(delta*Vdsi))+(Qx0/Cgc))/n))
staticContributions[admsBRA_ID_sf_GND] += (((Vgsi+((model_.delta)*Vdsi))+(Qx0/Cgc))/n);
d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] += (((Cgc*d_Qx0_dV_sf_GND-Qx0*d_Cgc_dV_sf_GND)/Cgc/Cgc)/n);
d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND] += ((n*((d_Vgsi_dV_si_GND+(model_.delta)*d_Vdsi_dV_si_GND)+((Cgc*d_Qx0_dV_si_GND-Qx0*d_Cgc_dV_si_GND)/Cgc/Cgc))-((Vgsi+((model_.delta)*Vdsi))+(Qx0/Cgc))*d_n_dV_si_GND)/n/n);
d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND] += (d_Vgsi_dV_g_GND/n);
d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND] += ((n*((d_Vgsi_dV_di_GND+(model_.delta)*d_Vdsi_dV_di_GND)+((Cgc*d_Qx0_dV_di_GND-Qx0*d_Cgc_dV_di_GND)/Cgc/Cgc))-((Vgsi+((model_.delta)*Vdsi))+(Qx0/Cgc))*d_n_dV_di_GND)/n/n);

d_f1_dV_si_GND = (((-d_Tx_dV_si_GND)*Fs+(Tx*d_Fd_dV_si_GND+d_Tx_dV_si_GND*Fd))/(2.0*Fs));
d_f1_dV_di_GND = (((-d_Tx_dV_di_GND)*Fs+(Tx*d_Fd_dV_di_GND+d_Tx_dV_di_GND*Fd))/(2.0*Fs));
d_f1_dV_sf_GND = (((2.0*Fs)*(((2.0-Tx)*d_Fs_dV_sf_GND+(-d_Tx_dV_sf_GND)*Fs)+(Tx*d_Fd_dV_sf_GND+d_Tx_dV_sf_GND*Fd))-(((2.0-Tx)*Fs)+(Tx*Fd))*2.0*d_Fs_dV_sf_GND)/(2.0*Fs)/(2.0*Fs));
f1 = ((((2.0-Tx)*Fs)+(Tx*Fd))/(2.0*Fs));

d_Vdsat_dV_si_GND = (((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*d_f1_dV_si_GND;
d_Vdsat_dV_di_GND = (((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*d_f1_dV_di_GND;
d_Vdsat_dV_sf_GND = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*d_f1_dV_sf_GND+(((lambda+((2.0*(model_.ksee))*Leff))*(2.0*phit)*d_lambda_dV_sf_GND-((2.0*phit)*(lambda+Leff))*d_lambda_dV_sf_GND)/(lambda+((2.0*(model_.ksee))*Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*f1);
Vdsat = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*(model_.ksee))*Leff)))*f1);
{
double value_fabs_0 = fabs((Vdsi/Vdsat));
double value_pow_1 = pow(value_fabs_0,(model_.beta));
double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat))>=0)?(+1.0):(-1.0));
double  deriv_pow_1_d0 = ((value_fabs_0 == 0.0)?0.0:(value_pow_1*(model_.beta)/value_fabs_0));

d_Vdsatbeta_dV_sf_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((-Vdsi*d_Vdsat_dV_sf_GND/Vdsat/Vdsat)))));
d_Vdsatbeta_dV_si_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_si_GND-Vdsi*d_Vdsat_dV_si_GND)/Vdsat/Vdsat)))));
d_Vdsatbeta_dV_di_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_di_GND-Vdsi*d_Vdsat_dV_di_GND)/Vdsat/Vdsat)))));
Vdsatbeta = value_pow_1;
}
{
double value_fabs_0 = fabs((Vdsi/Vdsat));
double value_pow_1 = pow((1.0+Vdsatbeta),(1.0/(model_.beta)));
double  deriv_fabs_0_d0 = ((((Vdsi/Vdsat))>=0)?(+1.0):(-1.0));
double  deriv_pow_1_d0 = (((1.0+Vdsatbeta) == 0.0)?0.0:(value_pow_1*(1.0/(model_.beta))/(1.0+Vdsatbeta)));

d_Fsat_dV_sf_GND = ((value_pow_1*(deriv_fabs_0_d0*((-Vdsi*d_Vdsat_dV_sf_GND/Vdsat/Vdsat)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta_dV_sf_GND)))/value_pow_1/value_pow_1);
d_Fsat_dV_si_GND = ((value_pow_1*(deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_si_GND-Vdsi*d_Vdsat_dV_si_GND)/Vdsat/Vdsat)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta_dV_si_GND)))/value_pow_1/value_pow_1);
d_Fsat_dV_di_GND = ((value_pow_1*(deriv_fabs_0_d0*(((Vdsat*d_Vdsi_dV_di_GND-Vdsi*d_Vdsat_dV_di_GND)/Vdsat/Vdsat)))-value_fabs_0*(deriv_pow_1_d0*(d_Vdsatbeta_dV_di_GND)))/value_pow_1/value_pow_1);
Fsat = (value_fabs_0/value_pow_1);
}

d_vx0_dV_sf_GND = (((lambda+((2.0*(model_.ksee))*Leff))*(vT*d_lambda_dV_sf_GND+d_vT_dV_sf_GND*lambda)-(vT*lambda)*d_lambda_dV_sf_GND)/(lambda+((2.0*(model_.ksee))*Leff))/(lambda+((2.0*(model_.ksee))*Leff)));
vx0 = ((vT*lambda)/(lambda+((2.0*(model_.ksee))*Leff)));
{
double value_fabs_0 = fabs(Qx0);
double  deriv_fabs_0_d0 = (((Qx0)>=0)?(+1.0):(-1.0));

d_Id_dV_si_GND = (value_fabs_0*d_Fsat_dV_si_GND+(deriv_fabs_0_d0*(d_Qx0_dV_si_GND))*Fsat)*vx0*(model_.W);
d_Id_dV_di_GND = (value_fabs_0*d_Fsat_dV_di_GND+(deriv_fabs_0_d0*(d_Qx0_dV_di_GND))*Fsat)*vx0*(model_.W);
d_Id_dV_sf_GND = ((value_fabs_0*Fsat)*d_vx0_dV_sf_GND+(value_fabs_0*d_Fsat_dV_sf_GND+(deriv_fabs_0_d0*(d_Qx0_dV_sf_GND))*Fsat)*vx0)*(model_.W);
Id = (((value_fabs_0*Fsat)*vx0)*(model_.W));
}
Qacc = (1.6021766208e-19*(model_.nacc));
Id_sat = (((model_.W)*Qacc)*vT_acc);
{
double value_fabs_0 = fabs((Id/Id_sat));
double value_pow_1 = pow(value_fabs_0,(model_.beta));
double  deriv_fabs_0_d0 = ((((Id/Id_sat))>=0)?(+1.0):(-1.0));
double  deriv_pow_1_d0 = ((value_fabs_0 == 0.0)?0.0:(value_pow_1*(model_.beta)/value_fabs_0));

d_Idsatbeta_dV_si_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Id_dV_si_GND/Id_sat)))));
d_Idsatbeta_dV_di_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Id_dV_di_GND/Id_sat)))));
d_Idsatbeta_dV_sf_GND = (deriv_pow_1_d0*((deriv_fabs_0_d0*((d_Id_dV_sf_GND/Id_sat)))));
Idsatbeta = value_pow_1;
}
{
double value_pow_0 = pow((1-Idsatbeta),(1.0/(model_.beta)));
double  deriv_pow_0_d0 = (((1-Idsatbeta) == 0.0)?0.0:(value_pow_0*(1.0/(model_.beta))/(1-Idsatbeta)));

d_Rs_dV_si_GND = (-Rc*(deriv_pow_0_d0*((-d_Idsatbeta_dV_si_GND)))/value_pow_0/value_pow_0);
d_Rs_dV_di_GND = (-Rc*(deriv_pow_0_d0*((-d_Idsatbeta_dV_di_GND)))/value_pow_0/value_pow_0);
d_Rs_dV_sf_GND = (-Rc*(deriv_pow_0_d0*((-d_Idsatbeta_dV_sf_GND)))/value_pow_0/value_pow_0);
Rs = (Rc/value_pow_0);
}

d_Rd_dV_si_GND = d_Rs_dV_si_GND;
d_Rd_dV_di_GND = d_Rs_dV_di_GND;
d_Rd_dV_sf_GND = d_Rs_dV_sf_GND;
Rd = Rs;
// I(di,si) <+ (((type*dir)*Id))
staticContributions[admsNodeID_di] += (((model_.type)*dir)*Id);
d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND] += ((model_.type)*dir)*d_Id_dV_si_GND;
d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND] += ((model_.type)*dir)*d_Id_dV_di_GND;
d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND] += ((model_.type)*dir)*d_Id_dV_sf_GND;
staticContributions[admsNodeID_si] -= (((model_.type)*dir)*Id);
d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND] -= ((model_.type)*dir)*d_Id_dV_si_GND;
d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND] -= ((model_.type)*dir)*d_Id_dV_di_GND;
d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND] -= ((model_.type)*dir)*d_Id_dV_sf_GND;
// I(d,di) <+ (((V(d,GND)-V(di,GND))/Rd))
staticContributions[admsNodeID_d] += (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND] += (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_si_GND/Rd/Rd);
d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND] += (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_sf_GND/Rd/Rd);
d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND] += ((Rd*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND])-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_di_GND)/Rd/Rd);
d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND] += (d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]/Rd);
staticContributions[admsNodeID_di] -= (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND] -= (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_si_GND/Rd/Rd);
d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND] -= (-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_sf_GND/Rd/Rd);
d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND] -= ((Rd*(-d_probeVars[admsProbeID_V_di_GND][admsProbeID_V_di_GND])-((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))*d_Rd_dV_di_GND)/Rd/Rd);
d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND] -= (d_probeVars[admsProbeID_V_d_GND][admsProbeID_V_d_GND]/Rd);
// I(si,s) <+ (((V(si,GND)-V(s,GND))/Rs))
staticContributions[admsNodeID_si] += (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND] += (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_di_GND/Rs/Rs);
d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND] += (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_sf_GND/Rs/Rs);
d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND] += ((-d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND])/Rs);
d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND] += ((Rs*d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_si_GND)/Rs/Rs);
staticContributions[admsNodeID_s] -= (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND] -= (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_di_GND/Rs/Rs);
d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND] -= (-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_sf_GND/Rs/Rs);
d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND] -= ((-d_probeVars[admsProbeID_V_s_GND][admsProbeID_V_s_GND])/Rs);
d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND] -= ((Rs*d_probeVars[admsProbeID_V_si_GND][admsProbeID_V_si_GND]-((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))*d_Rs_dV_si_GND)/Rs/Rs);

          // Additional term resulting from contributions into V(sf,GND)
staticContributions[admsNodeID_sf] += probeVars[admsProbeID_I_sf_GND];
d_staticContributions[admsNodeID_sf][admsProbeID_I_sf_GND] += d_probeVars[admsProbeID_I_sf_GND][admsProbeID_I_sf_GND];
  // Final term for branch equation admsBRA_ID_sf_GND 
// Derivative of this term with respect to node is +/-1
// Handling of that derivative is done explicitly in the loadDAEdFdX method
  staticContributions[admsBRA_ID_sf_GND] -= (*solVectorPtr)[li_sf];


  // -- endcode converted from analog/code block
  if (DEBUG_DEVICE && isActive(Diag::DEVICE_PARAMETERS) && getSolverState().debugTimeFlag)
  {
    Xyce::dout() << " probeVars[admsProbeID_V_sf_GND] =  "
         <<probeVars[admsProbeID_V_sf_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_s_GND] =  "
         <<probeVars[admsProbeID_V_s_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_d_GND] =  "
         <<probeVars[admsProbeID_V_d_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_di_GND] =  "
         <<probeVars[admsProbeID_V_di_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_si_GND] =  "
         <<probeVars[admsProbeID_V_si_GND] << std::endl;
    Xyce::dout() << " probeVars[admsProbeID_V_g_GND] =  "
         <<probeVars[admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_d] =  "
         <<staticContributions[admsNodeID_d] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_d].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_d][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_d] =  "
         <<dynamicContributions[admsNodeID_d] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_d].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_d][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_g] =  "
         <<staticContributions[admsNodeID_g] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_g].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_g][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_g] =  "
         <<dynamicContributions[admsNodeID_g] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_g].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_g][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_s] =  "
         <<staticContributions[admsNodeID_s] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_s].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_s][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_s] =  "
         <<dynamicContributions[admsNodeID_s] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_s].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_s][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_di] =  "
         <<staticContributions[admsNodeID_di] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_di].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_di][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_di] =  "
         <<dynamicContributions[admsNodeID_di] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_di].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_di][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_si] =  "
         <<staticContributions[admsNodeID_si] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_si].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_si][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_si] =  "
         <<dynamicContributions[admsNodeID_si] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_si].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_si][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsNodeID_sf] =  "
         <<staticContributions[admsNodeID_sf] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsNodeID_sf].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsNodeID_sf][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsNodeID_sf] =  "
         <<dynamicContributions[admsNodeID_sf] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsNodeID_sf].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsNodeID_sf][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " staticContributions[admsBRA_ID_sf_GND] =  "
         <<staticContributions[admsBRA_ID_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_sf_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_s_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_d_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_di_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_si_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    staticContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_g_GND) =  " <<d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND] << std::endl;
    Xyce::dout() << " dynamicContributions[admsBRA_ID_sf_GND] =  "
         <<dynamicContributions[admsBRA_ID_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_sf_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_s_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_s_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_d_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_d_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_di_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_si_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND] << std::endl;
      Xyce::dout() << "    dynamicContributions[admsBRA_ID_sf_GND].dx(admsProbeID_V_g_GND) =  " <<d_dynamicContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND] << std::endl;

    if (!origFlag)
      Xyce::dout() << "This step was limited by this device." << std::endl;
  }


  if (loadLeadCurrent)
  {
    // If needed, we must now copy all the data from staticContributions
    // and dynamicContributionsinto the lead current F vector
    // Must make sure all collapsed node contributions get summed into the
    // external nodes properly.
    for ( int unmappedNode=0; unmappedNode < 3 ; unmappedNode++)
    {
      leadCurrentF[unmappedNode] = 0.0;
      leadCurrentQ[unmappedNode] = 0.0;
    }
    for ( int unmappedNode=0; unmappedNode < 6; unmappedNode++)
    {
      if (nodeMap[unmappedNode] < 3 && nodeMap[unmappedNode] != -1 )
      {
        leadCurrentF[nodeMap[unmappedNode]] += staticContributions[unmappedNode];
        leadCurrentQ[nodeMap[unmappedNode]] += dynamicContributions[unmappedNode];
      }
    }
  }
  return true;
}


//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEdFdx
// Purpose       :
// Special Notes : Load the dFdx ("static jacobian") matrix
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEdFdx()
{
  bool bsuccess = true;
  Linear::Matrix & dFdx = *(extData.dFdxMatrixPtr);

#ifndef Xyce_NONPOINTER_MATRIX_LOAD
  (*f_di_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND];
  (*f_si_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND];
  (*f_di_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND];
  (*f_si_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND];
  (*f_di_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND];
  (*f_si_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND];
  (*f_d_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND];
  (*f_d_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND];
  (*f_d_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND];
  (*f_d_Equ_d_Node_Ptr) +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND];
  (*f_di_Equ_d_Node_Ptr) +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND];
  (*f_s_Equ_di_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND];
  (*f_s_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND];
  (*f_si_Equ_s_Node_Ptr) +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND];
  (*f_s_Equ_s_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND];
  (*f_s_Equ_si_Node_Ptr) +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND];
  (*f_sf_Equ_BRA_sf_GND_Var_Ptr) += d_staticContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
    // there also need to be extra loads for branch sf,GND
    // Load for branch sf,GND equ var sf
     // depends on probe V(sf,GND)
  (*f_BRA_sf_GND_Equ_sf_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] -1;
    // Load for branch sf,GND equ var si
     // depends on probe V(si,GND)
  (*f_BRA_sf_GND_Equ_si_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND];
    // Load for branch sf,GND equ var g
     // depends on probe V(g,GND)
  (*f_BRA_sf_GND_Equ_g_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND];
    // Load for branch sf,GND equ var di
     // depends on probe V(di,GND)
  (*f_BRA_sf_GND_Equ_di_Node_Ptr) +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND];

#else
  //use the offsets instead of pointers
  dFdx[li_di][A_di_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_si_GND];
  dFdx[li_si][A_si_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_si_GND];
  dFdx[li_di][A_di_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_di_GND];
  dFdx[li_si][A_si_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_di_GND];
  dFdx[li_di][A_di_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_sf_GND];
  dFdx[li_si][A_si_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_sf_GND];
  dFdx[li_d][A_d_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_si_GND];
  dFdx[li_d][A_d_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_sf_GND];
  dFdx[li_d][A_d_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_di_GND];
  dFdx[li_d][A_d_Equ_d_NodeOffset] +=  +d_staticContributions[admsNodeID_d][admsProbeID_V_d_GND];
  dFdx[li_di][A_di_Equ_d_NodeOffset] +=  +d_staticContributions[admsNodeID_di][admsProbeID_V_d_GND];
  dFdx[li_s][A_s_Equ_di_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_di_GND];
  dFdx[li_s][A_s_Equ_sf_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_sf_GND];
  dFdx[li_si][A_si_Equ_s_NodeOffset] +=  +d_staticContributions[admsNodeID_si][admsProbeID_V_s_GND];
  dFdx[li_s][A_s_Equ_s_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_s_GND];
  dFdx[li_s][A_s_Equ_si_NodeOffset] +=  +d_staticContributions[admsNodeID_s][admsProbeID_V_si_GND];
  dFdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset] += d_staticContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
    // there also need to be extra loads for branch sf,GND
    // Load for branch sf,GND equ var sf
     // depends on probe V(sf,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_sf_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_sf_GND] -1;
    // Load for branch sf,GND equ var si
     // depends on probe V(si,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_si_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_si_GND];
    // Load for branch sf,GND equ var g
     // depends on probe V(g,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_g_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_g_GND];
    // Load for branch sf,GND equ var di
     // depends on probe V(di,GND)
  dFdx[li_BRA_sf_GND][A_BRA_sf_GND_Equ_di_Node_Offset] +=  +d_staticContributions[admsBRA_ID_sf_GND][admsProbeID_V_di_GND];

#endif

  return bsuccess;
}


//-----------------------------------------------------------------------------
// Function      : Instance::loadDAEdQdx
// Purpose       :
// Special Notes : Load the dQdx ("dynamic jacobian") matrix
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::loadDAEdQdx()
{
  bool bsuccess = true;
  Linear::Matrix & dQdx = *(extData.dQdxMatrixPtr);

#ifndef Xyce_NONPOINTER_MATRIX_LOAD
  (*q_sf_Equ_BRA_sf_GND_Var_Ptr) += d_dynamicContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
    // there also need to be extra loads for branch sf,GND
    // Load for branch sf,GND equ var sf
    // Load for branch sf,GND equ var si
    // Load for branch sf,GND equ var g
    // Load for branch sf,GND equ var di

#else
  //use the offsets instead of pointers
  dQdx[li_sf][A_sf_Equ_BRA_sf_GND_Var_Offset] += d_dynamicContributions[admsNodeID_sf][admsProbeID_I_sf_GND];
    // there also need to be extra loads for branch sf,GND
    // Load for branch sf,GND equ var sf
    // Load for branch sf,GND equ var si
    // Load for branch sf,GND equ var g
    // Load for branch sf,GND equ var di


#endif
  return bsuccess;
}

//-----------------------------------------------------------------------------
// Function      : Instance::updateTemperature
// Purpose       : Set temperature and update any parameters that depend on it
// Special Notes : In Xyce ADMS, we'll simply copy the temperature, which is
//                 in Kelvin, to our "admsTemperature" variable, which needs
//                 to be in Celsius.
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Instance::updateTemperature(const double & temperatureTemp)
{

  admsTemperature = temperatureTemp;
  adms_vt_nom = adms_vt(temperatureTemp);

  return true;
}

// Class Model
//-----------------------------------------------------------------------------
// Function      : Model::processParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
bool Model::processParams()
{

  // Set any non-constant parameter defaults:
  // Set any parameters that were not given and whose defaults depend on other
  // parameters:

// set internal model type based on model card type
if (getType() == "pmos" || getType() == "PMOS")
    type = -1;



  // Now we need to check that any parameters are within their ranges as
  // specified in the verilog:

//    Parameter type : [ (-1), 1 ]] 0, 0 [
  if ( (!((type >=(-1) && type <=1 )) || (type >0 && type <0 )) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter type value " << type << " out of range [ (-1), 1 ] or  ] 0, 0 [";
  }

//    Parameter W : ] 0,  (+inf) [
  if ( (!((W >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter W value " << W << " out of range ] 0,  (+inf) [";
  }

//    Parameter Lgdr : ] 0,  (+inf) [
  if ( (!((Lgdr >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Lgdr value " << Lgdr << " out of range ] 0,  (+inf) [";
  }

//    Parameter dLg : [ 0,  (+inf) [
  if ( (!((dLg >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter dLg value " << dLg << " out of range [ 0,  (+inf) [";
  }

//    Parameter Cins : ] 0,  (+inf) [
  if ( (!((Cins >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Cins value " << Cins << " out of range ] 0,  (+inf) [";
  }

//    Parameter Tjun : ] 0,  (+inf) [
  if ( (!((Tjun >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Tjun value " << Tjun << " out of range ] 0,  (+inf) [";
  }

//    Parameter energy_diff_volt :  ] (-inf)  (+inf) [

//    Parameter delta : [ 0,  (+inf) [
  if ( (!((delta >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter delta value " << delta << " out of range [ 0,  (+inf) [";
  }

//    Parameter n0 : [ 1.0,  (+inf) [
  if ( (!((n0 >=1.0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter n0 value " << n0 << " out of range [ 1.0,  (+inf) [";
  }

//    Parameter Rc0 : ] 0,  (+inf) [
  if ( (!((Rc0 >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter Rc0 value " << Rc0 << " out of range ] 0,  (+inf) [";
  }

//    Parameter nacc : ] 0,  (+inf) [
  if ( (!((nacc >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter nacc value " << nacc << " out of range ] 0,  (+inf) [";
  }

//    Parameter meff : ] 0, 1 ]
  if ( (!((meff >0 && meff <=1 ))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter meff value " << meff << " out of range ] 0, 1 ]";
  }

//    Parameter np_mass : [ 0,  (+inf) [
  if ( (!((np_mass >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter np_mass value " << np_mass << " out of range [ 0,  (+inf) [";
  }

//    Parameter mu_eff : ] 0,  (+inf) [
  if ( (!((mu_eff >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter mu_eff value " << mu_eff << " out of range ] 0,  (+inf) [";
  }

//    Parameter ksee : ] 0,  (+inf) [
  if ( (!((ksee >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter ksee value " << ksee << " out of range ] 0,  (+inf) [";
  }

//    Parameter B : ] 0,  (+inf) [
  if ( (!((B >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter B value " << B << " out of range ] 0,  (+inf) [";
  }

//    Parameter dqm0 : ] 0,  (+inf) [
  if ( (!((dqm0 >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter dqm0 value " << dqm0 << " out of range ] 0,  (+inf) [";
  }

//    Parameter eps : ] 0,  (+inf) [
  if ( (!((eps >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter eps value " << eps << " out of range ] 0,  (+inf) [";
  }

//    Parameter theta : ] 0,  (+inf) [
  if ( (!((theta >0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter theta value " << theta << " out of range ] 0,  (+inf) [";
  }

//    Parameter beta : [ 1,  (+inf) [
  if ( (!((beta >=1))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter beta value " << beta << " out of range [ 1,  (+inf) [";
  }

//    Parameter nd : [ 0,  (+inf) [
  if ( (!((nd >=0))) )
  {
    UserWarning(*this) << "ADMSmvs_2_0_0_hemt: Parameter nd value " << nd << " out of range [ 0,  (+inf) [";
  }

  // and of course, this routine is where we should put the initial_model
  // stuff


  return true;
}
//----------------------------------------------------------------------------
// Function      : Model::processInstanceParams
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//----------------------------------------------------------------------------
bool Model::processInstanceParams()
{

  std::vector<Instance*>::iterator iter;
  std::vector<Instance*>::iterator first = instanceContainer.begin();
  std::vector<Instance*>::iterator last  = instanceContainer.end();

  for (iter=first; iter!=last; ++iter)
  {
    (*iter)->processParams();
  }

  return true;
}

//-----------------------------------------------------------------------------
// Function      : Model::Model
// Purpose       : model block constructor
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
Model::Model(
  const Configuration & configuration,
  const ModelBlock &    model_block,
  const FactoryBlock &  factory_block)
  : DeviceModel(model_block, configuration.getModelParameters(), factory_block),
    version(2.00),
    type(1),
    W(1.0e-6),
    Lgdr(80.0e-9),
    dLg(10.5e-9),
    Cins(3.17e-2),
    Tjun(300.0),
    energy_diff_volt(0.153),
    delta(0.120),
    n0(1.35),
    Rc0(160.0e-6),
    nacc(2.25e16),
    meff(0.041),
    np_mass(9.0),
    mu_eff(1.0),
    ksee(0.1),
    B(6.8e-9),
    dqm0(4.6e-9),
    eps(13.6),
    theta(2.5),
    beta(1.55),
    nd(0.0)
{
  // Set params to constant default values (from parTable):
  setDefaultParams();

  // Set params according to .model line and constant defaults from metadata:
  setModParams(model_block.params);

  if (!given("XYCEADMSMODTEMP"))
    admsModTemp=getDeviceOptions().temp.getImmutableValue<double>();

  // Calculate any parameters specified as expressions:

  updateDependentParameters();

  // calculate dependent (ie computed) params and check for errors:
  processParams();
}

//-----------------------------------------------------------------------------
// Function      : Model::~Model
// Purpose       : destructor
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
Model::~Model()
{
  std::vector<Instance*>::iterator iterI;
  std::vector<Instance*>::iterator firstI = instanceContainer.begin ();
  std::vector<Instance*>::iterator lastI  = instanceContainer.end ();

  // loop over instances:
  for (iterI = firstI; iterI != lastI; ++iterI)
  {
    delete (*iterI);
  }
}

//-----------------------------------------------------------------------------
// Function      : Model::printOutInstances
// Purpose       : debugging tool.
// Special Notes :
// Scope         : public
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------
std::ostream &Model::printOutInstances(std::ostream &os) const
{
  std::vector<Instance*>::const_iterator iter;
  std::vector<Instance*>::const_iterator first = instanceContainer.begin();
  std::vector<Instance*>::const_iterator last  = instanceContainer.end();

  int i;
  os << std::endl;
  os << "    name     model name  Parameters" << std::endl;
  for (i=0, iter=first; iter!=last; ++iter, ++i)
  {
    os << "  " << i << ": " << (*iter)->getName() << "      ";
    os << getName();

    os << std::endl;
    os << std::endl;
  }

  os << std::endl;

  return os;
}

//-----------------------------------------------------------------------------
// Function      : Model::forEachInstance
// Purpose       :
// Special Notes :
// Scope         : public
// Creator       : David Baur
// Creation Date : 2/4/2014
//-----------------------------------------------------------------------------
/// Apply a device instance "op" to all instances associated with this
/// model
///
/// @param[in] op Operator to apply to all instances.
///
///
void Model::forEachInstance(DeviceInstanceOp &op) const
{
  for (std::vector<Instance *>::const_iterator it = instanceContainer.begin(); it != instanceContainer.end(); ++it)
    op(*it);
}

Device *Traits::factory(const Configuration &configuration, const FactoryBlock &factory_block)
{
  return new DeviceMaster<Traits>(configuration, factory_block, factory_block.solverState_, factory_block.deviceOptions_);
}

void
registerDevice(const DeviceCountMap& deviceMap, const std::set<int>& levelSet)
{
if (deviceMap.empty() ||
((deviceMap.find("M") != deviceMap.end() && (levelSet.find(2001)!=levelSet.end()))))
{
MOSFET1::registerDevice();
  Config<Traits>::addConfiguration()
    .registerDevice("m", 2001)
    .registerModelType("nmos", 2001)
    .registerModelType("pmos", 2001);
}
}


#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Function      : evaluateInitialInstance
// Purpose       : Evaluate the statements in the initial_instance block
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void evaluateInitialInstance(
// model parameters
// reals
AdmsSensFadType & modelPar_version,
bool modelPar_given_version,
AdmsSensFadType & modelPar_W,
bool modelPar_given_W,
AdmsSensFadType & modelPar_Lgdr,
bool modelPar_given_Lgdr,
AdmsSensFadType & modelPar_dLg,
bool modelPar_given_dLg,
AdmsSensFadType & modelPar_Cins,
bool modelPar_given_Cins,
AdmsSensFadType & modelPar_Tjun,
bool modelPar_given_Tjun,
AdmsSensFadType & modelPar_energy_diff_volt,
bool modelPar_given_energy_diff_volt,
AdmsSensFadType & modelPar_delta,
bool modelPar_given_delta,
AdmsSensFadType & modelPar_n0,
bool modelPar_given_n0,
AdmsSensFadType & modelPar_Rc0,
bool modelPar_given_Rc0,
AdmsSensFadType & modelPar_nacc,
bool modelPar_given_nacc,
AdmsSensFadType & modelPar_meff,
bool modelPar_given_meff,
AdmsSensFadType & modelPar_np_mass,
bool modelPar_given_np_mass,
AdmsSensFadType & modelPar_mu_eff,
bool modelPar_given_mu_eff,
AdmsSensFadType & modelPar_ksee,
bool modelPar_given_ksee,
AdmsSensFadType & modelPar_B,
bool modelPar_given_B,
AdmsSensFadType & modelPar_dqm0,
bool modelPar_given_dqm0,
AdmsSensFadType & modelPar_eps,
bool modelPar_given_eps,
AdmsSensFadType & modelPar_theta,
bool modelPar_given_theta,
AdmsSensFadType & modelPar_beta,
bool modelPar_given_beta,
AdmsSensFadType & modelPar_nd,
bool modelPar_given_nd,
// non-reals (including hidden)
int modelPar_type,
bool modelPar_given_type,
 double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, const Instance & theInstance)
{
}



//-----------------------------------------------------------------------------
// Function      : evaluateInitialModel
// Purpose       : Evaluate the statements in the initial_model block
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void evaluateInitialModel(
// model parameters
// reals
AdmsSensFadType & modelPar_version,
bool modelPar_given_version,
AdmsSensFadType & modelPar_W,
bool modelPar_given_W,
AdmsSensFadType & modelPar_Lgdr,
bool modelPar_given_Lgdr,
AdmsSensFadType & modelPar_dLg,
bool modelPar_given_dLg,
AdmsSensFadType & modelPar_Cins,
bool modelPar_given_Cins,
AdmsSensFadType & modelPar_Tjun,
bool modelPar_given_Tjun,
AdmsSensFadType & modelPar_energy_diff_volt,
bool modelPar_given_energy_diff_volt,
AdmsSensFadType & modelPar_delta,
bool modelPar_given_delta,
AdmsSensFadType & modelPar_n0,
bool modelPar_given_n0,
AdmsSensFadType & modelPar_Rc0,
bool modelPar_given_Rc0,
AdmsSensFadType & modelPar_nacc,
bool modelPar_given_nacc,
AdmsSensFadType & modelPar_meff,
bool modelPar_given_meff,
AdmsSensFadType & modelPar_np_mass,
bool modelPar_given_np_mass,
AdmsSensFadType & modelPar_mu_eff,
bool modelPar_given_mu_eff,
AdmsSensFadType & modelPar_ksee,
bool modelPar_given_ksee,
AdmsSensFadType & modelPar_B,
bool modelPar_given_B,
AdmsSensFadType & modelPar_dqm0,
bool modelPar_given_dqm0,
AdmsSensFadType & modelPar_eps,
bool modelPar_given_eps,
AdmsSensFadType & modelPar_theta,
bool modelPar_given_theta,
AdmsSensFadType & modelPar_beta,
bool modelPar_given_beta,
AdmsSensFadType & modelPar_nd,
bool modelPar_given_nd,
// non-reals (including hidden)
int modelPar_type,
bool modelPar_given_type,
 double admsTemperature, double ADMSgmin_arg, const Instance & theInstance)
{
}



//-----------------------------------------------------------------------------
// Function      : evaluateModelEquations
// Purpose       : Evaluate the main module block.  Similar to
//                 updateIntermediateVars, but takes all instance and model
//                 parameters and variables as arguments instead of using
//                 the ones stored in the objects.
// Special Notes : specific for sensitivity use
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
void evaluateModelEquations(
std::vector <double> & probeVars,
// probe constants
const int admsProbeID_V_sf_GND,
const int admsProbeID_V_s_GND,
const int admsProbeID_V_d_GND,
const int admsProbeID_V_di_GND,
const int admsProbeID_V_si_GND,
const int admsProbeID_V_g_GND,
const int admsProbeID_I_sf_GND,
// node constants
const int admsNodeID_d,
const int admsNodeID_g,
const int admsNodeID_s,
const int admsNodeID_di,
const int admsNodeID_si,
const int admsNodeID_sf,
const int admsBRA_ID_sf_GND,
// model parameters
// reals
AdmsSensFadType & modelPar_version,
bool modelPar_given_version,
AdmsSensFadType & modelPar_W,
bool modelPar_given_W,
AdmsSensFadType & modelPar_Lgdr,
bool modelPar_given_Lgdr,
AdmsSensFadType & modelPar_dLg,
bool modelPar_given_dLg,
AdmsSensFadType & modelPar_Cins,
bool modelPar_given_Cins,
AdmsSensFadType & modelPar_Tjun,
bool modelPar_given_Tjun,
AdmsSensFadType & modelPar_energy_diff_volt,
bool modelPar_given_energy_diff_volt,
AdmsSensFadType & modelPar_delta,
bool modelPar_given_delta,
AdmsSensFadType & modelPar_n0,
bool modelPar_given_n0,
AdmsSensFadType & modelPar_Rc0,
bool modelPar_given_Rc0,
AdmsSensFadType & modelPar_nacc,
bool modelPar_given_nacc,
AdmsSensFadType & modelPar_meff,
bool modelPar_given_meff,
AdmsSensFadType & modelPar_np_mass,
bool modelPar_given_np_mass,
AdmsSensFadType & modelPar_mu_eff,
bool modelPar_given_mu_eff,
AdmsSensFadType & modelPar_ksee,
bool modelPar_given_ksee,
AdmsSensFadType & modelPar_B,
bool modelPar_given_B,
AdmsSensFadType & modelPar_dqm0,
bool modelPar_given_dqm0,
AdmsSensFadType & modelPar_eps,
bool modelPar_given_eps,
AdmsSensFadType & modelPar_theta,
bool modelPar_given_theta,
AdmsSensFadType & modelPar_beta,
bool modelPar_given_beta,
AdmsSensFadType & modelPar_nd,
bool modelPar_given_nd,
// non-reals (including hidden)
int modelPar_type,
bool modelPar_given_type,
// basic variables
 double admsTemperature, double adms_vt_nom, double ADMSgmin_arg, std::vector <AdmsSensFadType> & staticContributions, std::vector <AdmsSensFadType> & dynamicContributions, const Instance & theInstance)
{

  // Local variables
  AdmsSensFadType Rd;
  AdmsSensFadType Rs;
  AdmsSensFadType Idsatbeta;
  AdmsSensFadType Id_sat;
  AdmsSensFadType Qacc;
  AdmsSensFadType Id;
  AdmsSensFadType vx0;
  AdmsSensFadType Fsat;
  AdmsSensFadType Vdsatbeta;
  AdmsSensFadType Vdsat;
  AdmsSensFadType f1;
  AdmsSensFadType n;
  AdmsSensFadType Cgc;
  AdmsSensFadType Cstern;
  AdmsSensFadType xav;
  AdmsSensFadType QB;
  AdmsSensFadType Qx0;
  AdmsSensFadType Tx;
  AdmsSensFadType Lcrit;
  AdmsSensFadType Lcrit_sat;
  AdmsSensFadType Lcrit_lin;
  AdmsSensFadType f2;
  AdmsSensFadType Vdsatbeta2;
  AdmsSensFadType Vdsat2;
  AdmsSensFadType vT_acc;
  AdmsSensFadType extr_coef_acc;
  AdmsSensFadType FDhalfs_acc;
  AdmsSensFadType c1_acc;
  AdmsSensFadType den1_acc;
  AdmsSensFadType A1_acc;
  AdmsSensFadType expMeta_acc;
  AdmsSensFadType expu_acc;
  AdmsSensFadType exp_eta_acc;
  AdmsSensFadType eta_acc;
  AdmsSensFadType vT;
  AdmsSensFadType lambda;
  AdmsSensFadType dgen_lambda;
  AdmsSensFadType FDminushalfs;
  AdmsSensFadType t2_fd1;
  AdmsSensFadType den_t1_fd1;
  AdmsSensFadType aterm1;
  double num_t1_fd1;
  double c_pow1;
  double b_pow1;
  double a_pow1;
  double j_pow1;
  AdmsSensFadType u1;
  AdmsSensFadType extr_coef;
  AdmsSensFadType FDhalfs;
  AdmsSensFadType c1;
  AdmsSensFadType den1;
  AdmsSensFadType A1;
  AdmsSensFadType expMeta;
  AdmsSensFadType NP_fac_velocity;
  AdmsSensFadType NP_fac_lambda;
  AdmsSensFadType meff_np;
  AdmsSensFadType Fd;
  AdmsSensFadType Ed_sq;
  AdmsSensFadType ffd;
  AdmsSensFadType expEd;
  double sign_Ed;
  AdmsSensFadType Ed;
  AdmsSensFadType Fs;
  AdmsSensFadType Es_sq;
  AdmsSensFadType ffs;
  AdmsSensFadType expEs;
  double sign_Es;
  AdmsSensFadType Es;
  AdmsSensFadType N2D;
  AdmsSensFadType lambda_int;
  AdmsSensFadType vT_int;
  AdmsSensFadType mD0;
  double sqrt_pi;
  double hbar;
  AdmsSensFadType kT;
  AdmsSensFadType phit;
  AdmsSensFadType Rc;
  AdmsSensFadType Leff;
  double dir;
  AdmsSensFadType Vgsi;
  AdmsSensFadType Vdsi;
  AdmsSensFadType Vgs;
  AdmsSensFadType Vds;
  AdmsSensFadType Vgdraw;
  AdmsSensFadType Vgsraw;


  // -- code converted from analog/code block
Vgsraw = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_si_GND])));
Vgdraw = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_di_GND])));
if ((Vgsraw>=Vgdraw))
{
Vds = (modelPar_type*((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_s_GND])));
Vgs = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_s_GND])));
Vdsi = (modelPar_type*((probeVars[admsProbeID_V_di_GND])-(probeVars[admsProbeID_V_si_GND])));
Vgsi = Vgsraw;
dir = 1;
}
else
{
Vds = (modelPar_type*((probeVars[admsProbeID_V_s_GND])-(probeVars[admsProbeID_V_d_GND])));
Vgs = (modelPar_type*((probeVars[admsProbeID_V_g_GND])-(probeVars[admsProbeID_V_d_GND])));
Vdsi = (modelPar_type*((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_di_GND])));
Vgsi = Vgdraw;
dir = (-1);
}
Leff = (modelPar_Lgdr-modelPar_dLg);
Rc = (modelPar_Rc0/modelPar_W);
phit = ((1.3806503e-23*modelPar_Tjun)/1.6021766208e-19);
kT = (1.3806503e-23*modelPar_Tjun);
hbar = (6.62607004081e-34/(2.0*3.14159265358979323846));
sqrt_pi = sqrt(static_cast<double>(3.14159265358979323846));
mD0 = (modelPar_meff*9.10938215e-31);
vT_int = sqrt(((((2.0*kT)/3.14159265358979323846)*1.0)/mD0));
lambda_int = (((2.0*phit)*modelPar_mu_eff)/vT_int);
N2D = ((mD0/((3.14159265358979323846*hbar)*hbar))*kT);
Es = ((modelPar_energy_diff_volt+(probeVars[admsProbeID_V_sf_GND]))/phit);
if ((Es>0))
{
sign_Es = 1.0;
}
else
{
if ((Es==0))
{
sign_Es = 0;
}
else
{
if ((Es<0))
{
sign_Es = (-1.0);
}
}
}
expEs = exp(Es);
if ((Es>=40))
{
ffs = 0;
}
else
{
ffs = (1.0/(1.0+(expEs*0.6)));
}
Es_sq = ((((1.0+sign_Es)*Es)*Es)/4.0);
Fs = (log((1.0+expEs))+((modelPar_np_mass*phit)*((ffs*expEs)+((1-ffs)*Es_sq))));
Ed = (((modelPar_energy_diff_volt+(probeVars[admsProbeID_V_sf_GND]))-Vdsi)/phit);
if ((Ed>0))
{
sign_Ed = 1.0;
}
else
{
if ((Ed==0))
{
sign_Ed = 0;
}
else
{
if ((Ed<0))
{
sign_Ed = (-1.0);
}
}
}
expEd = exp(Ed);
if ((Ed>=40))
{
ffd = 0;
}
else
{
ffd = (1.0/(1.0+(expEd*0.6)));
}
Ed_sq = ((((1.0+sign_Ed)*Ed)*Ed)/4.0);
Fd = (log((1.0+expEd))+((modelPar_np_mass*phit)*((ffd*expEd)+((1.0-ffd)*Ed_sq))));
if ((Es>=40))
{
meff_np = (Fs/expEs);
}
else
{
meff_np = (Fs/log((1.0+expEs)));
}
NP_fac_lambda = sqrt(meff_np);
NP_fac_velocity = (1.0/NP_fac_lambda);
expMeta = (1.0/expEs);
A1 = ((50.0+pow(Es,4.0))+((33.6*Es)*(1-(0.68*exp((((-0.17)*(1.0+Es))*(1.0+Es)))))));
den1 = pow(A1,(3.0/8.0));
c1 = (((3.0/4.0)*sqrt_pi)/den1);
FDhalfs = (1.0/(c1+expMeta));
extr_coef = (FDhalfs/log((1.0+expEs)));
u1 = Es;
j_pow1 = (-0.5);
a_pow1 = sqrt(((1.0+((15.0/4.0)*(j_pow1+1.0)))+(((1.0/40.0)*(j_pow1+1.0))*(j_pow1+1.0))));
b_pow1 = (1.8+(0.61*j_pow1));
c_pow1 = (2.0+((2.0-sqrt(static_cast<double>(2.0)))*pow(2.0,(-j_pow1))));
num_t1_fd1 = ((j_pow1+1.0)*pow(2.0,(1.0+j_pow1)));
aterm1 = pow((((b_pow1+u1)+pow(a_pow1,c_pow1))+pow(fabs((u1-b_pow1)),c_pow1)),(1.0/c_pow1));
den_t1_fd1 = pow(aterm1,(1.0+j_pow1));
t2_fd1 = (exp((-u1))/sqrt(static_cast<double>(3.14159265358979323846)));
FDminushalfs = ((1.0/sqrt(static_cast<double>(3.14159265358979323846)))*pow(((num_t1_fd1/den_t1_fd1)+t2_fd1),(-1.0)));
dgen_lambda = (log((1.0+expEs))/FDminushalfs);
lambda = ((lambda_int*NP_fac_lambda)*dgen_lambda);
vT = ((vT_int*NP_fac_velocity)*extr_coef);
eta_acc = log((exp((modelPar_nacc/N2D))-1.0));
exp_eta_acc = (exp((modelPar_nacc/N2D))-1.0);
expu_acc = exp_eta_acc;
expMeta_acc = (1.0/expu_acc);
A1_acc = ((50.0+pow(eta_acc,4.0))+((33.6*eta_acc)*(1-(0.68*exp((((-0.17)*(1.0+eta_acc))*(1.0+eta_acc)))))));
den1_acc = pow(A1_acc,(3.0/8.0));
c1_acc = (((3.0/4.0)*sqrt_pi)/den1_acc);
FDhalfs_acc = (1.0/(c1_acc+expMeta_acc));
extr_coef_acc = (FDhalfs_acc/log((1.0+exp_eta_acc)));
vT_acc = (vT_int*extr_coef_acc);
Vdsat2 = (modelPar_theta*phit);
Vdsatbeta2 = pow(fabs((Vdsi/Vdsat2)),modelPar_beta);
f2 = (fabs((Vdsi/Vdsat2))/pow((1.0+Vdsatbeta2),(1.0/modelPar_beta)));
Lcrit_lin = Leff;
Lcrit_sat = (modelPar_ksee*Leff);
Lcrit = (((1.0-f2)*Lcrit_lin)+(f2*Lcrit_sat));
Tx = (lambda/(lambda+Lcrit));
Qx0 = ((((-1.6021766208e-19)*N2D)/2.0)*((Fs*(2.0-Tx))+(Fd*Tx)));
QB = pow(fabs((modelPar_B/modelPar_dqm0)),3.0);
xav = (modelPar_B/pow((QB+((11.0/32.0)*fabs(Qx0))),(1/3.0)));
Cstern = ((modelPar_eps*8.854187817e-12)/xav);
Cgc = ((modelPar_Cins*Cstern)/(modelPar_Cins+Cstern));
n = (modelPar_n0+fabs((modelPar_nd*Vdsi)));
// V(sf,GND) <+ ((((Vgsi+(delta*Vdsi))+(Qx0/Cgc))/n))
staticContributions[admsBRA_ID_sf_GND] += (((Vgsi+(modelPar_delta*Vdsi))+(Qx0/Cgc))/n);
f1 = ((((2.0-Tx)*Fs)+(Tx*Fd))/(2.0*Fs));
Vdsat = ((((2.0*phit)*(lambda+Leff))/(lambda+((2.0*modelPar_ksee)*Leff)))*f1);
Vdsatbeta = pow(fabs((Vdsi/Vdsat)),modelPar_beta);
Fsat = (fabs((Vdsi/Vdsat))/pow((1.0+Vdsatbeta),(1.0/modelPar_beta)));
vx0 = ((vT*lambda)/(lambda+((2.0*modelPar_ksee)*Leff)));
Id = (((fabs(Qx0)*Fsat)*vx0)*modelPar_W);
Qacc = (1.6021766208e-19*modelPar_nacc);
Id_sat = ((modelPar_W*Qacc)*vT_acc);
Idsatbeta = pow(fabs((Id/Id_sat)),modelPar_beta);
Rs = (Rc/pow((1-Idsatbeta),(1.0/modelPar_beta)));
Rd = Rs;
// I(di,si) <+ (((type*dir)*Id))
staticContributions[admsNodeID_di] += ((modelPar_type*dir)*Id);
staticContributions[admsNodeID_si] -= ((modelPar_type*dir)*Id);
// I(d,di) <+ (((V(d,GND)-V(di,GND))/Rd))
staticContributions[admsNodeID_d] += (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
staticContributions[admsNodeID_di] -= (((probeVars[admsProbeID_V_d_GND])-(probeVars[admsProbeID_V_di_GND]))/Rd);
// I(si,s) <+ (((V(si,GND)-V(s,GND))/Rs))
staticContributions[admsNodeID_si] += (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
staticContributions[admsNodeID_s] -= (((probeVars[admsProbeID_V_si_GND])-(probeVars[admsProbeID_V_s_GND]))/Rs);
}



//-----------------------------------------------------------------------------
// Function      : InstanceSensitivity::operator()
// Purpose       : return sensitivity for a single instance parameter
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
/// Compute sensitivity of a device instance's outputs to a specified instance
/// parameter
///
///
/// @param[in] entity  The device entity that owns the parameter
/// @param[in] name    The unadorned parameter name specific to the entity
/// @param[out] dfdp   The derivative of the F vector with respect to the parameter
/// @param[out] dqdp   The derivative of the Q vector with respect to the parameter
/// @param[out] dbdp   The derivative of the B vector with respect to the parameter
/// @param[out] Findices   The indices into the F vector corresponding to the elements of dfdp
/// @param[out] Qindices   The indices into the Q vector corresponding to the elements of dfdp
/// @param[out] Bindices   The indices into the B vector corresponding to the elements of dfdp
///
///
void InstanceSensitivity::operator()
(
const ParameterBase &entity,
const std::string &name,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const
{
const ParameterBase * e1 = &entity;
const Instance & in = *(dynamic_cast<const Instance *> (e1));
const Model & mod =in.model_;

dfdp.resize(6+1);
dqdp.resize(6+1);
Findices.resize(6+1);
Qindices.resize(6+1);

std::vector <double> probeVars(7);
std::vector <AdmsSensFadType> staticContributions(6+1);
std::vector <AdmsSensFadType> dynamicContributions(6+1);


// initialize contributions to zero (automatically sets derivatives to zero)
for (int i=0; i < 6+1 ; ++i)
{
   staticContributions[i]=0;
   dynamicContributions[i]=0;
}

// Copy out all the model parameters (doubles) into FAD types
//reals
AdmsSensFadType modelPar_version=mod.version;
bool modelPar_given_version=mod.given("version");
AdmsSensFadType modelPar_W=mod.W;
bool modelPar_given_W=mod.given("W");
AdmsSensFadType modelPar_Lgdr=mod.Lgdr;
bool modelPar_given_Lgdr=mod.given("Lgdr");
AdmsSensFadType modelPar_dLg=mod.dLg;
bool modelPar_given_dLg=mod.given("dLg");
AdmsSensFadType modelPar_Cins=mod.Cins;
bool modelPar_given_Cins=mod.given("Cins");
AdmsSensFadType modelPar_Tjun=mod.Tjun;
bool modelPar_given_Tjun=mod.given("Tjun");
AdmsSensFadType modelPar_energy_diff_volt=mod.energy_diff_volt;
bool modelPar_given_energy_diff_volt=mod.given("energy_diff_volt");
AdmsSensFadType modelPar_delta=mod.delta;
bool modelPar_given_delta=mod.given("delta");
AdmsSensFadType modelPar_n0=mod.n0;
bool modelPar_given_n0=mod.given("n0");
AdmsSensFadType modelPar_Rc0=mod.Rc0;
bool modelPar_given_Rc0=mod.given("Rc0");
AdmsSensFadType modelPar_nacc=mod.nacc;
bool modelPar_given_nacc=mod.given("nacc");
AdmsSensFadType modelPar_meff=mod.meff;
bool modelPar_given_meff=mod.given("meff");
AdmsSensFadType modelPar_np_mass=mod.np_mass;
bool modelPar_given_np_mass=mod.given("np_mass");
AdmsSensFadType modelPar_mu_eff=mod.mu_eff;
bool modelPar_given_mu_eff=mod.given("mu_eff");
AdmsSensFadType modelPar_ksee=mod.ksee;
bool modelPar_given_ksee=mod.given("ksee");
AdmsSensFadType modelPar_B=mod.B;
bool modelPar_given_B=mod.given("B");
AdmsSensFadType modelPar_dqm0=mod.dqm0;
bool modelPar_given_dqm0=mod.given("dqm0");
AdmsSensFadType modelPar_eps=mod.eps;
bool modelPar_given_eps=mod.given("eps");
AdmsSensFadType modelPar_theta=mod.theta;
bool modelPar_given_theta=mod.given("theta");
AdmsSensFadType modelPar_beta=mod.beta;
bool modelPar_given_beta=mod.given("beta");
AdmsSensFadType modelPar_nd=mod.nd;
bool modelPar_given_nd=mod.given("nd");


// hidden reals


// non-reals (including hiddens)
int modelPar_type=mod.type;
bool modelPar_given_type=mod.given("type");



// Copy out all the instance parameters (doubles) into FAD types
// Keep a map so we can set the right one to the independent variable
// We do this solely to avoid a big ugly "if/else" block just to find the
// one parameter we're doing sensitivities on.
unordered_map <std::string,AdmsSensFadType*,HashNoCase,EqualNoCase> inParamMap;

// reals


// Copy all the real hidden instance params into fad types



// Copy all the non-real instance params into vars of their appropriate type:


// Set the one parameter whose name was passed in to be the independent
// variable for Sacado purposes.  Since we stored variable pointers, this
// makes sure that that ONE variable gets set right.
// FIXME: make this check the name first, otherwise segfault on invalid name!
inParamMap[name]->diff(0,1);

//make local copies of all instance vars
//reals


//non-reals


//make local copies of all model vars
//reals


// non-reals



Linear::Vector * solVectorPtr = in.extData.nextSolVectorPtr;

// extract solution variables and set as Fad independent variables.
probeVars[in.admsProbeID_V_sf_GND] = (*solVectorPtr)[in.li_sf];
probeVars[in.admsProbeID_V_s_GND] = (*solVectorPtr)[in.li_s];
probeVars[in.admsProbeID_V_d_GND] = (*solVectorPtr)[in.li_d];
probeVars[in.admsProbeID_V_di_GND] = (*solVectorPtr)[in.li_di];
probeVars[in.admsProbeID_V_si_GND] = (*solVectorPtr)[in.li_si];
probeVars[in.admsProbeID_V_g_GND] = (*solVectorPtr)[in.li_g];

    probeVars[in.admsProbeID_I_sf_GND] = (*solVectorPtr)[in.li_BRA_sf_GND];



// Now call  the function that does the heavy lifting.
evaluateModelEquations(
probeVars,
// probe constants
in.admsProbeID_V_sf_GND,
in.admsProbeID_V_s_GND,
in.admsProbeID_V_d_GND,
in.admsProbeID_V_di_GND,
in.admsProbeID_V_si_GND,
in.admsProbeID_V_g_GND,
in.admsProbeID_I_sf_GND,

// node constants
in.admsNodeID_d,
in.admsNodeID_g,
in.admsNodeID_s,
in.admsNodeID_di,
in.admsNodeID_si,
in.admsNodeID_sf,
in.admsBRA_ID_sf_GND,
// model parameters
// reals
modelPar_version,
modelPar_given_version,
modelPar_W,
modelPar_given_W,
modelPar_Lgdr,
modelPar_given_Lgdr,
modelPar_dLg,
modelPar_given_dLg,
modelPar_Cins,
modelPar_given_Cins,
modelPar_Tjun,
modelPar_given_Tjun,
modelPar_energy_diff_volt,
modelPar_given_energy_diff_volt,
modelPar_delta,
modelPar_given_delta,
modelPar_n0,
modelPar_given_n0,
modelPar_Rc0,
modelPar_given_Rc0,
modelPar_nacc,
modelPar_given_nacc,
modelPar_meff,
modelPar_given_meff,
modelPar_np_mass,
modelPar_given_np_mass,
modelPar_mu_eff,
modelPar_given_mu_eff,
modelPar_ksee,
modelPar_given_ksee,
modelPar_B,
modelPar_given_B,
modelPar_dqm0,
modelPar_given_dqm0,
modelPar_eps,
modelPar_given_eps,
modelPar_theta,
modelPar_given_theta,
modelPar_beta,
modelPar_given_beta,
modelPar_nd,
modelPar_given_nd,
// non-reals (including hidden)
 modelPar_type,
modelPar_given_type,
 in.admsTemperature,
 in.adms_vt_nom,
 in.getDeviceOptions().gmin,
 staticContributions,
 dynamicContributions,
 in);


// We now have the F and Q vector stuff, populate the dependencies:

    dfdp[in.admsNodeID_d] += staticContributions[in.admsNodeID_d].dx(0);
    dqdp[in.admsNodeID_d] += dynamicContributions[in.admsNodeID_d].dx(0);
    Findices[in.admsNodeID_d] = in.li_d;
    Qindices[in.admsNodeID_d] = in.li_d;
    dfdp[in.admsNodeID_g] += staticContributions[in.admsNodeID_g].dx(0);
    dqdp[in.admsNodeID_g] += dynamicContributions[in.admsNodeID_g].dx(0);
    Findices[in.admsNodeID_g] = in.li_g;
    Qindices[in.admsNodeID_g] = in.li_g;
    dfdp[in.admsNodeID_s] += staticContributions[in.admsNodeID_s].dx(0);
    dqdp[in.admsNodeID_s] += dynamicContributions[in.admsNodeID_s].dx(0);
    Findices[in.admsNodeID_s] = in.li_s;
    Qindices[in.admsNodeID_s] = in.li_s;
    dfdp[in.admsNodeID_di] += staticContributions[in.admsNodeID_di].dx(0);
    dqdp[in.admsNodeID_di] += dynamicContributions[in.admsNodeID_di].dx(0);
    Findices[in.admsNodeID_di] = in.li_di;
    Qindices[in.admsNodeID_di] = in.li_di;
    dfdp[in.admsNodeID_si] += staticContributions[in.admsNodeID_si].dx(0);
    dqdp[in.admsNodeID_si] += dynamicContributions[in.admsNodeID_si].dx(0);
    Findices[in.admsNodeID_si] = in.li_si;
    Qindices[in.admsNodeID_si] = in.li_si;
    dfdp[in.admsNodeID_sf] += staticContributions[in.admsNodeID_sf].dx(0);
    dqdp[in.admsNodeID_sf] += dynamicContributions[in.admsNodeID_sf].dx(0);
    Findices[in.admsNodeID_sf] = in.li_sf;
    Qindices[in.admsNodeID_sf] = in.li_sf;
  dfdp[in.admsBRA_ID_sf_GND] += staticContributions[in.admsBRA_ID_sf_GND].dx(0);
  dqdp[in.admsBRA_ID_sf_GND] += dynamicContributions[in.admsBRA_ID_sf_GND].dx(0);
  Findices[in.admsBRA_ID_sf_GND] = in.li_BRA_sf_GND;
  Qindices[in.admsBRA_ID_sf_GND] = in.li_BRA_sf_GND;


}

//-----------------------------------------------------------------------------
// Function      : ModelSensitivity::operator()
// Purpose       : return sensitivity for a single model parameter
// Special Notes :
// Scope         : public
// Creator       : admsXml
// Creation Date :
//-----------------------------------------------------------------------------
/// Compute sensitivity to a specified model
/// parameter of all device instances of that model's outputs
///
///
/// @param[in] entity  The device entity that owns the parameter
/// @param[in] name    The unadorned parameter name specific to the entity
/// @param[out] dfdp   The derivative of the F vector with respect to the parameter
/// @param[out] dqdp   The derivative of the Q vector with respect to the parameter
/// @param[out] dbdp   The derivative of the B vector with respect to the parameter
/// @param[out] Findices   The indices into the F vector corresponding to the elements of dfdp
/// @param[out] Qindices   The indices into the Q vector corresponding to the elements of dfdp
/// @param[out] Bindices   The indices into the B vector corresponding to the elements of dfdp
///
///
void ModelSensitivity::operator()
(
const ParameterBase &entity,
const std::string &name,
std::vector<double> & dfdp,
std::vector<double> & dqdp,
std::vector<double> & dbdp,
std::vector<int> & Findices,
std::vector<int> & Qindices,
std::vector<int> & Bindices
) const
{
const ParameterBase * e1 = &entity;
const Model & mod = *(dynamic_cast<const Model *> (e1));
int sizeInstance = mod.instanceContainer.size();

dfdp.resize((6+1)*sizeInstance);
dqdp.resize((6+1)*sizeInstance);
Findices.resize((6+1)*sizeInstance);
Qindices.resize((6+1)*sizeInstance);

std::vector <double> probeVars(7);
std::vector <AdmsSensFadType> staticContributions(6+1);
std::vector <AdmsSensFadType> dynamicContributions(6+1);


// Copy out all the model parameters (doubles) into FAD types
// Keep a map so we can set the right one to the independent variable
// We do this solely to avoid a big ugly "if/else" block just to find the
// one parameter we're doing sensitivities on.
unordered_map <std::string,AdmsSensFadType*,HashNoCase,EqualNoCase> modParamMap;

// reals
AdmsSensFadType modelPar_version=mod.version;
bool modelPar_given_version=mod.given("version");
modParamMap["version"] = &modelPar_version;
AdmsSensFadType modelPar_W=mod.W;
bool modelPar_given_W=mod.given("W");
modParamMap["W"] = &modelPar_W;
AdmsSensFadType modelPar_Lgdr=mod.Lgdr;
bool modelPar_given_Lgdr=mod.given("Lgdr");
modParamMap["Lgdr"] = &modelPar_Lgdr;
AdmsSensFadType modelPar_dLg=mod.dLg;
bool modelPar_given_dLg=mod.given("dLg");
modParamMap["dLg"] = &modelPar_dLg;
AdmsSensFadType modelPar_Cins=mod.Cins;
bool modelPar_given_Cins=mod.given("Cins");
modParamMap["Cins"] = &modelPar_Cins;
AdmsSensFadType modelPar_Tjun=mod.Tjun;
bool modelPar_given_Tjun=mod.given("Tjun");
modParamMap["Tjun"] = &modelPar_Tjun;
AdmsSensFadType modelPar_energy_diff_volt=mod.energy_diff_volt;
bool modelPar_given_energy_diff_volt=mod.given("energy_diff_volt");
modParamMap["energy_diff_volt"] = &modelPar_energy_diff_volt;
AdmsSensFadType modelPar_delta=mod.delta;
bool modelPar_given_delta=mod.given("delta");
modParamMap["delta"] = &modelPar_delta;
AdmsSensFadType modelPar_n0=mod.n0;
bool modelPar_given_n0=mod.given("n0");
modParamMap["n0"] = &modelPar_n0;
AdmsSensFadType modelPar_Rc0=mod.Rc0;
bool modelPar_given_Rc0=mod.given("Rc0");
modParamMap["Rc0"] = &modelPar_Rc0;
AdmsSensFadType modelPar_nacc=mod.nacc;
bool modelPar_given_nacc=mod.given("nacc");
modParamMap["nacc"] = &modelPar_nacc;
AdmsSensFadType modelPar_meff=mod.meff;
bool modelPar_given_meff=mod.given("meff");
modParamMap["meff"] = &modelPar_meff;
AdmsSensFadType modelPar_np_mass=mod.np_mass;
bool modelPar_given_np_mass=mod.given("np_mass");
modParamMap["np_mass"] = &modelPar_np_mass;
AdmsSensFadType modelPar_mu_eff=mod.mu_eff;
bool modelPar_given_mu_eff=mod.given("mu_eff");
modParamMap["mu_eff"] = &modelPar_mu_eff;
AdmsSensFadType modelPar_ksee=mod.ksee;
bool modelPar_given_ksee=mod.given("ksee");
modParamMap["ksee"] = &modelPar_ksee;
AdmsSensFadType modelPar_B=mod.B;
bool modelPar_given_B=mod.given("B");
modParamMap["B"] = &modelPar_B;
AdmsSensFadType modelPar_dqm0=mod.dqm0;
bool modelPar_given_dqm0=mod.given("dqm0");
modParamMap["dqm0"] = &modelPar_dqm0;
AdmsSensFadType modelPar_eps=mod.eps;
bool modelPar_given_eps=mod.given("eps");
modParamMap["eps"] = &modelPar_eps;
AdmsSensFadType modelPar_theta=mod.theta;
bool modelPar_given_theta=mod.given("theta");
modParamMap["theta"] = &modelPar_theta;
AdmsSensFadType modelPar_beta=mod.beta;
bool modelPar_given_beta=mod.given("beta");
modParamMap["beta"] = &modelPar_beta;
AdmsSensFadType modelPar_nd=mod.nd;
bool modelPar_given_nd=mod.given("nd");
modParamMap["nd"] = &modelPar_nd;


// hidden reals


// non-reals (including hiddens)
int modelPar_type=mod.type;
bool modelPar_given_type=mod.given("type");


// Set the one parameter whose name was passed in to be the independent
// variable for Sacado purposes.  Since we stored variable pointers, this
// makes sure that that ONE variable gets set right.
// FIXME: make this check name for presence first!  Segfault on invalid.
modParamMap[name]->diff(0,1);

//make local copies of all model vars
//reals


// non-reals



// Now loop over all instances and do the deed
int inst=0;
for (std::vector<Instance*>::const_iterator in_it=mod.instanceContainer.begin(); in_it != mod.instanceContainer.end(); ++in_it,++inst)
{

  Instance & in=*(*in_it);
  // initialize contributions to zero (automatically sets derivatives to zero)
  for (int i=0; i < 6+1 ; ++i)
  {
  staticContributions[i]=0;
  dynamicContributions[i]=0;
  }



  // Copy out all the instance parameters (doubles) into FAD types
  // reals


  // real hidden instance


  // Copy all the non-real instance params into vars of their appropriate type:




  // If there are any instance parameters that were not given, and have
  // corresponding model params, copy the model param into the instance.
  // This was already done by the instance constructor, but we do it again
  // because now we're propagating derivatives, and the user could be trying
  // to get sensitivity to the model parameter.


  //make local copies of all instance vars
  //reals


  //non-reals



  Linear::Vector * solVectorPtr = in.extData.nextSolVectorPtr;

  // extract solution variables and set as Fad independent variables.
probeVars[in.admsProbeID_V_sf_GND] = (*solVectorPtr)[in.li_sf];
probeVars[in.admsProbeID_V_s_GND] = (*solVectorPtr)[in.li_s];
probeVars[in.admsProbeID_V_d_GND] = (*solVectorPtr)[in.li_d];
probeVars[in.admsProbeID_V_di_GND] = (*solVectorPtr)[in.li_di];
probeVars[in.admsProbeID_V_si_GND] = (*solVectorPtr)[in.li_si];
probeVars[in.admsProbeID_V_g_GND] = (*solVectorPtr)[in.li_g];
probeVars[in.admsProbeID_I_sf_GND] = (*solVectorPtr)[in.li_BRA_sf_GND];




// Now call  the function that does the heavy lifting.

evaluateModelEquations(
probeVars,
// probe constants
in.admsProbeID_V_sf_GND,
in.admsProbeID_V_s_GND,
in.admsProbeID_V_d_GND,
in.admsProbeID_V_di_GND,
in.admsProbeID_V_si_GND,
in.admsProbeID_V_g_GND,
in.admsProbeID_I_sf_GND,

// node constants
in.admsNodeID_d,
in.admsNodeID_g,
in.admsNodeID_s,
in.admsNodeID_di,
in.admsNodeID_si,
in.admsNodeID_sf,
in.admsBRA_ID_sf_GND,
// model parameters
// reals
modelPar_version,
modelPar_given_version,
modelPar_W,
modelPar_given_W,
modelPar_Lgdr,
modelPar_given_Lgdr,
modelPar_dLg,
modelPar_given_dLg,
modelPar_Cins,
modelPar_given_Cins,
modelPar_Tjun,
modelPar_given_Tjun,
modelPar_energy_diff_volt,
modelPar_given_energy_diff_volt,
modelPar_delta,
modelPar_given_delta,
modelPar_n0,
modelPar_given_n0,
modelPar_Rc0,
modelPar_given_Rc0,
modelPar_nacc,
modelPar_given_nacc,
modelPar_meff,
modelPar_given_meff,
modelPar_np_mass,
modelPar_given_np_mass,
modelPar_mu_eff,
modelPar_given_mu_eff,
modelPar_ksee,
modelPar_given_ksee,
modelPar_B,
modelPar_given_B,
modelPar_dqm0,
modelPar_given_dqm0,
modelPar_eps,
modelPar_given_eps,
modelPar_theta,
modelPar_given_theta,
modelPar_beta,
modelPar_given_beta,
modelPar_nd,
modelPar_given_nd,
// non-reals (including hidden)
 modelPar_type,
modelPar_given_type,
 in.admsTemperature,
 in.adms_vt_nom,
 in.getDeviceOptions().gmin,
 staticContributions,
 dynamicContributions,
 in);


  // We now have the F and Q vector stuff, populate the dependencies:

    dfdp[in.admsNodeID_d+inst*(6+1)] += staticContributions[in.admsNodeID_d].dx(0);
    dqdp[in.admsNodeID_d+inst*(6+1)] += dynamicContributions[in.admsNodeID_d].dx(0);
    Findices[in.admsNodeID_d+inst*(6+1)] = in.li_d;
    Qindices[in.admsNodeID_d+inst*(6+1)] = in.li_d;
    dfdp[in.admsNodeID_g+inst*(6+1)] += staticContributions[in.admsNodeID_g].dx(0);
    dqdp[in.admsNodeID_g+inst*(6+1)] += dynamicContributions[in.admsNodeID_g].dx(0);
    Findices[in.admsNodeID_g+inst*(6+1)] = in.li_g;
    Qindices[in.admsNodeID_g+inst*(6+1)] = in.li_g;
    dfdp[in.admsNodeID_s+inst*(6+1)] += staticContributions[in.admsNodeID_s].dx(0);
    dqdp[in.admsNodeID_s+inst*(6+1)] += dynamicContributions[in.admsNodeID_s].dx(0);
    Findices[in.admsNodeID_s+inst*(6+1)] = in.li_s;
    Qindices[in.admsNodeID_s+inst*(6+1)] = in.li_s;
    dfdp[in.admsNodeID_di+inst*(6+1)] += staticContributions[in.admsNodeID_di].dx(0);
    dqdp[in.admsNodeID_di+inst*(6+1)] += dynamicContributions[in.admsNodeID_di].dx(0);
    Findices[in.admsNodeID_di+inst*(6+1)] = in.li_di;
    Qindices[in.admsNodeID_di+inst*(6+1)] = in.li_di;
    dfdp[in.admsNodeID_si+inst*(6+1)] += staticContributions[in.admsNodeID_si].dx(0);
    dqdp[in.admsNodeID_si+inst*(6+1)] += dynamicContributions[in.admsNodeID_si].dx(0);
    Findices[in.admsNodeID_si+inst*(6+1)] = in.li_si;
    Qindices[in.admsNodeID_si+inst*(6+1)] = in.li_si;
    dfdp[in.admsNodeID_sf+inst*(6+1)] += staticContributions[in.admsNodeID_sf].dx(0);
    dqdp[in.admsNodeID_sf+inst*(6+1)] += dynamicContributions[in.admsNodeID_sf].dx(0);
    Findices[in.admsNodeID_sf+inst*(6+1)] = in.li_sf;
    Qindices[in.admsNodeID_sf+inst*(6+1)] = in.li_sf;
    dfdp[in.admsBRA_ID_sf_GND+inst*(6+1)] += staticContributions[in.admsBRA_ID_sf_GND].dx(0);
    dqdp[in.admsBRA_ID_sf_GND+inst*(6+1)] += dynamicContributions[in.admsBRA_ID_sf_GND].dx(0);
    Findices[in.admsBRA_ID_sf_GND+inst*(6+1)] = in.li_BRA_sf_GND;
    Qindices[in.admsBRA_ID_sf_GND+inst*(6+1)] = in.li_BRA_sf_GND;
}

}

#endif // Xyce_ADMS_SENSITIVITIES

} // namespace ADMSmvs_2_0_0_hemt
} // namespace Device
} // namespace Xyce
