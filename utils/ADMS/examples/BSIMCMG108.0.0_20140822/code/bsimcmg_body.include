// ********************************************************
// ********************************************************
// **** BSIM-CMG 108.0.0 released by by Sourabh Khandelwal on 08/22/2014 ****/
// *  BSIM Common Multi-Gate Model Equations (Verilog-A)
// ********************************************************
//
// ********************************************************
// * Copyright 2014 Regents of the University of California. 
// * All rights reserved.
// *
// * Project Director: Prof. Chenming Hu.
// * Authors: Sriramkumar V., Navid Paydavosi, Juan Duarte, Sourabh Khandelwal, Darsen Lu, 
// *          Chung-Hsun Lin, Mohan Dunga, Shijing Yao,
// *          Ali Niknejad, Chenming Hu
// ********************************************************
// ********************************************************
// *   NONDISCLOSURE STATEMENT
// Software is distributed as is, completely without warranty or service
// support. The University of California and its employees are not liable
// for the condition or performance of the software.
// The University of California owns the copyright and grants users a perpetual,
// irrevocable, worldwide, non-exclusive, royalty-free license with 
// respect to the software as set forth below.
// The University of California hereby disclaims all implied warranties.
// The University of California grants the users the right to modify, copy,
// and redistribute the software and documentation, both within the user's
// organization and externally, subject to the following restrictions
// 1. The users agree not to charge for the University of California code
// itself but may charge for additions, extensions, or support.
// 2. In any product based on the software, the users agree to acknowledge
// the University of California that developed the software. This
// acknowledgment shall appear in the product documentation.
// 3. The users agree to obey all U.S. Government restrictions governing
// redistribution or export of the software.
// 4. The users agree to reproduce any copyright notice which appears on
// the software on any copy or modification of such made available
// to others
// Agreed to on __Aug 22, 2014_________________
// By: ___University of California, Berkeley____ 
//     ___Chenming Hu_____________________ 
//     ___Professor in Graduate School _______
// ********************************************************

// Clamped exponential function
analog function real lexp;
    input   x;
    real x;

    begin
        if(x > `EXPL_THRESHOLD) begin
            lexp =  `MAX_EXPL * (1.0+(x)-`EXPL_THRESHOLD);
        end else if(x < -`EXPL_THRESHOLD) begin
            lexp =  `MIN_EXPL;
        end else begin
            lexp =  exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input   x;
    real x;

    begin
        lln  =  ln(max(x , `N_MINLOG));
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input   x , c;
    real x , c;

    begin
        hypsmooth  =  0.5 * (x + sqrt(x*x + 4*c*c));
    end
endfunction

// Hyperbolic smooth max function
analog function real hypmax;
    input   x , xmin, c;
    real x , xmin, c;

    begin
        hypmax  =  xmin + 0.5 * (x-xmin-c + sqrt((x-xmin-c)*(x-xmin-c)-4*xmin*c));
    end
endfunction

// Temperature Dependence Type
analog function real Tempdep;
    input   PARAML , PARAMT, DELTEMP, TEMPMOD;
    real PARAML , PARAMT, DELTEMP, TEMPMOD;

    begin
        if (TEMPMOD!=0)
            Tempdep  = PARAML + hypmax(PARAMT * DELTEMP, -PARAML, 1.0e-6);
        else
            Tempdep  = PARAML * hypsmooth(1.0 + PARAMT * DELTEMP - 1.0E-6, 1.0E-3); 
    end
endfunction


// Node definitions
`ifdef __RGATEMOD__
    `define GateEdgeNode ge
`else
    `define GateEdgeNode g
`endif
`ifdef __NQSMOD1__
    `define IntrinsicGate gi
`else
    `define IntrinsicGate `GateEdgeNode
`endif

/***************************/
/*  Instance Parameters    */
/***************************/

/* Note: Some instance parameters are also model parameters.  */
/*       Please refer to the technical note for details.      */
parameter real L         =  30n from [1n:inf) `attr(type="instance" xyceAlsoModel="YES" info="Designed Gate Length");        // Designed Gate Length
parameter real D         =  40n from [1n:inf) `attr(type="instance" xyceAlsoModel="YES" info="Diameter of the cylinder (GEOMOD=3)");        // Diameter of the cylinder (GEOMOD=3)
parameter real TFIN      =  15n from [1n:inf) `attr(type="instance" xyceAlsoModel="YES" info="Body (Fin) thickness");        // Body (Fin) thickness
parameter real FPITCH    =  80n from [TFIN:inf) `attr(type="instance" xyceAlsoModel="YES" info="Fin pitch");      // Fin pitch
parameter integer NF     =  1 from [1:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of fingers");           // Number of fingers
parameter real NFIN      =  1.0 from (0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of fins per finger (real number enables optimization)");         // Number of fins per finger (real number enables optimization)
parameter integer NGCON  =  1 from [1:2] `attr(type="instance" xyceAlsoModel="YES" info="number of gate contact (1 or 2 sided)");             // number of gate contact (1 or 2 sided)
parameter real ASEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Source to substrate overlap area through oxide");               // Source to substrate overlap area through oxide
parameter real ADEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Drain to substrate overlap area through oxide");               // Drain to substrate overlap area through oxide
parameter real PSEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Perimeter of source to substrate overlap region through oxide");               // Perimeter of source to substrate overlap region through oxide
parameter real PDEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Perimeter of drain to substrate overlap region through oxide");               // Perimeter of drain to substrate overlap region through oxide
parameter real ASEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Source junction area (BULKMOD=1)");               // Source junction area (BULKMOD=1)
parameter real ADEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Drain junction area (BULKMOD=1)");               // Drain junction area (BULKMOD=1)
parameter real PSEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Source to substrate PN junction perimeter (BULKMOD=1)");               // Source to substrate PN junction perimeter (BULKMOD=1)
parameter real PDEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Drain to substrate PN junction perimeter (BULKMOD=1)");               // Drain to substrate PN junction perimeter (BULKMOD=1)
parameter real COVS  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant g/s overlap capacitance (CGEOMOD=1)");               // Constant g/s overlap capacitance (CGEOMOD=1)
parameter real COVD  =  COVS from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant g/d overlap capacitance (CGEOMOD=1)");            // Constant g/d overlap capacitance (CGEOMOD=1)
parameter real CGSP  =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant gate-to-source fringe capacitance (CGEOMOD=1)");             // Constant gate-to-source fringe capacitance (CGEOMOD=1)
parameter real CGDP  =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant gate-to-drain fringe capacitance (CGEOMOD=1)");             // Constant gate-to-drain fringe capacitance (CGEOMOD=1)
parameter real CDSP  =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant drain-to-source fringe capacitance (All CGEOMOD)");             // Constant drain-to-source fringe capacitance (All CGEOMOD)
parameter real NRS   =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of source diffusion squares");             // Number of source diffusion squares
parameter real NRD   =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of source diffusion squares");             // Number of source diffusion squares
parameter real LRSD  =  L from (0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Length of the source/drain");               // Length of the source/drain

//Variability Handles
parameter real XL         =  0 `attr(info="L offset for channel length due to mask/etch effect");                       // L offset for channel length due to mask/etch effect
parameter real DTEMP      =  0 `attr(info="Variability in Device Temperature    ");                       // Variability in Device Temperature    
parameter real DELVTRAND =  0 `attr(info="Variability in Vth");                        // Variability in Vth
parameter real U0MULT    =  1 from [0:inf) `attr(info="Variability in carrier mobility");           // Variability in carrier mobility
parameter real IDS0MULT  =  1 from [0:inf) `attr(info="Variability in Drain current for misc. reasons    ");           // Variability in Drain current for misc. reasons    


/************************/
/*  Model Parameters    */
/************************/
parameter integer DEVTYPE  =  `ntype from [`ptype:`ntype];
parameter integer TYPE     = DEVTYPE from [`ptype:`ntype]; 
parameter integer BULKMOD  =  0 from [0:1] `attr(info="Bulk model");
                                                      // 0: SOI multi-gate
                                                      // 1: Bulk multi-gate
parameter integer COREMOD  =  0 from [0:1] `attr(info="Surface potential algorithm");
                                                      // 0: Default surface potential algorithm
                                                      // 1: Simplified (efficient) surface potential algorithm
parameter integer GEOMOD   =  1 from [0:3] `attr(info="Geometry mode selector");
                                                      // 0: Double gate
                                                      // 1: Triple gate
                                                      // 2: Quadruple gate
                                                      // 3: Cylindrical gate
parameter integer CGEO1SW = 0 from [0:1];             // For CGEOMOD=1 only, this switch enables the parameters COVS, COVD, CGSP,  
                                                      // and CGDP to be in F per fin, per gate-finger, per unit channel width
parameter integer RDSMOD   =  0 from [0:2] `attr(info="Resistance model selector");
                                                      // 0: Internal s/d resistance model
                                                      // 1: External s/d resistance model
                                                      // 2: Both bias dependent and independent part of source/drain resistance internal 
parameter integer ASYMMOD  =  0 from [0:1] `attr(info="Asymmetric model selector");
                                                      // 0: Asymmetry Model turned off - forward mode parameters used
                                                      // 1: Asymmetry Model turned on
parameter integer IGCMOD   =  0 from [0:1] `attr(info="Model selector for Igc, Igs, and Igd");
                                                      // 0: Turn off Igc, Igs and Igd
                                                      // 1: Turn on Igc, Igs and Igd
parameter integer IGBMOD   =  0 from [0:1] `attr(info="Model selector for Igb");
                                                      // 0: Turn off Igb
                                                      // 1: Turn on Igb
parameter integer GIDLMOD  =  0 from [0:1] `attr(info="GIDL/GISL current switcher");
                                                      // 0: Turn off GIDL/GISL current
                                                      // 1: Turn on GIDL/GISL current
parameter integer IIMOD    =  0 from [0:2] `attr(info="Impact ionization model switch");
                                                      // 0: No impact ionization current
                                                      // 1: BSIM4-based model
                                                      // 2: BSIMSOI-based model
parameter integer NQSMOD   =  0 from [0:2];           // 0: NQS models turned off  **NQSMOD=3 is disabled for now.**
                                                      // 1: NQS gate resistance / gi node turned on
                                                      // 2: NQS charge deficit model (BSIM4) / q node turned on
                                                      // 3: NQS charge segmentation model / Nseg nodes turned on
parameter integer SHMOD    =  0 from [0:1] `attr(info="Self heating and T node switcher --- NOT USED IN XYCE");
                                                      // 0: No self-heating
                                                      // 1: Self-heating turned on
parameter integer TEMPMOD  =  0 from [0:1];           // 1: Changes the temperature dependency's type of specific parameters
parameter integer RGATEMOD =  0 from [0:1]  `attr(info="Gate electrode resistance on/off seector");
                                                      // 0: Gate electrode resistance / ge node turned off
                                                      // 1: Gate electrode resistance / ge node turned on
parameter integer RGEOMOD  =  0 from [0:1] `attr(info="Geometry-dependent source/drain resistance");           // Geometry-dependent source/drain resistance
                                                      // 0: RSH-based; 1: Holistic
parameter integer CGEOMOD  =  0 from [0:2] `attr(info="Geometry dependent parasitic capacitance model selector");           // Geometry dependent parasitic capacitance model selector
parameter integer CAPMOD   =  0 from[0:1] `attr(info="Accumulation capacitance selector");            // For BULKMOD =1;
                                                      // 0: No accumulation capacitance; 1: Accumulation capacitance included
parameter real LINT    =  0 `attr(info="Length reduction parameter (dopant diffusion effect)");                          // Length reduction parameter (dopant diffusion effect)
parameter real LL      =  0 `attr(info="Length reduction parameter (dopant diffusion effect)");                          // Length reduction parameter (dopant diffusion effect)
parameter real LLN     =  1 `attr(info="Length reduction parameter (dopant diffusion effect)");                          // Length reduction parameter (dopant diffusion effect)
parameter real DLC     =  0 `attr(info="Delta L for C-V model");                          // Delta L for C-V model
parameter real DLCACC  =  0 `attr(info="Delta L for C-V model in accumulation region (CAPMOD=1, BULKMOD=1)");                          // Delta L for C-V model in accumulation region (CAPMOD=1, BULKMOD=1)
parameter real DLBIN   =  0 `attr(info="Delta L for Binning");                          // Delta L for Binning
parameter real LLC     =  0 `attr(info="Length reduction parameter (dopant diffusion effect)");                          // Length reduction parameter (dopant diffusion effect)
parameter real EOT     =  1.0n from [0.1n:inf) `attr(info="equivalent oxide thickness in meters");       // equivalent oxide thickness in meters
parameter real TOXP    =  1.2n from [0.1n:inf) `attr(info="physical oxide thickness in meters");       // physical oxide thickness in meters
parameter real EOTBOX  =  140n from [1n:inf) `attr(info="equivalent oxide thickness of the buried oxide (SOI FinFET) or STI (bulk FinFET) in meters");         // equivalent oxide thickness of the buried oxide (SOI FinFET)
                                                      //   or STI (bulk FinFET) in meters
parameter real HFIN    =  30n from [1n:inf) `attr(info="Fin height in meters");          // Fin height in meters
parameter real FECH    =  1 from [0:inf) `attr(info="End-channel factor, for different orientation/shape");             // End-channel factor, for different orientation/shape
parameter real DELTAW  =  0 `attr(info="change of effective width due to shape of fin/cylinder");                          // change of effective width due to shape of fin/cylinder
parameter real FECHCV  =  1 from [0:inf) `attr(info="CV end-channel factor, for different orientation/shape");             // CV end-channel factor, for different orientation/shape
parameter real DELTAWCV=  0 `attr(info="CV change of effective width due to shape of fin/cylinder");                          // CV change of effective width due to shape of fin/cylinder

parameter real NBODY    =  1e22 `attr(info="channel (body) doping");                      // channel (body) doping
parameter real NBODYN1  =  0  `attr(info="NFIN dependence of channel (body) doping");                        // NFIN dependence of channel (body) doping
parameter real NBODYN2  =  1.0e5 exclude 0 `attr(info="NFIN dependence of channel (body) doping");           // NFIN dependence of channel (body) doping
parameter real NSD     =  2e26 from [2e25:1e27] `attr(info="Source/drain active doping concentration in m-3");      // Source/drain active doping concentration in m-3

parameter real PHIG    =  4.61 from [0:inf) `attr(info="Gate workfunction, eV");          // Gate workfunction, eV
parameter real PHIGL   =  0 `attr(info="Length dependence of Gate workfunction, eV/m");                          // Length dependence of Gate workfunction, eV/m
parameter real PHIGN1  =  0  `attr(info="NFIN dependence of Gate workfunction");                         // NFIN dependence of Gate workfunction
parameter real PHIGN2  =  1.0e5 exclude 0 `attr(info="NFIN dependence of Gate workfunction");            // NFIN dependence of Gate workfunction

parameter real EPSROX  =  3.9 from [1:inf) `attr(info="Relative dielectric constant of the gate dielectric");           // Relative dielectric constant of the gate dielectric
parameter real EPSRSUB =  11.9 from [1:inf) `attr(info="Relative dielectric constant of the channel material");          // Relative dielectric constant of the channel material
parameter real EASUB   =  4.05 from [0:inf) `attr(info="Electron affinity of substrate, eV");          // Electron affinity of substrate, eV
parameter real NI0SUB  =  1.1e16 `attr(info="Intrinsic carrier constant at 300.15K, m-3");                     // Intrinsic carrier constant at 300.15K, m-3
parameter real BG0SUB  =  1.12 `attr(info="Band gap of substrate at 300.15K, eV");                       // Band gap of substrate at 300.15K, eV
parameter real NC0SUB  =  2.86e25 `attr(info="Conduction band density of states, m-3");                    // Conduction band density of states, m-3
parameter real NGATE   =  0.0 `attr(info="Parameter for Poly Gate Doping, for metal gate please set NGATE = 0");                        // Parameter for Poly Gate Doping, for metal gate please set NGATE = 0
parameter real Imin    =  1.0E-15 `attr(info="Parameter for Vgs Clamping for inversion region calc. in accumulation");                    // Parameter for Vgs Clamping for inversion region calc. in accumulation
// Short Channel Effects
parameter real CIT      =  0.0 `attr(info="parameter for interface trap");                       // parameter for interface trap
parameter real CITR      =  CIT `attr(info="parameter for interface trap in reverse mode for asymmetric model");                      // parameter for interface trap in reverse mode for asymmetric model
parameter real CDSC     =  7e-3 `attr(info="coupling capacitance between S/D and channel");                      // coupling capacitance between S/D and channel
parameter real CDSCN1   =  0  `attr(info="NFIN dependence of CDSC");                        // NFIN dependence of CDSC
parameter real CDSCN2   =  1.0e5  `attr(info="NFIN dependence of CDSC");                    // NFIN dependence of CDSC
parameter real CDSCD    =  7e-3 `attr(info="drain-bias sensitivity of CDSC");                      // drain-bias sensitivity of CDSC
parameter real CDSCDN1  =  0  `attr(info="NFIN dependence of CDSCD");                        // NFIN dependence of CDSCD
parameter real CDSCDN2  =  1.0e5 exclude 0 `attr(info="NFIN dependence of CDSCD");           // NFIN dependence of CDSCD
parameter real CDSCDR   =  CDSCD `attr(info="Reverse-mode drain-bias sensitivity of CDSC (Experimental)");                     // Reverse-mode drain-bias sensitivity of CDSC (Experimental)
parameter real CDSCDRN1 =  CDSCDN1  `attr(info="NFIN dependence of CDSCD");                  // NFIN dependence of CDSCD
parameter real CDSCDRN2 =  CDSCDN2 exclude 0  `attr(info="NFIN dependence of CDSCD");        // NFIN dependence of CDSCD
parameter real DVT0     =  0.0 `attr(info="SCE coefficient");                       // SCE coefficient
parameter real DVT1     =  0.60 `attr(info="SCE exponent coefficient, after binning should be in (0:inf)");                      // SCE exponent coefficient, after binning should be in (0:inf)
parameter real DVT1SS   =  DVT1 `attr(info="Subthreshold Swing exponent coefficient, after binning should be in (0:inf)");                      // Subthreshold Swing exponent coefficient, after binning should be in (0:inf)
parameter real PHIN     =  0.05 `attr(info="Nonuniform vertical doping effect on surface potential, V");                      // Nonuniform vertical doping effect on surface potential, V
parameter real ETA0     =  0.60 `attr(info="DIBL coefficient");                      // DIBL coefficient
parameter real ETA0N1   =  0  `attr(info="NFIN dependence of ETA0");                        // NFIN dependence of ETA0
parameter real ETA0N2   =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of ETA0");    // NFIN dependence of ETA0
parameter real TETA0    =  0.0 `attr(info="Temperature dependence of DIBL coefficient, 1/K");                       // Temperature dependence of DIBL coefficient, 1/K
parameter real ETA0R    =  ETA0 `attr(info="Reverse-mode DIBL coefficient (Experimental)");                      // Reverse-mode DIBL coefficient (Experimental)
parameter real TETA0R   =  TETA0 `attr(info="Temperature dependence of Reverse-mode DIBL coefficient, 1/K");                     // Temperature dependence of Reverse-mode DIBL coefficient, 1/K
parameter real DSUB     =  1.06 `attr(info="DIBL exponent coefficient");                      // DIBL exponent coefficient
parameter real DVTP0    =  0 `attr(info="Coefficient for Drain-Induced Vth Shift (DITS)");                         // Coefficient for Drain-Induced Vth Shift (DITS)
parameter real DVTP1    =  0 `attr(info="DITS exponent coefficient");                         // DITS exponent coefficient
parameter real K1RSCE   =  0.0 `attr(info="K1 for reverse short channel effect calculation ");                       // K1 for reverse short channel effect calculation 
parameter real LPE0     =  5.0n `attr(info="Equivalent length of pocket region at zero bias");                      // Equivalent length of pocket region at zero bias
parameter real DVTSHIFT =  0 `attr(info="Vth shift handle");                         // Vth shift handle
parameter real DVTSHIFTR = DVTSHIFT  `attr(info="Vth shift handle for asymmetric mode");                 // Vth shift handle for asymmetric mode

parameter real THETASCE  =  0 `attr(info="Vth roll-off length dependence. If defined by user, will overwrite Theta_SCE in the code");                        // Vth roll-off length dependence. If defined by user, will overwrite Theta_SCE in the code
parameter real THETADIBL =  0 `attr(info="DIBL length dependence. If defined by user, will overwrite Theta_DIBL in the code");                        // DIBL length dependence. If defined by user, will overwrite Theta_DIBL in the code
parameter real THETASW   =  0 `attr(info="Subthreshold Swing length dependence. If defined by user, will overwrite Theta_SW in the code");                        // Subthreshold Swing length dependence. If defined by user, will overwrite Theta_SW in the code
parameter real NVTM      =  0 `attr(info="Subthreshold Swing factor multiplied by Vtm. If defined by user, will overwrite nVtm in the code");                        // Subthreshold Swing factor multiplied by Vtm. If defined by user, will overwrite nVtm in the code
parameter real K0      =  0.0 `attr(info="Lateral NUD voltage parameter, V");                        // Lateral NUD voltage parameter, V
parameter real K01     =  0.0 `attr(info="Temperature dependence of lateral NUD voltage parameter, V/K");                        // Temperature dependence of lateral NUD voltage parameter, V/K
parameter real K0SI    =  1.0 `attr(info="Correction factor for strong inversion, used in Mnud, after binnig should be from (0:inf)");                        // Correction factor for strong inversion, used in Mnud, after binnig should be from (0:inf)
parameter real K0SI1   =  0.0 `attr(info="Temperature dependence of K0SI, 1/K");                        // Temperature dependence of K0SI, 1/K
parameter real K1SI    =  K0SI `attr(info="Correction factor for strong inversion, used in Mob");                       // Correction factor for strong inversion, used in Mob
parameter real K1SI1   =  K0SI1 `attr(info="Temperature dependence of K1SI, 1/K");                      // Temperature dependence of K1SI, 1/K

// Body Effect for MG Devices on Bulk Substrate (ex: FinFETs on BULK)
parameter real PHIBE   =  0.7 `attr(info="Body effect voltage parameter, V, after binnig should be from [0.2:1.2]");                        // Body effect voltage parameter, V, after binnig should be from [0.2:1.2]
parameter real K1      =  0.0 `attr(info="Body effect coefficient for sub-threshold region");                        // Body effect coefficient for sub-threshold region
parameter real K11     =  0.0 `attr(info="Temperature dependence of K1");                        // Temperature dependence of K1
parameter real K1SAT   =  0.0 `attr(info="Correction factor for K1 in saturation (high Vds)        ");                        // Correction factor for K1 in saturation (high Vds)        
parameter real K1SAT1  =  0.0 `attr(info="Temperature dependence of K1SAT1    ");                        // Temperature dependence of K1SAT1    

// Quantum Mechanical Effect
parameter real QMFACTOR  =  0.0 `attr(info="Prefactor + switch for QM Vth correction");                      // Prefactor + switch for QM Vth correction
parameter real QMTCENIV  =  0.0 `attr(info="Prefactor + switch for QM Width correction for IV");                      // Prefactor + switch for QM Width correction for IV
parameter real QMTCENCV  =  0.0 `attr(info="Prefactor + switch for QM Width and Toxeff correction for CV");                      // Prefactor + switch for QM Width and Toxeff correction for CV
parameter real QMTCENCVA =  0.0 `attr(info="Prefactor + switch for QM Width and Toxeff correction for CV (accumulation region)");                      // Prefactor + switch for QM Width and Toxeff correction for CV (accumulation region)
parameter real AQMTCEN   =  0.0 `attr(info="Parameter for Geometric dependence of Tcen on R/TFIN/HFIN");                      // Parameter for Geometric dependence of Tcen on R/TFIN/HFIN
parameter real BQMTCEN   =  12.0e-9 exclude 0 `attr(info="Parameter for Geometric dependence of Tcen on R/TFIN/HFIN");        // Parameter for Geometric dependence of Tcen on R/TFIN/HFIN
parameter real ETAQM     =  0.54 `attr(info="Bulk charge coefficient for Tcen");                     // Bulk charge coefficient for Tcen
parameter real QM0       =  1.00e-3 `attr(info="Knee-Point for Tcen in inversion (Charge normalized to Cox)");                  // Knee-Point for Tcen in inversion (Charge normalized to Cox)
parameter real PQM       =  0.66 `attr(info="Slope of normalized Tcen in inversion");                     // Slope of normalized Tcen in inversion
parameter real QM0ACC    =  1.00e-3 `attr(info="Knee-Point for Tcen in accumulation (Charge normalized to Cox)");                  // Knee-Point for Tcen in accumulation (Charge normalized to Cox)
parameter real PQMACC    =  0.66 `attr(info="Slope of normalized Tcen in accumulation");                     // Slope of normalized Tcen in accumulation

// Velocity Saturation Model
parameter real VSAT        =  85000; 
parameter real VSATR       = VSAT ;
parameter real VSATN1      =  0  `attr(info="NFIN dependence of VSAT ");                     // NFIN dependence of VSAT 
parameter real VSATN2      =  1.0e5 exclude 0  `attr(info="NFIN dependence of VSAT ");       // NFIN dependence of VSAT 
parameter real VSATRN1    =  VSATN1  `attr(info="NFIN dependence of VSATR ");                 // NFIN dependence of VSATR 
parameter real VSATRN2    =  VSATN2 exclude 0  `attr(info="NFIN dependence of VSATR ");       // NFIN dependence of VSATR 
parameter real AVSAT       =  0.0; 
parameter real BVSAT       =  100.0e-9 exclude 0; 
parameter real VSAT1       =  VSAT `attr(info="Velocity Saturation parameter for I_on degradation - forward mode");                   // Velocity Saturation parameter for I_on degradation - forward mode
parameter real VSAT1N1     =  VSATN1  `attr(info="NFIN dependence of VSAT1 ");                // NFIN dependence of VSAT1 
parameter real VSAT1N2     =  VSATN2 exclude 0 `attr(info="NFIN dependence of VSAT1 ");       // NFIN dependence of VSAT1 
parameter real VSAT1R      =  VSAT1 `attr(info="Velocity Saturation parameter for I_on degradation - reverse mode");                  // Velocity Saturation parameter for I_on degradation - reverse mode
parameter real VSAT1RN1    =  VSAT1N1  `attr(info="NFIN dependence of VSAT1R ");               // NFIN dependence of VSAT1R 
parameter real VSAT1RN2    =  VSAT1N2 exclude 0  `attr(info="NFIN dependence of VSAT1R ");     // NFIN dependence of VSAT1R 
parameter real AVSAT1      =  AVSAT;     
parameter real BVSAT1      =  BVSAT exclude 0; 
parameter real DELTAVSAT   =  1.0;
parameter real PSAT        =  2.0 `attr(info="Velocity saturation exponent, after binnig should be from [2.0:inf)");                    // Velocity saturation exponent, after binnig should be from [2.0:inf)
parameter real APSAT       =  0.0;
parameter real BPSAT       =  1.0 exclude 0; 
parameter real KSATIV      =  1.0; 
parameter real KSATIVR      =  KSATIV `attr(info="KSATIV in asymmetric mode ");                // KSATIV in asymmetric mode 
parameter real VSATCV      =  VSAT `attr(info="Velocity Saturation parameter for CV");                   // Velocity Saturation parameter for CV
parameter real AVSATCV     =  AVSAT;     
parameter real BVSATCV     =  BVSAT exclude 0; 
parameter real DELTAVSATCV =  DELTAVSAT;
parameter real PSATCV      =  PSAT `attr(info="Velocity saturation exponent for C-V");                   // Velocity saturation exponent for C-V
parameter real APSATCV     =  APSAT;
parameter real BPSATCV     =  BPSAT exclude 0; 
parameter real MEXP        =  4.0; 
parameter real AMEXP       =  0.0; 
parameter real BMEXP       =  1.0; 
parameter real MEXPR       =  MEXP; 
parameter real AMEXPR      =  AMEXP; 
parameter real BMEXPR      =  BMEXP; 
parameter real PTWG        =  0.0 `attr(info="Gmsat degradation parameter - forward mode ");                    // Gmsat degradation parameter - forward mode 
parameter real PTWGR       =  PTWG `attr(info="Gmsat degradation parameter - reverse mode");                   // Gmsat degradation parameter - reverse mode
parameter real APTWG       =  0.0; 
parameter real BPTWG       =  100.0e-9 exclude 0; 
parameter real AT          =  -1.56e-3; 
parameter real ATR          =  AT; 
parameter real ATCV        =  AT; 
parameter real TMEXP       =  0.0;
parameter real TMEXPR      =  TMEXP;  
parameter real PTWGT       =  0.004; 

// Mobility Model
parameter real U0       =  0.03; 
parameter real U0R       =  U0;
parameter real U0N1     =  0  `attr(info="NFIN dependence of U0 ");                       // NFIN dependence of U0 
parameter real U0N1R     =  U0N1 ;
parameter real U0N2     =  1.0e5 exclude 0 `attr(info="NFIN dependence of U0 ");          // NFIN dependence of U0 
parameter real U0N2R     =  U0N2 exclude 0;
parameter real ETAMOB   =  2.0; 
parameter real UP       =  0; 
parameter real LPA      =  1.0; 
parameter real UPR       =  UP; 
parameter real LPAR      =  LPA; 
parameter real UA       =  0.3; 
parameter real UAR       =  UA;
parameter real AUA      =  0.0; 
parameter real AUAR      =  AUA; 
parameter real BUA      =  100.0e-9 exclude 0; 
parameter real BUAR      =  BUA exclude 0; 
parameter real UC       =  0.0 `attr(info="Body effect for mobility degradation parameter - BULKMOD=1");                     // Body effect for mobility degradation parameter - BULKMOD=1
parameter real UCR       =  0.0;  
parameter real EU       =  2.5; 
parameter real EUR       =  EU; 
parameter real AEU      =  0.0; 
parameter real AEUR      =  AEU;
parameter real BEU      =  100.0e-9 exclude 0; 
parameter real BEUR      =  BEU exclude 0; 
parameter real UD       =  0.0; 
parameter real UDR       =  UD;
parameter real AUD      =  0.0; 
parameter real AUDR      =  AUD;
parameter real BUD      =  50.0e-9 exclude 0; 
parameter real BUDR      =  BUD exclude 0; 
parameter real UCS      =  1.0; 
parameter real UTE      =  0.0; 
parameter real UTER      =  UTE; 
parameter real UTL      =  -1.5e-3;
parameter real UTLR      =  UTL;
parameter real EMOBT    =  0.0; 
parameter real UA1      =  1.032e-3;
parameter real UA1R      =  UA1;
parameter real UC1      =  0.056e-9;
parameter real UC1R      =  UC1; 
parameter real UD1      =  0.0; 
parameter real UD1R      =  UD1;
parameter real UCSTE    =  -4.775e-3;
parameter real CHARGEWF =  0 from [-1:1] `attr(info="Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side  ");           // Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side  

// Access Resistance Model
parameter real RDSWMIN =  0.0; 
parameter real RDSW    =  100.0; 
parameter real ARDSW   =  0.0; 
parameter real BRDSW   =  100.0e-9 exclude 0; 
parameter real RSWMIN  =  0.0; 
parameter real RSW     =  50.0; 
parameter real ARSW    =  0.0; 
parameter real BRSW    =  100.0e-9 exclude 0; 
parameter real RDWMIN  =  0.0; 
parameter real RDW     =  50.0; 
parameter real ARDW    =  0.0; 
parameter real BRDW    =  100.0e-9 exclude 0;
parameter real RSDR    =  0.0    from[0:inf) `attr(info="Source side drift resistance parameter - forward mode");       // Source side drift resistance parameter - forward mode
parameter real RSDRR   =  RSDR   from[0:inf) `attr(info="Source side drift resistance parameter - reverse mode");       // Source side drift resistance parameter - reverse mode
parameter real RDDR    =  RSDR   from[0:inf) `attr(info="Drain side drift resistance parameter - forward mode");       // Drain side drift resistance parameter - forward mode
parameter real RDDRR   =  RDDR   from[0:inf) `attr(info="Drain side drift resistance parameter - reverse mode");       // Drain side drift resistance parameter - reverse mode
parameter real PRSDR   =  1.0 `attr(info="Source side quasi-saturation parameter");                      // Source side quasi-saturation parameter
parameter real PRDDR   =  PRSDR `attr(info="Drain side quasi-saturation parameter");                    // Drain side quasi-saturation parameter
parameter real PRWGS   =  0.0 `attr(info="Gate bias dependence of source extension resistance, Units:V^-1");                      // Gate bias dependence of source extension resistance, Units:V^-1
parameter real PRWGD   =  PRWGS `attr(info="Gate bias dependence of drain extension resistance, Units:V^-1");                    // Gate bias dependence of drain extension resistance, Units:V^-1
parameter real WR      =  1.0; 
parameter real PRT     =  0.001;
parameter real TRSDR   =  0.0;
parameter real TRDDR   =  TRSDR;
//parameter real RCVFAC  = 1.0;                     // Series resistance correction factor for CV  Navid_added
// DIBL Model
parameter real PDIBL1  =  1.30 `attr(info="DIBL Output Conductance parameter - forward mode");                     // DIBL Output Conductance parameter - forward mode
parameter real PDIBL1R =  PDIBL1 `attr(info="DIBL Output Conductance parameter - reverse mode ");                   // DIBL Output Conductance parameter - reverse mode 
parameter real PDIBL2  =  2.0e-4 `attr(info="DIBL Output Conductance parameter ");                   // DIBL Output Conductance parameter 
parameter real PDIBL2R  = PDIBL2 `attr(info="DIBL Output Conductance parameter - reverse mode");                   // DIBL Output Conductance parameter - reverse mode
parameter real DROUT   =  1.06; 
parameter real PVAG    =  1.0; 

// Channel Length Modulation Effect
parameter real PCLM    =  0.013;
parameter real PCLMR   = PCLM  `attr(info="Reverse Model PCLM parameter ");                     // Reverse Model PCLM parameter 
parameter real APCLM   =  0.0; 
parameter real APCLMR   =  APCLM; 
parameter real BPCLM   =  100.0e-9 exclude 0;
parameter real BPCLMR   =  BPCLM exclude 0; 
parameter real PCLMG   =  0.0; 
parameter real PCLMCV  =  PCLM `attr(info="CLM parameter for Short Channel CV ");                     // CLM parameter for Short Channel CV 

// Non-saturation Effect
parameter real A1      =  0.0 `attr(info="Non-saturation effect parameter for strong inversion region");                      // Non-saturation effect parameter for strong inversion region
parameter real A11     =  0.0 `attr(info="Temperature dependence of A1");                      // Temperature dependence of A1
parameter real A2      =  0.0 `attr(info="Non-saturation effect parameter for moderate inversion region");                      // Non-saturation effect parameter for moderate inversion region
parameter real A21     =  0.0 `attr(info="Temperature dependence of A2");                      // Temperature dependence of A2

// Gate Electrode Resistance
parameter real RGEXT   =  0.0 from [0:inf) `attr(info="Effective gate electrode external resistance");         // Effective gate electrode external resistance
parameter real RGFIN   =  1.0e-3 from [1.0e-3:inf) `attr(info="Effective gate electrode per finger per fin resistance"); // Effective gate electrode per finger per fin resistance

// Geometry dependent Source/Drain Resistance RGEOMOD=0
parameter real RSHS    =  0.0 `attr(info="Source-side sheet resistance");                      // Source-side sheet resistance
parameter real RSHD    =  RSHS `attr(info="Drain-side sheet resistance");                     // Drain-side sheet resistance

// Geometry dependent Source/Drain Resistance RGEOMOD=1 for variability modeling
// These parameters are shared with CGEOMOD = 2
parameter real HEPI      =  10.0n `attr(info="Height of the raised source/drain on top of the fin");                  // Height of the raised source/drain on top of the fin
parameter real TSILI     =  10.0n `attr(info="Thickness of the silicide on top of the raised source/drain");                  // Thickness of the silicide on top of the raised source/drain
parameter real RHOC      =  1.0e-12 from [1.0e-18:1.0e-9];
parameter real RHORSD    =  1.0 from (0:inf);
parameter real CRATIO    =  0.5 from [0:1];
parameter real DELTAPRSD =  0.0 from (-FPITCH:inf);
parameter integer SDTERM =  0 from [0:1];
parameter real LSP       =  0.2 * (L + XL) from (0:inf);
//parameter real LDG       =  5.0e-9 from [0:inf);
parameter real EPSRSP    =  3.9 from [1:inf) `attr(info="Relative dielectric constant of the spacer");       // Relative dielectric constant of the spacer
parameter real TGATE     =  30.0n from (0:inf) `attr(info="Gate height on top of the hard mask");     // Gate height on top of the hard mask
parameter real TMASK     =  30.0n from [0:inf) `attr(info="Height of hard mask on top of the fin");     // Height of hard mask on top of the fin
parameter real ASILIEND  =  0.0 from [0:inf);
parameter real ARSDEND   =  0.0 from [0:inf);
parameter real PRSDEND   =  0.0 from [0:inf);
parameter real NSDE      =  2e25 from [1e25:1e26] `attr(info="Source/drain active doping concentration at Leff edge");  // Source/drain active doping concentration at Leff edge
parameter real RGEOA     =  1.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOB     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOC     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOD     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOE     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real CGEOA     =  1.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOB     =  0.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOC     =  0.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOD     =  0.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOE     =  1.0 from [0:inf) `attr(info="Fitting parameter for CGEOMOD=2");       // Fitting parameter for CGEOMOD=2

// Gate Current
parameter real AIGBINV  =  1.11e-2 `attr(info="parameter for Igb in inversion");                 // parameter for Igb in inversion
parameter real AIGBINV1 =  0 `attr(info="parameter for Igb in inversion");                       // parameter for Igb in inversion
parameter real BIGBINV  =  9.49e-4 `attr(info="parameter for Igb in inversion");                 // parameter for Igb in inversion
parameter real CIGBINV  =  6.00e-3 `attr(info="parameter for Igb in inversion");                 // parameter for Igb in inversion
parameter real EIGBINV  =  1.1 `attr(info="parameter for Igb in inversion");                     // parameter for Igb in inversion
parameter real NIGBINV  =  3.0 `attr(info="parameter for Igb in inversion");                     // parameter for Igb in inversion
parameter real AIGBACC  =  1.36e-2 `attr(info="parameter for Igb in accumulation");                 // parameter for Igb in accumulation
parameter real AIGBACC1 =  0 `attr(info="parameter for Igb in accumulation");                       // parameter for Igb in accumulation
parameter real BIGBACC  =  1.71e-3 `attr(info="parameter for Igb in accumulation");                 // parameter for Igb in accumulation
parameter real CIGBACC  =  7.5e-2 `attr(info="parameter for Igb in accumulation");                  // parameter for Igb in accumulation
parameter real NIGBACC  =  1.0 `attr(info="parameter for Igb in accumulation");                     // parameter for Igb in accumulation
parameter real AIGC     =  1.36e-2 `attr(info="parameter for Igc in inversion");                 // parameter for Igc in inversion
parameter real AIGC1    =  0 `attr(info="parameter for Igc in inversion");                       // parameter for Igc in inversion
parameter real BIGC     =  1.71e-3 `attr(info="parameter for Igc in inversion");                 // parameter for Igc in inversion
parameter real CIGC     =  0.075 `attr(info="parameter for Igc in inversion");                   // parameter for Igc in inversion
parameter real PIGCD    =  1.0 `attr(info="parameter for Igc partition");                     // parameter for Igc partition
parameter real DLCIGS   =  0 `attr(info="Delta L for Igs model");                       // Delta L for Igs model
parameter real AIGS     =  1.36e-2 `attr(info="parameter for Igs in inversion");                 // parameter for Igs in inversion
parameter real AIGS1    =  0 `attr(info="parameter for Igs in inversion");                       // parameter for Igs in inversion
parameter real BIGS     =  1.71e-3 `attr(info="parameter for Igs in inversion");                 // parameter for Igs in inversion
parameter real CIGS     =  0.075 `attr(info="parameter for Igs in inversion");                   // parameter for Igs in inversion
parameter real DLCIGD   =  DLCIGS `attr(info="Delta L for Igd model");                  // Delta L for Igd model
parameter real AIGD     =  AIGS `attr(info="parameter for Igd in inversion");                    // parameter for Igd in inversion
parameter real AIGD1    =  AIGS1 `attr(info="parameter for Igd in inversion");                   // parameter for Igd in inversion
parameter real BIGD     =  BIGS `attr(info="parameter for Igd in inversion");                    // parameter for Igd in inversion
parameter real CIGD     =  CIGS `attr(info="parameter for Igd in inversion");                    // parameter for Igd in inversion
parameter real TOXREF   =  1.2n from (0:inf) `attr(info="Target tox value [m]");       // Target tox value [m]
parameter real TOXG     =  TOXP `attr(info="oxide thickness for gate current model in meters, Introduced in BSIM-CMG106.1.0");                    // oxide thickness for gate current model in meters, Introduced in BSIM-CMG106.1.0
parameter real NTOX     =  1.0 `attr(info="Exponent for Tox ratio");                     // Exponent for Tox ratio
parameter real POXEDGE  =  1.0 `attr(info="Factor for the gate edge Tox");                     // Factor for the gate edge Tox
// GIDL/GISL Current
parameter real AGISL   =  6.055p `attr(info="pre-exponential coeff. for GISL in mho");                   // pre-exponential coeff. for GISL in mho
parameter real BGISL   =  0.3e9 `attr(info="exponential coeff. for GISL in V/m");                    // exponential coeff. for GISL in V/m
parameter real CGISL   =  0.5 `attr(info="parameter for body-effect of GISL in V^3");                      // parameter for body-effect of GISL in V^3
parameter real EGISL   =  0.2 `attr(info="band bending parameter for GISL in V");                      // band bending parameter for GISL in V
parameter real PGISL   =  1.0 `attr(info="parameter for body-bias effect on GISL");                      // parameter for body-bias effect on GISL
parameter real AGIDL   =  AGISL `attr(info="pre-exponential coeff. for GIDL in mho");                    // pre-exponential coeff. for GIDL in mho
parameter real BGIDL   =  BGISL `attr(info="exponential coeff. for GIDL in V/m");                    // exponential coeff. for GIDL in V/m
parameter real CGIDL   =  CGISL `attr(info="parameter for body-effect of GIDL in V^3");                    // parameter for body-effect of GIDL in V^3
parameter real EGIDL   =  EGISL `attr(info="band bending parameter for GIDL in V");                    // band bending parameter for GIDL in V
parameter real PGIDL   =  PGISL `attr(info="parameter for body-bias effect on GIDL");                    // parameter for body-bias effect on GIDL

// Impact Ionization Current
// IIMOD=1    
parameter real ALPHA0  =  0.0 `attr(info="first parameter of Iii, m/V");                       // first parameter of Iii, m/V
parameter real ALPHA01 =  0.0 `attr(info="Temperature dependence of ALPHA0, m/V/degrees");                       // Temperature dependence of ALPHA0, m/V/degrees
parameter real ALPHA1  =  0.0 `attr(info="L scaling parameter of Iii, 1/V");                       // L scaling parameter of Iii, 1/V
parameter real ALPHA11 =  0.0 `attr(info="Temperature dependence ALPHA1, 1/V/degree");                       // Temperature dependence ALPHA1, 1/V/degree
parameter real BETA0   =  0.0 `attr(info="Vds dependent parameter of Iii, 1/V");                       // Vds dependent parameter of Iii, 1/V
// IIMOD=2
parameter real ALPHAII0  =  0.0 `attr(info="first parameter of Iii for IIMOD=2, m/V                                                ");                     // first parameter of Iii for IIMOD=2, m/V                                                
parameter real ALPHAII01 =  0.0 `attr(info="Temperature dependence of ALPHAII0, m/V/degrees");                     // Temperature dependence of ALPHAII0, m/V/degrees
parameter real ALPHAII1  =  0.0 `attr(info="L scaling parameter of Iii for IIMOD=2, 1/V");                     // L scaling parameter of Iii for IIMOD=2, 1/V
parameter real ALPHAII11 =  0.0 `attr(info="Temperature dependence of ALPHAII1, 1/V/degrees");                     // Temperature dependence of ALPHAII1, 1/V/degrees

parameter real BETAII0     =  0.0 `attr(info="Vds dependent parameter of Iii, 1/V");                   // Vds dependent parameter of Iii, 1/V
parameter real BETAII1     =  0.0 `attr(info="Vds dependent parameter of Iii");                   // Vds dependent parameter of Iii
parameter real BETAII2     =  0.1 `attr(info="Vds dependent parameter of Iii, V");                   // Vds dependent parameter of Iii, V
parameter real ESATII      =  1.0e7 `attr(info="Saturation channel E-Field for Iii, V/m");                 // Saturation channel E-Field for Iii, V/m
parameter real LII         =  0.5E-9 `attr(info="Channel length dependent parameter of Iii, V-m");                // Channel length dependent parameter of Iii, V-m
parameter real SII0        =  0.5 `attr(info="Vgs dependent parameter of Iii, 1/V");                   // Vgs dependent parameter of Iii, 1/V
parameter real SII1        =  0.1 `attr(info="1st Vgs dependent parameter of Iii, 1/V");                   // 1st Vgs dependent parameter of Iii, 1/V
parameter real SII2        =  0.0 `attr(info="2nd Vgs dependent parameter of Iii");                   // 2nd Vgs dependent parameter of Iii
parameter real SIID        =  0.0 `attr(info="3rd Vds dependent parameter of Iii, 1/V");                   // 3rd Vds dependent parameter of Iii, 1/V

// Accumulation Capacitance (CAPMOD=1)
parameter real EOTACC    =  EOT from [0.1n:inf) `attr(info="equivalent oxide thickness for accumulation region in meters");     // equivalent oxide thickness for accumulation region in meters
parameter real DELVFBACC =  0.0 `attr(info="Change in Flatband Voltage; Vfb_accumulation-Vfb_inversion");                     // Change in Flatband Voltage; Vfb_accumulation-Vfb_inversion

// Fringe capacitance
// CGEOMOD=0
parameter real CFS =  2.5e-11 from [0:inf) `attr(info="Outer Fringe Cap (source side)");          // Outer Fringe Cap (source side)
parameter real CFD =  CFS from [0:inf) `attr(info="Outer Fringe Cap (drain side)");              // Outer Fringe Cap (drain side)

// Overlap capacitance (CGEOMOD=0 and 2)
parameter real CGSO    =  0.0 from [0:inf) `attr(info="Non LDD region source-gate overlap capacitance per unit channel width");          // Non LDD region source-gate overlap capacitance per unit channel width
parameter real CGDO    =  CGSO from [0:inf) `attr(info="Non LDD region drain-gate overlap capacitance per unit channel width");         // Non LDD region drain-gate overlap capacitance per unit channel width
parameter real CGSL    =  0.0 from [0:inf);
parameter real CGDL    =  CGSL from [0:inf);
parameter real CKAPPAS =  0.6 from [0.02:inf);
parameter real CKAPPAD =  CKAPPAS from [0.02:inf);
parameter real CGBO    =  0.0 from [0:inf) `attr(info="Gate to substrate overlap cap per unit channel length per finger per NGCON    ");          // Gate to substrate overlap cap per unit channel length per finger per NGCON    
parameter real CGBN    =  0.0 from [0:inf) `attr(info="Gate to substrate overlap cap per unit channel length per fin per finger");          // Gate to substrate overlap cap per unit channel length per fin per finger
parameter real CGBL    =  0.0 from [0:inf) `attr(info="Bias dependent component of Gate to substrate overlap cap per unit channel length per fin per finger");          // Bias dependent component of Gate to substrate overlap cap 
                                                     // per unit channel length per fin per finger 
parameter real CKAPPAB =  0.6 from [0.02:inf);

// Source/drain to substrate sidewall capacitance
parameter real CSDESW  =  0.0 from [0:inf) `attr(info="Coefficient for source/drain to substrate sidewall cap");          // Coefficient for source/drain to substrate sidewall cap

// Junction current and capacitance
// Junction Capacitance
parameter real CJS    =  5.0e-4 `attr(info="Unit area source-side junction capacitance at zero bias");                     // Unit area source-side junction capacitance at zero bias
parameter real CJD    =  CJS `attr(info="Unit area drain-side junction capacitance at zero bias");                        // Unit area drain-side junction capacitance at zero bias
parameter real CJSWS  =  5.0e-10 `attr(info="Unit length source-side sidewall junction capacitance at zero bias");                    // Unit length source-side sidewall junction capacitance at zero bias
parameter real CJSWD  =  CJSWS `attr(info="Unit length drain-side sidewall junction capacitance at zero bias");                      // Unit length drain-side sidewall junction capacitance at zero bias
parameter real CJSWGS =  0.0 `attr(info="Unit length source-side gate sidewall junction capacitance at zero bias");                        // Unit length source-side gate sidewall junction capacitance at zero bias
parameter real CJSWGD =  CJSWGS `attr(info="Unit length drain-side gate sidewall junction capacitance at zero bias");                     // Unit length drain-side gate sidewall junction capacitance at zero bias
parameter real PBS    =  1.0 `attr(info="Source-side bulk junction built-in potential");                        // Source-side bulk junction built-in potential
parameter real PBD    =  PBS `attr(info="Drain-side bulk junction built-in potential");                        // Drain-side bulk junction built-in potential
parameter real PBSWS  =  1.0 `attr(info="Built-in potential for Source-side sidewall junction capacitance");                        // Built-in potential for Source-side sidewall junction capacitance
parameter real PBSWD  =  PBSWS `attr(info="Built-in potential for Drain-side sidewall junction capacitance");                      // Built-in potential for Drain-side sidewall junction capacitance
parameter real PBSWGS =  PBSWS `attr(info="Built-in potential for Source-side gate sidewall junction capacitance");                      // Built-in potential for Source-side gate sidewall junction capacitance
parameter real PBSWGD =  PBSWGS `attr(info="Built-in potential for Drain-side gate sidewall junction capacitance");                     // Built-in potential for Drain-side gate sidewall junction capacitance
parameter real MJS    =  0.5 `attr(info="Source bottom junction capacitance grading coefficient");                        // Source bottom junction capacitance grading coefficient
parameter real MJD    =  MJS `attr(info="Drain bottom junction capacitance grading coefficient");                        // Drain bottom junction capacitance grading coefficient
parameter real MJSWS  =  0.33 `attr(info="Source sidewall junction capacitance grading coefficient");                       // Source sidewall junction capacitance grading coefficient
parameter real MJSWD  =  MJSWS `attr(info="Drain sidewall junction capacitance grading coefficient");                      // Drain sidewall junction capacitance grading coefficient
parameter real MJSWGS =  MJSWS `attr(info="Source-side gate sidewall junction capacitance grading coefficient");                      // Source-side gate sidewall junction capacitance grading coefficient
parameter real MJSWGD =  MJSWGS `attr(info="Drain-side gate sidewall junction capacitance grading coefficient");                     // Drain-side gate sidewall junction capacitance grading coefficient

// Second junction for the Two-Step junction cap 
parameter real SJS     =  0.0 from [0:inf) `attr(info="Constant for source-side two-step second junction");          // Constant for source-side two-step second junction
parameter real SJD     =  SJS from [0:inf) `attr(info="Constant for drain-side two-step second junction");          // Constant for drain-side two-step second junction
parameter real SJSWS   =  0.0 from [0:inf) `attr(info="Constant for source-side sidewall two-step second junction");          // Constant for source-side sidewall two-step second junction
parameter real SJSWD   =  SJSWS from [0:inf) `attr(info="Constant for drain-side sidewall two-step second junction");        // Constant for drain-side sidewall two-step second junction
parameter real SJSWGS  =  0.0 from [0:inf) `attr(info="Constant for source-side gate sidewall two-step second junction");          // Constant for source-side gate sidewall two-step second junction
parameter real SJSWGD  =  SJSWGS from [0:inf) `attr(info="Constant for source-side gate sidewall two-step second junction");       // Constant for source-side gate sidewall two-step second junction
parameter real MJS2    =  0.125 `attr(info="Source bottom two-step second junction capacitance grading coefficient");                     // Source bottom two-step second junction capacitance grading coefficient
parameter real MJD2    =  MJS2 `attr(info="Drain bottom two-step second junction capacitance grading coefficient        ");                      // Drain bottom two-step second junction capacitance grading coefficient        
parameter real MJSWS2  =  0.083 `attr(info="Source sidewall two-step second junction capacitance grading coefficient");                     // Source sidewall two-step second junction capacitance grading coefficient
parameter real MJSWD2  =  MJSWS2 `attr(info="Drain sidewall two-step second junction capacitance grading coefficient");                    // Drain sidewall two-step second junction capacitance grading coefficient
parameter real MJSWGS2 =  MJSWS2 `attr(info="Source-side gate sidewall two-step second junction capacitance grading coefficient");                    // Source-side gate sidewall two-step
                                                     // second junction capacitance grading coefficient
parameter real MJSWGD2 =  MJSWGS2 `attr(info="Drain-side gate sidewall two-step second junction capacitance grading coefficient");                   // Drain-side gate sidewall two-step
                                                     // second junction capacitance grading coefficient
// Junction Current
parameter real JSS =  1.0e-4 `attr(info="Bottom source junction reverse saturation current density");                        // Bottom source junction reverse saturation current density
parameter real JSD =  JSS `attr(info="Bottom drain junction reverse saturation current density");                           // Bottom drain junction reverse saturation current density
parameter real JSWS  =  0.0 `attr(info="Unit length reverse saturation current for sidewall source junction");                         // Unit length reverse saturation current for sidewall source junction
parameter real JSWD  =  JSWS `attr(info="Unit length reverse saturation current for sidewall drain junction");                        // Unit length reverse saturation current for sidewall drain junction
parameter real JSWGS =  0.0 `attr(info="Unit length reverse saturation current for gate-edge sidewall source junction");                         // Unit length reverse saturation current for gate-edge sidewall source junction
parameter real JSWGD =  JSWGS `attr(info="Unit length reverse saturation current for gate-edge sidewall drain junction");                       // Unit length reverse saturation current for gate-edge sidewall drain junction
parameter real NJS   =  1.0 exclude 0 `attr(info="Source junction emission coefficient");               // Source junction emission coefficient
parameter real NJD   =  NJS exclude 0 `attr(info="Drain junction emission coefficient");               // Drain junction emission coefficient
parameter real IJTHSFWD  =  0.1 `attr(info="Forward source diode breakdown limiting current");                     // Forward source diode breakdown limiting current
parameter real IJTHDFWD  =  IJTHSFWD `attr(info="Forward drain diode breakdown limiting current");                // Forward drain diode breakdown limiting current
parameter real IJTHSREV  =  0.1 `attr(info="Reverse source diode breakdown limiting current");                     // Reverse source diode breakdown limiting current
parameter real IJTHDREV  =  IJTHSREV `attr(info="Reverse drain diode breakdown limiting current");                // Reverse drain diode breakdown limiting current
parameter real BVS =  10.0 `attr(info="Source diode breakdown voltage");                          // Source diode breakdown voltage
parameter real BVD =  BVS `attr(info="Drain diode breakdown voltage");                           // Drain diode breakdown voltage
parameter real XJBVS =  1.0 `attr(info="Fitting parameter for source diode breakdown current");                         // Fitting parameter for source diode breakdown current
parameter real XJBVD =  XJBVS `attr(info="Fitting parameter for drain diode breakdown current");                       // Fitting parameter for drain diode breakdown current

// Tunneling Component of Junction Current
parameter real JTSS    =  0.0 `attr(info="Bottom source junction trap-assisted saturation current density");                       // Bottom source junction trap-assisted saturation current density
parameter real JTSD    =  JTSS `attr(info="Bottom drain junction trap-assisted saturation current density");                      // Bottom drain junction trap-assisted saturation current density
parameter real JTSSWS  =  0.0 `attr(info="Unit length trap-assisted saturation current for sidewall source junction");                       // Unit length trap-assisted saturation current for sidewall source junction
parameter real JTSSWD  =  JTSSWS `attr(info="Unit length trap-assisted saturation current for sidewall drain junction");                    // Unit length trap-assisted saturation current for sidewall drain junction
parameter real JTSSWGS =  0.0 `attr(info="Unit length trap-assisted saturation current for gate-edge sidewall source junction");                       // Unit length trap-assisted saturation current for 
                                                     // gate-edge sidewall source junction
parameter real JTSSWGD =  JTSSWGS `attr(info="Unit length trap-assisted saturation current for gate-edge sidewall drain junction");                   // Unit length trap-assisted saturation current for 
                                                     // gate-edge sidewall drain junction
parameter real JTWEFF  =  0.0 `attr(info="Trap assisted tunneling current width dependence");                       // Trap assisted tunneling current width dependence
parameter real NJTS    =  20.0 `attr(info="Non-ideality factor for JTSS");                      // Non-ideality factor for JTSS
parameter real NJTSD   =  NJTS `attr(info="Non-ideality factor for JTSD");                      // Non-ideality factor for JTSD
parameter real NJTSSW  =  20.0 `attr(info="Non-ideality factor for JTSSWS");                      // Non-ideality factor for JTSSWS
parameter real NJTSSWD =  NJTSSW `attr(info="Non-ideality factor for JTSSWD");                    // Non-ideality factor for JTSSWD
parameter real NJTSSWG =  20.0 `attr(info="Non-ideality factor for JTSSWGS");                      // Non-ideality factor for JTSSWGS
parameter real NJTSSWGD=  NJTSSWG `attr(info="Non-ideality factor for JTSSWGD");                   // Non-ideality factor for JTSSWGD
parameter real VTSS    =  10.0 `attr(info="Bottom source junction trap-assisted current voltage dependent parameter");                      // Bottom source junction trap-assisted current voltage dependent parameter
parameter real VTSD    =  VTSS `attr(info="Bottom drain junction trap-assisted current voltage dependent parameter");                      // Bottom drain junction trap-assisted current voltage dependent parameter
parameter real VTSSWS  =  10.0 `attr(info="Unit length trap-assisted current voltage dependent parameter for sidewall source junction");                      // Unit length trap-assisted current voltage dependent parameter 
                                                     // for sidewall source junction
parameter real VTSSWD  =  VTSSWS `attr(info="Unit length trap-assisted current voltage dependent parameter for sidewall drain junction");                    // Unit length trap-assisted current voltage dependent parameter 
                                                     // for sidewall drain junction
parameter real VTSSWGS =  10.0 `attr(info="Unit length trap-assisted current voltage dependent parameter for gate-edge sidewall source junction");                      // Unit length trap-assisted current voltage dependent parameter for 
                                                     // gate-edge sidewall source junction
parameter real VTSSWGD =  VTSSWGS `attr(info="Unit length trap-assisted current voltage dependent parameter for gate-edge sidewall drain junction");                   // Unit length trap-assisted current voltage dependent parameter for 
                                                     // gate-edge sidewall drain junction

// Recombination-Generation Current
parameter real LINTIGEN  =  0 `attr(info="Lint for Thermal Generation Current");                       // Lint for Thermal Generation Current
parameter real NTGEN     =  1.0 `attr(info="Thermal Generation Current Parameter");                     // Thermal Generation Current Parameter
parameter real AIGEN     =  0 `attr(info="Thermal Generation Current Parameter");                       // Thermal Generation Current Parameter
parameter real BIGEN     =  0 `attr(info="Thermal Generation Current Parameter");                       // Thermal Generation Current Parameter

// NQS Gate Resistance Model & NQS Charge Deficit Model
// For NQSMOD=1, Set XRCRG1=0 to turn off NQS gate resistance
parameter real XRCRG1  =  12.0;
parameter real XRCRG2  =  1.0;

// NQS Charge Segmentation Model
parameter integer NSEG =  4 from [4:10] `attr(info="Number of segments for NQSMOD=3 (3,5 & 10 supported)");             // Number of segments for NQSMOD=3 (3,5 & 10 supported)

// Flicker Noise
parameter real EF    =  1.0 `attr(info="Flicker Noise frequency exponent");                         // Flicker Noise frequency exponent
parameter real EM    =  4.1e7;
parameter real NOIA  =  6.250e+39;
parameter real NOIB  =  3.125e+24;
parameter real NOIC  =  8.750e+07;

// Thermal Noise
parameter real NTNOI =  1.0 from [0:inf);
parameter integer TNOIMOD  = 0 from [0:2] `attr(info="0: charge based, 1: holistic thermal noise based on BSIM4 noise model");           // 0: charge based, 1: holistic thermal noise based on BSIM4 noise model
parameter real      TNOIA    = 1.5 `attr(info="Thermal noise parameter");                  // Thermal noise parameter
parameter real    TNOIB    = 3.5 `attr(info="Thermal noise parameter");                    // Thermal noise parameter
parameter real      RNOIA    = 0.577 `attr(info="Thermal noise coefficient");                // Thermal noise coefficient
parameter real      RNOIB    = 0.37 `attr(info="Thermal noise coefficient");                 // Thermal noise coefficient

//Parameters controlled by Correlated Thermal Noise Switch
`ifdef  __TNOIMOD2__
    parameter real TNOIC    = 3.5 `attr(info="Thermal noise parameter for TNOIMOD=2");                   // Thermal noise parameter for TNOIMOD=2
    parameter real RNOIC    = 0.395 `attr(info="Thermal noise coefficient for TNOIMOD=2");                 // Thermal noise coefficient for TNOIMOD=2
    parameter real SCALEN   = 1e5;
`endif
// Temperature Effects;
parameter real TNOM      =  27.0 from [ -`P_CELSIUS0:inf) `attr(info="Temperature at which the model is extracted (degrees)");      // Temperature at which the model is extracted (degrees)
parameter real TBGASUB   =  7.02e-4 `attr(info="Bandgap Temperature Coefficient (eV / degrees)");                  // Bandgap Temperature Coefficient (eV / degrees)
parameter real TBGBSUB   =  1108.0 `attr(info="Bandgap Temperature Coefficient (degrees)");                   // Bandgap Temperature Coefficient (degrees)
parameter real KT1       =  0.0 `attr(info="Vth Temperature Coefficient (V)");                      // Vth Temperature Coefficient (V)
parameter real KT1L      =  0.0 `attr(info="Vth Temperature L Coefficient (m-V)");                      // Vth Temperature L Coefficient (m-V)
parameter real TSS       =  0.0 `attr(info="SSwing Temperature Coefficient (/ degrees)");                      // SSwing Temperature Coefficient (/ degrees)
parameter real IIT       =  -0.5 `attr(info="Impact Ionization Temperature Dependence, IIMOD=1");                     // Impact Ionization Temperature Dependence, IIMOD=1
parameter real TII       =  0.0 `attr(info="Impact Ionization Temperature Dependence, IIMOD=2");                      // Impact Ionization Temperature Dependence, IIMOD=2
parameter real TGIDL     =  -0.003 `attr(info="GIDL/GISL Temperature Dependence");                   // GIDL/GISL Temperature Dependence
parameter real IGT       =  2.5 `attr(info="Gate Current Temperature Dependence");                      // Gate Current Temperature Dependence
parameter real TCJ       =  0.0 `attr(info="Temperature coefficient for CJS/CJD");                      // Temperature coefficient for CJS/CJD
parameter real TCJSW     =  0.0 `attr(info="Temperature coefficient for CJSWS/CJSWD");                      // Temperature coefficient for CJSWS/CJSWD
parameter real TCJSWG    =  0.0 `attr(info="Temperature coefficient for CJSWGS/CJSWGD");                      // Temperature coefficient for CJSWGS/CJSWGD
parameter real TPB       =  0.0 `attr(info="Temperature coefficient for PBS/PBD");                      // Temperature coefficient for PBS/PBD
parameter real TPBSW     =  0.0 `attr(info="Temperature coefficient for PBSWS/PBSWD");                      // Temperature coefficient for PBSWS/PBSWD
parameter real TPBSWG    =  0.0 `attr(info="Temperature coefficient for PBSWGS/PBSWGD");                      // Temperature coefficient for PBSWGS/PBSWGD
parameter real XTIS      =  3.0 `attr(info="Source junction current temperature exponent");                      // Source junction current temperature exponent
parameter real XTID      =  XTIS `attr(info="Drain junction current temperature exponent");                     // Drain junction current temperature exponent
parameter real XTSS      =  0.02 `attr(info="Power dependence of JTSS on temperature");                     // Power dependence of JTSS on temperature
parameter real XTSD      =  XTSS `attr(info="Power dependence of JTSD on temperature");                     // Power dependence of JTSD on temperature
parameter real XTSSWS    =  0.02 `attr(info="Power dependence of JTSSWS on temperature");                     // Power dependence of JTSSWS on temperature
parameter real XTSSWD    =  XTSSWS `attr(info="Power dependence of JTSSWD on temperature");                   // Power dependence of JTSSWD on temperature
parameter real XTSSWGS   =  0.02 `attr(info="Power dependence of JTSSWGS on temperature");                     // Power dependence of JTSSWGS on temperature
parameter real XTSSWGD   =  XTSSWGS `attr(info="Power dependence of JTSSWGD on temperature");                  // Power dependence of JTSSWGD on temperature
parameter real TNJTS     =  0.0 `attr(info="Temperature coefficient for NJTS");                      // Temperature coefficient for NJTS
parameter real TNJTSD    =  TNJTS `attr(info="Temperature coefficient for NJTSD");                    // Temperature coefficient for NJTSD
parameter real TNJTSSW   =  0.0 `attr(info="Temperature coefficient for NJTSSW");                      // Temperature coefficient for NJTSSW
parameter real TNJTSSWD  =  TNJTSSW `attr(info="NTemperature coefficient for NJTSSWD");                  // NTemperature coefficient for NJTSSWD
parameter real TNJTSSWG  =  0.0 `attr(info="Temperature coefficient for NJTSSWG");                      // Temperature coefficient for NJTSSWG
parameter real TNJTSSWGD =  TNJTSSWG `attr(info="Temperature coefficient for NJTSSWGD");                 // Temperature coefficient for NJTSSWGD

// Self Heating
parameter real RTH0  =  0.01 from [0:inf) `attr(info="Thermal resistance");            // Thermal resistance
parameter real CTH0  =  1.0E-05 from [0:inf) `attr(info="Thermal capacitance");         // Thermal capacitance
parameter real WTH0  =  0.0 from [0:inf) `attr(info="Width dependence coefficient for Rth and Cth");             // Width dependence coefficient for Rth and Cth

//Binning Parameters
`include "bsimcmg_binning_parameters.include"

// Output variables
`ifdef __OPINFO__
    (* desc=  "WEFF" *)     real WEFF;
    (* desc=  "LEFF" *)     real LEFF;
    (* desc=  "WEFFCV" *)   real WEFFCV;
    (* desc=  "LEFFCV" *)   real LEFFCV;
    (* desc=  "IDS" *)      real IDS;
    (* desc=  "IDEFF" *)    real IDEFF;
    (* desc=  "ISEFF" *)    real ISEFF;
    (* desc=  "IGTOT" *)    real IGTOT;
    (* desc=  "IDSGEN" *)   real IDSGEN;
    (* desc=  "III" *)      real III;
    (* desc=  "IGIDL" *)    real IGIDL;
    (* desc=  "IGISL" *)    real IGISL;
    (* desc=  "IJSB" *)     real IJSB;
    (* desc=  "IJDB" *)     real IJDB;
    (* desc=  "ISUB" *)     real ISUB;
    (* desc=  "BETA" *)     real BETA;
    (* desc=  "VTH" *)      real VTH;
    (* desc=  "VDSSAT" *)   real VDSSAT;
    (* desc=  "VFB" *)      real VFB;
    (* desc=  "GM" *)       real GM;
    (* desc=  "GDS" *)      real GDS;
    (* desc=  "GMBS" *)     real GMBS;
    (* desc=  "QGI" *)      real QGI;
    (* desc=  "QDI" *)      real QDI;
    (* desc=  "QSI" *)      real QSI;
    (* desc=  "QBI" *)      real QBI;
    (* desc=  "QG" *)       real QG;
    (* desc=  "QD" *)       real QD;
    (* desc=  "QS" *)       real QS;
    (* desc=  "QB" *)       real QB;
    (* desc=  "CGGI" *)     real CGGI;
    (* desc=  "CGSI" *)     real CGSI;
    (* desc=  "CGDI" *)     real CGDI;
    (* desc=  "CGEI" *)     real CGEI;
    (* desc=  "CDGI" *)     real CDGI;
    (* desc=  "CDDI" *)     real CDDI;
    (* desc=  "CDSI" *)     real CDSI;
    (* desc=  "CDEI" *)     real CDEI;
    (* desc=  "CSGI" *)     real CSGI;
    (* desc=  "CSDI" *)     real CSDI;
    (* desc=  "CSSI" *)     real CSSI;
    (* desc=  "CSEI" *)     real CSEI;
    (* desc=  "CEGI" *)     real CEGI;
    (* desc=  "CEDI" *)     real CEDI;
    (* desc=  "CESI" *)     real CESI;
    (* desc=  "CEEI" *)     real CEEI;
    (* desc=  "CGG" *)      real CGG;
    (* desc=  "CGS" *)      real CGS;
    (* desc=  "CGD" *)      real CGD;
    (* desc=  "CGE" *)      real CGE;
    (* desc=  "CDG" *)      real CDG;
    (* desc=  "CDD" *)      real CDD;
    (* desc=  "CDS" *)      real CDS;
    (* desc=  "CDE" *)      real CDE;
    (* desc=  "CSG" *)      real CSG;
    (* desc=  "CSD" *)      real CSD;
    (* desc=  "CSS" *)      real CSS;
    (* desc=  "CSE" *)      real CSE;
    (* desc=  "CEG" *)      real CEG;
    (* desc=  "CED" *)      real CED;
    (* desc=  "CES" *)      real CES;
    (* desc=  "CEE" *)      real CEE;
    (* desc=  "CGSEXT" *)   real CGSEXT;
    (* desc=  "CGDEXT" *)   real CGDEXT;
    (* desc=  "CGBOV" *)    real CGBOV;
    (* desc=  "CJST" *)     real CJST;
    (* desc=  "CJDT" *)     real CJDT;
    (* desc=  "RSGEO" *)    real RSGEO;
    (* desc=  "RDGEO" *)    real RDGEO;
    (* desc=  "CFGEO" *)    real CFGEO;
    (* desc=  "TDEVICE" *)    real TDEVICE;
    `ifdef __DEBUG__
        (* desc=  "IGS" *)      real IGS;
        (* desc=  "IGD" *)         real IGD;
        (* desc=  "IGCS" *)     real IGCS;
        (* desc=  "IGCD" *)     real IGCD;
        (* desc=  "IGBS" *)     real IGBS;
        (* desc=  "IGBD" *)     real IGBD;
        (* desc=  "IGBACC" *)   real IGBACC;
        (* desc=  "IGBINV" *)   real IGBINV;

        (* desc=  "DIDSDVG" *)   real DIDSDVG;
        (* desc=  "DIDSDVS" *)      real DIDSDVS;
        (* desc=  "DIDSDVD" *)      real DIDSDVD;
        (* desc=  "DIGSDVG" *)      real DIGSDVG;
        (* desc=  "DIGSDVS" *)      real DIGSDVS;
        (* desc=  "DIGSDVD" *)      real DIGSDVD;
        (* desc=  "DIGDDVG" *)      real DIGDDVG;
        (* desc=  "DIGDDVS" *)      real DIGDDVS;
        (* desc=  "DIGDDVD" *)      real DIGDDVD;
        (* desc=  "DIIIDVG" *)      real DIIIDVG;
        (* desc=  "DIIIDVS" *)      real DIIIDVS;
        (* desc=  "DIIIDVD" *)      real DIIIDVD;
        (* desc=  "DIGIDLDVG" *) real DIGIDLDVG;
        (* desc=  "DIGIDLDVS" *) real DIGIDLDVS;
        (* desc=  "DIGIDLDVD" *) real DIGIDLDVD;
        (* desc=  "DIGISLDVG" *) real DIGISLDVG;
        (* desc=  "DIGISLDVS" *) real DIGISLDVS;
        (* desc=  "DIGISLDVD" *) real DIGISLDVD;

        `ifdef __SHMOD__
            (* desc=  "CGT" *)        real CGT;
            (* desc=  "CST" *)        real CST;
            (* desc=  "CDT" *)        real CDT;
            (* desc=  "DIDSDVTH" *)   real DIDSDVTH;
            (* desc=  "DIGSDVTH" *)   real DIGSDVTH;
            (* desc=  "DIGDDVTH" *)   real DIGDDVTH;
            (* desc=  "DIIIDVTH" *)   real DIIIDVTH;
            (* desc=  "DIGIDLDVTH" *) real DIGIDLDVTH;
            (* desc=  "DIGISLDVTH" *) real DIGISLDVTH;
            (* desc=  "DITHDVTH" *)   real DITHDVTH;
        `endif
        (* desc=  "ITH" *)      real ITH;
        (* desc=  "DITHDVG" *)  real DITHDVG;
        (* desc=  "DITHDVS" *)  real DITHDVS;
        (* desc=  "DITHDVD" *)  real DITHDVD;
    `endif
`endif

// Variables inside the model
integer initialized;
integer devsign;

real NFINtotal;
real DevTemp;
real R, ids0, ids0_ov_dqi, ids, idscv, dqi_idscv, vgs, vds, vdsx, sigvds, vch, etaiv;
real vgs_noswap, vds_noswap, vgd_noswap;
real qd, qg, qs, qb, Qbul;
real ni, epssub, epssp, epsratio, Eg, Eg0, Nc;
real Lg, deltaL, deltaL1, deltaLCV, Leff, Leff1, LeffCV, LeffCV_acc, Weff0, WeffCV0, Weff, WeffCV;
real cox, csi, cdsc, cbox;
real nbody, phib, deltaPhi;
real T0, T1, T2, T3, T4, T4a, T5, T6, T7, T8, T9, TA, Tcom;
real Vtm, Vtm0, nVtm;
real beta, beta0 ;
real wf, wr;

// Temperature Effects
real Tnom, TRatio, dvth_temp, delTemp, ThetaSS;
real K0_t, K0SI_t, K1SI_t, K1_t, K1SAT_t, A1_t, A2_t;
real AIGBINV_t, AIGBACC_t, AIGC_t, AIGS_t, AIGD_t;
real BETA0_t, SII0_t, BGISL_t, BGIDL_t, igtemp, PTWG_t, PTWGR_t;
real ALPHA0_t, ALPHA1_t, ALPHAII0_t, ALPHAII1_t;
real CJS_t, CJSWS_t, CJSWGD_t, CJD_t, CJSWD_t, CJSWGS_t;
real PBS_t, PBSWS_t, PBSWGS_t, PBD_t, PBSWD_t, PBSWGD_t;
real JSS_t, JSWS_t, JSWGS_t, JSD_t, JSWD_t, JSWGD_t;
real JTSS_t, JTSD_t, JTSSWS_t, JTSSWD_t, JTSSWGS_t, JTSSWGD_t;
real NJTS_t, NJTSD_t, NJTSSW_t, NJTSSWD_t, NJTSSWG_t, NJTSSWGD_t;

// Variables for analytical surface potential
real phibulk;
real r1, r2, F0, z1, z2, cdop, vtdop, q0, guessA, guessB;
real g0, tang0, cosg0, secg0, secg0sq, lng0, tang0s, tang0d;
real F1, F2, Inv_r1pi, aab, g0s, g0d;
real phis, phid, g0max, g0min;
real T10, T11, T12, T13, T14;
real expff, lncosg0, inv_g0, inv_g0sq, e0, e1, e2, e3;

// Accumulation Model
real vgsfb, vgsfbeff, vt0;

// Short Channel Effect
real ETA0_t, ETA0R_t;
real scl, vbi, heff, phist, dvth_vtroll, dvth_dibl, dvth_rsce, dvth_all;
real tmp, Theta_SCE, Theta_SW, Theta_DIBL, Theta_RSCE;

//Lateral Non-uniform Doping Effect
real Mnud;

// Body Effect for BULKMOD=1
real ves, vesx, vesmax, veseff, Mob;

// Quantum mechanical correction [units are MKS]
real coxeff, Tcen0, Tcen, dvch_qm, MTcen;
real E0, E0prime, E1, E1prime, mx, mxprime, md, mdprime;
real gprime, gfactor, gam0, gam1, kT;

// Polysilicon Depletion
real vpoly0, vpolys, vpolyd, cpoly, kpoly;

// Drain Saturation Voltage
real Vdseff, qis, qid, qbs, Dmobs;

// Midpoint Potential and Charge
real qia, qia2, qba, dqi;
real qb0;
real eta_mu, eta_mu_cv, Eeffm, Eeffm_cv, Dmob, Dmob_cv, u0, ueff, u0_a, u0r; 
real UA_t, UAR_t, UC_t, UCR_t, UCS_t, UD_t, UDR_t, U0_t, U0R_t, ETAMOB_t, Eeffs, EeffFactor;

real Dr, WeffWRFactor;    
real RSourceGeo, RDrainGeo; 
real RDSWMIN_i, RDWMIN_i, RSWMIN_i; 
real Rdrain, Rsource; 

real rdstemp, Rdsi, Rdss;
real RSDR_t, RSDRR_t, RDDR_t, RDDRR_t;

real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm; 
real MclmCV, inv_MclmCV;

real Dvsat, Vdsat, inv_MEXP, DvsatCV, Nsat; 
real VSAT_t, VSAT1_t, VSAT1R_t, VSATCV_t, MEXP_t, MEXPR_t, Esat, EsatL, Esat1, Esat1L, EsatCV, EsatCVL; 
real WVCox, Ta, Tb, Tc; 

// Asymmetry Model
real VSAT1_a, MEXP_a, PTWG_a, RSDR_a, RDDR_a, PDIBL1_a, VSAT_a;

// Geometry dependent Source/Drain Resistance
real mu_max, mu_rsd, rhorsd, afin, thetarsp;
real Rsp, lt, arsd_total, prsd_total, alpha;
real eta, RrsdTML, Rrsdside, Rrsd;
real Rdsgeo, Arsd, Prsd;

// Geometry dependent fringing capacitance
real Hg, Wg, Trsd, Hrsd, Cgg_top, Cgg_side, Cfr_geo, Acorner, Ccorner;

// Gate Electrode Resistance
`ifdef __RGATEMOD__
    real ggeltd, Rgeltd;
`endif

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, igs, igd, vgs_eff, vgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;

// Impact Ionization current
real Iii, Vdiff, Vdsatii, VgsStep, Ratio, ALPHAII;

// Accumulation Capacitance
real cox_acc, vgsfbeff_acc, r1_acc, Inv_r1pi_acc;
real g0a, tang0a, qi_acc, q0_acc, qg_acc, qb_acc;
real F1_acc, cdop_acc, vtdop_acc, vt0_acc, vge;

// Parasitic Capacitance
real qgs_ov, qgd_ov, qgs_fr, qgd_fr, qds_fr;
real qgs_parasitic, qgd_parasitic, Qes, Qed, Qeg;
real vgs_overlap, vgd_overlap, vge_overlap;
real cgsp, cgdp, csbox, cdbox, cgbox;

// Junction Current and Capacitance
real Ies, Ied, ves_jct, ved_jct, vec;
real Czbs, Czbssw, Czbsswg, Czbd, Czbdsw, Czbdswg;
real pb2, arg, sarg, Qec;
real Qesj, Qesj1, Qesj2, Qesj3, Qedj, Qedj1, Qedj2, Qedj3;
real Isbs, Isbd, Nvtms, Nvtmd;
real SslpRev, IVjsmRev, VjsmRev, SslpFwd, IVjsmFwd, VjsmFwd, XExpBVS;
real DslpRev, IVjdmRev, VjdmRev, DslpFwd, IVjdmFwd, VjdmFwd, XExpBVD;
real igentemp, idsgen, LINTIGEN_i;

// NQS Gate Resistance
`ifdef __NQSMOD1__
    real gcrg, XRCRG1_i, XRCRG2_i;
    real IdovVds;
`endif

// NQS Charge Deficit Model
`ifdef __NQSMOD2__
    real xdpart, gtau, gcrg, XRCRG1_i, XRCRG2_i;
    real IdovVds;
`endif


// NQS Charge Deficit Model
`ifdef __NQSMOD3__
    real qil, qir, qiarl, dqirl, Tcomrl;
    real ids1, ids2, ids3, ids4, ids5, ids6, ids7, ids8, ids9, ids10, idsN;
    real qg1, qg2, qg3, qg4, qg5, qg6, qg7, qg8, qg9, qg10;
    real qd1, qd2, qd3, qd4, qd5, qd6, qd7, qd8, qd9, qd10;
`endif

// Flicker Noise
real LINTNOI_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real NTNOI_i, qinv;
real Gtnoi, sid;
real gspr, gdpr;

//Variables controlled by Correlated Thermal Noise Switch
`ifdef  __TNOIMOD2__
    real Abulk, etaa, gamma, delta, epsilon, gche;
    real npart_beta, npart_theta, ctnoi, npart_c;
    real noiGd0, GammaGd0, C0, sf;
`endif
// Self Heating
`ifdef __SHMOD__
    real gth, cth;
`endif

// Operating Point Vth
real qith;

// Binning
real Inv_L, Inv_NFIN, Inv_LNFIN;
real NBODY_i, PHIG_i, CFD_i, CFS_i, COVS_i, COVD_i, CGSO_i, CGDO_i;
real CGSL_i, CGDL_i, CGBL_i, CKAPPAS_i, CKAPPAD_i, CKAPPAB_i;
real QMFACTOR_i, QMTCENIV_i, QMTCENCV_i, QMTCENCVA_i, KSATIV_i, KSATIVR_i, KSATIV_a;
real CDSC_i, CDSCD_i, CDSCD_a, CDSCDR_i, CIT_i, DVT0_i, CITR_i, CIT_a;
real DVT1_i, DVT1SS_i, PHIN_i, ETA0_i, ETA0_a, ETA0R_i, DSUB_i, VSAT_i, VSATR_i, VSATR_t;
real K0_i, K01_i, K0SI_i, K0SI1_i, K1SI_i, K1SI1_i, PHIBE_i, K1_i, K11_i, K1SAT_i, K1SAT1_i;
real DELTAVSAT_i, PSAT_i, DELTAVSATCV_i, PSATCV_i, VSAT1_i, VSAT1R_i, PTWG_i, PTWGR_i, VSATCV_i;
real UP_i, U0_i, U0R_i, ETAMOB_i, NGATE_i, RDSW_i, UPR_i;
real PRWGS_i, PRWGD_i, WR_i, PDIBL1_i, PDIBL1R_i, PDIBL2_i,PDIBL2R_i, PDIBL2_a ;
real DROUT_i, PVAG_i;
real AIGBINV_i, AIGBINV1_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, AIGBACC1_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real AIGC_i, AIGC1_i, BIGC_i, CIGC_i, PIGCD_i;
real AIGS_i, AIGS1_i, BIGS_i, CIGS_i, NTOX_i, POXEDGE_i;
real AIGD_i, AIGD1_i, BIGD_i, CIGD_i;
real AGIDL_i, BGIDL_i, CGIDL_i, EGIDL_i, PGIDL_i;
real AGISL_i, BGISL_i, CGISL_i, EGISL_i, PGISL_i;
real ALPHA0_i, ALPHA1_i, ALPHAII0_i, ALPHAII1_i, BETA0_i;
real BETAII0_i, BETAII1_i, BETAII2_i, ESATII_i;
real LII_i, SII0_i, SII1_i, SII2_i, SIID_i, TII_i;
real MEXP_i, MEXPR_i;
real PCLM_i, PCLMG_i, PCLMCV_i, PCLM_a, PCLMR_i;
real A1_i, A2_i, A11_i, A21_i;
real K1RSCE_i, LPE0_i, DVTSHIFT_i, DVTSHIFT_a, DVTSHIFTR_i ;
real UA_i, UC_i, EU_i, UD_i, UCS_i, UAR_i, EUR_i, UCR_i, UDR_i, UA_a, UD_a, UC_a, EU_a; 
real UA1_i, UA1R_i, UC1_i, UD1_i, UCSTE_i, UTE_i, UTL_i, EMOBT_i, UC1R_i, UD1R_i, UTER_i, UTLR_i;
real PTWGT_i;
real AT_i, ATCV_i, ATR_i;
real RDW_i, RSW_i;
real PRT_i, KT1_i, TSS_i, IIT_i, IGT_i, TGIDL_i;
real NTGEN_i, AIGEN_i, BIGEN_i;
real theta_tnoi, beta_tnoi;
real overall_conductance;


//===================================================
//               analog block begins
//===================================================
analog begin
    
    /************************************************/
    /*      Geometry dependent calculations         */
    /************************************************/
`ifdef insideADMS
    @(initial_instance)
`endif
    begin : CMGBiasIndepCalc
        initialized  =  1;
        
        // Variable initialization to prevent hidden states
        R = 0;
        vgsfbeff_acc = 0; vt0 = 0; vt0_acc = 0;
        F1 = 0; F1_acc = 0; cdop_acc = 0;
        qid = 0; qis = 0; tang0d = 0; tang0s = 0;
        T11 = 0; T12 = 0; T13 = 0; T14 = 0;
        ids = 0; sigvds = 0; Iii = 0;
        qd = 0; qg = 0; qs = 0; qb = 0;
        Qbul = 0; aab = 0;
        Weff0 = 0; WeffCV0 = 0; Weff = 0; WeffCV = 0;
        CJS_t = 0; CJSWS_t = 0; CJSWGS_t = 0;
        CJD_t = 0; CJSWD_t = 0; CJSWGD_t = 0;
        PBS_t = 0; PBSWS_t = 0; PBSWGS_t = 0;
        PBD_t = 0; PBSWD_t = 0; PBSWGD_t = 0;
        JSS_t = 0; JSWS_t = 0; JSWGS_t = 0;
        JSD_t = 0; JSWD_t = 0; JSWGD_t = 0;
        JTSS_t = 0; JTSSWS_t = 0; JTSSWGS_t = 0;
        JTSD_t = 0; JTSSWD_t = 0; JTSSWGD_t = 0;
        NJTS_t = 0; NJTSSW_t = 0; NJTSSWG_t = 0;
        NJTSD_t = 0; NJTSSWD_t = 0; NJTSSWGD_t = 0;
        Ies = 0; Ied = 0;
        Czbs = 0; Czbssw = 0; Czbsswg = 0;
        Czbd = 0; Czbdsw = 0; Czbdswg = 0;
        Qes = 0; Qed = 0; Qeg = 0;
        Isbs = 0; Isbd = 0; Nvtms = 0; Nvtmd = 0;
        SslpRev = 0; IVjsmRev = 0; VjsmRev = 0;
        SslpFwd = 0; IVjsmFwd = 0; VjsmFwd = 0;    
        DslpRev = 0; IVjdmRev = 0; VjdmRev = 0;
        DslpFwd = 0; IVjdmFwd = 0; VjdmFwd = 0;    
        XExpBVS = 0; XExpBVD = 0; idsgen = 0;
        phibulk = 0; g0s = 0; g0d = 0;
        r1 = 0; q0 = 0; F2 = 0; Inv_r1pi = 0;
        Tcen = 0; MTcen = 0;
        Rdrain = 0; Rsource = 0; Cfr_geo = 0;
        igbinv = 0; igbs = 0; igbd = 0;
        igbacc = 0; igcs = 0; igcd = 0;
        igidl = 0; igisl = 0; igs = 0; igd = 0;
        cox_acc = 0; r1_acc = 0; Inv_r1pi_acc = 0;
        CGSO_i = 0; CGDO_i = 0;
        q0_acc = 0; qb_acc = 0; qg_acc = 0; qi_acc = 0;
        qgs_fr = 0; qgd_fr = 0; qds_fr = 0;
        qgs_parasitic = 0; qgd_parasitic = 0;
        FNPowerAt1Hz = 0; Gtnoi = 0;
        gspr = 0; gdpr = 0; Dr = 1.0 ;
        CDSCDR_i = 0; ETA0R_i  =  0; VSAT1R_i =  0; VSAT1R_t = 0;
        MEXPR_i  =  0; MEXPR_t = 0; PTWGR_i  =  0;PTWGR_t  =  0; PDIBL1R_i=  0; PDIBL2R_i = 0;
        PHIBE_i  =  0; K1_i =  0; K11_i = 0;
        K1SAT_i  =  0; K1SAT1_i = 0 ; KSATIVR_i = 0; 
        UC_i = 0; UC1_i = 0 ; UC_t = 0; U0R_i = 0 ; UPR_i = 0 ; EUR_i = 0 ; ATR_i = 0 ;
        CITR_i = 0; ETA0R_i = 0;
        PDIBL2R_i=0; PCLMR_i = 0 ;
        LeffCV_acc = 0; 
        RDDRR_t = 0 ; RSDRR_t = 0 ; Rdsi = 0;
        T3 = 0 ; Tcen0 = 0; vpolys = 0 ;  veseff = 0 ;
        U0R_t = 0 ; UAR_t = 0 ; UCR_t = 0 ; UDR_t = 0 ; VSAT_a = 0 ; 
        DVTSHIFTR_i = 0 ;UA1R_i = 0 ; UAR_i = 0 ; UC1R_i = 0 ; UCR_i = 0 ; UD1R_i = 0 ; UDR_i = 0 ; 
        UTER_i = 0; UTLR_i = 0; VSATR_i = 0; VSATR_t = 0; u0r = 0 ;
        // Thermal Noise 
        theta_tnoi = 0;  sid = 0 ; 
        beta_tnoi = 0;
        overall_conductance = 0;
	`ifdef  __TNOIMOD2__
            Abulk = 0; etaa = 0; gamma = 0; delta = 0; epsilon = 0; gche = 0;
            npart_beta=0; npart_theta=0; ctnoi = 0; npart_c = 0;
            noiGd0=0; GammaGd0=0; C0=0; sf=0;
        `endif
        
        `ifdef __RGATEMOD__
            ggeltd = 0;
        `endif
        `ifdef __NQSMOD3__
            ids1 = 0; ids2 = 0; ids3 = 0; ids4 = 0; ids5 = 0;
            ids6 = 0; ids7 = 0; ids8 = 0; ids9 = 0; ids10 = 0;
            idsN = 0;
            qg1 = 0; qg2 = 0; qg3 = 0; qg4 = 0; qg5 = 0;
            qg6 = 0; qg7 = 0; qg8 = 0; qg9 = 0; qg10 = 0;
            qd1 = 0; qd2 = 0; qd3 = 0; qd4 = 0; qd5 = 0;
            qd6 = 0; qd7 = 0; qd8 = 0; qd9 = 0; qd10 = 0;
        `endif
        

        // Effective Width Calculation
        case(GEOMOD)
            0: begin
                Weff0    =  2 * HFIN - DELTAW;
                WeffCV0  =  2 * HFIN - DELTAWCV;
            end
            1: begin
                Weff0    =  2 * HFIN + FECH * TFIN - DELTAW;
                WeffCV0  =  2 * HFIN + FECHCV * TFIN - DELTAWCV;
            end
            2: begin
                Weff0    =  2 * HFIN + 2 * FECH * TFIN - DELTAW;
                WeffCV0  =  2 * HFIN + 2 * FECHCV * TFIN - DELTAWCV;
            end
            3: begin
                R        =  D / 2.0;
                Weff0    =  `M_PI * D - DELTAW;
                WeffCV0  =  `M_PI * D - DELTAWCV;
             end
        endcase
        
        
        // Constants
        if( TYPE == `ntype ) devsign  =  1;
        else devsign =  -1;
        
        epssub =  EPSRSUB * `EPS0;
        epssp  =  EPSRSP * `EPS0;
        cox    =  3.9 * `EPS0 / EOT;
        csi    =  epssub / TFIN;
        cbox   =  3.9 * `EPS0 / EOTBOX;
        epsratio =  EPSRSUB / 3.9;  // for terms with EOT
        if (CAPMOD != 0 && BULKMOD != 0) cox_acc =  3.9 * `EPS0 / EOTACC;
        
        // SCE scaling length
        scl  =  sqrt(0.5 * epsratio * TFIN * EOT * (1.0 + TFIN/(4.0*epsratio*EOT)));
        heff =  sqrt(HFIN * (HFIN + 2 * epsratio * EOT) / 8.0);
        case(GEOMOD)
        1: begin
            scl  =  1.0 / sqrt(1.0 / (scl*scl) + 0.25 / (heff*heff));
        end
        2: begin
            scl  =  0.5 / sqrt(1.0 / (scl*scl) + 0.25 / (heff*heff));
        end
        3: begin
            scl  =  sqrt(0.5 * epsratio * R * EOT * (1.0 + R/(2.0*epsratio*EOT)));
        end
        endcase
        
        // Constants for quantum mechanical effects
        mx         =  0.916 * `MEL;
        mxprime    =  0.190 * `MEL;
        md         =  0.190 * `MEL;
        mdprime    =  0.417 * `MEL;
        gprime     =  4.0;
        gfactor    =  2.0;
        
        // Effective Channel Length for I-V / C-V
        Lg       =  L + XL;
        deltaL   =  LINT + LL * pow(Lg, -LLN);
        deltaL1  =  LINT + LL * pow(Lg+DLBIN, -LLN);
        deltaLCV =  DLC + LLC * pow(Lg, -LLN);
        Leff     =  Lg - 2.0 * deltaL;
        Leff1    =  Lg + DLBIN - 2.0 * deltaL1;        //Used in the binning equations only
        LeffCV   =  Lg - 2.0 * deltaLCV;
        if(CAPMOD == 1 && BULKMOD != 0) LeffCV_acc = LeffCV - DLCACC;

        // Total Fins
        NFINtotal  =  NFIN * NF;
        //Range Checking on Leff and Leff1 
        if(Leff <= 0) begin
            $strobe("Fatal: Leff = %e is not positive.", Leff);
        end else if(Leff <= 1e-9) begin
            $strobe("Warning: Leff = %e <= 1.0e-9.", Leff);
        end
        
        if(Leff1 <= 0) begin
            $strobe("Fatal: Leff1 = %e is not positive.", Leff1);
        end else if(Leff1 <= 1e-9) begin
            $strobe("Warning: Leff1 = %e <= 1.0e-9.", Leff1);
        end
        // Binning
        Inv_L     =  1.0e-6 / (Leff1);
        Inv_NFIN  =  1.0 / NFIN;
        Inv_LNFIN =  1.0e-6 / (Leff1 * NFIN);
        
        // Binning Equations (process parameters)
        NBODY_i  =  NBODY + Inv_L * LNBODY + Inv_NFIN * NNBODY + Inv_LNFIN * PNBODY;
        PHIG_i   =  PHIG + Inv_L * LPHIG + Inv_NFIN * NPHIG + Inv_LNFIN * PPHIG;
        NGATE_i  =  NGATE + Inv_L * LNGATE + Inv_NFIN * NNGATE + Inv_LNFIN * PNGATE;
        
        // Binning Equations (model parameters)
        CIT_i    =  CIT    + Inv_L * LCIT    + Inv_NFIN * NCIT    + Inv_LNFIN * PCIT;
        CDSC_i   =  CDSC   + Inv_L * LCDSC   + Inv_NFIN * NCDSC   + Inv_LNFIN * PCDSC;
        CDSCD_i  =  CDSCD  + Inv_L * LCDSCD  + Inv_NFIN * NCDSCD  + Inv_LNFIN * PCDSCD;
        DVT0_i   =  DVT0   + Inv_L * LDVT0   + Inv_NFIN * NDVT0   + Inv_LNFIN * PDVT0;
        DVT1_i   =  DVT1   + Inv_L * LDVT1   + Inv_NFIN * NDVT1   + Inv_LNFIN * PDVT1;
        DVT1SS_i =  DVT1SS + Inv_L * LDVT1SS + Inv_NFIN * NDVT1SS + Inv_LNFIN * PDVT1SS;
        PHIN_i   =  PHIN   + Inv_L * LPHIN   + Inv_NFIN * NPHIN   + Inv_LNFIN * PPHIN;
        ETA0_i   =  ETA0   + Inv_L * LETA0   + Inv_NFIN * NETA0   + Inv_LNFIN * PETA0;
        DSUB_i   =  DSUB   + Inv_L * LDSUB   + Inv_NFIN * NDSUB   + Inv_LNFIN * PDSUB;
        K1RSCE_i =  K1RSCE + Inv_L * LK1RSCE + Inv_NFIN * NK1RSCE + Inv_LNFIN * PK1RSCE;
        LPE0_i   =  LPE0   + Inv_L * LLPE0   + Inv_NFIN * NLPE0   + Inv_LNFIN * PLPE0;
        DVTSHIFT_i    =  DVTSHIFT + Inv_L * LDVTSHIFT + Inv_NFIN * NDVTSHIFT + Inv_LNFIN * PDVTSHIFT;
        K0_i          =  K0  + Inv_L * LK0  + Inv_NFIN * NK0  + Inv_LNFIN * PK0;
        K01_i         =  K01 + Inv_L * LK01  + Inv_NFIN * NK01 + Inv_LNFIN * PK01;
        K0SI_i        =  K0SI  + Inv_L * LK0SI  + Inv_NFIN * NK0SI  + Inv_LNFIN * PK0SI;
        K0SI1_i       =  K0SI1 + Inv_L * LK0SI1 + Inv_NFIN * NK0SI1 + Inv_LNFIN * PK0SI1;
        K1SI_i        =  K1SI  + Inv_L * LK1SI  + Inv_NFIN * NK1SI  + Inv_LNFIN * PK1SI;
        K1SI1_i       =  K1SI1 + Inv_L * LK1SI1 + Inv_NFIN * NK1SI1 + Inv_LNFIN * PK1SI1;
        
        if(BULKMOD != 0) begin
            PHIBE_i       =  PHIBE + Inv_L * LPHIBE + Inv_NFIN * NPHIBE + Inv_LNFIN * PPHIBE;
            K1_i          =  K1  + Inv_L * LK1  + Inv_NFIN * NK1  + Inv_LNFIN * PK1;
            K11_i         =  K11 + Inv_L * LK11 + Inv_NFIN * NK11 + Inv_LNFIN * PK11;
            K1SAT_i       =  K1SAT  + Inv_L * LK1SAT  + Inv_NFIN * NK1SAT  + Inv_LNFIN * PK1SAT;
            K1SAT1_i      =  K1SAT1 + Inv_L * LK1SAT1 + Inv_NFIN * NK1SAT1 + Inv_LNFIN * PK1SAT1;
        end
        
        QMFACTOR_i    =  QMFACTOR + Inv_L * LQMFACTOR + Inv_NFIN * NQMFACTOR + Inv_LNFIN * PQMFACTOR;
        QMTCENIV_i    =  QMTCENIV + Inv_L * LQMTCENIV + Inv_NFIN * NQMTCENIV + Inv_LNFIN * PQMTCENIV;
        QMTCENCV_i    =  QMTCENCV + Inv_L * LQMTCENCV + Inv_NFIN * NQMTCENCV + Inv_LNFIN * PQMTCENCV;
        QMTCENCVA_i   =  QMTCENCVA + Inv_L * LQMTCENCVA + Inv_NFIN * NQMTCENCVA + Inv_LNFIN * PQMTCENCVA;
        VSAT_i        =  VSAT + Inv_L * LVSAT + Inv_NFIN * NVSAT + Inv_LNFIN * PVSAT;
        VSAT1_i       =  VSAT1 + Inv_L * LVSAT1 + Inv_NFIN * NVSAT1 + Inv_LNFIN * PVSAT1;
        VSATCV_i      =  VSATCV + Inv_L * LVSATCV + Inv_NFIN * NVSATCV + Inv_LNFIN * PVSATCV;
        DELTAVSAT_i   =  DELTAVSAT + Inv_L * LDELTAVSAT + Inv_NFIN * NDELTAVSAT + Inv_LNFIN * PDELTAVSAT;
        PSAT_i        =  PSAT   + Inv_L * LPSAT   + Inv_NFIN * NPSAT   + Inv_LNFIN * PPSAT;
        DELTAVSATCV_i =  DELTAVSATCV + Inv_L * LDELTAVSATCV + Inv_NFIN * NDELTAVSATCV + Inv_LNFIN * PDELTAVSATCV;
        PSATCV_i =  PSATCV + Inv_L * LPSATCV + Inv_NFIN * NPSATCV + Inv_LNFIN * PPSATCV;
        KSATIV_i =  KSATIV + Inv_L * LKSATIV + Inv_NFIN * NKSATIV + Inv_LNFIN * PKSATIV;
        MEXP_i   =  MEXP  + Inv_L  * LMEXP  + Inv_NFIN * NMEXP  + Inv_LNFIN * PMEXP;
        PTWG_i   =  PTWG  + Inv_L  * LPTWG  + Inv_NFIN * NPTWG  + Inv_LNFIN * PPTWG;
        U0_i      =  U0 + Inv_L * LU0 + Inv_NFIN * NU0 + Inv_LNFIN * PU0;
        ETAMOB_i =  ETAMOB + Inv_L * LETAMOB + Inv_NFIN * NETAMOB + Inv_LNFIN * PETAMOB;
        UP_i      =  UP + Inv_L * LUP + Inv_NFIN * NUP + Inv_LNFIN * PUP;
        UA_i      =  UA + Inv_L * LUA + Inv_NFIN * NUA + Inv_LNFIN * PUA;
        if(BULKMOD != 0) begin
             UC_i  =  UC + Inv_L * LUC + Inv_NFIN * NUC + Inv_LNFIN * PUC;
        end
        EU_i      =  EU + Inv_L * LEU + Inv_NFIN * NEU + Inv_LNFIN * PEU;
        UD_i      =  UD + Inv_L * LUD + Inv_NFIN * NUD + Inv_LNFIN * PUD;
        UCS_i    =  UCS + Inv_L * LUCS + Inv_NFIN * NUCS + Inv_LNFIN * PUCS;
        PCLM_i   =  PCLM + Inv_L * LPCLM + Inv_NFIN * NPCLM + Inv_LNFIN * PPCLM;
        PCLMG_i  =  PCLMG + Inv_L * LPCLMG + Inv_NFIN * NPCLMG + Inv_LNFIN * PPCLMG;
        PCLMCV_i =  PCLMCV + Inv_L * LPCLMCV + Inv_NFIN * NPCLMCV + Inv_LNFIN * PPCLMCV;
        A1_i     =  A1  + Inv_L * LA1  + Inv_NFIN * NA1  + Inv_LNFIN * PA1;
        A11_i     =  A11 + Inv_L * LA11 + Inv_NFIN * NA11 + Inv_LNFIN * PA11;
        A2_i      =  A2  + Inv_L * LA2  + Inv_NFIN * NA2  + Inv_LNFIN * PA2;
        A21_i      =  A21 + Inv_L * LA21 + Inv_NFIN * NA21 + Inv_LNFIN * PA21;
        RDSW_i   =  RDSW + Inv_L * LRDSW + Inv_NFIN * NRDSW + Inv_LNFIN * PRDSW;
        RSW_i    =  RSW + Inv_L * LRSW + Inv_NFIN * NRSW + Inv_LNFIN * PRSW;
        RDW_i    =  RDW + Inv_L * LRDW + Inv_NFIN * NRDW + Inv_LNFIN * PRDW;
        PRWGD_i  =  PRWGD + Inv_L * LPRWGD + Inv_NFIN * NPRWGD + Inv_LNFIN * PPRWGD;
        PRWGS_i  =  PRWGS + Inv_L * LPRWGS + Inv_NFIN * NPRWGS + Inv_LNFIN * PPRWGS;
        WR_i      =  WR + Inv_L * LWR + Inv_NFIN * NWR + Inv_LNFIN * PWR;
        PDIBL1_i =  PDIBL1 + Inv_L * LPDIBL1 + Inv_NFIN * NPDIBL1 + Inv_LNFIN * PPDIBL1;
        PDIBL2_i =  PDIBL2 + Inv_L * LPDIBL2 + Inv_NFIN * NPDIBL2 + Inv_LNFIN * PPDIBL2;
        DROUT_i  =  DROUT + Inv_L * LDROUT + Inv_NFIN * NDROUT + Inv_LNFIN * PDROUT;
        PVAG_i   =  PVAG + Inv_L * LPVAG + Inv_NFIN * NPVAG + Inv_LNFIN * PPVAG;
        AIGBINV_i  =  AIGBINV  + Inv_L * LAIGBINV  + Inv_NFIN * NAIGBINV  + Inv_LNFIN * PAIGBINV;
        AIGBINV1_i =  AIGBINV1 + Inv_L * LAIGBINV1 + Inv_NFIN * NAIGBINV1 + Inv_LNFIN * PAIGBINV1;
        BIGBINV_i  =  BIGBINV  + Inv_L * LBIGBINV  + Inv_NFIN * NBIGBINV  + Inv_LNFIN * PBIGBINV;
        CIGBINV_i  =  CIGBINV  + Inv_L * LCIGBINV  + Inv_NFIN * NCIGBINV  + Inv_LNFIN * PCIGBINV;
        EIGBINV_i  =  EIGBINV  + Inv_L * LEIGBINV  + Inv_NFIN * NEIGBINV  + Inv_LNFIN * PEIGBINV;
        NIGBINV_i  =  NIGBINV  + Inv_L * LNIGBINV  + Inv_NFIN * NNIGBINV  + Inv_LNFIN * PNIGBINV;
        AIGBACC_i  =  AIGBACC  + Inv_L * LAIGBACC  + Inv_NFIN * NAIGBACC  + Inv_LNFIN * PAIGBACC;
        AIGBACC1_i =  AIGBACC1 + Inv_L * LAIGBACC1 + Inv_NFIN * NAIGBACC1 + Inv_LNFIN * PAIGBACC1;
        BIGBACC_i  =  BIGBACC  + Inv_L * LBIGBACC  + Inv_NFIN * NBIGBACC  + Inv_LNFIN * PBIGBACC;
        CIGBACC_i  =  CIGBACC  + Inv_L * LCIGBACC  + Inv_NFIN * NCIGBACC  + Inv_LNFIN * PCIGBACC;
        NIGBACC_i  =  NIGBACC  + Inv_L * LNIGBACC  + Inv_NFIN * NNIGBACC  + Inv_LNFIN * PNIGBACC;
        AIGC_i      =  AIGC  + Inv_L * LAIGC  + Inv_NFIN * NAIGC  + Inv_LNFIN * PAIGC;
        AIGC1_i  =  AIGC1 + Inv_L * LAIGC1 + Inv_NFIN * NAIGC1 + Inv_LNFIN * PAIGC1;
        BIGC_i   =  BIGC  + Inv_L * LBIGC  + Inv_NFIN * NBIGC  + Inv_LNFIN * PBIGC;
        CIGC_i   =  CIGC  + Inv_L * LCIGC  + Inv_NFIN * NCIGC  + Inv_LNFIN * PCIGC;
        PIGCD_i  =  PIGCD + Inv_L * LPIGCD + Inv_NFIN * NPIGCD + Inv_LNFIN * PPIGCD;
        AIGS_i   =  AIGS  + Inv_L * LAIGS  + Inv_NFIN * NAIGS  + Inv_LNFIN * PAIGS;
        AIGS1_i  =  AIGS1 + Inv_L * LAIGS1 + Inv_NFIN * NAIGS1 + Inv_LNFIN * PAIGS1;
        BIGS_i   =  BIGS  + Inv_L * LBIGS  + Inv_NFIN * NBIGS  + Inv_LNFIN * PBIGS;
        CIGS_i   =  CIGS  + Inv_L * LCIGS  + Inv_NFIN * NCIGS  + Inv_LNFIN * PCIGS;
        AIGD_i   =  AIGD  + Inv_L * LAIGD  + Inv_NFIN * NAIGD  + Inv_LNFIN * PAIGD;
        AIGD1_i  =  AIGD1 + Inv_L * LAIGD1 + Inv_NFIN * NAIGD1 + Inv_LNFIN * PAIGD1;
        BIGD_i   =  BIGD  + Inv_L * LBIGD  + Inv_NFIN * NBIGD  + Inv_LNFIN * PBIGD;
        CIGD_i   =  CIGD  + Inv_L * LCIGD  + Inv_NFIN * NCIGD  + Inv_LNFIN * PCIGD;
        NTOX_i   =  NTOX  + Inv_L * LNTOX  + Inv_NFIN * NNTOX  + Inv_LNFIN * PNTOX;
        POXEDGE_i  =  POXEDGE + Inv_L * LPOXEDGE + Inv_NFIN * NPOXEDGE + Inv_LNFIN * PPOXEDGE;
        AGIDL_i    =  AGIDL + Inv_L * LAGIDL + Inv_NFIN * NAGIDL + Inv_LNFIN * PAGIDL;
        BGIDL_i    =  BGIDL + Inv_L * LBGIDL + Inv_NFIN * NBGIDL + Inv_LNFIN * PBGIDL;
        CGIDL_i    =  CGIDL + Inv_L * LCGIDL + Inv_NFIN * NCGIDL + Inv_LNFIN * PCGIDL;
        EGIDL_i    =  EGIDL + Inv_L * LEGIDL + Inv_NFIN * NEGIDL + Inv_LNFIN * PEGIDL;
        PGIDL_i    =  PGIDL + Inv_L * LPGIDL + Inv_NFIN * NPGIDL + Inv_LNFIN * PPGIDL;
        AGISL_i    =  AGISL + Inv_L * LAGISL + Inv_NFIN * NAGISL + Inv_LNFIN * PAGISL;
        BGISL_i    =  BGISL + Inv_L * LBGISL + Inv_NFIN * NBGISL + Inv_LNFIN * PBGISL;
        CGISL_i    =  CGISL + Inv_L * LCGISL + Inv_NFIN * NCGISL + Inv_LNFIN * PCGISL;
        EGISL_i    =  EGISL + Inv_L * LEGISL + Inv_NFIN * NEGISL + Inv_LNFIN * PEGISL;
        PGISL_i    =  PGISL + Inv_L * LPGISL + Inv_NFIN * NPGISL + Inv_LNFIN * PPGISL;
        ALPHA0_i   =  ALPHA0 + Inv_L * LALPHA0 + Inv_NFIN * NALPHA0 + Inv_LNFIN * PALPHA0;
        ALPHA1_i   =  ALPHA1 + Inv_L * LALPHA1 + Inv_NFIN * NALPHA1 + Inv_LNFIN * PALPHA1;
        
        ALPHAII0_i =  ALPHAII0 + Inv_L * LALPHAII0 + Inv_NFIN * NALPHAII0 + Inv_LNFIN * PALPHAII0;
        ALPHAII1_i =  ALPHAII1 + Inv_L * LALPHAII1 + Inv_NFIN * NALPHAII1 + Inv_LNFIN * PALPHAII1;
        
        BETA0_i    =  BETA0 + Inv_L * LBETA0 + Inv_NFIN * NBETA0 + Inv_LNFIN * PBETA0;
        BETAII0_i  =  BETAII0 + Inv_L * LBETAII0 + Inv_NFIN * NBETAII0 + Inv_LNFIN * PBETAII0;
        BETAII1_i  =  BETAII1 + Inv_L * LBETAII1 + Inv_NFIN * NBETAII1 + Inv_LNFIN * PBETAII1;
        BETAII2_i  =  BETAII2 + Inv_L * LBETAII2 + Inv_NFIN * NBETAII2 + Inv_LNFIN * PBETAII2;
        ESATII_i   =  ESATII + Inv_L * LESATII + Inv_NFIN * NESATII + Inv_LNFIN * PESATII;
        LII_i  =  LII + Inv_L * LLII + Inv_NFIN * NLII + Inv_LNFIN * PLII;
        SII0_i =  SII0 + Inv_L * LSII0 + Inv_NFIN * NSII0 + Inv_LNFIN * PSII0;
        SII1_i =  SII1 + Inv_L * LSII1 + Inv_NFIN * NSII1 + Inv_LNFIN * PSII1;
        SII2_i =  SII2 + Inv_L * LSII2 + Inv_NFIN * NSII2 + Inv_LNFIN * PSII2;
        SIID_i =  SIID + Inv_L * LSIID + Inv_NFIN * NSIID + Inv_LNFIN * PSIID;
        TII_i  =  TII + Inv_L * LTII + Inv_NFIN * NTII + Inv_LNFIN * PTII;
        CFS_i  =  CFS + Inv_L * LCFS + Inv_NFIN * NCFS + Inv_LNFIN * PCFS;
        CFD_i  =  CFD + Inv_L * LCFD + Inv_NFIN * NCFD + Inv_LNFIN * PCFD;
        COVS_i =  COVS + Inv_L * LCOVS + Inv_NFIN * NCOVS + Inv_LNFIN * PCOVS;
        COVD_i =  COVD + Inv_L * LCOVD + Inv_NFIN * NCOVD + Inv_LNFIN * PCOVD;
        CGSL_i =  CGSL + Inv_L * LCGSL + Inv_NFIN * NCGSL + Inv_LNFIN * PCGSL;
        CGDL_i =  CGDL + Inv_L * LCGDL + Inv_NFIN * NCGDL + Inv_LNFIN * PCGDL;
        CGBL_i =  CGBL + Inv_L * LCGBL + Inv_NFIN * NCGBL + Inv_LNFIN * PCGBL;
        CKAPPAS_i  =  CKAPPAS + Inv_L * LCKAPPAS + Inv_NFIN * NCKAPPAS + Inv_LNFIN * PCKAPPAS;
        CKAPPAD_i  =  CKAPPAD + Inv_L * LCKAPPAD + Inv_NFIN * NCKAPPAD + Inv_LNFIN * PCKAPPAD;
        CKAPPAB_i  =  CKAPPAB + Inv_L * LCKAPPAB + Inv_NFIN * NCKAPPAB + Inv_LNFIN * PCKAPPAB;
        NTGEN_i    =  NTGEN + Inv_L * LNTGEN + Inv_NFIN * NNTGEN + Inv_LNFIN * PNTGEN;
        AIGEN_i    =  AIGEN + Inv_L * LAIGEN + Inv_NFIN * NAIGEN + Inv_LNFIN * PAIGEN;
        BIGEN_i    =  BIGEN + Inv_L * LBIGEN + Inv_NFIN * NBIGEN + Inv_LNFIN * PBIGEN;

        if(ASYMMOD != 0) begin
            CDSCDR_i =  CDSCDR + Inv_L * LCDSCDR + Inv_NFIN * NCDSCDR + Inv_LNFIN * PCDSCDR;
            CITR_i    =  CITR    + Inv_L * LCITR    + Inv_NFIN * NCITR    + Inv_LNFIN * PCITR;
            ETA0R_i  =  ETA0R + Inv_L * LETA0R + Inv_NFIN * NETA0R + Inv_LNFIN * PETA0R;
            VSAT1R_i =  VSAT1R + Inv_L * LVSAT1R + Inv_NFIN * NVSAT1R + Inv_LNFIN * PVSAT1R;
            MEXPR_i  =  MEXPR + Inv_L  * LMEXPR + Inv_NFIN * NMEXPR + Inv_LNFIN * PMEXPR;
            PTWGR_i  =  PTWGR + Inv_L * LPTWGR + Inv_NFIN * NPTWGR + Inv_LNFIN * PPTWGR;
            PDIBL1R_i=  PDIBL1R + Inv_L * LPDIBL1R + Inv_NFIN * NPDIBL1R + Inv_LNFIN * PPDIBL1R;
            PDIBL2R_i=  PDIBL2R + Inv_L * LPDIBL2R + Inv_NFIN * NPDIBL2R + Inv_LNFIN * PPDIBL2R;
            PCLMR_i=  PCLMR + Inv_L * LPCLMR + Inv_NFIN * NPCLMR + Inv_LNFIN * PPCLMR;
            DVTSHIFTR_i    =  DVTSHIFTR + Inv_L * LDVTSHIFTR + Inv_NFIN * NDVTSHIFTR + Inv_LNFIN * PDVTSHIFTR;
            VSATR_i        =  VSATR + Inv_L * LVSATR + Inv_NFIN * NVSATR + Inv_LNFIN * PVSATR;
            KSATIVR_i =  KSATIVR + Inv_L * LKSATIVR + Inv_NFIN * NKSATIVR + Inv_LNFIN * PKSATIVR;
            U0R_i      =  U0R + Inv_L * LU0R + Inv_NFIN * NU0R + Inv_LNFIN * PU0R;
            UAR_i      =  UAR + Inv_L * LUAR + Inv_NFIN * NUAR + Inv_LNFIN * PUAR;
            if(BULKMOD != 0) begin
                UCR_i = UCR + Inv_L * LUCR + Inv_NFIN * NUCR + Inv_LNFIN * PUCR;
            end
            EUR_i      =  EUR + Inv_L * LEUR + Inv_NFIN * NEUR + Inv_LNFIN * PEUR;
            UDR_i      =  UDR + Inv_L * LUDR + Inv_NFIN * NUDR + Inv_LNFIN * PUDR;
        end

        `ifdef __NQSMOD1__
            if(NQSMOD == 1 && XRCRG1 != 0) begin
                XRCRG1_i =  XRCRG1 + Inv_L * LXRCRG1 + Inv_NFIN * NXRCRG1 + Inv_LNFIN * PXRCRG1;
                XRCRG2_i =  XRCRG2 + Inv_L * LXRCRG2 + Inv_NFIN * NXRCRG2 + Inv_LNFIN * PXRCRG2;
            end else begin
                XRCRG1_i =  0.0;
                XRCRG2_i =  0.0;
            end
        `else
            if(NQSMOD == 1)
                $strobe("[bsimcmg] Although the model selector NQSMOD is set to 1, the NQS gate resistance model is not activated in the Verilog-A code. Please uncomment \"`define __NQSMOD1__\" in bsimcmg.va to activate it.");
        `endif

        `ifdef __NQSMOD2__
            if(NQSMOD == 2 && XRCRG1 != 0) begin
                XRCRG1_i =  XRCRG1 + Inv_L * LXRCRG1 + Inv_NFIN * NXRCRG1 + Inv_LNFIN * PXRCRG1;
                XRCRG2_i =  XRCRG2 + Inv_L * LXRCRG2 + Inv_NFIN * NXRCRG2 + Inv_LNFIN * PXRCRG2;
            end else begin
                XRCRG1_i =  0.0;
                XRCRG2_i =  0.0;
            end
        `else
            if(NQSMOD == 2)
                $strobe("[bsimcmg] Although the model selector NQSMOD is set to 2, the NQS gate resistance model is not activated in the Verilog-A code. Please uncomment \"`define __NQSMOD2__\" in bsimcmg.va to activate it.");
        `endif

        UTE_i    =  UTE + Inv_L * LUTE + Inv_NFIN * NUTE + Inv_LNFIN * PUTE;
        UTL_i    =  UTL + Inv_L * LUTL + Inv_NFIN * NUTL + Inv_LNFIN * PUTL;
        EMOBT_i  =  EMOBT + Inv_L * LEMOBT + Inv_NFIN * NEMOBT + Inv_LNFIN * PEMOBT;
        UA1_i    =  UA1 + Inv_L * LUA1 + Inv_NFIN * NUA1 + Inv_LNFIN * PUA1;
                
        if(BULKMOD != 0) begin
            UC1_i  =  UC1 + Inv_L * LUC1 + Inv_NFIN * NUC1 + Inv_LNFIN * PUC1;
        end
        UD1_i    =  UD1 + Inv_L * LUD1 + Inv_NFIN * NUD1 + Inv_LNFIN * PUD1;
        UCSTE_i  =  UCSTE + Inv_L * LUCSTE + Inv_NFIN * NUCSTE + Inv_LNFIN * PUCSTE;
        PTWGT_i  =  PTWGT + Inv_L * LPTWGT + Inv_NFIN * NPTWGT + Inv_LNFIN * PPTWGT;
        AT_i     =  AT    + Inv_L * LAT    + Inv_NFIN * NAT + Inv_LNFIN * PAT;
        ATCV_i   =  ATCV  + Inv_L * LATCV  + Inv_NFIN * NATCV  + Inv_LNFIN * PATCV;
        PRT_i    =  PRT   + Inv_L * LPRT   + Inv_NFIN * NPRT   + Inv_LNFIN * PPRT;
        KT1_i    =  KT1   + Inv_L * LKT1   + Inv_NFIN * NKT1   + Inv_LNFIN * PKT1;
        TSS_i    =  TSS   + Inv_L * LTSS   + Inv_NFIN * NTSS   + Inv_LNFIN * PTSS;
        IIT_i    =  IIT   + Inv_L * LIIT   + Inv_NFIN * NIIT   + Inv_LNFIN * PIIT;
        TGIDL_i  =  TGIDL + Inv_L * LTGIDL + Inv_NFIN * NTGIDL + Inv_LNFIN * PTGIDL;
        IGT_i    =  IGT   + Inv_L * LIGT   + Inv_NFIN * NIGT   + Inv_LNFIN * PIGT;
        
        if (ASYMMOD != 0) begin
             UTER_i    =  UTER + Inv_L * LUTER + Inv_NFIN * NUTER + Inv_LNFIN * PUTER;
             UTLR_i    =  UTLR + Inv_L * LUTLR + Inv_NFIN * NUTLR + Inv_LNFIN * PUTLR;
             UA1R_i    =  UA1R + Inv_L * LUA1R + Inv_NFIN * NUA1R + Inv_LNFIN * PUA1R;
             UD1R_i    =  UD1R + Inv_L * LUD1R + Inv_NFIN * NUD1R + Inv_LNFIN * PUD1R;
             ATR_i     =  ATR    + Inv_L * LATR    + Inv_NFIN * NATR + Inv_LNFIN * PATR;
             if(BULKMOD != 0) begin
                 UC1R_i  =  UC1R + Inv_L * LUC1R + Inv_NFIN * NUC1R + Inv_LNFIN * PUC1R;
             end
        end
        // Geometrical scaling
        // NFIN Scaling
        if(PHIGN1 !=0)
            PHIG_i  =  PHIG_i * (1.0 + PHIGN1/NFIN * lln(1.0 + NFIN/PHIGN2));
        
        if(ETA0N1 !=0)
            ETA0_i  =  ETA0_i * (1.0 + ETA0N1/NFIN * lln(1.0 + NFIN/ETA0N2));
    
        if(CDSCN1 !=0)
            CDSC_i  =  CDSC_i * (1.0 + CDSCN1/NFIN * lln(1.0 + NFIN/CDSCN2));

        if(CDSCDN1 !=0)
            CDSCD_i  =  CDSCD_i * (1.0 + CDSCDN1/NFIN * lln(1.0 + NFIN/CDSCDN2));

        if(CDSCDRN1 !=0)
            CDSCDR_i  =  CDSCDR_i * (1.0 + CDSCDRN1/NFIN * lln(1.0 + NFIN/CDSCDRN2));
        
        if(NBODYN1 !=0)
            NBODY_i  =  NBODY_i * (1.0 + NBODYN1/NFIN * lln(1.0 + NFIN/NBODYN2));
    
        if(VSATN1 !=0)
            VSAT_i  =  VSAT_i * (1.0 + VSATN1/NFIN * lln(1.0 + NFIN/VSATN2));
        
        if(VSAT1N1 !=0)
            VSAT1_i  =  VSAT1_i * (1.0 + VSAT1N1/NFIN * lln(1.0 + NFIN/VSAT1N2));
    
        if(VSAT1RN1 !=0)
            VSAT1R_i  =  VSAT1R_i * (1.0 + VSAT1RN1/NFIN * lln(1.0 + NFIN/VSAT1RN2));
    
        if(U0N1 !=0)
            U0_i  =  U0_i * (1.0 + U0N1/NFIN * lln(1.0 + NFIN/U0N2));
        if(U0N1R !=0) U0R_i  =  U0R_i * (1.0 + U0N1R/NFIN * lln(1.0 + NFIN/U0N2R));
        // Length Scaling
        PHIG_i = PHIG_i + PHIGL * Leff;
        
        if(LPA > 0) U0_i =  U0_i * (1 - UP_i * pow(Leff, -LPA)); 
        else U0_i  =  U0_i * (1 - UP_i); 
        
        UA_i =  UA_i + AUA * lexp(-Leff / BUA); 
        UD_i =  UD_i + AUD * lexp(-Leff / BUD); 
        EU_i =  EU_i + AEU * lexp(-Leff / BEU);
        
        if (ASYMMOD != 0) begin
            if(LPAR > 0) U0R_i =  U0R_i * (1 - UPR_i * pow(Leff, -LPAR)); 
            else U0R_i  =  U0R_i * (1 - UPR_i); 
            UAR_i =  UAR_i + AUAR * lexp(-Leff / BUAR);
            UDR_i =  UDR_i + AUDR * lexp(-Leff / BUDR);
            EUR_i =  EUR_i + AEUR * lexp(-Leff / BEUR);
        end
            
        if(RDSMOD == 1) begin 
            RSW_i  =  RSW_i + ARSW * lexp(-Leff / BRSW); 
            RDW_i  =  RDW_i + ARDW * lexp(-Leff / BRDW); 
        end else begin 
            RDSW_i =  RDSW_i + ARDSW * lexp(-Leff / BRDSW); 
        end 
        
        PCLM_i   =  PCLM_i  + APCLM  * lexp(-Leff / BPCLM);
        if(ASYMMOD != 0) PCLMR_i  =  PCLMR_i + APCLMR * pow(Leff, -BPCLMR);
        MEXP_i   =  MEXP_i  + AMEXP  * pow(Leff, -BMEXP);
        if(ASYMMOD != 0) MEXPR_i  =  MEXPR_i + AMEXPR * pow(Leff, -BMEXPR);
        PTWG_i   =  PTWG_i + APTWG * lexp(-Leff / BPTWG); 
        if(ASYMMOD != 0)  PTWGR_i  =  PTWGR_i + APTWG * lexp(-Leff / BPTWG); 
        VSAT_i   =  VSAT_i + AVSAT * lexp(-Leff / BVSAT); 
        VSAT1_i  =  VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1);
        if(ASYMMOD != 0)  VSAT1R_i =  VSAT1R_i + AVSAT1 * lexp(-Leff / BVSAT1);
        PSAT_i   =  PSAT_i   + APSAT   * lexp(-Leff / BPSAT);
        PSATCV_i =  PSATCV_i + APSATCV * lexp(-Leff / BPSATCV); 
        VSATCV_i =  VSATCV_i + AVSATCV * lexp(-LeffCV / BVSATCV);
        
        // Geometrical Scaling for Toxeff / Charge Centroid Tcen
        if(QMTCENIV_i > 0.0 || QMTCENCV_i > 0.0 || QMTCENCVA_i > 0.0) begin
            case(GEOMOD)
                0 : begin
                    MTcen  =  1.0 + AQMTCEN * lexp(- TFIN / BQMTCEN);
                    Tcen0  =  TFIN * MTcen;
                end
                1 : begin
                    MTcen  =  1.0 + AQMTCEN * lexp(- min(HFIN,TFIN) / BQMTCEN);
                    Tcen0  =  min(TFIN,HFIN) * MTcen ;
                end
                2: begin
                    MTcen  =  1.0 + AQMTCEN * lexp(- min(HFIN,TFIN) / BQMTCEN);
                    Tcen0  =  min(TFIN,HFIN) * MTcen ;
                end
                3 : begin
                    MTcen  =  1.0 + AQMTCEN * lexp(- R / BQMTCEN);
                    Tcen0  =  R * MTcen;
                end
            endcase
        end
        
        // **************************************
        //           Parameter checking
        // **************************************
        
        if(LeffCV <= 1e-9) begin
            $strobe("Warning: LeffCV = %e <= 1.0e-9.", LeffCV);
        end
        if(CAPMOD != 0 && BULKMOD != 0) begin
            if(LeffCV_acc <= 1e-9) begin
                $strobe("Warning: LeffCV_acc = %e <= 1.0e-9.", LeffCV_acc);
            end
        end
        if(Weff0 <= 1e-9) begin
            $strobe("Warning: Weff0 = %e <= 1.0e-9.", Weff0);
        end
        if(WeffCV0 <= 1e-9) begin
            $strobe("Warning: WeffCV0 = %e <= 1.0e-9.", WeffCV0);
        end
        if(NBODY_i <= 0) begin
            $strobe("Fatal: NBODY_i = %e is not positive.", NBODY_i);
        end else if(NBODY_i <= 1e18) begin
            $strobe("Warning: NBODY_i = %e m^-3 may be too small.", NBODY_i);
        end 
        if(NGATE_i < 0) begin
            $strobe("Fatal: NGATE_i = %e is negative.", NGATE_i);
        end else if(NGATE_i != 0 && NGATE_i <= 1e24) begin
            $strobe("Warning: NGATE_i = %e may be too small.", NGATE_i);
        end else if(NGATE_i > 1e31) begin
            $strobe("Fatal: NGATE_i = %e is too high.", NGATE_i);
        end
        if(DVT0_i < 0) begin
            $strobe("Warning: DVT0_i = %e is negative.", DVT0_i);
        end
        if(PHIG_i <= 0) begin
            $strobe("Fatal: PHIG_i = %e is not positive.", PHIG_i);
        end
        if(VSAT_i <= 0) begin
            $strobe("Fatal: VSAT_i = %e is not positive.", VSAT_i);
        end
        if(VSAT1_i <= 0) begin
            $strobe("Fatal: VSAT1_i = %e is not positive.", VSAT1_i);
        end
        if( ASYMMOD != 0 && VSAT1R_i <= 0 ) begin
            $strobe("Fatal: VSAT1R_i = %e is not positive.", VSAT1R_i);
        end
        if(DVT1_i <= 0) begin
            $strobe("Fatal: DVT1_i = %e is not positive.", DVT1_i);
        end
        if(DVT1SS_i <= 0) begin
            $strobe("Fatal: DVT1SS_i = %e is not positive.", DVT1SS_i);
        end
        if(CDSC_i < 0) begin
            $strobe("Warning: CDSC_i = %e is negative.", CDSC_i);
        end
        if(CDSCD_i < 0) begin
            $strobe("Warning: CDSCD_i = %e is negative.", CDSCD_i);
        end
        if(ASYMMOD != 0 && CDSCDR_i < 0) begin
            $strobe("Warning: CDSCDR_i = %e is negative.", CDSCDR_i);
        end
        if(DSUB_i <= 0) begin
            $strobe("Fatal: DSUB_i = %e is not positive.", DSUB_i);
        end
        if(ETA0_i < 0) begin
            $strobe("Warning: ETA0_i = %e is negative, setting it to 0", ETA0_i);
            ETA0_i = 0;
        end
        if(ETA0R_i < 0) begin
            $strobe("Warning: ETA0R_i = %e is negative, setting it to 0", ETA0R_i);
            ETA0R_i = 0;
        end
        if(LPE0_i < -Leff) begin
            $strobe("Warning: LPE0_i = %e is less than -Leff. Clipping LPE0_i to 0", LPE0_i);
            LPE0_i =  0;
        end

        if(K0SI_i <= 0) begin
            $strobe("Warning: K0SI_i = %e is not positive, setting it to 0.", K0SI_i);
            K0SI_i = 0;
        end

        if(K1SI_i <= 0) begin
            $strobe("Warning: K1SI_i = %e is not positive, setting it to 0.", K1SI_i);
            K1SI_i = 0;
        end

        if(PHIBE_i < 0.2 && BULKMOD != 0) begin
            $strobe("Warning: PHIBE_i = %e is less than 0.2, setting it to 0.2.", PHIBE_i);
            PHIBE_i = 0.2;
        end

        if(PHIBE_i > 1.2 && BULKMOD != 0) begin
            $strobe("Warning: PHIBE_i = %e is larger than 1.2, setting it to 1.2.", PHIBE_i);
            PHIBE_i = 1.2;
        end

        if(PSAT_i < 2.0) begin
            $strobe("Warning: PSAT_i = %e is less than 2.0, setting it to 2.0.", PSAT_i);
            PSAT_i = 2.0; 
        end
        
        if(PSATCV_i < 2.0) begin
            $strobe("Warning: PSATCV_i = %e is less than 2.0, setting it to 2.0.", PSATCV_i);
            PSATCV_i = 2.0; 
        end

        if(U0_i < 0) begin 
            $strobe("Warning: U0_i = %e is negative, setting it to 0.", U0_i); 
            U0_i   =  0; 
        end 
        if(UA_i < 0) begin 
            $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i); 
            UA_i   =  0; 
        end 
        if(EU_i < 0) begin 
            $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i); 
            EU_i   =  0; 
        end 
         
        if(UD_i < 0) begin 
            $strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i); 
            UD_i   =  0; 
        end 
         
        if(UCS_i < 0) begin 
            $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i); 
            UCS_i  =  0; 
        end
        if(ETAMOB_i < 0) begin
            $strobe("Warning: ETAMOB_i = %e is negative, setting it to 0", ETAMOB_i);
            ETAMOB_i = 0;
        end
        RDSWMIN_i  =  RDSWMIN; 
        if(RDSWMIN_i < 0) begin 
            $strobe("Warning: RDSWMIN = %e is negative.  Set to zero", RDSWMIN_i); 
            RDSWMIN_i  =  0; 
        end 
        if(RDSW_i < 0) begin 
            $strobe("Warning: RDSW_i = %e is negative.  Set to zero", RDSW_i); 
            RDSW_i =  0; 
        end 
        RSWMIN_i   =  RSWMIN; 
        if(RSWMIN_i < 0) begin 
            $strobe("Warning: RSWMIN = %e is negative.  Set to zero", RSWMIN_i); 
            RSWMIN_i =  0; 
        end 
        if(RSW_i < 0) begin 
            $strobe("Warning: RSW_i = %e is negative.  Set to zero", RSW_i); 
            RSW_i    =  0; 
        end 
        RDWMIN_i =  RDWMIN; 
        if(RDWMIN_i < 0) begin 
            $strobe("Warning: RDWMIN = %e is negative.  Set to zero", RDWMIN_i); 
            RDWMIN_i =  0; 
        end 
        if(RDW_i < 0) begin 
            $strobe("Warning: RDW_i = %e is negative.  Set to zero", RDW_i); 
            RDW_i    =  0; 
        end 
        if(PRWGD_i < 0) begin 
            $strobe("Warning: PRWGD_i = %e is negative.  Set to zero", PRWGD_i); 
            PRWGD_i   =  0; 
        end
        if(PRWGS_i < 0) begin 
            $strobe("Warning: PRWGS_i = %e is negative.  Set to zero", PRWGS_i); 
            PRWGS_i   =  0; 
        end
        
        if(PCLM_i < 0) begin 
            $strobe("Warning: PCLM_i = %e is negative.", PCLM_i); 
        end

        if(PDIBL1_i < 0) begin 
            $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i); 
        end

        if(ASYMMOD != 0) begin
            if(PDIBL1R_i < 0) begin 
                $strobe("Warning: PDIBL1R_i = %e is negative.", PDIBL1R_i); 
            end 
        end
        if(ASYMMOD != 0) begin
            if(PDIBL2R_i < 0) begin 
                $strobe("Warning: PDIBL1R_i = %e is negative.", PDIBL2R_i); 
            end
               if(U0R_i < 0) begin 
                    $strobe("Warning: U0R_i = %e is negative, setting it to 0.", U0R_i); 
                     U0R_i   =  0; 
            end
            if(UAR_i < 0) begin 
                $strobe("Warning: UAR_i = %e is negative, setting it to 0.", UAR_i); 
                UAR_i   =  0; 
            end 
            if(EUR_i < 0) begin 
                $strobe("Warning: EUR_i = %e is negative, setting it to 0.", EUR_i); 
                EUR_i   =  0; 
            end
            if(UDR_i < 0) begin 
                $strobe("Warning: UDR_i = %e is negative, setting it to 0.", UDR_i); 
                UDR_i   =  0; 
            end
        end
        if(PDIBL2_i < 0) begin 
            $strobe("Fatal: PDIBL2_i = %e is negative.", PDIBL2_i); 
        end 
        if(DROUT_i <= 0) begin 
            $strobe("Fatal: DROUT_i = %e is non-positive.", DROUT_i); 
        end
        
        if(MEXP_i < 2.0) begin 
            $strobe("Warning: MEXP_i = %e < 2.  Setting MEXP_i = 2.", MEXP_i); 
            MEXP_i   =  2.0; 
        end
        if(ASYMMOD != 0) begin
            if(MEXPR_i < 2.0) begin 
                $strobe("Warning: MEXPR_i = %e < 2.  Setting MEXPR_i = 2.", MEXPR_i); 
                MEXPR_i   =  2.0; 
            end
        end
        if (PTWG_i < 0) begin
            $strobe("Warning: PTWG_i = %e is negative, setting it to 0.", PTWG_i );
            PTWG_i = 0;
        end
        if(QMTCENIV_i >0 || QMTCENCV_i >0) begin
            if(QM0 <= 0) begin
                $strobe("Fatal: QM0 = %e is non-positive.", QM0);
            end
        end
        if(CAPMOD != 0 && BULKMOD != 0 && QMTCENCVA_i >0) begin
            if(QM0ACC <= 0) begin
                $strobe("Fatal: QM0ACC = %e is non-positive.", QM0ACC);
            end
        end
        if(CGIDL_i < 0.0) begin
            $strobe("Warning: CGIDL_i = %e < 0.  Setting CGIDL_i = 0.", CGIDL_i); 
            CGIDL_i   =  0.0; 
        end
        if(CGISL_i < 0.0) begin
            $strobe("Warning: CGISL_i = %e < 0.  Setting CGISL_i = 0.", CGISL_i); 
            CGISL_i   =  0.0; 
        end
        if(IGBMOD != 0) begin
            if(NIGBINV_i <= 0) begin
                $strobe("Fatal: NIGBINV_i = %e is non-positive.", NIGBINV_i);
            end
            if(NIGBACC_i <= 0) begin
                $strobe("Fatal: NIGBACC_i = %e is non-positive.", NIGBACC_i);
            end
        end
        if(IGCMOD != 0) begin
            if(POXEDGE_i <= 0) begin
                $strobe("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i);
            end
            if(PIGCD_i <= 0) begin
                $strobe("Fatal: PIGCD_i = %e is non-positive.", PIGCD_i);
            end
        end
        if(IGCMOD != 0 || IGBMOD != 0) begin
            if(TOXREF <= 0) begin
                $strobe("Fatal: TOXREF = %e is non-positive.", TOXREF);
            end
        end
        if(LINTIGEN >= Leff/2) begin
            $strobe("Warning: LINTIGEN = %e is too large - Leff for r/g current is negative.  Re-setting LINTIGEN = 0.", LINTIGEN);
            LINTIGEN_i =  0;
        end else begin
            LINTIGEN_i =  LINTIGEN;
        end
        if(NTGEN_i <= 0) begin
            $strobe("Fatal: NTGEN_i = %e is non-positive.", NTGEN_i);
        end
        `ifdef __NQSMOD1__
        if(NQSMOD == 1 && XRCRG1_i != 0 && XRCRG1_i < 1.0e-3) begin
            $strobe("Warning: XRCRG1_i = %e.  Gate resistance may be too large. Disabling NQS Gate Resistance.", XRCRG1_i);
            XRCRG1_i   =  0;
        end
        `endif
        if(IIMOD==2) begin
            if (BETAII0_i < 0.0)
                $strobe("Warning:  BETAII0_i = %e is negative.",BETAII0_i);
            if (BETAII1_i < 0.0)
                $strobe("Warning:  BETAII1_i = %e is negative.", BETAII1_i);
            if (BETAII2_i < 0.0)
                $strobe("Warning:  BETAII2_i = %e is negative.", BETAII2_i);
            if (ESATII_i < 0.0)
                $strobe("Warning:  ESATII_i = %e is negative.", ESATII_i);
            if (LII_i < 0.0)
                $strobe("Warning:  LII_i = %e is negative.", LII_i);
            if (SII1_i < 0.0)
                $strobe("Warning:  SII1_i = %e is negative.", SII1);
            if (SII2_i < 0.0)
                $strobe("Warning:  SII2_i = %e is negative.", SII2_i);
            if (SIID_i < 0.0)
                $strobe("Warning:  SIID_i = %e is negative.", SIID_i);
        end
        if(EF <= 0) begin
            $strobe("Fatal: EF = %e is non-positive.", EF);
        end else if(EF > 2.0) begin
            $strobe("Fatal: EF = %e > 2.0.", EF);
        end
        if(LINTNOI >= Leff/2) begin
            $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
            LINTNOI_i  =  0;
        end else begin
            LINTNOI_i  =  LINTNOI;
        end
        if(NTNOI < 0) begin
            $strobe("Warning: NTNOI = %e is negative. Set to zero.", NTNOI);
            NTNOI_i    =  0;
        end else begin
            NTNOI_i    =  NTNOI;
        end
        
        // Self-heating
        `ifdef __SHMOD__
            if(SHMOD != 0 && RTH0 > 0) begin
                gth  =  NF * (WTH0 + NFIN * FPITCH) / RTH0;
                cth  =  CTH0 * NF* (WTH0 + NFIN * FPITCH);
            end else begin
                gth  =  1.0;    // set gth to some value to prevent a singular G matrix
                cth  =  0.0;
            end
        `else
            if(SHMOD != 0)
                $strobe("[bsimcmg] Although the model selector SHMOD is set to 1, the self heating model is not activated in the Verilog-A code.  Please uncomment \"`define __SHMOD__\" in bsimcmg.va to activate it.");
        `endif
        
        // Gate Electrode Resistance
        `ifdef __RGATEMOD__
            if(RGATEMOD != 0) begin
                Rgeltd =  (RGEXT/NGCON + (RGFIN * NFIN) / (NGCON == 2 ? 12.0 : 3.0)) / NF;
                ggeltd =  1.0 / max(Rgeltd, 1.0e-3);
            end
        `else
            if(RGATEMOD != 0)
                $strobe("[bsimcmg] Although the model selector RGATEMOD is set to 1, the gate electrode resistance model is not activated in the Verilog-A code.  Please uncomment \"`define __RGATEMOD__\" in bsimcmg.va to activate it.");
        `endif
        
        // Geometry dependent Source/Drain Resistance
        if(RGEOMOD == 0) begin
            RSourceGeo =  RSHS * NRS;
            RDrainGeo  =  RSHD * NRD;
        end else begin
            // Area and perimeter calculation
            if(HEPI > 0) begin
                Arsd   =  FPITCH * HFIN + (TFIN + (FPITCH - TFIN) * CRATIO) * HEPI;
            end else begin
                Arsd   =  FPITCH * max(HFIN + HEPI, 1.0e-9);
            end
            Prsd =  FPITCH + DELTAPRSD;
            // Resistivity calculation
            if($param_given(RHORSD)) begin
                rhorsd =  RHORSD;
            end else begin
                mu_max =  (TYPE == `ntype) ? 1417 : 470.5;   // cm^2/V-s
                if(TYPE == `ntype) begin
                    mu_rsd =  (52.2 + (mu_max - 52.2) / (1 + pow(NSD / 9.68e22, 0.680)) - 43.4 / (1.0 + pow(3.43e26 / NSD, 2))) * 1.0e-4;
                end else begin
                    mu_rsd =  (44.9 + (mu_max - 44.9) / (1 + pow(NSD / 2.23e22, 0.719)) - 29.0 / (1.0 + pow(6.10e26 / NSD, 2))) * 1.0e-4;
                end
                rhorsd =  1 / (`q * NSD * mu_rsd);
            end
                        
            // Component 2: Spreading Resistance (extension -> hdd)
            thetarsp =  55 * `M_PI / 180;
            afin     =  min(max(TFIN * (HFIN + min(HEPI, 0.0)), 1.0e-18), Arsd);
            T1       =  `COT(thetarsp);
            Rsp      =  rhorsd * T1 / (sqrt(`M_PI) * NFIN) * (1.0 / sqrt(afin) - 2.0 / sqrt(Arsd) + sqrt(afin / (Arsd*Arsd)));
            
            // Component 3: Contact Resistance
            arsd_total =  Arsd * NFIN + ARSDEND;
            prsd_total =  Prsd * NFIN + PRSDEND;
            lt         =  sqrt(RHOC * arsd_total / (rhorsd * prsd_total));
            alpha      =  LRSD / lt;
            T0         =  lexp(alpha + alpha);
            if(SDTERM == 1) begin
                eta  =  rhorsd * lt / RHOC;
                T1   =  T0 * (1.0 + eta);
                T2   =  T1 + 1.0 - eta;
                T3   =  T1 - 1.0 + eta;
            end else begin
                T2   =  T0 + 1.0;
                T3   =  T0 - 1.0;
            end
            RrsdTML  =  rhorsd * lt * T2 / (arsd_total * T3);
            
            if(HEPI < -1.0e-10) begin
                Rrsdside =  RHOC / (-HEPI * TFIN * NFIN);
                Rrsd =  (RrsdTML + Rsp) * Rrsdside / ((RrsdTML + Rsp) + Rrsdside);
            end else begin
                Rrsd =  RrsdTML + Rsp;
            end
            //Rdsgeo   =  (Rrsd + Rext) / NF * max(RGEOA + RGEOB * TFIN + RGEOC * FPITCH + RGEOD * LRSD + RGEOE * HEPI, 0);
            Rdsgeo   =  Rrsd / NF * max(RGEOA + RGEOB * TFIN + RGEOC * FPITCH + RGEOD * LRSD + RGEOE * HEPI, 0);
            RSourceGeo =  Rdsgeo;
            RDrainGeo  =  Rdsgeo;
        end  

        // Clamping of Source/Drain Resistances
        if(RSourceGeo <= 1.0e-3) RSourceGeo = 1.0e-3;
        if(RDrainGeo  <= 1.0e-3) RDrainGeo  = 1.0e-3;

        if(RDSMOD == 1) begin
            if (RSWMIN_i <= 0) RSWMIN_i = 0;
            if (RDWMIN_i <= 0) RDWMIN_i = 0;
            if (RSW_i <= 0) RSW_i = 0;
            if (RDW_i <= 0) RDW_i = 0;
        end else begin
            if (RDSWMIN_i <= 0) RDSWMIN_i = 0;
            if (RDSW_i <= 0) RDSW_i = 0;
        end
        // End - Clamping of Source/Drain Resistances
        
        if(CGEOMOD != 1) begin
            if($param_given(CGSO))
                CGSO_i =  CGSO;
            else begin
                if($param_given(DLC) && DLC > 0)
                    CGSO_i =  max(0, DLC * cox - CGSL_i);
                else
                    CGSO_i =  0.3 * TFIN * cox;
            end
            if($param_given(CGDO))
                CGDO_i =  CGDO;
            else begin
                if($param_given(DLC) && DLC > 0)
                    CGDO_i =  max(0, DLC * cox - CGDL_i);
                else
                    CGDO_i =  0.3 * TFIN * cox;
            end
        end
        
        // Parasitic source/drain to gate fringe capacitance model
        if(CGEOMOD == 2) begin
            Hg =  TGATE + TMASK;
            Trsd =  0.5 * (FPITCH - TFIN);
            Wg   =  max(Trsd - TOXP, 0.0);
            Hrsd =  max(HEPI + TSILI, 0.0);
            
            // Top component
            if(TMASK > 0) begin
                // Capacitance model developed by Chung-Hsun Lin (IBM)
                T0 =  3.467e-11 * lln(1.0e-7 * EPSRSP / (3.9 * LSP));
                T1 =  0.942 * Hrsd * epssp / LSP;
                Cgg_top  =  (T0 + T1) * (TFIN + (FPITCH - TFIN) * CRATIO);
            end else begin
                `Cfringe_2d(cfr_top_trigate, Hg, Hrsd, LSP, TFIN, LRSD, Lg, TOXP, 0.85, Cgg_top)
            end
            
            // Side component
            if(TMASK > 0) begin
                `Cfringe_2d(cfr_side_dblgate, Wg, Trsd, LSP, HFIN, LRSD, Lg, TOXP, 0.70, Cgg_side)
            end else begin
                `Cfringe_2d(cfr_side_trigate, Wg, Trsd, LSP, HFIN, LRSD, Lg, TOXP, 0.85, Cgg_side)
            end
            
            // Corner component
            if(TMASK > 0) begin
                Acorner  =  0.0;
            end else begin
                if(HEPI > 0) begin
                    Acorner  =  (FPITCH - TFIN) * (HEPI * CRATIO + TSILI);
                end else begin
                    Acorner  =  (FPITCH - TFIN) * Hrsd;
                end
            end
            Ccorner  =  (NFIN * Acorner + ARSDEND + ASILIEND) * epssp / LSP;
            Cfr_geo  =  (Ccorner + Cgg_top * NFIN + CGEOE * Cgg_side * NFIN * 2.0) * NF;
            Cfr_geo  =  Cfr_geo * max(CGEOA + CGEOB * TFIN + CGEOC * FPITCH + CGEOD * LRSD, 0);
        end
        
        // Source/gate/drain to substrate parasitic capacitances
        T0     =  CSDESW * lln(1.0 + HFIN / EOTBOX);
        csbox  =  cbox * ASEO + T0 * max(0.0, PSEO - FPITCH * NFINtotal);
        cdbox  =  cbox * ADEO + T0 * max(0.0, PDEO - FPITCH * NFINtotal);
        cgbox  =  (CGBO * NF * NGCON + CGBN * NFINtotal) * Lg;
        
        // Mobility Degradation
        EeffFactor   =  1.0e-8 / (epsratio * (EOT));
        WeffWRFactor =  1.0 / (pow((Weff0)*1.0e6, WR_i) * (NFINtotal));
        litl         =  sqrt(epsratio * EOT * 0.5 * TFIN);
        
        if (!$param_given(THETASCE)) 
        begin    
            tmp = DVT1_i * Leff / scl + 1.0e-6;
            if (tmp < 40.0)
                Theta_SCE    =  0.5 / (cosh(tmp) - 1.0);
            else
                Theta_SCE    =  exp(-tmp);
        end else
        Theta_SCE   =  THETASCE;

        if (!$param_given(THETASW)) 
        begin        
            tmp = DVT1SS_i * Leff / scl + 1.0e-6;
            if (tmp < 40.0)
                Theta_SW    =  0.5 / (cosh(tmp) - 1.0);
            else
                Theta_SW    =  exp(-tmp);
        end else
        Theta_SW   =  THETASW;

        if (!$param_given(THETADIBL)) 
        begin        
            tmp = DSUB_i * Leff / scl + 1.0e-6;
            if (tmp < 40.0)
                Theta_DIBL   =  0.5 / (cosh(tmp) - 1.0);

            else
                Theta_DIBL   =  exp(-tmp);
        end else
        Theta_DIBL   =  THETADIBL;            
        Theta_RSCE   =  sqrt(1.0 + LPE0_i / Leff) - 1.0;

        // Body doping correction
        if(COREMOD != 0 && NBODY_i > 1e23) nbody =  1e23;   // Limit doping to 1e17 cm^-3 in the simplified analytical surface potential case
        else                               nbody =  NBODY_i;
        if(GEOMOD != 3) qbs =  `q * nbody * TFIN / (2 * cox);
        else            qbs =  `q * nbody * R / (2 * cox);
        
        // Variables for the core model
        if( GEOMOD != 3) begin
            phibulk =  `q/(2*epssub) * nbody * (TFIN/2) * (TFIN/2);            
            Qbul    =  (COREMOD != 0) ? 0 : (sqrt(2* `q * nbody * epssub * phibulk));
            F2      =  lln(2.0/TFIN);
        end else begin
            r1      =  2 * epssub / (R * cox);
            if(CAPMOD != 0 && BULKMOD != 0) r1_acc =  2.0 * epssub / (R * cox_acc);
        end
        
        // Gate current
        if(TYPE == `ntype) Aechvb = 4.97232e-7; //NMOS
        else                  Aechvb = 3.42537e-7; //PMOS 
        if(TYPE == `ntype) Bechvb = 7.45669e11; //NMOS
        else                  Bechvb = 1.16645e12; //PMOS

        T0              = TOXG * TOXG;
        T1              = TOXG * POXEDGE_i;
        T2              = T1 * T1;
        Toxratio      = lexp(NTOX_i * lln(TOXREF / TOXG)) / T0;
        Toxratioedge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
        igsd_mult0   = Weff0 * Aechvb * Toxratioedge;

        if(TNOM < -`P_CELSIUS0) begin 
            $strobe("Warning: (TNOM=%e) < -`P_CELSIUS0. Set to 27 C.", TNOM); 
            Tnom = `REFTEMP; //`REFTEMP is in Kelvin i.e. 300.15 K
        end else begin 
            Tnom = TNOM + `CONSTCtoK; 
        end
        
    end // End of CMGBiasIndepCalc initial step
    
    /************************************************/
    /*      Temperature dependent calculations      */
    /************************************************/
    `ifdef __SHMOD__
        if(SHMOD != 0 && RTH0 > 0) begin
            DevTemp  =  $temperature + Temp(rth_branch) + DTEMP;
        end else begin
            `endif
            DevTemp  =  $temperature + DTEMP;
            `ifdef __SHMOD__
        end
    `endif
    
    begin : CMGTempDepCalc
        TRatio  = DevTemp / Tnom;
        delTemp = DevTemp - Tnom;
        Vtm     = `KboQ * DevTemp;
        Vtm0    = `KboQ * Tnom;
        Eg      = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
        Eg0     = BG0SUB - TBGASUB * Tnom * Tnom / (Tnom + TBGBSUB);
        T1      = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
        ni      = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
        Nc      = NC0SUB * T1;
        ThetaSS = hypsmooth(1.0 + TSS_i*delTemp - 1.0E-6, 1.0E-3); 
        
        // Quantum Mechanical Vth Correction
        // Ref: Trivedi et al., EDL 2005
        if(GEOMOD != 3) begin
            kT         =  Vtm * `q;
            T0         =  `HBAR * `M_PI / TFIN;
            E0         =  T0 * T0 / (2.0 * mx);
            E0prime =  T0 * T0 / (2.0 * mxprime);
            E1         =  4.0 * E0;
            E1prime =  4.0 * E0prime;
            T1         =  gprime * mdprime / (gfactor * md);
            gam0     =  1.0 + T1 * lexp((E0 - E0prime) / kT);
            gam1     =  gam0 + lexp((E0 - E1) / kT) + T1 * lexp((E0 - E1prime) / kT);
            T2       =  -Vtm * lln(gfactor * md / (`M_PI * `HBAR * `HBAR * Nc) * kT / TFIN * gam1);
            dvch_qm =  QMFACTOR_i * (E0 / `q + T2);
        end else begin
            T0         =  `HBAR * 2.4048 / R;
            E0         =  T0 * T0 / (2.0 * mx);
            dvch_qm =  QMFACTOR_i * E0 / `q;
        end
        
        // Temperature Dependence
        ETA0_t   =  Tempdep(ETA0_i, TETA0, delTemp, TEMPMOD);
        ETA0R_t  =  Tempdep(ETA0R_i, TETA0R, delTemp, TEMPMOD);
        T1       =  U0_i * pow(TRatio, UTE_i);
        U0_t     =  T1 + hypmax(UTL_i*delTemp, -0.9 * T1, 1e-4); 
        u0       =  U0_t; 
        if (ASYMMOD == 1) begin
            T1       =  U0R_i * pow(TRatio, UTER_i);
            U0R_t     =  T1 + hypmax(UTLR_i*delTemp, -0.9 * T1, 1e-4); 
            u0r       =  U0R_t;
        end
        
        ETAMOB_t =  Tempdep(ETAMOB_i, EMOBT_i, delTemp, TEMPMOD);
        UA_t     =  UA_i + hypmax(UA1_i*delTemp, -UA_i, 1.0e-6);
        
        if (ASYMMOD != 0) UAR_t     =  UAR_i + hypmax(UA1R_i*delTemp, -UAR_i, 1.0e-6);
        
        if(BULKMOD != 0) begin  
            if (TEMPMOD==0) begin 
                   UC_t = Tempdep(UC_i, UC1_i, delTemp, 0);
                   if (ASYMMOD != 0) UCR_t = Tempdep(UCR_i, UC1R_i, delTemp, 0);
            end                   
            else begin
               UC_t = UC_i + UC1_i*delTemp;
               if (ASYMMOD != 0) UCR_t = UCR_i + UC1R_i*delTemp;
            end               
        end
        
        UD_t     =  UD_i  * pow(TRatio, UD1_i); 
        if (ASYMMOD != 0) UDR_t     =  UDR_i  * pow(TRatio, UD1R_i); 
        UCS_t    =  UCS_i * pow(TRatio, UCSTE_i);
        
        rdstemp  =  hypsmooth(1.0 + PRT_i * delTemp - 1.0E-6, 1.0E-3);
        RSDR_t   = Tempdep(RSDR, TRSDR, delTemp, TEMPMOD);
        if(ASYMMOD != 0)  RSDRR_t   = Tempdep(RSDRR , TRSDR, delTemp, TEMPMOD);
        RDDR_t   = Tempdep(RDDR, TRDDR, delTemp, TEMPMOD);
        if(ASYMMOD != 0)  RDDRR_t   = Tempdep(RDDRR , TRDDR, delTemp, TEMPMOD);
            
        VSAT_t   = Tempdep(VSAT_i, -AT_i, delTemp, TEMPMOD);
        if(VSAT_t < 1000) begin 
            $strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT_t); 
            VSAT_t =  1000; 
        end 
        
        if(ASYMMOD != 0) begin 
        VSATR_t   = Tempdep(VSATR_i, -ATR_i, delTemp, TEMPMOD);
            if(VSATR_t < 1000) begin 
                $strobe("Warning: VSATR(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATR_t); 
                VSATR_t =  1000; 
            end 
        end
        
        VSAT1_t   = Tempdep(VSAT1_i, -AT_i, delTemp, TEMPMOD);
        if(VSAT1_t < 1000) begin 
            $strobe("Warning: VSAT1(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1_t); 
            VSAT1_t  =  1000; 
        end
        if(ASYMMOD != 0) begin
            VSAT1R_t   = Tempdep(VSAT1R_i, -AT_i, delTemp, TEMPMOD);
            if(VSAT1R_t < 1000) begin 
                $strobe("Warning: VSAT1R(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1R_t); 
                VSAT1R_t  =  1000; 
            end
        end

        VSATCV_t   = Tempdep(VSATCV_i, -ATCV_i, delTemp, TEMPMOD);
        if(VSATCV_t < 1000) begin 
            $strobe("Warning: VSATCV(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATCV_t); 
            VSATCV_t  =  1000; 
        end  
        
        MEXP_t      =  hypsmooth(MEXP_i  * (1.0 + TMEXP  * delTemp)-2.0 , 1.0E-3) + 2.0;
        if(ASYMMOD != 0) MEXPR_t     =  hypsmooth(MEXPR_i * (1.0 + TMEXPR * delTemp)-2.0 , 1.0E-3) + 2.0;
        
        PTWG_t      =  Tempdep(PTWG_i , -PTWGT_i, delTemp, TEMPMOD);
        if(ASYMMOD != 0)  PTWGR_t   =  Tempdep(PTWGR_i , -PTWGT_i, delTemp, TEMPMOD);
        dvth_temp   =  (KT1_i + KT1L / Leff) * (TRatio - 1.0);
        BETA0_t     =  BETA0_i * pow(TRatio, IIT_i);
        SII0_t      =  SII0_i * (hypsmooth(1 + TII_i * (TRatio -1) - 0.01, 1.0E-3) + 0.01);
        
        K0_t        =  K0_i    + K01_i * delTemp;
        K0SI_t        =  K0SI_i  + hypmax(K0SI1_i  * delTemp, -K0SI_i,  1E-6);
        K1SI_t        =  K1SI_i  + hypmax(K1SI1_i  * delTemp, -K1SI_i,  1E-6);
        K1_t        =  K1_i    + hypmax(K11_i    * delTemp, -K1_i,    1E-6);
        K1SAT_t        =  K1SAT_i + K1SAT1_i * delTemp;
        A1_t        =  A1_i    + A11_i    * delTemp;
        A2_t        =  A2_i    + A21_i    * delTemp;

        AIGBINV_t    =  AIGBINV_i + hypmax(AIGBINV1_i * delTemp, -AIGBINV_i, 1.0E-6);
        AIGBACC_t    =  AIGBACC_i + hypmax(AIGBACC1_i * delTemp, -AIGBACC_i, 1.0E-6);
        AIGC_t        =  AIGC_i    + hypmax(AIGC1_i    * delTemp, -AIGC_i,    1.0E-6);
        AIGS_t        =  AIGS_i    + hypmax(AIGS1_i    * delTemp, -AIGS_i,    1.0E-6);
        AIGD_t        =  AIGD_i    + hypmax(AIGD1_i    * delTemp, -AIGD_i,    1.0E-6);

        BGIDL_t     =  BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
        BGISL_t     =  BGISL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
        
        ALPHA0_t    =  ALPHA0_i + hypmax(ALPHA01 * delTemp, -ALPHA0_i, 1.0E-6);
        ALPHA1_t    =  ALPHA1_i + hypmax(ALPHA11 * delTemp, -ALPHA1_i, 1.0E-6);
        
        ALPHAII0_t    =  ALPHAII0_i + hypmax(ALPHAII01 * delTemp, -ALPHAII0_i, 1.0E-6);  
        ALPHAII1_t    =  ALPHAII1_i + hypmax(ALPHAII11 * delTemp, -ALPHAII1_i, 1.0E-6);    

        igtemp      =  lexp(IGT_i * lln(TRatio));  //pow(TRatio, IGT_i);
        igsd_mult   =  igsd_mult0 * igtemp;
        if(BULKMOD != 0) begin
            CJS_t    =  Tempdep(CJS,    TCJ,    delTemp, TEMPMOD);
             CJD_t    =  Tempdep(CJD,    TCJ,    delTemp, TEMPMOD);
            CJSWS_t  =  Tempdep(CJSWS,  TCJSW,  delTemp, TEMPMOD);
            CJSWD_t  =  Tempdep(CJSWD,  TCJSW,  delTemp, TEMPMOD);
            CJSWGS_t =  Tempdep(CJSWGS, TCJSWG, delTemp, TEMPMOD);
            CJSWGD_t =  Tempdep(CJSWGD, TCJSWG, delTemp, TEMPMOD);
            
            PBS_t    =  hypsmooth(PBS - TPB       * delTemp - 0.01, 1.0E-3) + 0.01;
            PBD_t    =  hypsmooth(PBD - TPB       * delTemp - 0.01, 1.0E-3) + 0.01;
            PBSWS_t  =  hypsmooth(PBSWS - TPBSW   * delTemp - 0.01, 1.0E-3) + 0.01;
            PBSWD_t  =  hypsmooth(PBSWD - TPBSW   * delTemp - 0.01, 1.0E-3) + 0.01;
            PBSWGS_t =  hypsmooth(PBSWGS - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
            PBSWGD_t =  hypsmooth(PBSWGD - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
            
            T0          =  Eg0 / Vtm0 - Eg / Vtm;
            T1          =  lln(TRatio);
            T3          =  lexp((T0 + XTIS * T1) / NJS);
            JSS_t    =  JSS * T3;
            JSWS_t   =  JSWS * T3;
            JSWGS_t  =  JSWGS * T3;
            T3          =  lexp((T0 + XTID * T1) / NJD);
            JSD_t    =  JSD * T3;
            JSWD_t   =  JSWD * T3;
            JSWGD_t  =  JSWGD * T3;
            
            JTSS_t     =  JTSS * lexp(Eg0 * XTSS * (TRatio - 1) / Vtm);
            JTSD_t     =  JTSD * lexp(Eg0 * XTSD * (TRatio - 1) / Vtm);
            JTSSWS_t   =  JTSSWS * lexp(Eg0 * XTSSWS * (TRatio - 1) / Vtm);
            JTSSWD_t   =  JTSSWD * lexp(Eg0 * XTSSWD * (TRatio - 1) / Vtm);
            JTSSWGS_t  =  JTSSWGS * (sqrt(JTWEFF / Weff0) + 1.0) * lexp(Eg0 * XTSSWGS * (TRatio - 1) / Vtm);
            JTSSWGD_t  =  JTSSWGD * (sqrt(JTWEFF / Weff0) + 1.0) * lexp(Eg0 * XTSSWGD * (TRatio - 1) / Vtm);
            
            //All NJT*'s smoothed to 0.01 to prevent divide by zero / negative values
            NJTS_t         =  hypsmooth(NJTS     * (1.0 + TNJTS     * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
            NJTSD_t      =  hypsmooth(NJTSD    * (1.0 + TNJTSD    * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
            NJTSSW_t     =  hypsmooth(NJTSSW   * (1.0 + TNJTSSW   * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
            NJTSSWD_t      =  hypsmooth(NJTSSWD  * (1.0 + TNJTSSWD  * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
            NJTSSWG_t      =  hypsmooth(NJTSSWG  * (1.0 + TNJTSSWG  * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
            NJTSSWGD_t     =  hypsmooth(NJTSSWGD * (1.0 + TNJTSSWGD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
            
        end
        
        beta0  =  u0 * cox * Weff0 / Leff;
        if (NGATE > 0) begin
            vfbsd  =  devsign*(hypsmooth(0.5*Eg-Vtm*lln(NGATE/ni),1.0E-4) - (0.5*Eg - devsign * (0.5*Eg-hypsmooth(0.5*Eg-Vtm*lln(NSD/ni),1.0E-4))));  
        end else begin
            vfbsd  =  devsign*(PHIG_i - (EASUB + 0.5*Eg - devsign * (0.5*Eg-hypsmooth(0.5*Eg-Vtm*lln(NSD/ni),1.0E-4))));
        end
        
        `ifdef __SHMOD__
            if(SHMOD != 0 && RTH0 > 0) begin
                T0    =  Vtm * lln(nbody/ni);
                phib  =  sqrt(T0 * T0 + 1.0E-6);
            end else begin
                phib  =  Vtm * lln(nbody/ni);
            end
        `else
            phib  =  Vtm * lln(nbody/ni);
        `endif

        `ifdef __SHMOD__
            if(SHMOD != 0 && RTH0 > 0) begin
                T0    =  Vtm * lln(nbody*NSD/(ni*ni));
                vbi   =  sqrt(T0 * T0 + 1.0E-6);
            end else begin
                vbi   =  Vtm * lln(nbody*NSD/(ni*ni));
            end
        `else
            vbi   =  Vtm * lln(nbody*NSD/(ni*ni));
        `endif

        // deltaPhi definition and Polysilicon Depletion
        // deltaPhi: workfunction difference between the gate and the n+ source.
        if(NGATE_i > 0) begin
            deltaPhi =  hypsmooth(0.5 * Eg - Vtm*lln(NGATE_i/ni),1.0E-4);
            if(GEOMOD != 3) begin
                vpoly0 =  `q * NGATE_i * epssub / (2.0 * cox * cox);
                cpoly  =  1.0 / (4.0 * vpoly0) ;
            end else begin
                T0        =  (R + EOT) / R ;
                vpoly0 =  `q * NGATE_i * epssub * T0 * T0 / (2.0 * cox * cox);
                cpoly  =  1.0 / (4.0 * vpoly0) ;
            end
            kpoly  =  (1.0 + 2.0 * cpoly * qbs);
        end else begin
            deltaPhi =  devsign*(PHIG_i - (EASUB + (TYPE == `ntype ? 0 : Eg)));
            cpoly    =  0.0;
            vpoly0   =  0.0;
            kpoly    =  0.0;
        end
        
        
        // Analytical Surface Potential
        if(GEOMOD != 3) begin
            r1 =  2.0*epssub/(cox*TFIN);
            g0max  =  1.57079;
            g0min  =  1e-37;
            Inv_r1pi =  1.0 / (r1 * `M_PI);
            if(CAPMOD != 0 && BULKMOD != 0) begin
                r1_acc =  2.0*epssub/(cox_acc*TFIN);
                Inv_r1pi_acc =  1.0 / (r1_acc * `M_PI);
            end
        end else begin
            g0max  =  700;
            g0min  =  1e-37;
        end

        // Calculating Poly Depletion term for all GEOMOD's
        if(NGATE_i>0) begin
            if(GEOMOD != 3) r2 =  4.0 * Vtm * epssub / (`q * TFIN * TFIN * NGATE_i);
            else            r2 =  2.0 * cpoly * r1 * r1 * Vtm;
        end else begin
            r2 =  0.0;
        end

        // Mobility Degradation
        eta_mu    =  0.5 * ETAMOB_t;
        eta_mu_cv =  0.5; 
        if( TYPE != `ntype ) begin 
            eta_mu    =  1.0 / 3.0 * ETAMOB_t; 
            eta_mu_cv =  1.0 / 3.0; 
        end 
        
    
        // Junction Current and Capacitance
        if(BULKMOD != 0) begin
            // Source-side junction current
            Isbs   =  ASEJ * JSS_t + PSEJ * JSWS_t + Weff0 * NFINtotal * JSWGS_t;
            if(Isbs > 0.0) begin
                Nvtms       =  Vtm * NJS;
                XExpBVS  =  lexp(-BVS / Nvtms) * XJBVS;
                T2          =  max(IJTHSFWD / Isbs, 10.0);
                Tb          =  1.0 + T2 - XExpBVS;
                VjsmFwd  =  Nvtms * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVS)));
                T0          =  lexp(VjsmFwd / Nvtms);
                IVjsmFwd =  Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
                SslpFwd  =  Isbs * (T0 + XExpBVS / T0) / Nvtms;
                T2          =  hypsmooth(IJTHSREV / Isbs - 10.0, 1.0E-3) + 10.0;
                VjsmRev  =  -BVS - Nvtms * lln((T2 - 1.0) / XJBVS);
                T1          =  XJBVS * lexp(-(BVS + VjsmRev) / Nvtms);
                IVjsmRev =  Isbs * (1.0 + T1);
                SslpRev  =  -Isbs * T1 / Nvtms;
            end
            
            // Drain-side junction current
            Isbd =  ADEJ * JSD_t + PDEJ * JSWD_t + Weff0 * NFINtotal * JSWGD_t;
            if(Isbd > 0.0) begin
                Nvtmd       =  Vtm * NJD;
                XExpBVD  =  lexp(-BVD / Nvtmd) * XJBVD;
                T2          =  max(IJTHDFWD / Isbd, 10.0);
                Tb          =  1.0 + T2 - XExpBVD;
                VjdmFwd  =  Nvtmd * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVD)));
                T0          =  lexp(VjdmFwd / Nvtmd);
                IVjdmFwd =  Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
                DslpFwd  =  Isbd * (T0 + XExpBVD / T0) / Nvtmd;
                T2          =  hypsmooth(IJTHDREV / Isbd - 10.0, 1.0E-3) + 10.0;
                VjdmRev  =  -BVD - Nvtmd * lln((T2 - 1.0) / XJBVD);
                T1          =  XJBVD * lexp(-(BVD + VjdmRev) / Nvtmd);
                IVjdmRev =  Isbd * (1.0 + T1);
                DslpRev  =  -Isbd * T1 / Nvtmd;
            end
            
            // Junction Capacitance
            Czbs     =  CJS_t * ASEJ;
            Czbssw     =  CJSWS_t * PSEJ;
            Czbsswg =  CJSWGS_t * Weff0 * NFINtotal;
            Czbd     =  CJD_t * ADEJ;
            Czbdsw     =  CJSWD_t * PDEJ;
            Czbdswg =  CJSWGD_t * Weff0 * NFINtotal;
        end
        
        // Generation / recombination current
        T0          =  Eg / Vtm * (TRatio - 1.0);
        T1          =  T0 / NTGEN_i;
        igentemp =  lexp(T1);
        
    end     // end of temperature dependent calculations
    
    
    /************************************************/
    /*     Bias dependent calculations follow       */
    /************************************************/
    
        // *** Load Terminal Voltages ***
        vgs_noswap = devsign * V(`IntrinsicGate, si);
        vds_noswap = devsign * V(di, si);
        vgd_noswap = devsign * V(`IntrinsicGate, di);
        ves_jct    = devsign * V(e, si);
        ved_jct    = devsign * V(e, di);
        vge        = devsign * V(`IntrinsicGate, e);
        
        // *** Source-drain interchange ***
        sigvds =  1.0;
        if (vds_noswap < 0.0) begin
            sigvds = -1.0;
            vgs    =  vgs_noswap - vds_noswap;
            vds    =  -1.0 * vds_noswap;
            ves    =  ved_jct;
        end else begin
            vgs    =  vgs_noswap;
            vds    =  vds_noswap;
            ves    =  ves_jct;
        end
        vgsfb  =  vgs - deltaPhi;
        
        //Initialize certain variables to zero to prevent unnecessary update
        etaiv  =  0.0;
        Qes    =  0.0;    Qesj   =  0.0;
        Qeg    =  0.0;
        Qed    =  0.0;    Qedj   =  0.0;
        
        // *** Vds smoothing ***
        vdsx   =  sqrt (vds * vds + 0.01) - 0.1;
        
        // *** Ves smoothing ***
        if(BULKMOD != 0) begin
            vesx    =  ves - 0.5 * (vds - vdsx);
            vesmax  =  0.95 * PHIBE_i;
            T2      =  vesmax - vesx - 1.0E-3;
            veseff  =  vesmax - 0.5 * (T2 + sqrt(T2 * T2 + 0.004 * vesmax));
        end

        // Asymmetry Model
        T0         =  tanh(0.6 * vds_noswap / Vtm);
        wf         =  0.5 + 0.5 * T0;
        wr         =  1.0 - wf;
        if(ASYMMOD != 0) begin
            CDSCD_a    =  CDSCDR_i * wr + CDSCD_i * wf;
            ETA0_a     =  ETA0R_t * wr + ETA0_t * wf;
            PDIBL1_a   =  PDIBL1R_i * wr + PDIBL1_i * wf; 
            PDIBL2_a   =  PDIBL2R_i * wr + PDIBL2_i * wf;
            MEXP_a     =  MEXPR_t * wr + MEXP_t * wf;
            PTWG_a     =  PTWGR_t * wr + PTWG_t * wf;
            VSAT1_a    =  VSAT1R_t * wr + VSAT1_t * wf;        
            RSDR_a     =  RSDRR_t * wr + RSDR_t * wf;
            RDDR_a     =  RDDRR_t * wr + RDDR_t * wf;
            PCLM_a     =  PCLMR_i * wr + PCLM_i * wf;
            VSAT_a     =  VSATR_t * wr + VSAT_t * wf;
            KSATIV_a   =  KSATIVR_i * wr + KSATIV_i * wf;
            DVTSHIFT_a =  DVTSHIFTR_i * wr + DVTSHIFT_i * wf;
            CIT_a      =  CITR_i * wr + CIT_i * wf ;
            u0_a       =  u0r * wr + u0 * wf ;
            UA_a       =  UAR_t*wr + UA_t * wf ;
            UD_a       =  UDR_t * wr + UD_t * wf ;
            UC_a       =  UCR_t * wr + UC_t * wf ;
            EU_a       =  EUR_i * wr + EU_i * wf ;
        end else begin
            CDSCD_a    =  CDSCD_i;
            ETA0_a     =  ETA0_t;
            PDIBL1_a   =  PDIBL1_i;
            PDIBL2_a   =  PDIBL2_i;
            MEXP_a     =  MEXP_t;
            PTWG_a     =  PTWG_t;
            VSAT1_a    =  VSAT1_t;        
            RSDR_a     =  RSDR_t;
            RDDR_a     =  RDDR_t;
            PCLM_a     = PCLM_i ;
            VSAT_a     = VSAT_t ;
            KSATIV_a   = KSATIV_i ;
            DVTSHIFT_a = DVTSHIFT_i ;
            CIT_a      = CIT_i ;
            u0_a       = u0 ;
            UA_a       = UA_t ;
            UD_a       = UD_t ;
            UC_a       = UC_t ;
            EU_a       = EU_i ;
        end
        // Drain Saturation Voltage
        inv_MEXP   =  1.0 / MEXP_a;
        
        // *** SCE, DIBL, SS degradation effects *** Ref: BSIM4 Model
        phist       =  0.4 + phib + PHIN_i;
        if(GEOMOD !=3) T1 =  2*cox*csi/(2*csi + cox);
        else           T1 =  cox;
        cdsc        =  Theta_SW * (CDSC_i + CDSCD_a * vdsx);
        
        if (!$param_given(NVTM))
                nVtm  =  Vtm * ThetaSS * (1.0 + (CIT_a + cdsc) / T1);
        else nVtm = NVTM;    
                
        dvth_vtroll =  -DVT0_i * Theta_SCE * (vbi - phist);
        dvth_dibl   =  -ETA0_a * Theta_DIBL * vdsx + DVTP0 * pow(vdsx, DVTP1);
        dvth_rsce   =  K1RSCE_i * Theta_RSCE * sqrt(phist);
        dvth_all    =  dvth_vtroll + dvth_dibl + dvth_rsce + dvth_temp + DVTSHIFT_a;
        vgsfb       =  vgsfb - dvth_all;
        
        // *** Threshold voltage shift for doped multi-gate FET ***
        if(GEOMOD !=3) begin
            F1 =  0.5*lln(2*epssub*nVtm/(`q*Nc)) + F2;
            if(COREMOD != 0) vgsfb =  vgsfb - 0.5 * `q * nbody * TFIN / cox;
            else q0  =  (5.0 * nVtm * (epssub/TFIN) + 2.0 * Qbul) / cox;
            if(CAPMOD != 0 && BULKMOD != 0) F1_acc =  0.5*lln(2*epssub*Vtm/(`q*Nc)) + F2;
            cdop =  1.0;
        end else begin
            q0    =  2.0 * nVtm * r1;
            T0    =  `q * nbody * R / cox ;
            vtdop =  - nVtm * lln(nVtm / T0) - nVtm * lln(1 - lexp(-T0/(2.0*r1*nVtm)));
            cdop  =  2.0 * r1 * lexp(-vtdop / nVtm);
            vt0   =  0.5 * T0 + 2.0*phib*nVtm/Vtm - nVtm * lln(0.5*T0/nVtm) + vtdop;
            if(CAPMOD != 0 && BULKMOD != 0) begin
                q0_acc       =  2.0 * Vtm * r1_acc;
                T0           =  `q * ni * R / cox_acc ;
                vtdop_acc =  - Vtm * lln(Vtm / T0) - Vtm * lln(1 - lexp(-T0/(2.0*r1_acc*Vtm)));
                cdop_acc  =  2.0 * r1_acc * lexp(-vtdop_acc / Vtm);
                vt0_acc   =  0.5 * T0 - Vtm * lln(0.5*T0/Vtm) + vtdop_acc;
            end
        end
        
        // *** Vgs Clamping for inversion region calc. in accumulation ***
        beta0  =  u0_a * cox * Weff0 / Leff;
        if(GEOMOD != 3) begin
            T0       =  -(dvch_qm + nVtm * lln(2.0 * cox * Imin / (beta0 * nVtm * `q * Nc * TFIN)));
            T1       =  vgsfb + T0 + DELVTRAND;
            vgsfbeff =  hypsmooth(T1 , 1.0E-4) - T0;
        end else begin
            T0       =  -(dvch_qm + nVtm * lln(2.0 * cox * Imin / (beta0 * nVtm * `q * ni * R)));
            T1       =  vgsfb + DELVTRAND + T0 + 0.5 * Eg + phib*nVtm/Vtm;
            vgsfbeff =  hypsmooth(T1 , 1.0E-4) - T0 - vt0;
        end
        
        // *** Vgs Clamping for accumulation region calc. in inversion ***
        if(CAPMOD != 0 && BULKMOD != 0) begin
            T1 =  - vge + deltaPhi - 0.5*Eg + DELVFBACC;
            if(GEOMOD != 3) vgsfbeff_acc =  hypsmooth(T1 , 1.0E-4) - 0.5 * Eg;
            else            vgsfbeff_acc =  hypsmooth(T1 , 1.0E-4) - vt0_acc;
        end
        
        // *** Surface potential calculations shared by source & drain ***
        if(GEOMOD != 3) begin
            // T1x are temporary variables needs to be used for both
            //    source and drain surface potential calculations.
            T14  =  2.0*nVtm;
            if(COREMOD == 0) begin
                aab  =  phibulk/(nVtm*nVtm);
                T0   =  phibulk*aab;
                T11  =  r1 * phibulk / nVtm + r2 * T0;
                T12  =  lexp(phibulk/(2.0*nVtm));
                T13  =  T12*T12;
            end
        end
        
        //***********************************************************************************************
        // *** Surface Potential Calculation for Accumulation region operation, CAPMOD=1 && BULKMOD=1 ***
        if(CAPMOD != 0 && BULKMOD != 0) begin
            if(GEOMOD != 3) begin
                F0     =  (vgsfbeff_acc)/(2.0*Vtm) - F1_acc;
                expff  =  lexp(F0);
                
                // Initial guess for sub-threshold
                z1 =  atan(expff);
                
                // Initial guess for strong inversion
                if (F0 > `EXPL_THRESHOLD) T0 =  F0;
                else T0  =  lln(1.0 + expff);
                z2 =  atan(2*T0*Inv_r1pi_acc);
                
                // initial guess
                g0 =  min(z1, max(z2, 1e-15));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else           g0  =  g0min;
                end
                
                tang0    =  tan(g0);
                lng0     =  lln(g0);
                secg0sq  =  tang0*tang0 + 1.0;
                lncosg0  =  -0.5 * lln(secg0sq);
                inv_g0   =  1.0 / g0;
                
                T0 =  g0 * tang0;
                
                e0 =  lng0 - lncosg0 + r1_acc*T0 - F0;
                e1 =  inv_g0 + secg0sq*g0*r1_acc + tang0*(1.0 + r1_acc);
                e2 =  secg0sq*(1.0 + 2.0*(r1_acc + T0*r1_acc)) - inv_g0*inv_g0;
                e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*r1_acc
                            + 2.0*secg0sq*tang0*(1.0 + 3.0*r1_acc + 2.0*r1_acc*T0);
                
                // 1st stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                tang0    =  tan(g0);
                lng0     =  lln(g0);
                secg0sq  =  tang0*tang0 + 1.0;
                lncosg0  =  -0.5 * lln(secg0sq);
                inv_g0   =  1.0/g0;
                
                T0 =  g0 * tang0;
                
                e0 =  lng0 - lncosg0 + r1_acc*T0 - F0;
                e1 =  inv_g0 + secg0sq*g0*r1_acc + tang0*(1.0 + r1_acc);
                e2 =  secg0sq*(1.0 + 2.0*(r1_acc + T0*r1_acc)) - inv_g0*inv_g0;
                e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*r1_acc
                            + 2.0*secg0sq*tang0*(1.0 + 3.0*r1_acc + 2.0*r1_acc*T0);
                
                // 2nd stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                // Calculate accumulation charge
                g0a  =  g0;
                tang0a =  tan(g0a);
                qi_acc =  vgsfbeff_acc - 2.0 * Vtm * (lln(g0a) + 0.5 * lln(1.0 + tang0a * tang0a) + F1_acc);
            end else begin
                //GEOMOD=3 case
                F0 =  (vgsfbeff_acc)/(2.0*Vtm);
                
                if(F0 > `EXPL_THRESHOLD) T0  =  F0;
                else T0  =  lln(1 + lexp(F0));
                
                if(F0 < -10) g0  =  lexp(2*F0);
                else if(F0 > 10) g0  =  F0 / r1_acc;
                else g0  =  (sqrt(0.25 + r1_acc * r1_acc * T0 * T0) - 0.5) / (r1_acc * r1_acc);
                
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                if(F0 < -50) g0a =  g0;
                else begin
                    
                    inv_g0   =  1.0 / g0;
                    inv_g0sq =  inv_g0 * inv_g0;
                    T0          =  1 + cdop_acc*g0;
                    T1          =  cdop_acc / T0 ;
                    T2          =  T1 * T1;
                    
                    e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1_acc*g0 - F0;
                    e1 =  0.5*inv_g0 + 0.5 * T1 + r1_acc;
                    e2 =  -0.5*inv_g0sq - 0.5 * T2;
                    e3 =  inv_g0*inv_g0sq + T2*T1;
                    
                    // 1st stage correction
                    g0 =  g0 - (e0/e1)*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                    if (g0 > g0max || g0 < g0min) begin
                        if(g0 > g0max) g0  =  g0max;
                        else g0  =  g0min;
                    end
                    
                    inv_g0   =  1.0 / g0;
                    inv_g0sq =  inv_g0 * inv_g0;
                    T0          =  1 + cdop_acc*g0;
                    T1          =  cdop_acc / T0 ;
                    T2          =  T1 * T1;
                    
                    e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1_acc*g0 - F0;
                    e1 =  0.5*inv_g0 + 0.5 * T1 + r1_acc;
                    e2 =  -0.5*inv_g0sq - 0.5 * T2;
                    e3 =  inv_g0*inv_g0sq + T2*T1;
                    
                    // 2nd stage correction
                    g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                    if (g0 > g0max || g0 < g0min) begin
                        if(g0 > g0max) g0  =  g0max;
                        else g0  =  g0min;
                    end
                    g0a = g0;
                    
                end
                    // Calculate accumulation charge
                qi_acc = q0_acc * g0a;
            end
        end
        //*************************************************************************
        // *** Surface Potential at the source-end (Normal region of operation) ***
        // Householder's cubic iteration
        vch  =  0.0 + dvch_qm;
        if(GEOMOD != 3) begin
            if(COREMOD != 0) begin
                
                //*************************************************************************
                // ** Surface potential calculation for lightly-doped double gate MOSFET **
                F0     =  (vgsfbeff - vch)/(2.0*nVtm) - F1;
                expff  =  lexp(F0);
                
                // Initial guess for sub-threshold
                z1 =  atan(expff);
                
                // Initial guess for strong inversion
                if (F0 > `EXPL_THRESHOLD) T0 =  F0;
                else T0  =  lln(1.0 + expff);
                z2 =  atan(2*T0*Inv_r1pi);
                
                // initial guess
                g0 =  min(z1, max(z2, 1e-15));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                tang0    =  tan(g0);
                lng0     =  lln(g0);
                secg0sq  =  tang0*tang0 + 1.0;
                lncosg0  =  -0.5 * lln(secg0sq);
                inv_g0   =  1.0 / g0;
                
                T0 =  g0 * tang0;
                T1 =  T0 * T0;
                
                e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
                e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
                e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
                e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
                            + 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 +2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
                
                // 1st stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                tang0       =  tan(g0);
                lng0     =  lln(g0);
                secg0sq  =  tang0*tang0 + 1.0;
                lncosg0  =  -0.5 * lln(secg0sq);
                inv_g0   =  1.0/g0;
                
                T0 =  g0 * tang0;
                T1 =  T0 * T0;
                
                e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
                e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
                e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
                e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
                            + 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
                
                // 2nd stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                // Calculate surface potential
                g0s    =  g0;
                tang0s =  tan(g0s);
                phis   =  vch + 2.0 * nVtm * (lln(g0s) + 0.5 * lln(1.0 + tang0s * tang0s) + F1);
                
            end else begin
                
                //*************************************************************************
                // ** Surface potential calculation for heavily-doped double gate MOSFET **
                F0  = (vgsfbeff - phibulk - vch)/T14 - F1;
                T0  =  phibulk*aab;                
                T1  =  phibulk/T14;
                z1  =  (2.0*r1-1.0) * T1 + r2 * T0;             
                guessA = 2.0 * r1 * T1;
                guessA = guessA/(1.0-exp(-guessA));    
                                                    
                z2  = z1 + ln((sqrt(guessA)/r1));
                if((F0-z2)>-0.3/T14) begin
                    if ((F0-z2)< 20)
                            T2 = (0.5/guessA)* ln(1.0 + exp(2.0*(F0-z2))) + 1.0;
                    else
                            T2 = (0.5/guessA)*(2.0*(F0-z2)) + 1.0;

                    T3 = pow(T2, 2.0);
                    guessB = (guessA/r1) * sqrt(T3-1.0) * exp(-T1);
                end else
                    guessB =  exp(F0-z1-T1);
                
                g0=guessB;
                if (g0>1e-60) begin    
                    g0 = 1.0/((1.0/g0)+(1.0/(0.5*`M_PI)));
                    
                //----------------------------------------------------                                    
                    tang0    =  tan(g0);
                    cosg0    =  cos(g0);  
                    secg0    =  1.0/cosg0;
                    secg0sq  =  secg0*secg0;            
                    lng0     =  -ln(1.0/g0);
                
                    T0 =  1.0 + g0*tang0;
                    T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
                    T2 =  sqrt(T1);
                    T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
                    T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
                    T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);
                    T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
                    T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
                    T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
                    TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
            
                    // 1st stage correction 
                    g0 =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
        
                    tang0    =  tan(g0);
                    cosg0    =  cos(g0);
                    secg0    =  1.0/cosg0;
                    secg0sq  =  secg0*secg0;
                    lng0     = -ln(1.0/g0);
                
                    T0 =  1.0 + g0*tang0;
                    T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
                    T2 =  sqrt(T1);
                    T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
                    T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
                    T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);                
                    T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
                    T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
                    T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
                    TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
                
                    // 2nd stage correction 
                    g0    =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
                    lng0  = -ln(1.0/g0);
                    
                end else begin
                    if (g0>=1e-300)
                        lng0 = -ln(1.0/g0);
                    else begin
                        if((F0-z2)>-0.3/T14) 
                            lng0 = -ln(1.0/((guessA/r1) * sqrt(T3-1.0)))-T1;
                         else
                            lng0 = F0-z1-T1;
                    end    
                end

                phis =  vch + T14*(lng0-lln(cos(g0))+F1) + phibulk;
                
            end // Surface Potential Model Switch
        end else begin  //GEOMOD 3 switched
            
            //***********************************************************
            // ** Surface potential calculation for cylindrical MOSFET **
            F0 =  (vgsfbeff - vch)/(2.0*nVtm);
            
            if(F0 < -10) g0  =  lexp(2.0*F0);
            else if(F0 > 10) g0  =  F0 / r1;
            else begin
                T0 =  lln(1 + lexp(F0));
                g0 =  (sqrt(0.25 + r1 * r1 * T0 * T0) - 0.5) / (r1 * r1);
            end
            
            if (g0 > g0max || g0 < g0min) begin
                if(g0 > g0max) g0  =  g0max;
                else g0  =  g0min;
            end
            
            if(F0 < -50) g0s =  g0;
            else begin
                
                inv_g0   =  1.0 / g0;
                inv_g0sq =  inv_g0 * inv_g0;
                T0          =  1 + cdop*g0;
                T1          =  cdop / T0 ;
                T2          =  T1 * T1;
                
                e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
                e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
                e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2*r2;
                e3 =  inv_g0*inv_g0sq + T2*T1;
                
                // 1st stage correction
                g0 =  g0 - (e0/e1)*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                inv_g0   =  1.0 / g0;
                inv_g0sq =  inv_g0 * inv_g0;
                T0          =  1 + cdop*g0;
                T1          =  cdop / T0 ;
                T2          =  T1 * T1;
                
                e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
                e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
                e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2.0 * r2;
                e3 =  inv_g0*inv_g0sq + T2*T1;
                
                // 2nd stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                g0s  =  g0;
                
            end
            
            // Calculate surface potential
            vpolys   =  2.0 * nVtm * r2 * g0s * g0s;
            phis   =  vgsfbeff - 2.0 * nVtm * r1 * g0s - vpolys;
            qis      =  q0 * g0s;
        end     //End of GEOMOD SPE source-end
        //******************************************************
        
        // *** Drain Saturation Voltage ***
        if(GEOMOD != 3) begin
            if(NGATE_i > 0) begin
                T0     =  sqrt(1.0 + (vgsfbeff-phis)/vpoly0) - 1.0;
                vpolys =  vpoly0 * T0 * T0;
            end else vpolys  =  0;
            qis  =  (COREMOD != 0) ? (vgsfbeff - phis - vpolys) : (vgsfbeff - phis - qbs - vpolys);
        end
        
        Eeffs  =  EeffFactor * (qbs + eta_mu * qis);  // in the unit of MV/cm
        qb0    =  1.0e-2 / cox;
        T2     =  pow(0.5 * (1.0 + abs((qis) / qb0)), UCS_t);     //Changed in BSIM-CMG106.1.0
        if(BULKMOD != 0) begin
            T3     =  (UA_a + UC_a * veseff) * pow(abs(Eeffs), EU_a) + UD_a / T2;
        end else begin
            T3     =  UA_a * pow(abs(Eeffs), EU_a) + UD_a / T2;
        end
        Dmobs  =  1.0 + T3; 
        Dmobs  =  Dmobs / U0MULT; 

        if(RDSMOD == 1)  Rdss  =  0.0; 
        else if (RDSMOD == 0) begin
            T4       =  1.0 + PRWGS_i * qis; 
            T1       =  1.0 / T4; 
            T0       =  0.5 * (T1 + sqrt(T1 * T1 + 0.01)); 
                   Rdss     =  (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NFINtotal * rdstemp;
        end
        else begin
            T4       =  1.0 + PRWGS_i * qis; 
            T1       =  1.0 / T4; 
            T0       =  0.5 * (T1 + sqrt(T1 * T1 + 0.01)); 
                   Rdss     =  (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NFINtotal * rdstemp;
        end
        
        Esat  =  2 * VSAT_a / u0_a * Dmobs; 
        EsatL =  Esat * Leff; 
        T6    =  KSATIV_a * (vgsfbeff - phis + 2*Vtm); 
        
        if (Rdss == 0) begin 
            Vdsat  =  EsatL * T6 / (EsatL + T6); 
        end else begin 
            WVCox  =  Weff0 * VSAT_a * cox; 
            T0        =  WVCox * Rdss; 
            Ta        =  2 * T0; 
            Tb        =  T6 + EsatL + 3*T6*T0; 
            Tc        =  T6 * (EsatL + 2*T6*T0); 
            Vdsat  =  (Tb - sqrt(Tb*Tb - 2*Ta*Tc)) / Ta; 
        end 
        Vdsat  =  hypsmooth(Vdsat-1.0E-3 , 1.0E-5) + 1.0E-3; 
        T7     =  pow(vds/Vdsat , MEXP_a); 
        T8     =  pow(1.0+T7, inv_MEXP); 
        Vdseff =  vds / T8; 
        if (Vdseff > vds) Vdseff =  vds;    
        //********************************************
        // *** Surface Potential at the drain-end  ***
        vch  =  Vdseff + dvch_qm;
        
        if(GEOMOD != 3) begin
            if(COREMOD != 0) begin
                
                //*************************************************************************
                // ** Surface potential calculation for lightly-doped double gate MOSFET **
                F0        =  (vgsfbeff - vch)/(2.0*nVtm) - F1;
                expff  =  lexp(F0);
                
                // Initial guess for sub-threshold
                z1 =  atan(expff);
                
                // Initial guess for strong inversion
                if (F0 > `EXPL_THRESHOLD) T0 =  F0;
                else T0  =  lln(1.0 + expff);
                z2 =  atan(2*T0*Inv_r1pi);
                
                // initial guess
                g0 =  min(z1, max(z2, 1e-15));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                tang0    =  tan(g0);
                lng0     =  lln(g0);
                secg0sq  =  tang0*tang0 + 1.0;
                lncosg0  =  -0.5 * lln(secg0sq);
                inv_g0   =  1.0 / g0;
                
                T0 =  g0 * tang0;
                T1 =  T0 * T0;
                
                e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
                e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
                e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
                e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
                        + 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 +2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
                
                // 1st stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                tang0    =  tan(g0);
                lng0     =  lln(g0);
                secg0sq  =  tang0*tang0 + 1.0;
                lncosg0  =  -0.5 * lln(secg0sq);
                inv_g0   =  1.0/g0;
                
                T0 =  g0 * tang0;
                T1 =  T0 * T0;
                
                e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
                e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
                e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
                e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
                + 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
                
                // 2nd stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                // Calculate surface potential
                g0d    =  g0;
                tang0d =  tan(g0d);
                phid   =  vch + 2.0 * nVtm * (lln(g0d) + 0.5 * lln(1.0 + tang0d * tang0d) + F1);
            end else begin
                
                //*************************************************************************
                // ** Surface potential calculation for heavily-doped double gate MOSFET **
                //Juan and Navid's Initial Guess 3/2013--------------------------------------
                F0  = (vgsfbeff - phibulk - vch)/T14 - F1;
                T0  =  phibulk*aab;                
                T1  =  phibulk/T14;
                z1  =  (2.0*r1-1.0) * T1 + r2 * T0;             
                guessA = 2.0 * r1 * T1;
                guessA = guessA/(1.0-exp(-guessA));    
                                                    
                z2  = z1 + ln((sqrt(guessA)/r1));
                if((F0-z2)>-0.3/T14) begin
                    if ((F0-z2)< 20)
                            T2 = (0.5/guessA)* ln(1.0 + exp(2.0*(F0-z2))) + 1.0;
                    else
                            T2 = (0.5/guessA)*(2.0*(F0-z2)) + 1.0;
                    T3 = pow(T2, 2.0);
                    guessB = (guessA/r1) * sqrt(T3-1.0) * exp(-T1);
                end else
                    guessB = exp(F0-z1-T1);
                g0=guessB;
                
                if (g0>1e-60) begin
                    g0 = 1.0/((1.0/g0)+(1.0/(0.5*`M_PI)));
                
                //----------------------------------------------------------------            
                    tang0    =  tan(g0);
                    cosg0    =  cos(g0);
                    secg0    =  1.0/cosg0;
                    secg0sq  =  secg0*secg0;
                    lng0     =  -ln(1.0/g0);
                    
                    T0 =  1.0 + g0*tang0;
                    T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
                    T2 =  sqrt(T1);
                    T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
                    T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
                    T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);
                    T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
                    T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
                    T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
                    TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
                
                    // 1st stage correction 
                    g0 =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
                
                    tang0  =  tan(g0);
                    cosg0  =  cos(g0);
                    secg0    =  1.0/cosg0;
                    secg0sq  =  secg0*secg0;
                    lng0     = -ln(1.0/g0);
                
                    T0 =  1.0 + g0*tang0;
                    T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
                    T2 =  sqrt(T1);
                    T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
                    T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
                    T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);
                
                    T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
                    T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
                    T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
                    TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
                
                    // 2nd stage correction 
                    g0 =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
                    lng0  = -ln(1.0/g0);                    

                end else begin
                    if (g0>=1e-300)
                        lng0 = -ln(1.0/g0);
                    else begin
                        if((F0-z2)>-0.3/T14) 
                            lng0 = -ln(1.0/((guessA/r1) * sqrt(T3-1.0)))-T1;
                         else
                            lng0 = F0-z1-T1;
                    end    
                end

                phid =  vch + T14 * (lng0-lln(cos(g0)) + F1) + phibulk;
                
            end // Surface Potential Model Switch
        end else begin  //GEOMOD 3 switch
            
            //***********************************************************
            // ** Surface potential calculation for cylindrical MOSFET **
            F0 =  (vgsfbeff - vch)/(2.0*nVtm);
            
            if(F0 < -10) g0  =  lexp(2.0*F0);
            else if(F0 > 10) g0  =  F0 / r1;
            else begin
                T0 =  lln(1.0 + lexp(F0));
                g0 =  (sqrt(0.25 + r1 * r1 * T0 * T0)- 0.5) / (r1 * r1);
            end
            
            if (g0 > g0max || g0 < g0min) begin
                if(g0 > g0max) g0  =  g0max;
                else g0  =  g0min;
            end
            
            if(F0 < -50) g0d =  g0;
            else begin
                
                inv_g0   =  1.0 / g0;
                inv_g0sq =  inv_g0 * inv_g0;
                T0          =  1 + cdop*g0;
                T1          =  cdop / T0 ;
                T2          =  T1 * T1;
                
                e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
                e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
                e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2*r2;
                e3 =  inv_g0*inv_g0sq + T2*T1;
                
                // 1st stage correction
                g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                
                inv_g0 =  1.0 / g0;
                inv_g0sq =  inv_g0 * inv_g0;
                T0 =  1 + cdop*g0;
                T1 =  cdop / T0 ;
                T2 =  T1 * T1;
                
                e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
                e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
                e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2*r2;
                e3 =  inv_g0*inv_g0sq + T2*T1;
                
                // 2nd stage correction
                g0 =  g0 - (e0/e1)*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
                if (g0 > g0max || g0 < g0min) begin
                    if(g0 > g0max) g0  =  g0max;
                    else g0  =  g0min;
                end
                g0d  =  g0;
            end
            
            // Calculate surface potential
            vpolyd   =  2 * nVtm * r2 * g0d * g0d;
            phid   =  vgsfbeff - 2 * nVtm * r1 * g0d - vpolyd;
            qid      =  q0 * g0d;
        end     //End of all GEOMOD SPE drain-end
        //****************************************************
        
        // *** Drain Side and Average Potential/ Charge ***
        qba  =  qbs;
        if(GEOMOD != 3) begin
            if(NGATE_i > 0) begin
                T0 =  sqrt(1 + (vgsfbeff-phid)/vpoly0) - 1;
                vpolyd =  vpoly0 * T0 * T0;
            end else vpolyd  =  0;
            qid  =  (COREMOD != 0) ? (vgsfbeff - phid - vpolyd) : (vgsfbeff - phid - qbs - vpolyd);
        end
        qia  =  0.5 * (qis + qid);
        dqi  =  qis - qid;

        T0 = pow(Vdseff,2.0) / 6.25e-4;   //pow(Vdseff,2.0) / pow(25e-3, 2.0)
        if(CHARGEWF != 0)          
            qia2 = 0.5 * (qis + qid) + CHARGEWF * (1.0-lexp(-T0))* 0.5 * dqi;    
        else
            qia2 = 0.5 * (qis + qid);

        `ifdef __DEBUG__
            if(qis < 0) $strobe("Warning: negative source-side inversion carrier density.  Vgs=%f  Vds=%f  Vbs=%f qis=%e", V(g, s), V(d, s), V(e, s), qis);
            if(qid < 0) $strobe("Warning: negative drain-side inversion carrier density.  Vgs=%f  Vds=%f  Vbs=%f qid=%e", V(g, s), V(d, s), V(e, s), qid);
        `endif
        
        // *** Toxeff model for quantum mechanical effects ***
        // ** Normal operation (Vgs > Vfb) **
        if(QMTCENIV_i > 0.0 || QMTCENCV_i > 0.0) begin
            T4     =  (qia + ETAQM * qba) / QM0;
            T5     =  1.0 + pow(T4 , PQM);
            Tcen   =  Tcen0 / T5;
            case(GEOMOD)
            0: begin
                Weff   =  Weff0;
                WeffCV =  WeffCV0;
            end
            1: begin
                Weff   =  Weff0 - 4.0 * QMTCENIV_i * Tcen;
                WeffCV =  WeffCV0 - 4.0 * QMTCENCV_i * Tcen;
            end
            2: begin
                Weff   =  Weff0 - 8.0 * QMTCENIV_i * Tcen;
                WeffCV =  WeffCV0 - 8.0 * QMTCENCV_i * Tcen;
            end
            3: begin
                Weff   =  Weff0 - 2.0 * `M_PI * QMTCENIV_i * Tcen;
                WeffCV =  WeffCV0 - 2.0 * `M_PI * QMTCENCV_i * Tcen;
            end
            endcase
            //TOXP will be used with 'Tcen' added for coxeff
            if(GEOMOD !=3) coxeff  =  3.9 * `EPS0 / (TOXP * 3.9 / EPSROX + Tcen * QMTCENCV_i / epsratio);
            else coxeff  =  3.9 * `EPS0 / (R *(lln(R / (R - Tcen * QMTCENCV_i)) / epsratio + lln(1 + TOXP/R) * 3.9 / EPSROX));
        end else begin
            Weff   =  Weff0;
            WeffCV =  WeffCV0;
            coxeff =  cox;  //EOT will continue to be used for coxeff
        end
                    
        //** Quantum Mechanical effect Correction for  Accumulation Side Cap (Vgs < Vfb) **        
        if(CAPMOD != 0 && BULKMOD != 0 && QMTCENCVA_i != 0) begin
            T6    =  1.0 + pow(qi_acc / QM0ACC, PQMACC);
            Tcen  =  Tcen0 / T6;
            //TOXP will be used with 'Tcen' added for cox_acc
            if(GEOMOD !=3) cox_acc =  3.9 * `EPS0 / (TOXP * 3.9 / EPSROX + Tcen * QMTCENCVA_i / epsratio);
            else cox_acc =  3.9 * `EPS0 / (R *(lln(R / (R - Tcen * QMTCENCVA_i)) / epsratio + lln(1 + TOXP/R) * 3.9 / EPSROX));
        end //cox_acc already defined above with EOTACC

        //*** Multiplication factor for I-V ***
        beta =  u0_a * cox * Weff / Leff;
        
        // *** Mobility Degradation ***
        Eeffm =  EeffFactor * (qba + eta_mu * qia2);    // in the unit of MV/cm
        T2    =  pow(0.5 * (1.0 + abs((qia2) / qb0)), UCS_t);  //Changed in BSIM-CMG106.1.0
        if(BULKMOD != 0) begin
            T3    =  (UA_a + UC_a * veseff) * pow(abs(Eeffm), EU_a) + UD_a / T2; 
        end else begin
            T3    =  UA_a * pow(abs(Eeffm), EU_a) + UD_a / T2; 
        end    
        Dmob  =  1.0 + T3; 
        Dmob  =  Dmob / U0MULT; 
        ueff  =  u0_a / Dmob; 

        // *** Mobility Degradation for C-V ***
        Eeffm_cv =  EeffFactor * (qba + eta_mu_cv * qia2);    // in the unit of MV/cm
        T3       =  UA_a * pow(abs(Eeffm_cv), EU_a) + UD_a / T2; 
        Dmob_cv  =  1.0 + T3; 
        Dmob_cv  =  Dmob_cv / U0MULT; 

        // *** Calculate current and capacitance enhancement factors due to CLM and DIBL ***
        tmp = DROUT_i * Leff / scl + 1.0e-6;
        if (tmp < 40.0)
            DIBLfactor   =  0.5 * PDIBL1_a / (cosh(tmp) - 1.0) + PDIBL2_a;
        else
            DIBLfactor   =  PDIBL1_a * exp(-tmp) + PDIBL2_a;

        if(PVAG_i > 0) PVAGfactor  =  1.0 + PVAG_i * qia / EsatL; 
        else PVAGfactor  =  1.0 / (1.0 - PVAG_i * qia / EsatL); 
        
        if (Vdseff > vds) Vdseff =  vds; 
        diffVds  =  vds - Vdseff; 
        Vgst2Vtm =  qia + 2.0 * Vtm; 
        if (DIBLfactor > 0) begin 
            T1     =  Vgst2Vtm; 
            T3     =  T1 / (Vdsat + T1); 
            VaDIBL =  T1 / DIBLfactor * T3 * PVAGfactor; 
            Moc    =  1.0 + diffVds / VaDIBL; 
        end else begin 
            Moc    =  1.0; 
        end 
        
        if(PCLM_a > 0) begin 
            if(PCLMG_i < 0.0) 
                T1 =  1.0 / (1.0 / PCLM_a - PCLMG_i * qia); 
            else 
                T1 =  PCLM_a + PCLMG_i * qia; 
            Mclm   =  1.0 + T1 * lln(1.0 + (vds - Vdseff) / T1 / (Vdsat + EsatL)); 
        end else 
            Mclm   =  1.0; 
        
        Moc  =  Moc * Mclm; 
        
        // *** Current degradation factor due to velocity saturation ***
        Esat1  =  2.0 * VSAT1_a / ueff; 
        Esat1L =  Esat1 * Leff; 
        T0        =  lexp(PSAT_i * lln(dqi / Esat1L));
        Ta     =  (1.0 + lexp(1.0/PSAT_i * lln(DELTAVSAT_i))); 
        Dvsat  =  (1.0 + lexp(1.0/PSAT_i * lln(DELTAVSAT_i + T0))) / Ta; 
        Dvsat  =  Dvsat + 0.5 * PTWG_a * qia * dqi * dqi;

        // ** Non-saturation effect **
        T0     =  A1_t + A2_t / (qia + 2.0 * nVtm);
        T1     =  T0 * dqi * dqi;
        T2     =  T1 + 1.0 - 0.001;
        T3     =  -1.0 + 0.5 * (T2 + sqrt(T2*T2 + 0.004));   //max(T1,-1.0)
        Nsat   =  0.5 * (1.0 + sqrt(1.0 + T3));
        Dvsat  =  Dvsat * Nsat;        
        
        
        // *** Lateral Non-uniform doping effect (IV-CV Vth shift) factor ***
        if(K0_t != 0) begin
            T1      =  K0_t / (K0SI_t * qia + 2.0 * nVtm);
            Mnud    =  lexp(-T1);
        end else
            Mnud    =  1.0;

        // *** Body- effect factor for BULKMOD = 1 ***
        if(BULKMOD != 0) begin
            T0      =  hypsmooth((K1_t + K1SAT_t * vdsx),1.0E-6);
            T1      =  T0 / (K1SI_t * qia + 2.0 * nVtm);
            T3      =  sqrt(PHIBE_i - veseff) - sqrt(PHIBE_i);
             Mob     =  lexp(- T1 * T3);
        end else
            Mob = 1.0;

        // *** Velocity Saturation factor for C-V ***
        EsatCV  =  2.0 * VSATCV_t * Dmob_cv / u0_a; 
        EsatCVL =  EsatCV * LeffCV; 
        T0         =  lexp(PSATCV_i * lln(dqi / EsatCVL)); 
        Ta      =  (1.0 + lexp(1.0/PSATCV_i * lln(DELTAVSATCV_i))); 
        DvsatCV =  (1.0 + lexp(1.0/PSATCV_i * lln(DELTAVSATCV_i + T0))) / Ta; 

        // *** Channel Length Modulation factor for C-V ***
        if(PCLMCV_i != 0)
            MclmCV =  1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL)); 
        else 
            MclmCV =  1.0;


        //Calculating fixed body charge qb with sign (Here to avoid multiple calculation in NQSMOD=3 case)
        if(GEOMOD != 3) qb =  -`q * nbody * HFIN * TFIN * LeffCV;
        else qb  =  -`q * nbody * `M_PI * R * R * LeffCV;
        
        //******************************************
        // ***   Drain Current & Charge Model    ***
        
        if(GEOMOD !=3 && COREMOD != 0) begin
            
            //*************************************************
            // **   I-V model for lightly-doped MuGFETs     **
            T0   =  2.0 * csi / cox;
            T1   =  g0s * tang0s;
            T2   =  g0d * tang0d;
            if(NGATE_i > 0.0)
                T3 =  4.0 * r2 * (T1 * T1 + T1 * T2 + T2 * T2) / 3.0 + T0 * (T1 + T2);
            else
                T3 =  T0 * (T1 + T2);
            T6              =  g0s * g0s - g0d * g0d;
            ids0          =  2.0 * T0 * nVtm * nVtm * ((T3 + 2.0) * (T1 - T2) - T6);
            ids0_ov_dqi  =  0.5 * nVtm * (T3 + 1.0);
            
            // S/D series resistance
            `include "bsimcmg_rdsmod.include"
                
            ids  =  NFINtotal * beta * ids0 * Moc * Mob * Mnud / (Dmob * Dvsat * Dr);
            ids  =  ids * IDS0MULT;
            
            // Quasi Static C-V Model
            if(NGATE_i >0.0) Tcom  =  qis*qis + qis * qid + qid*qid;
            else Tcom  =  0.0;
            `include "bsimcmg_quasi_static_cv.include"
            
        end else begin
            //*************************************************************************
            // ** I-V model for GEOMOD=3 || Heavily-doped MuGFETs (NQSMOD=3 allowed) **    
            `ifdef __NQSMOD3__
            
                // Common Factor in I-V and C-V for Poly Gate case
                if(NGATE_i >0.0) Tcom  =  qis*qis + qis * qid + qid*qid;
                else Tcom  =  0.0;
                // Quasi Static I-V Model    
                if(NGATE_i > 0) begin
                    T0 =  2.0 * cpoly * Tcom / 3;
                    T1 =  kpoly * qia;
                end else begin
                    T0 =  0;
                    T1 =  qia;
                end
                etaiv  =  q0 / (q0 + cdop *qia);
                T2 =  (2.0 - etaiv) * nVtm;
                ids0_ov_dqi  =  T0 + T1 + T2;
                
                // S/D series resistance
                `include "bsimcmg_rdsmod.include"                

                
                if(NQSMOD == 3) begin
                    $strobe("[bsimcmg] You sure you wanted the NQS Charge Segmentation model! Proceed with absolute caution!");
                    `include "bsimcmg_nqsmod3_iv_cv.include"
                end else begin

                    $strobe("[bsimcmg] Although NQS charge segmentation model is activated, the model selector NQSMOD is not set to 3. Quasi-static calculations being performed instead.");
                    ids0 =  ids0_ov_dqi * dqi;
                    ids  =  NFINtotal * beta * ids0 * Moc * Mob * Mnud / (Dmob * Dvsat * Dr);
                    ids  =  ids * IDS0MULT;
                    
                    // Quasi Static C-V Model
                    `include "bsimcmg_quasi_static_cv.include"

                end //End of NQSMOD=3 check in `ifdef __NQSMOD3__
                
            `else
                
                if(NQSMOD == 3) begin
                    $strobe("[bsimcmg] Although the model selector NQSMOD is set to 3, the NQS charge segmentation model is not activated in the Verilog-A code.  Please uncomment \"`define __NQSMOD3__\" in bsimcmg.va to activate it. Quasi-static calculations being performed instead");
                end //End of NQSMOD=3 check in `else
                
                // Common Factor in I-V and C-V for Poly Gate case
                if(NGATE_i >0.0) Tcom  =  qis*qis + qis * qid + qid*qid;
                else Tcom  =  0.0;
                // Quasi Static I-V Model    
                if(NGATE_i > 0) begin
                    T0 =  2.0 * cpoly * Tcom / 3;
                    T1 =  kpoly * qia;
                end else begin
                    T0 =  0;
                    T1 =  qia;
                end
                etaiv  =  q0 / (q0 + cdop *qia);                   
                T2 =  (2.0 - etaiv) * nVtm;
                ids0_ov_dqi  =  T0 + T1 + T2;
                ids0 =  ids0_ov_dqi * dqi;
                
                // S/D series resistance
                `include "bsimcmg_rdsmod.include"
                
                ids  =  NFINtotal * beta * ids0 * Moc * Mob * Mnud / (Dmob * Dvsat * Dr);
                ids  =  ids * IDS0MULT;
                
                // Quasi Static C-V Model
                `include "bsimcmg_quasi_static_cv.include"
                
            `endif  //End of `ifdef __NQSMOD3__
            
        end //End of all I-V & C-V Models
        //*******************************************************
                
        // *** Accumulation Capacitance ***
        if(CAPMOD != 0 && BULKMOD != 0) begin
            T1     =  NFINtotal * WeffCV0 * LeffCV_acc * cox_acc;
            qg_acc =  - qi_acc * T1;
            qb_acc =  + qi_acc * T1;
        end
        
        // *** Parasitic Capacitances ***
        // ** Bias-dependent overlap capacitances (CGEOMOD=0 and 2) **
        qgs_ov =  0.0;
        qgd_ov =  0.0;
        if(CGEOMOD != 1) begin
            T1           =  NFINtotal * WeffCV * devsign;
            T2           =  devsign * V(`GateEdgeNode, si);
            T0           =  T2 - vfbsd + `DELTA_1;
            vgs_overlap  =  0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
            qgs_ov       =  T1 * (CGSL_i * (T2 - vfbsd - vgs_overlap
                            - 0.5 * CKAPPAS_i * (sqrt(1.0 - 4.0 * vgs_overlap / CKAPPAS_i)
                            - 1.0)) + CGSO_i * T2);
            
            T2           =  devsign * V(`GateEdgeNode, di);
            T0           =  T2 - vfbsd + `DELTA_1;
            vgd_overlap  =  0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
            qgd_ov       =  T1 * (CGDL_i * (T2 - vfbsd - vgd_overlap
                            - 0.5 * CKAPPAD_i * (sqrt(1.0 - 4.0 * vgd_overlap / CKAPPAD_i)
                            - 1.0)) + CGDO_i * T2);
        end
        
        if(CGEOMOD == 0) begin
            T1                =  NFINtotal * WeffCV0;            // Fringe caps dont see QM effects
            qgs_fr            =  T1 * CFS_i * V(`GateEdgeNode, si);
            qgd_fr            =  T1 * CFD_i * V(`GateEdgeNode, di);
            qgs_parasitic  =  qgs_ov + qgs_fr;
            qgd_parasitic  =  qgd_ov + qgd_fr;
        end else if(CGEOMOD == 1) begin // CGEO1SW=1 enables parameters to be in F per fin, per gate-finger, per unit channel width 
            if (CGEO1SW == 1) begin
                T0     = NFINtotal * WeffCV0;                
                COVS_i = T0 * COVS_i;
                COVD_i = T0 * COVD_i;
                cgsp   = T0 * CGSP;
                cgdp   = T0 * CGDP;
            end else begin
                cgsp   = CGSP;
                cgdp   = CGDP;
              end    
            qgs_ov         =  COVS_i * V(`GateEdgeNode, si);
            qgd_ov         =  COVD_i * V(`GateEdgeNode, di);
            qgs_parasitic  =  qgs_ov;
            qgd_parasitic  =  qgd_ov;
            qgs_fr         =  cgsp * V(`GateEdgeNode, s);
            qgd_fr         =  cgdp * V(`GateEdgeNode, d);
        end else begin
            qgs_fr         =  Cfr_geo * V(`GateEdgeNode, si);
            qgd_fr         =  Cfr_geo * V(`GateEdgeNode, di);
            qgs_parasitic  =  qgs_ov + qgs_fr;
            qgd_parasitic  =  qgd_ov + qgd_fr;
        end
        // ** Drain to Source Fringe Cap available for all CGEOMOD **
        qds_fr =  CDSP * V(d, s);
        
        // *** Impact Ionization Current ***
        // Ref: IIMOD=1 - BSIM4 Model, IIMOD=2 - BSIMSOI Model
        Iii = 0;
        if (IIMOD==1) begin
            T0 =  (ALPHA0_t + ALPHA1_t * Leff) / Leff;
            if ((T0 <= 0.0) || (BETA0_t <= 0.0))
                Iii  =  0.0;
            else begin
                T1   =  - BETA0_t / (diffVds + 1.0e-30);
                `ifdef __NQSMOD3__
                    if(GEOMOD !=3 && COREMOD !=0) begin
                        Iii  =  T0 * diffVds * ids * lexp(T1);
                    end else begin 
                        if(NQSMOD==3)
                            Iii  =  T0 * diffVds * idsN * lexp(T1);
                        else
                            Iii  =  T0 * diffVds * ids * lexp(T1);
                    end
                `else
                    Iii  =  T0 * diffVds * ids * lexp(T1);
                `endif
            end
        end else if (IIMOD==2) begin    //End of IIMOD=1
            ALPHAII    =  (ALPHAII0_t + ALPHAII1_t * Leff) / Leff;
            if (ALPHAII <= 0.0) begin
                Iii  =  0.0;
            end else begin
                T0       =  ESATII_i * Leff;
                T1       =  SII0_t * T0 / (1.0 + T0);
                T0       =  1.0 / (1.0 + hypsmooth(SII1_i * vgsfbeff, 1.0e-3)); // T0 = 1 / (1 + SII1_i * vgsfbeff)
                T3       =  T0 + SII2_i;
                T2       =  hypsmooth(vgsfbeff * T3, 1.0e-3);  //T2 = vgsfbeff * T3
                T3       =  1.0 / (1.0 + SIID_i * vds);
                VgsStep  =  T1 * T2 * T3;
                Vdsatii  =  VgsStep * (1.0 - LII_i / Leff);
                Vdiff    =  vds - Vdsatii;
                T0       =  BETAII2_i + BETAII1_i * Vdiff + BETAII0_i * Vdiff * Vdiff;
                T1       =  sqrt(T0*T0 + 1.0E-10);
                T2       =  10.0 - ALPHAII* lexp(Vdiff / T1) - 0.01;                 /* Avoid too high ratio */
                Ratio    =  10.0 - 0.5 * (T2 + sqrt(T2*T2 + 4.0*10.0*0.01)); //min(10,ALPHAII* lexp(Vdiff / T1))
                `ifdef __NQSMOD3__
                    if(GEOMOD !=3 && COREMOD !=0) begin
                        Iii    =  Ratio * ids;
                    end else begin
                        if(NQSMOD==3)
                            Iii    =  Ratio * idsN;
                        else
                            Iii    =  Ratio * ids;
                    end
                `else
                    Iii  =  Ratio * ids;
                `endif
            end
        end  //End of IIMOD=2        
        
        // *** Gate Current ***
        // Ref: BSIM4 Model
        igbinv   =  0.0;
        igbacc   =  0.0;
        igcs      =  0.0;
        igcd      =  0.0;
        igs       =  0.0;
        igd       =  0.0;
        
        // ** Igb **
        if (IGBMOD != 0) begin
            //Igbinv
            T1              =  (qia - EIGBINV_i) / NIGBINV_i / Vtm;
            Vaux_Igbinv  =  NIGBINV_i * Vtm * lln(1 + lexp(T1));
            T2              =  AIGBINV_t - BIGBINV_i * qia;
            T3              =  1 + CIGBINV_i * qia;
            T4              =  -9.82222e11 * TOXG * T2 * T3;
            T5              =  lexp(T4);
            T6              =  3.75956e-7;
            igbinv          =  Weff0 * Leff * T6 * Toxratio * vge * Vaux_Igbinv * T5;
            igbinv          =  igbinv * igtemp;
            
            // ** Igbacc **
            vfbzb           =  deltaPhi -Eg/2.0 - phib;
            T0              =  vfbzb - vge;
            T1              =  T0 / NIGBACC_i / Vtm;
            Vaux_Igbacc  =  NIGBACC_i * Vtm * lln(1 + lexp(T1));
            if(CAPMOD != 0 && BULKMOD != 0)
                Voxacc   =  qi_acc;
            else begin
                if(vfbzb <=0)
                    Voxacc =  0.5 * (T0 - 0.02 + sqrt((T0 - 0.02)*(T0 - 0.02) - 0.08 * vfbzb));
                else
                    Voxacc =  0.5 * (T0 - 0.02 + sqrt((T0 - 0.02)*(T0 - 0.02) + 0.08 * vfbzb));
            end
            T2              =  AIGBACC_t - BIGBACC_i * Voxacc;
            T3              =  1 + CIGBACC_i * Voxacc;
            T4              =  -7.45669e11 * TOXG * T2 * T3;
            T5              =  lexp(T4);
            T6              =  4.97232e-7;
            igbacc          =  Weff0 * Leff * T6 * Toxratio * vge * Vaux_Igbacc * T5;
            igbacc          =  igbacc * igtemp;
            
        end
        
        if(IGCMOD != 0) begin
            
            // ** Igcinv **
            T1   =  AIGC_t - BIGC_i * qia;
            T2   =  1.0 + CIGC_i * qia;
            T3   =  -Bechvb * TOXG * T1 * T2;
            T4   =  qia * lexp(T3);
            T5   =  (vge + 0.5 *vdsx + 0.5*(ves_jct+ ved_jct));
            igc0 =  Weff0 * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;
            
            // Gate-current partitioning
            Vdseffx  =  sqrt(Vdseff*Vdseff + 0.01) - 0.1;
            T1          =  PIGCD_i * Vdseffx;
            T1_exp   =  lexp(-T1);
            T3          =  T1 + T1_exp -1.0 + 1.0E-4;
            T4          =  1.0 - (T1 + 1.0) * T1_exp + 1.0E-4;
            T5          =  T1 * T1 + 2.0E-4;
            igcd      =  igc0 * T4 / T5;
            igcs      =  igc0 * T3 / T5;
            
            // ** Igs **
            T0        =  vgs_noswap - vfbsd;
            vgs_eff  =  sqrt(T0 * T0 + 1.0e-4);
            T1          =  AIGS_t - BIGS_i * vgs_eff;
            T2          =  1.0 + CIGS_i * vgs_eff;
            T3          =  -Bechvb * TOXG * POXEDGE_i * T1 * T2;
            T4          =  lexp(T3);
            if(sigvds > 0) igs  =  igsd_mult * DLCIGS * vgs_noswap * vgs_eff * T4;
            else           igd  =  igsd_mult * DLCIGS * vgs_noswap * vgs_eff * T4;
            
            // ** Igd **
            T0          =  vgd_noswap -vfbsd;
            vgd_eff  =  sqrt(T0 * T0 + 1.0e-4);
            T1          =  AIGD_t - BIGD_i * vgd_eff;
            T2          =  1.0 + CIGD_i * vgd_eff;
            T3          =  -Bechvb * TOXG * POXEDGE_i * T1 * T2;
            T4          =  lexp(T3);
            if(sigvds > 0) igd  =  igsd_mult * DLCIGD * vgd_noswap * vgd_eff * T4;
            else           igs  =  igsd_mult * DLCIGD * vgd_noswap * vgd_eff * T4;
            
        end
        
        // *** GIDL/GISL current ***
        // Ref: BSIM4 Model
        igisl  =  0.0;
        igidl  =  0.0;
        if (GIDLMOD != 0) begin
            
            T0 =  epsratio * EOT;
            
            // ** GIDL **
            if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
                T6 =  0.0;
            end else begin
                T1 =  (- vgd_noswap - EGIDL_i + vfbsd) / T0;
                T1 =  hypsmooth(T1, 1.0E-2);
                T2 =  BGIDL_t / (T1 + 1.0E-3);
                T3 =  lexp(PGIDL_i * lln(T1));
                if(BULKMOD != 0) begin
                    T4  =  - ved_jct*ved_jct*ved_jct;
                    T4a =  CGIDL_i + abs(T4) + 1.0E-5;
                    T5  =  hypsmooth(T4/T4a, 1.0E-6) - 1.0E-6;
                    T6  =  AGIDL_i * Weff0 * T3 * lexp(-T2) * T5;
                end else
                    T6  =  AGIDL_i * Weff0 * T3 * lexp(-T2) * vds_noswap;
            end
            if(sigvds > 0.0) igidl =  T6;
            else igisl =  T6;
            
            // ** GISL **
            if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
                T6 =  0.0;
            end else begin
                T1 =  (- vgs_noswap - EGISL_i + vfbsd) / T0;
                T1 =  hypsmooth(T1, 1.0E-2);
                T2 =  BGISL_t / (T1 + 1.0E-3);
                T3 =  lexp(PGISL_i * lln(T1));
                if(BULKMOD != 0) begin
                    T4 =  - ves_jct*ves_jct*ves_jct;
                    T4a =  CGISL_i + abs(T4) + 1.0E-5;
                    T5  =  hypsmooth(T4/T4a, 1.0E-6) - 1.0E-6;
                    T6 =  AGISL_i * Weff0 * T3 * lexp(-T2) * T5;
                end else
                    T6 =  AGISL_i * Weff0 * T3 * lexp(-T2) * (- vds_noswap);
            end
            if(sigvds > 0.0) igisl =  T6;
            else igidl =  T6;
            
        end // GIDLMOD
        
        // *** Junction current ***
        if(BULKMOD != 0) begin
            // ** Source-side junction current **
            if(Isbs > 0.0) begin
                if (ves_jct < VjsmRev) begin
                    T0   =  ves_jct / Nvtms;
                    T1   =  lexp(T0) - 1.0;
                    T2   =  IVjsmRev + SslpRev * (ves_jct - VjsmRev);
                    Ies  =  T1 * T2;
                end else if (ves_jct <= VjsmFwd) begin
                    T0   =  ves_jct / Nvtms;
                    T1   =  (BVS + ves_jct) / Nvtms;
                    T2   =  lexp(-T1);
                    Ies  =  Isbs * (lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
                end else
                    Ies  =  IVjsmFwd + SslpFwd * (ves_jct - VjsmFwd);
            end else
                Ies  =  0.0;
            
            //** Source-side junction tunneling current **
            if(JTSS_t > 0.0) begin
                if((VTSS - ves_jct) < (VTSS * 1.0e-3)) begin
                    T0 =  -ves_jct / Vtm0 / NJTS_t;
                    T1 =  lexp(T0 * 1.0e+3) - 1.0;
                    Ies  =  Ies - ASEJ * JTSS_t * T1;
                end else begin
                    T0   =  -ves_jct / Vtm0 / NJTS_t;
                    T1   =  lexp(T0 * VTSS / (VTSS - ves_jct)) - 1.0;
                    Ies  =  Ies - ASEJ * JTSS_t * T1;
                end
            end
            if(JTSSWS_t > 0.0) begin
                if((VTSSWS - ves_jct) < (VTSSWS * 1.0e-3)) begin
                    T0   =  -ves_jct / Vtm0 / NJTSSW_t;
                    T1   =  lexp(T0 * 1.0e+3) - 1.0;
                    Ies  =  Ies - PSEJ * JTSSWS_t * T1;
                end else begin
                    T0   =  -ves_jct / Vtm0 / NJTSSW_t;
                    T1   =  lexp(T0 * VTSSWS / (VTSSWS - ves_jct)) - 1.0;
                    Ies  =  Ies - PSEJ * JTSSWS_t * T1;
                end
            end
            if(JTSSWGS_t > 0.0) begin
                if((VTSSWGS - ves_jct) < (VTSSWGS * 1.0e-3)) begin
                    T0   =  -ves_jct / Vtm0 / NJTSSWG_t;
                    T1   =  lexp(T0 * 1.0e+3) - 1.0;
                    Ies  =  Ies - Weff0 * NFINtotal * JTSSWGS_t * T1;
                end else begin
                    T0   =  -ves_jct / Vtm0 / NJTSSWG_t;
                    T1   =  lexp(T0 * VTSSWGS / (VTSSWGS - ves_jct)) - 1.0;
                    Ies  =  Ies - Weff0 * NFINtotal * JTSSWGS_t * T1;
                end
            end
            
            // ** Drain-side junction current **
            if(Isbd > 0.0) begin
                if (ved_jct < VjdmRev) begin
                    T0   =  ved_jct / Nvtmd;
                    T1   =  lexp(T0) - 1.0;
                    T2   =  IVjdmRev + DslpRev * (ved_jct - VjdmRev);
                    Ied  =  T1 * T2;
                end else if (ved_jct <= VjdmFwd) begin
                    T0   =  ved_jct / Nvtmd;
                    T1   =  (BVD + ved_jct) / Nvtmd;
                    T2   =  lexp(-T1);
                    Ied  =  Isbd * (lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
                end else
                    Ied  =  IVjdmFwd + DslpFwd * (ved_jct - VjdmFwd);
            end else
                Ied  =  0.0;
            
            //** Drain-side junction tunneling current **
            if(JTSD_t > 0.0) begin
                if((VTSD - ved_jct) < (VTSD * 1.0e-3)) begin
                    T0 =  -ved_jct / Vtm0 / NJTSD_t;
                    T1 =  lexp(T0 * 1.0e+3) - 1.0;
                    Ied  =  Ied - ADEJ * JTSD_t * T1;
                end else begin
                    T0   =  -ved_jct / Vtm0 / NJTSD_t;
                    T1   =  lexp(T0 * VTSD/ (VTSD - ved_jct)) - 1.0;
                    Ied  =  Ied - ADEJ * JTSD_t * T1;
                end
            end
            if(JTSSWD_t > 0.0) begin
                if((VTSSWD - ved_jct) < (VTSSWD * 1.0e-3)) begin
                    T0   =  -ved_jct / Vtm0 / NJTSSWD_t;
                    T1   =  lexp(T0 * 1.0e+3) - 1.0;
                    Ied  =  Ied - PDEJ * JTSSWD_t * T1;
                end else begin
                    T0   =  -ved_jct / Vtm0 / NJTSSWD_t;
                    T1   =  lexp(T0 * VTSSWD / (VTSSWD - ved_jct)) - 1.0;
                    Ied  =  Ied - PDEJ * JTSSWD_t * T1;
                end
            end
            if(JTSSWGD_t > 0.0) begin
                if((VTSSWGD - ved_jct) < (VTSSWGD * 1.0e-3)) begin
                    T0   =  -ved_jct / Vtm0 / NJTSSWGD_t;
                    T1   =  lexp(T0 * 1.0e+3) - 1.0;
                    Ied  =  Ied - Weff0 * NFINtotal * JTSSWGD_t * T1;
                end else begin
                    T0   =  -ved_jct / Vtm0 / NJTSSWGD_t;
                    T1   =  lexp(T0 * VTSSWGD / (VTSSWGD - ved_jct)) - 1.0;
                    Ied  =  Ied - Weff0 * NFINtotal * JTSSWGD_t * T1;
                end
            end
    
            // *** Junction capacitance (no swapping !!) ***
            // ** Source-Substrate Junction **
            `BSIM6JunctnCap(ves_jct, Czbs, PBS_t, SJS, MJS, MJS2, Qesj1)
            `BSIM6JunctnCap(ves_jct, Czbssw, PBSWS_t, SJSWS, MJSWS, MJSWS2, Qesj2)
            `BSIM6JunctnCap(ves_jct, Czbsswg, PBSWGS_t, SJSWGS, MJSWGS, MJSWGS2, Qesj3)
            Qesj = Qesj1 + Qesj2 + Qesj3;
            
            // ** Drain-Substrate Junction **
            `BSIM6JunctnCap(ved_jct, Czbd, PBD_t, SJD, MJD, MJD2, Qedj1)
            `BSIM6JunctnCap(ved_jct, Czbdsw, PBSWD_t, SJSWD, MJSWD, MJSWD2, Qedj2)
            `BSIM6JunctnCap(ved_jct, Czbdswg, PBSWGD_t, SJSWGD, MJSWGD, MJSWGD2, Qedj3)
            Qedj = Qedj1 + Qedj2 + Qedj3;

        end //BULKMOD=0

        Qes  =  Qesj + csbox * ves_jct;
        Qed  =  Qedj + cdbox * ved_jct;
        
        // *** Gate to Substrate Parasitic Capacitance *** 
        // ** Bias Independent Component **
        Qeg  =  cgbox * devsign * V(e, `GateEdgeNode);
        if(BULKMOD != 0) begin
            //Bias Dependent Component
            T2 =  devsign * V(`GateEdgeNode, e);
            T3 =  T2 - deltaPhi + Eg/2.0 + phib - DELVFBACC;
            T0 =  T3 + `DELTA_1;
            vge_overlap  =  0.5 * (T0 + sqrt(T0 * T0 + 4.0 * `DELTA_1));
            Qeg  =  Qeg - NFINtotal * LeffCV * (CGBL_i * (T3 - vge_overlap
                        + 0.5 * CKAPPAB_i * ( sqrt(1.0 + 4.0 * vge_overlap / CKAPPAB_i) - 1.0 )));
        end
        
        // *** Generation/recombination component ***
        T0        =  vds;
        T1        =  T0 * (AIGEN_i + BIGEN_i * T0 * T0);
        idsgen =  HFIN * TFIN * (Leff - 2.0 * LINTIGEN_i) * igentemp * T1;
        
        
        // *** NQS Gate Resistance ***
        // Ref: BSIM4 Model
        T0       =  ueff * coxeff * Weff / Leff;
        `ifdef __NQSMOD1__
            if(NQSMOD == 1 && XRCRG1_i != 0) begin
                IdovVds  =  beta * ids0_ov_dqi * Moc / (Dmob * Dvsat * Dr);
                gcrg =  NFINtotal * XRCRG1_i * (IdovVds + XRCRG2_i * Vtm * T0);
            end
        `endif
        `ifdef __NQSMOD2__
            if(NQSMOD == 2) begin
                IdovVds  =  beta * ids0_ov_dqi * Moc / (Dmob * Dvsat * Dr);
                gcrg =  NFINtotal * XRCRG1_i * (IdovVds + XRCRG2_i * Vtm * T0);
                gtau =  gcrg / (cox * Weff * Leff);
            end
        `endif
        
        
        // *** Multiply all current and charge components by NFINtotal ***
        // Note: Do not multiply ids, qg, qs, qd, qb, Ies, Ied, Qbs, Qbd with NFINtotal
        //       since it is already considered.
        
        igidl    =  NFINtotal * igidl;
        igisl    =  NFINtotal * igisl;
        igcd      =  NFINtotal * igcd;
        igcs      =  NFINtotal * igcs;
        igs       =  NFINtotal * igs;
        igd       =  NFINtotal * igd;
        igbinv   =  NFINtotal * igbinv;
        igbacc   =  NFINtotal * igbacc;
        idsgen   =  NFINtotal * idsgen;
        //Iii      =  NFINtotal * Iii;

        // Gate to Body Tunneling current empirical partition for BULKMOD=0        
        igbs = 0.0;
        igbd = 0.0;
        if(BULKMOD == 0) begin
            igbs   =  (igbinv + igbacc) * wf;
            igbd   =  (igbinv + igbacc) * wr;
        end
        
        //********************************
        // ***      Noise Models       ***
        
        Esatnoi    =  2.0 * VSAT_a / ueff;  // Thermal noise and flicker noise
                
        // ** Flicker Noise **
        // Ref: BSIM4 Model; K. K. Hung et al., TED 1990 
        if(NOIA > 0 || NOIB > 0 || NOIC > 0) begin
            Leffnoi    =  Leff - 2.0 * LINTNOI_i;
            Leffnoisq  =  Leffnoi * Leffnoi;
            if(EM <= 0.0) DelClm =  0.0;
            else begin
                T0     =  (diffVds / litl + EM) / Esatnoi;
                DelClm =  litl * lln(T0);
                if (DelClm < 0.0) DelClm =  0.0;
            end
            `ifdef __NQSMOD3__
                if(GEOMOD !=3 && COREMOD !=0) begin
                    T1 =  `q * `q * `q * Vtm * abs(ids) * ueff;
                end else begin 
                    if(NQSMOD==3)
                        T1 =  `q * `q * `q * Vtm * abs(ids1) * ueff;
                    else
                        T1 =  `q * `q * `q * Vtm * abs(ids) * ueff;
                end
            `else
                T1 =  `q * `q * `q * Vtm * abs(ids) * ueff;
            `endif
            T2     =  1.0e10 * coxeff * Leffnoisq;
            N0     =  coxeff * qis / `q;
            Nl     =  coxeff * qid / `q;
            // Note: Cdep ~ 0 in a fully-depleted device
            Nstar  =  Vtm / `q * (coxeff + CIT_a);
            T3        =  NOIA * lln((N0 + Nstar) / (Nl + Nstar));
            T4        =  NOIB * (N0 - Nl);
            T5     =  0.5 * NOIC * (N0 * N0 - Nl * Nl);
            
            `ifdef __NQSMOD3__
                if(GEOMOD !=3 && COREMOD !=0) begin
                    T6 =  `q * Vtm * ids * ids;
                end else begin 
                    if(NQSMOD==3)
                        T6 =  `q * Vtm * ids1 * ids1;
                    else
                        T6 =  `q * Vtm * ids * ids;
                end
            `else
                T6 =  `q * Vtm * ids * ids;
            `endif

            T7 =  1.0e10 * Leffnoisq * Weff * NFINtotal;
            T8 =  NOIA + NOIB * Nl + NOIC * Nl * Nl;
            T9 =  (Nl + Nstar) * (Nl + Nstar);
            Ssi  =  T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
            
            T10  =  NOIA * `q * Vtm;
            T11  =  Weff * NFINtotal * Leffnoi * 1.0e10 * Nstar * Nstar;
            `ifdef __NQSMOD3__
                if(GEOMOD !=3 && COREMOD !=0) begin
                    Swi  =  T10 / T11 * ids * ids;
                end else begin
                    if(NQSMOD==3)
                        Swi  =  T10 / T11 * ids1 * ids1;
                    else
                        Swi  =  T10 / T11 * ids * ids;
                end
            `else
                Swi  =  T10 / T11 * ids * ids;
            `endif
            
            T1   =  Swi + Ssi;
            if (T1 > 0.0) FNPowerAt1Hz =  (Ssi * Swi) / T1;
            else FNPowerAt1Hz  =  0.0;
        end else begin
            FNPowerAt1Hz =  0.0;
        end
        
        
        // ** Thermal Noise **
        // Charge-based model (BSIM4 - TNOIMOD=0)
        `ifdef __NQSMOD3__
            if((NQSMOD==3)&&(!(GEOMOD !=3 && COREMOD !=0)))
                qinv  =  qg1 + qg2 + qg3 + qg4 + qg5 + qg6 + qg7 + qg8 + qg9 + qg10;
        `endif
        //////////////////// Thermal Noise  //////////////////////
                case(TNOIMOD)
            0 : begin
                T0     =  ueff * qinv;
                T1     =  T0 * Rdsi + Leff * Leff;
                Gtnoi  =  (T0 / T1) * NTNOI_i;
                sid    =  4 * Vtm * `q * Gtnoi;
               end
            1 : begin
`ifndef __XYCE__
                T0            = qis / EsatL;
                T1            = Leff * T0 * T0;
                theta_tnoi        = RNOIB * (1.0 + TNOIB * T1);    // theta_tnoi
                beta_tnoi        = RNOIA * (1.0 + TNOIA * T1);    // beta_tnoi
                if (theta_tnoi > 0.9)
                    theta_tnoi = 0.9;
                if (theta_tnoi > 0.9 * beta_tnoi)
                    theta_tnoi = 0.9 * beta_tnoi;
                T3    = devsign * ddx(ids, V(`IntrinsicGate));    // Gm
                if(sigvds > 0.0) 
                    T4    = devsign * ddx(ids,V(di));                // Gds
                else 
                    T4    = devsign * ddx(ids,V(si));                // Gds
                T5    = ddx(ids,V(e));                // Gmbs
                        
                overall_conductance    = T3 + T4 + T5;        // Gm + Gds + Gmbs 
                T7    = T4 + beta_tnoi * (T3 + T5);
                T8    = theta_tnoi * overall_conductance;
                sid    = 4 * Vtm * `q * (T7 * T7 - T8 * T8) * Vdseff / max(ids, 1.0e-9);
                if(sid < 0.0) sid = 0.0;
`else // !`ifndef __XYCE__
               // Technically this should be $fatal, but Xyce implements $finish as if it were fatal,
               // and does not implement $fatal.
               $finish("BSIM-CMG 108 TNOIMOD=1 is unsupported.");
`endif
               end 
            2: begin  //Correlated Thermal Noise by Navid, November 2013, Reference BSIMSOI4.5.0
            `ifdef __TNOIMOD2__
                Abulk = 1.0;
                Vgst2Vtm =  KSATIV_a * (qis + vpolys + 2*Vtm); 
                etaa  = 1.0 - Vdseff * Abulk / Vgst2Vtm ;
                T0    = 1.0 - etaa;
                T1    = 1.0 + etaa;
                T2    = T1 + 2.0 * Abulk * Vtm/(qia+1.0e-10);           
                T3    = T2*T2;
                T4    = T0*T0;           
                T5    = T3*T3;
                T6    = 1.0 / (1.0 + Vdseff/EsatL) ;
                
                gamma   = T6*(0.5*T1 + T0*T0/(6.0*T2)); 
                delta   = ((T1/T3)-(5.0*T1 + T2)*T4/(15.0*T5) + T4*T4/(9.0*T5*T2))/(6.0*T6*T6*T6);
                T7      = T0/T2;
                epsilon = (T7 + T7*T7*T7/3.0)/(6.0*T6);

                T8      = qia / (EsatL);
                T8      = T8 * T8;
                npart_c = RNOIC * (1.0 + T8 * TNOIC * Leff);  
                ctnoi   = epsilon / sqrt( gamma * delta) * (2.5316 * npart_c);
                if (ctnoi > 1) 
                    ctnoi=1;
                if (ctnoi < 0)
                    ctnoi=0;
                npart_beta  = RNOIA * (1.0 + T8 * TNOIA * Leff);
                npart_theta = RNOIB * (1.0 + T8 * TNOIB * Leff);
                gamma       = gamma * (3.0  * npart_beta  * npart_beta);
                delta       = delta * (3.75 * npart_theta * npart_theta);  
        
                T9        = qia * 0.5 * T1;
                gche      = beta * T9 * T6;
                noiGd0    = NFINtotal * beta * qia / (1.0 + gche * Rdsi);
                GammaGd0  = gamma * noiGd0;  
                sid       = 4 * Vtm * `q * GammaGd0;
                C0        = NFINtotal * coxeff * WeffCV * LeffCV;
                sf        = (noiGd0+1e-15)/sqrt(delta/gamma);
        
            `else
                $strobe("[Warning!] Although the model selector TNOIMOD is set to 2, the new correlated thermal noise model is not activated. Please uncomment \"`define __TNOIMOD2__\" in in the bsimcmg_main.va.");
            `endif
            end 
        endcase
        //////////////////// Thermal Noise Ends //////////////////////

        // Source and Drain conductance for thermal noise contribution
    if (RDSMOD !=2) begin
        gspr =  1 / Rsource;    /* Note: gspr considers all fins */
        gdpr =  1 / Rdrain;     /* Note: gdpr considers all fins */
        
    end    
    // End of Bias dependent calculation
    //********************************************************************************
        
    if(!initialized) begin
        devsign  =  0.0;
        Rsource  =  1.0;
        Rdrain   =  1.0;
        `ifdef __RGATEMOD__
            ggeltd =  1.0;
        `endif
        `ifdef __NQSMOD1__
            XRCRG1_i =  0.0;
        `endif
        `ifdef __SHMOD__
            gth  =  1.0;    // set gth to some value to prevent a singular G matrix
            cth  =  0.0;
        `endif
        $strobe("uninitialized");
    end //End of !initialized
    
    //Loading Ids, Gate and Drain charges
    `ifdef __NQSMOD2__
        if(sigvds > 0.0) I(di, si) <+  devsign * ids;
        else             I(si, di) <+  devsign * ids;
        
        if(NQSMOD == 2) begin
            I(`IntrinsicGate, si)  <+  devsign * gtau * -V(q);
            I(di, si)              <+  devsign * xdpart * gtau * V(q);
        end else begin  //Quasi-static stamping (Normal case)
            I(di, si)              <+  devsign * ddt(qd);
            I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
        end
    `else
        `ifdef __NQSMOD3__
            if(GEOMOD !=3 && COREMOD != 0) begin    //Case not supported for NQSMOD=3
                if(sigvds > 0.0) I(di, si) <+  devsign * ids;
                else             I(si, di) <+  devsign * ids;
                I(di, si)              <+  devsign * ddt(qd);
                I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
            end else begin
                if(NQSMOD == 3) begin
                    `include "bsimcmg_load_nqsmod3_segments.include"
                end else begin  //Quasi-static stamping (Normal case)
                    if(sigvds > 0.0) I(di, si) <+  devsign * ids;
                    else             I(si, di) <+  devsign * ids;
                    I(di, si)              <+  devsign * ddt(qd);
                    I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
                end
            end
        `else   //Quasi-static stamping (Normal case)
            if(sigvds > 0.0) I(di, si) <+  devsign * ids;
            else             I(si, di) <+  devsign * ids;
            I(di, si)              <+  devsign * ddt(qd);
            I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
        `endif
    `endif
    
    // Loading other currents
    if (sigvds > 0) begin
        I(di, si) <+  devsign * idsgen;
        I(`IntrinsicGate, si)   <+  devsign * (igcs + igs);
        I(`IntrinsicGate, di)   <+  devsign * (igcd + igd);
        if(BULKMOD != 0) begin
            I(di, e)               <+  devsign * (igidl + Iii);
            I(si, e)               <+  devsign * igisl;
            I(`IntrinsicGate, e)   <+  devsign * (igbinv + igbacc) ;
        end else begin
            I(di, si) <+  devsign * (igidl + Iii);
            I(si, di) <+  devsign * igisl;
        end
    end else begin
        I(si, di)               <+  devsign * idsgen;
        I(`IntrinsicGate, di)   <+  devsign * (igcs + igs);
        I(`IntrinsicGate, si)   <+  devsign * (igcd + igd);
        if(BULKMOD != 0) begin
            I(si, e)               <+  devsign * (igidl + Iii);
            I(di, e)               <+  devsign * igisl;
            I(`IntrinsicGate, e)   <+  devsign * (igbinv + igbacc);
        end else begin
            I(si, di) <+  devsign * (igidl + Iii);
            I(di, si) <+  devsign * igisl;
        end
    end
    if(BULKMOD == 0) begin
        I(`IntrinsicGate, si)  <+  devsign * igbs;
        I(`IntrinsicGate, di)  <+  devsign * igbd;
    end
    
    if(BULKMOD != 0) begin
        I(e, si)  <+  devsign * Ies;
        I(e, di)  <+  devsign * Ied;
    end
    I(e, si)               <+  devsign * ddt(Qes);
    I(e, di)               <+  devsign * ddt(Qed);
    I(e, `GateEdgeNode)    <+  devsign * ddt(Qeg);
    
    // Gmin for convergence - removed on consensus among EDA vendors.
    // Kindly use GMIN=1E-18 if at all required by the simulator
    // if(BULKMOD != 0) begin
    //    I(e, si)  <+  `GMIN * V(e, si);
    //    I(e, di)  <+  `GMIN * V(e, di);
    // end
    
    //Loading other charges     
    I(`GateEdgeNode, si)  <+  ddt(qgs_parasitic);
    I(`GateEdgeNode, di)  <+  ddt(qgd_parasitic);
    I(d, s) <+ ddt(qds_fr);
    if(CGEOMOD == 1) begin
        I(`GateEdgeNode, s) <+  ddt(qgs_fr);
        I(`GateEdgeNode, d) <+  ddt(qgd_fr);
    end
    // Accumulation charge for bulk FET
    if(CAPMOD != 0 && BULKMOD != 0) begin
        I(`IntrinsicGate, si) <+ devsign * ddt(qg_acc);
        I(e, si)              <+ devsign * ddt(qb_acc);
    end
    
    // External S/D Resistance
    if(RDSMOD == 2) begin
        V(d, di) <+ 0.0 ;
        V(s, si) <+ 0.0 ;
    end else begin
        I(d, di)  <+  V(d, di) / Rdrain; 
        I(s, si)  <+  V(s, si) / Rsource; 

    end
    
    // NQSMOD1 Gate Resistance Model
    `ifdef __NQSMOD1__
        if(NQSMOD == 1 && XRCRG1_i != 0)
            I(`GateEdgeNode, gi) <+  V(`GateEdgeNode, gi) * gcrg;
        else
            V(`GateEdgeNode, gi) <+  0;
    `endif
    
    // NQSMOD2 BSIM4 Charge Deficit Model
    `ifdef __NQSMOD2__
        if(NQSMOD ==2) begin
            I(q) <+  ddt(qg - qb);
            I(q) <+  V(q) * gtau;
            I(q) <+  ddt(V(q));
        end else
            V(q) <+  0;
    `endif
    
    // Gate Electrode Resistance
    `ifdef __RGATEMOD__
        if(RGATEMOD != 0)
            I(g, ge) <+  V(g, ge) * ggeltd;
        else
            V(g, ge) <+  0;
    `endif
    
    // Flicker Noise
    I(di,si) <+  flicker_noise(FNPowerAt1Hz, EF, "flicker");
    
    // Thermal noise for parasitics
    //////////////////// Thermal Noise //////////////////////
    if (RDSMOD != 2) begin
        if(TNOIMOD == 1) begin
            T1 = max(ids, 1.0e-9);
            if(sigvds >= 0) begin
                I(s, si) <+ white_noise(4 * Vtm * `q * gspr * (1.0 + gspr * theta_tnoi * theta_tnoi * Vdseff / T1), "thermal");
                I(d, di) <+ white_noise(4 * Vtm * `q * gdpr, "thermal");
            end else begin 
                I(d, di) <+ white_noise(4 * Vtm * `q * gdpr * (1.0 + gdpr * theta_tnoi * theta_tnoi * Vdseff / T1), "thermal");
                I(s, si) <+ white_noise(4 * Vtm * `q * gspr, "thermal");
            end
        end else begin
            I(d, di) <+ white_noise(4 * Vtm * `q * gdpr, "thermal");
            I(s, si) <+ white_noise(4 * Vtm * `q * gspr, "thermal");
        end
    end
    //////////////////// Thermal Noise Ends //////////////////////
    `ifdef __RGATEMOD__
        if(RGATEMOD != 0)
            I(g, ge) <+  white_noise(4 * Vtm * `q * ggeltd, "thermal");
    `endif
    
    // Channel thermal noise and induced gate noise stamping
    //    Implementation of correlated noise follows C. C. McAndrew, WCM 2005
    if (TNOIMOD !=2)
        I(di, si) <+ white_noise(sid, "thermal");
    else begin
        `ifdef __TNOIMOD2__
            I(di,si) <+  white_noise(sid*abs(1.0-ctnoi * ctnoi), "thermal");
            I(N)     <+  V(N) * sf * SCALEN; 
            I(N)     <+  white_noise(sid/(sf*sf*SCALEN*SCALEN));
            I(di,si) <+  ctnoi * V(N)*sf*SCALEN ;
            I(`IntrinsicGate,si) <+  ddt(0.5 * C0 * SCALEN * V(N));
            I(`IntrinsicGate,di) <+  ddt(0.5 * C0 * SCALEN * V(N));
        `else
            $strobe("[Warning!] Although the model selector TNOIMOD is set to 2, the new correlated thermal noise model is not activated. Please uncomment \"`define __TNOIMOD2__\" in in the bsimcmg_main.va.");
        `endif
    end
    // Gate current shot noise
    if(IGCMOD != 0) begin
        if(sigvds > 0) begin
            I(`IntrinsicGate, si)  <+  white_noise(2 * `q * abs(igcs + igs), "shot");
            I(`IntrinsicGate, di)  <+  white_noise(2 * `q * abs(igcd + igd), "shot");
        end else begin
            I(`IntrinsicGate, di)  <+  white_noise(2 * `q * abs(igcs + igs), "shot");
            I(`IntrinsicGate, si)  <+  white_noise(2 * `q * abs(igcd + igd), "shot");
        end
    end
    if(IGBMOD != 0) begin
        if(BULKMOD != 0) begin
            I(`IntrinsicGate, e)   <+  white_noise(2 * `q * abs(igbinv + igbacc), "shot");
        end else begin
            I(`IntrinsicGate, si)  <+  white_noise(2 * `q * abs(igbs), "shot");
            I(`IntrinsicGate, di)  <+  white_noise(2 * `q * abs(igbd), "shot");
        end
    end
            
    // Self Heating
    `ifdef __SHMOD__
        `ifdef __NQSMOD3__
            if(GEOMOD !=3 && COREMOD !=0) begin  //case not supported for NQSMOD=3
                if (SHMOD != 0 && RTH0 > 0) begin
                    if (RDSMOD != 2) begin
                    Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
                    end else begin
                    Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids );
                    end
                end
                Pwr(rth_branch) <+  Temp(rth_branch) * gth;
                Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
            end else begin
                if(NQSMOD==3) begin
                    if (SHMOD != 0 && RTH0 > 0) begin
                        if (RDSMOD != 2) begin
                        Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
                        end else begin
                        Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids );
                        end
                    end
                    Pwr(rth_branch) <+  Temp(rth_branch) * gth;
                    Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
                end else begin
                    if (SHMOD != 0 && RTH0 > 0) begin
                        if (RDSMOD != 2) begin
                        Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
                        end else begin
                        Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids );
                        end
                    end
                    Pwr(rth_branch) <+  Temp(rth_branch) * gth;
                    Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
                end
            end
        `else
            if(SHMOD != 0 && RTH0 > 0) begin
                        if (RDSMOD != 2) begin
                        Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
                        end else begin
                        Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids );
                        end
            end
                Pwr(rth_branch) <+  Temp(rth_branch) * gth;
                Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
        `endif
    `endif

    
    // Operating-Point information
    `ifdef __OPINFO__
        //W & L
        WEFF    =  Weff;                              // Effective width for IV
        LEFF    =  Leff;                              // Effective length for IV
        WEFFCV    =  WeffCV;                            // Effective width for CV
        LEFFCV    =  LeffCV;                            // Effective length for CV

        // Currents
        IDS    =  devsign * ids;                      // Intrinsic Drain Current (Electrical)
        if(sigvds > 0) begin                          // Total Source/Drain Currents (Physical)
            if(BULKMOD != 0) begin
                IDEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl) - devsign * Ied;
                ISEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * (igisl) - devsign * Ies; 
            end else begin
                IDEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd + igbd) + devsign * (Iii + igidl - igisl);    
                ISEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs + igbs) + devsign* (igisl - igidl);
            end
        end else begin
            if(BULKMOD != 0) begin
                IDEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * (igisl) - devsign * Ied;
                ISEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl) -  devsign * Ies;
            end else begin
                IDEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs + igbd) + devsign * (igisl - igidl);
                ISEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd + igbs) + devsign * (Iii + igidl - igisl);
            end
        end

        if(BULKMOD == 0) begin                        // Total Gate Current
            IGTOT  =  devsign * (igs + igd + igcs + igcd + igbs + igbd);
        end else begin
            IGTOT  =  devsign * (igs + igd + igcs + igcd + igbacc + igbinv);
        end

        IDSGEN =  sigvds * devsign * idsgen;          // Generation-Recombination Current (Physical)
        III    =  devsign * Iii;                      // Impact Ionization Current
        if(sigvds > 0) begin
            IGIDL  =  devsign * igidl;                    // GIDL Current (Physical)
            IGISL  =  devsign * igisl;                    // GISL Current (Physical)
        end else begin
            IGIDL  =  devsign * igisl;                    // GIDL Current (Physical)
            IGISL  =  devsign * igidl;                    // GISL Current (Physical)
        end

        if(BULKMOD != 0) begin
            IJSB   =  - devsign * Ies;                // Source-Body Junction Current (Physical)
            IJDB   =  - devsign * Ied;                // Drain-Body Junction Current (Physical)
        end    else begin
            IJSB   =  0.0;
            IJDB   =  0.0;
        end
            

        if(BULKMOD != 0) begin
            ISUB   =  - III - IGIDL - IGISL - IJSB - IJDB - devsign*(igbinv + igbacc);                // Substrate Current
        end else begin
            ISUB   =  0.0;
        end
        
        // Misc Variables
        BETA   =  beta;                               // Drain Current prefactor per fin per finger
        VDSSAT =  Vdsat;                              // Drain-Source saturation Voltage
        if(NGATE_i > 0)                               // Flatband Voltage
            VFB  =  - devsign * (phib + Vtm*lln(NGATE_i/ni));
        else
            VFB  =  PHIG_i - (EASUB + 0.5*Eg + devsign * phib);

        // Threshold Voltage Calculation
        
        if(GEOMOD != 3) begin
            q0      =  (5.0 * Vtm * (epssub/TFIN) + 2.0 * Qbul) / cox;
            T1        =  Vtm * (Vtm + q0);
            T2        =  cox * cox * T1;
              T3        =  2.0 * `q * ni * epssub * Vtm;
            VTH     =  VFB + devsign*(Vtm * lln(T2/T3) + dvch_qm + phib + qbs + Vtm + dvth_all - DELVTRAND);
            
        end else begin
            T1     =  Vtm * r1 / cdop;
            qith   =  sqrt(T1*T1 + 2.0 * T1 * Vtm) - T1;    //Charge in channel at half of (Gm/Id)_max
            g0     =  qith / q0;
            F0     =  0.5 * lln(g0) + 0.5 * lln(1.0 + cdop * g0) + r1 * g0 + r2 * g0 * g0;
            VTH    =  2.0 * Vtm * F0 + vt0 * Vtm/nVtm + deltaPhi - 0.5 * Eg - phib + dvth_all + dvch_qm - DELVTRAND;
        end
        

        // Conductances
        GM     =  ddx(IDS,V(`IntrinsicGate));         // Transconductance
        GDS    =  ddx(IDS,V(di));                     // Output conductance
        if(BULKMOD != 0)
            GMBS   =  ddx(IDS,V(e));                  // Body transconductance
        else   
            GMBS   =  0.0;

        // Intrinsic Charges (Physical) (Sriram: Not accurate for NQSMOD= 2 and 3)
        `ifdef __NQSMOD3__
            if(GEOMOD !=3 && COREMOD !=0) begin
                QGI =  devsign * qg + (CAPMOD == 1 ? devsign * qg_acc : 0);
                QDI =  devsign * qd;
                QSI =  devsign * qs;
            end else begin
                if(NQSMOD == 3) begin
                    qg  =  qg1 + qg2 + qg3 + qg4 + qg5 + qg6 + qg7 + qg8 + qg9 + qg10;
                    QGI =  devsign * (qg - qb) + (CAPMOD == 1 ? devsign * qg_acc : 0);
                    QDI =  0.0;  // Yet to do - Drain charge 
                    QSI =  0.0;  // Yet to do - Source charge
                end else begin
                    QGI =  devsign * qg + (CAPMOD == 1 ? devsign * qg_acc : 0);
                    QDI =  devsign * qd;
                    QSI =  devsign * qs;
                end
            end
        `else
            QGI =  devsign * qg + (CAPMOD == 1 ? devsign * qg_acc : 0);
            QDI =  devsign * qd;
            QSI =  devsign * qs;
        `endif

        QBI =  devsign * (qb + (CAPMOD == 1 ? qb_acc : 0));

        // Total Charges (Sriram: Not accurate for NQSMOD= 2 and 3)
        `ifdef __NQSMOD3__
            if(GEOMOD !=3 && COREMOD !=0) begin  //Case not supported for NQSMOD=3
                QG =  devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
                         + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
                QD =  devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0) - devsign * Qed + qds_fr;
                QS =  devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0) - devsign * Qes - qds_fr;
            end else begin
                if(NQSMOD == 3) begin
                    qg =  qg1 + qg2 + qg3 + qg4 + qg5 + qg6 + qg7 + qg8 + qg9 + qg10;
                    QG =  devsign * (qg - qb) + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
                             + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
                    QD =  0.0;  // Yet to do - Drain charge 
                    QS =  0.0;  // Yet to do - Source charge
                end else begin
                    QG =  devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
                             + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
                    QD =  devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0) - devsign * Qed;
                    QS =  devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0) - devsign * Qes;
                end
            end
        `else
            QG =  devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
                     + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
            QD =  devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0) - devsign * Qed;
            QS =  devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0) - devsign * Qes;
        `endif

        QB =  devsign * (qb + (CAPMOD == 1 ? qb_acc : 0)) + devsign * (Qeg + Qes + Qed);

        // Intrinsic Capacitances (Physical)
        CGGI  =  ddx(QGI, V(`IntrinsicGate));
        CGSI  =  - ddx(QGI, V(si));
        CGDI  =  - ddx(QGI, V(di));
        CGEI  =  - ddx(QGI, V(e));                    

        CSGI  =  - ddx(QSI, V(`IntrinsicGate));
        CSDI  =  - ddx(QSI, V(di));
        CSSI  =  ddx(QSI, V(si));
        CSEI  =  - ddx(QSI, V(e));                    // Should be zero everywhere

        CDGI  =  - ddx(QDI, V(`IntrinsicGate));
        CDDI  =  ddx(QDI, V(di));
        CDSI  =  - ddx(QDI, V(si));
        CDEI  =  - ddx(QDI, V(e));

        CEGI  =  - ddx(QBI, V(`IntrinsicGate));       
        CEDI  =  - ddx(QBI, V(di));                   // Should be zero everywhere
        CESI  =  - ddx(QBI, V(si));                   // Should be zero everywhere
        CEEI  =  ddx(QBI, V(e));

        // Total Capacitances
        CGG  =  ddx(QG, V(`IntrinsicGate));
        CGS  =  - ddx(QG, V(si));
        CGD  =  - ddx(QG, V(di));
        CGE  =  - ddx(QG, V(e));

        CSG  =  - ddx(QS, V(`IntrinsicGate));
        CSD  =  - ddx(QS, V(di));
        CSS  =  ddx(QS, V(si));
        CSE  =  - ddx(QS, V(e));

        CDG  =  - ddx(QD, V(`IntrinsicGate));
        CDD  =  ddx(QD, V(di));
        CDS  =  - ddx(QD, V(si));
        CDE  =  - ddx(QD, V(e));

        CEG  =  - ddx(QB, V(`IntrinsicGate));
        CED  =  - ddx(QB, V(di));
        CES  =  - ddx(QB, V(si));
        CEE  =  ddx(QB, V(e));

        //Total extrinsic capacitance
        CGSEXT     =  - ddx(qgs_parasitic + (CGEOMOD == 1 ? qgs_fr : 0),V(si));  //Gate-Source Overlap + outer fringing 
        CGDEXT     =  - ddx(qgd_parasitic + (CGEOMOD == 1 ? qgd_fr : 0),V(di));  //Gate-Drain Overlap + outer fringing 
        CGBOV    =  - devsign * ddx(Qeg,V(e));                     //Gate-Body Overlap

        // Total of Junction Capacitance and Source/Drain-Body Overlap Capacitance
        CJST    =  - devsign * ddx(Qes, V(si));
        CJDT    =  - devsign * ddx(Qed, V(di));

        RSGEO  =  RSourceGeo;                                                 // External bias independent Source Resistance
        RDGEO  =  RDrainGeo;                                                  // External bias independent Drain Resistance
        CFGEO  =  Cfr_geo;                                                    //Geometric Parasitic Cap for CGEOMOD=1
        TDEVICE = DevTemp ;
        
        `ifdef __DEBUG__
            // Individual Gate Current Components
            IGS    =  devsign * igs;
            IGD    =  devsign * igd;
            IGCS   =  devsign * igcs;
            IGCD   =  devsign * igcd;
            if(BULKMOD == 0) begin
                IGBS   =  devsign * igbs;
                IGBD   =  devsign * igbd;
            end else begin
                IGBINV =  devsign * igbinv;
                IGBACC =  devsign * igbacc;
            end

            DIDSDVG  =  devsign * sigvds * ddx(ids, V(`IntrinsicGate));
            DIDSDVS  =  devsign * sigvds * ddx(ids, V(si));
            DIDSDVD  =  devsign * sigvds * ddx(ids, V(di));
            `ifdef __SHMOD__
                DIDSDVTH =  devsign * sigvds * ddx(ids, Temp(rth_branch));
            `endif
            DIGSDVG  =  devsign * ddx(igs + igcs, V(`IntrinsicGate));
            DIGSDVS  =  devsign * ddx(igs + igcs, V(si));
            DIGSDVD  =  devsign * ddx(igs + igcs, V(di));
            `ifdef __SHMOD__
                DIGSDVTH =  devsign * ddx(igs + igcs, Temp(rth_branch));
            `endif
            DIGDDVG  =  devsign * ddx(igd + igcd, V(`IntrinsicGate));
            DIGDDVS  =  devsign * ddx(igd + igcd, V(si));
            DIGDDVD  =  devsign * ddx(igd + igcd, V(di));
            `ifdef __SHMOD__
                DIGDDVTH =  devsign * ddx(igd + igcd, Temp(rth_branch));
            `endif
            DIIIDVG  =  devsign * ddx(Iii, V(`IntrinsicGate));
            DIIIDVS  =  devsign * ddx(Iii, V(si));
            DIIIDVD  =  devsign * ddx(Iii, V(di));
            `ifdef __SHMOD__
                DIIIDVTH =  devsign * ddx(Iii, Temp(rth_branch));
            `endif
            DIGIDLDVG  =  devsign * ddx(igidl, V(`IntrinsicGate));
            DIGIDLDVS  =  devsign * ddx(igidl, V(si));
            DIGIDLDVD  =  devsign * ddx(igidl, V(di));
            `ifdef __SHMOD__
                DIGIDLDVTH =  devsign * ddx(igidl, Temp(rth_branch));
            `endif
            DIGISLDVG  =  devsign * ddx(igisl, V(`IntrinsicGate));
            DIGISLDVS  =  devsign * ddx(igisl, V(si));
            DIGISLDVD  =  devsign * ddx(igisl, V(di));
            `ifdef __SHMOD__
                DIGISLDVTH =  devsign * ddx(igisl, Temp(rth_branch));
            `endif

            `ifdef __SHMOD__
                CGT  =  ddx(QG, Temp(rth_branch));
                CST  =  ddx(QS, Temp(rth_branch));
                CDT  =  ddx(QD, Temp(rth_branch));
            `endif
            ITH  =  ids*vds;
            `ifdef __SHMOD__
                DITHDVTH =  ddx(ITH, Temp(rth_branch));
            `endif    
            DITHDVG  =  ddx(ITH, V(`IntrinsicGate));
            DITHDVS  =  ddx(ITH, V(si));
            DITHDVD  =  ddx(ITH, V(di));
        `endif // __DEBUG__
    `endif // __OPINFO__
end //           analog block ends
//================================================
