// ****************************************************************************
// *  BSIM-CMG 111.2.1 released on 06/06/2022                                 *
// *  BSIM Common Multi-Gate Model (Verilog-A)                                *
// ****************************************************************************

// ****************************************************************************
// *  Copyright Â© 2022 University of California                               *
// *                                                                          *
// *  Project director: Prof. Chenming Hu                                     *
// *                                                                          *
// *  Current developers: Girish Pahwa (Assistant Researcher)                 *
// *                      Dinesh Rajasekharan (Postdoc)                       *
// *                      Chetan Kumar Dabhi (Postdoc)                        *
// *                      Chien-Ting Tung (Ph.D. student)                     *
// ****************************************************************************

// ln(1 + exp(x)) function
analog function real ln_one_plus_exp;
    input x; real x;
    begin
        if (x > 37) begin
            ln_one_plus_exp = x;
        end else if (x < -37) begin
            ln_one_plus_exp = exp(x);
        end else begin
            ln_one_plus_exp = ln(1.0 + exp(x));
        end
    end
endfunction

analog begin

`ifdef insideADMS
   @(initial_instance)
   begin : initial_instance
`else
   begin : CMGBiasIndepCalc
`endif //insideADMS 
    // Bias-independent calculations
    // Initialize variables for periodic steady state analysis
    `include "bsimcmg_initialization.include"

    gmin=$simparam("gmin",0);

    if ($port_connected(t) == 1) begin
        if ((SHMOD == 0 || RTH0 == 0.0) && SH_WARN == 1) begin
            $strobe("The optional 5th terminal is present in instance %m but not active because SHMOD = 0 or RTH0 = 0.0");
        end
    end

    // N or p-type
    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    // Constants
    epssub = EPSRSUB * `EPS0;
    epssp = EPSRSP * `EPS0;
    cbox = EPSROX * `EPS0 / EOTBOX;
    epsratio = EPSRSUB / EPSROX;

    // Constants for quantum mechanical effects
    mx = 0.916 * `MEL;
    mxprime = 0.190 * `MEL;
    md = 0.190 * `MEL;
    mdprime = 0.417 * `MEL;
    gprime = 4.0;
    gfactor = 2.0;

    XL_i    = XL + 1.0e-6 * LXL / L + NXL / NFIN  + PXL * 1.0e-6 / (L * NFIN);
    DLBIN_i = DLBIN + 1.0e-6 * LDLBIN / L + NDLBIN / NFIN  + PDLBIN * 1.0e-6 / (L * NFIN);
    LINT_i  = LINT + 1.0e-6 * LLINT / L + NLINT / NFIN  + PLINT * 1.0e-6 / (L * NFIN);

    // Effective channel length for I-V and C-V
    Lg = L + XL_i;
    T0 = pow(Lg, -LLN);
    deltaL = LINT_i + LL * T0;
    deltaL1 = LINT_i + LL * pow((Lg + DLBIN_i), -LLN);
    deltaLCV = DLC + LLC * T0;
    Leff = Lg - 2.0 * deltaL;
    Leff1 = Lg + DLBIN_i - 2.0 * deltaL1;
    LeffCV = Lg - 2.0 * deltaLCV;
    LeffCV_acc = LeffCV - DLCACC;

    // Effective GAA channel width for I-V and C-V
    if (GEOMOD == 5) begin
        XW_i = XW + 1.0e-6 * LXW / L + NXW / NFIN  + PXW * 1.0e-6 / (L * NFIN) + 1.0e-6 * WXW / WGAA + P2XW * 1.0e-12 / (L * WGAA);
        DWBIN_i = DWBIN + 1.0e-6 * LDWBIN / L + NDWBIN / NFIN  + PDWBIN * 1.0e-6 / (L * NFIN) +  1.0e-6 * WDWBIN / WGAA + P2DWBIN * 1.0e-12 / (L * WGAA);
        WGAAeff = WGAA + XW_i;
        WGAAeff1 = WGAAeff + DWBIN_i;
    end else begin
        XW_i = 0;
        DWBIN_i = 0;
        WGAAeff = WGAA;
        WGAAeff1 = WGAA;
    end

    // Total Fins
    NFINtotal = NFIN * NF;

    // Binning
    Inv_L = 1.0e-6 / Leff1;
    Inv_NFIN = 1.0 / NFIN;
    Inv_LNFIN = 1.0e-6 / (Leff1 * NFIN);
    if (GEOMOD == 5) begin
        Inv_W = 1.0e-6 / WGAAeff1;
        Inv_WL = 1.0e-12 / (WGAAeff1 * Leff1);
    end else begin
        Inv_W = 0.0;
        Inv_WL = 0.0;
    end

    // Nbody binning equation
    `binning(NBODY_i, NBODY, LNBODY, NNBODY, PNBODY, 0.0, 0.0)
    if (NBODYN1 != 0.0) begin
        NBODY_i = NBODY_i * (1.0 + NBODYN1 / NFIN * `lln(1.0 + NFIN / NBODYN2));
    end

    // Unified FinFET compact model
    case (GEOMOD)
        // Double gate
        0: begin
            if (TFIN_TOP == 0.0 || TFIN_BASE == 0.0) begin
                Weff_UFCM = 2.0 * HFIN;
                Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
                Ach = HFIN * TFIN;
            end else begin
                Weff_UFCM = 2.0 * sqrt(HFIN * HFIN + (TFIN_TOP - TFIN_BASE) * (TFIN_TOP - TFIN_BASE) / 4.0);
                Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
                Ach = HFIN * (TFIN_TOP + TFIN_BASE) / 2.0;
            end
        end
        // Triple gate
        1: begin
            if (TFIN_TOP == 0.0 || TFIN_BASE == 0.0) begin
                Weff_UFCM = 2.0 * HFIN + TFIN;
                Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
                Ach = HFIN * TFIN;
            end else begin
                Weff_UFCM = 2.0 * sqrt(HFIN * HFIN + (TFIN_TOP - TFIN_BASE) * (TFIN_TOP - TFIN_BASE) / 4.0) + TFIN_TOP;
                Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
                Ach = HFIN * (TFIN_TOP + TFIN_BASE) / 2.0;
            end
        end
        // Quadruple gate
        2: begin
            if (TFIN_TOP == 0.0 || TFIN_BASE == 0.0) begin
                Weff_UFCM = 2.0 * HFIN + 2.0 * TFIN;
                Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
                Ach = HFIN * TFIN;
            end else begin
                Weff_UFCM = 2.0 * sqrt(HFIN * HFIN + (TFIN_TOP - TFIN_BASE) * (TFIN_TOP - TFIN_BASE) / 4.0) + TFIN_TOP + TFIN_BASE;
                Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
                Ach = HFIN * (TFIN_TOP + TFIN_BASE) / 2.0;
            end
            WeffB = TFIN_BASE;
        end
        // Cylindrical gate
        3: begin
            Weff_UFCM = `M_PI * D;
            Cins = 2.0 * `M_PI * EPSROX * `EPS0 / `lln(1.0 + 2.0 * EOT / D);
            Ach = `M_PI * D * D / 4.0;
            WeffB = D;
        end
        // Unified model
        4: begin
            Weff_UFCM = W_UFCM;
            Cins = CINS_UFCM;
            Ach = ACH_UFCM;
        end
        // Gate-All-Around FET model
        5: begin
            Weff1 = 2 * (WGAAeff + TGAA) + DWS1;
            Ach1 = WGAAeff * TGAA + DACH1;
            Weff_UFCM = Weff1;
            Ach = Ach1;
            if (NGAA > 1) begin
                Weff2 = 2 * (WGAAeff + TGAA) + DWS2;
                Ach2 = WGAAeff * TGAA + DACH2;
                Weff_UFCM = Weff1 + Weff2;
                Ach = Ach1 + Ach2;
            end
            if (NGAA > 2) begin
                Weff3 = 2 * (WGAAeff + TGAA) + DWS3;
                Ach3 = WGAAeff * TGAA + DACH3;
                Weff_UFCM = Weff1 + Weff2 + Weff3;
                Ach = Ach1 + Ach2 + Ach3;
            end
            if (NGAA > 3) begin
                Weff4 = 2 * (WGAAeff + TGAA) + DWS4;
                Ach4 = WGAAeff * TGAA + DACH4;
                Weff_UFCM = Weff1 + Weff2 + Weff3 + Weff4;
                Ach = Ach1 + Ach2 + Ach3 + Ach4;
            end
            if (NGAA > 4) begin
                Weff5 = 2 * (WGAAeff + TGAA) + DWS5;
                Ach5 = WGAAeff * TGAA + DACH5;
                Weff_UFCM = Weff1 + Weff2 + Weff3 + Weff4 + Weff5;
                Ach = Ach1 + Ach2 + Ach3 + Ach4 + Ach5;
            end
            if (NGAA > 5) begin
                Weff6 = 2 * (WGAAeff + TGAA) + DWS6;
                Ach6 = WGAAeff * TGAA + DACH6;
                Weff_UFCM = Weff1 + Weff2 + Weff3 + Weff4 + Weff5 + Weff6;
                Ach = Ach1 + Ach2 + Ach3 + Ach4 + Ach5 + Ach6;
            end
            WeffB = WGAA;
            Cins = Weff_UFCM * EPSROX * `EPS0 / EOT;
        end
    endcase
    rc = 2.0 * Cins / (Weff_UFCM * Weff_UFCM * epssub / Ach);
    Qdep_ov_Cins = -`q * NBODY_i * Ach / Cins;

    // Cox definition
    cox = Cins / Weff_UFCM;
    if (BULKMOD != 0) begin
        cox_acc = cox * EOT / EOTACC;
    end

    // Effective width calculation
    Weff0 = Weff_UFCM - DELTAW;
    WeffCV0 = Weff_UFCM - DELTAWCV;
    if (GEOMOD == 5) begin
        WeffCV_acc = Weff0 - 2 * NGAA * DWCACC;
    end else begin
        WeffCV_acc = Weff0;
    end

    // Binning equations
    `binning(PHIG_i, PHIG, LPHIG, NPHIG, PPHIG, WPHIG, P2PHIG)
    `binning(NGATE_i, NGATE, LNGATE, NNGATE, PNGATE, WNGATE, P2NGATE)
    `binning(CIT_i, CIT, LCIT, NCIT, PCIT, WCIT, P2CIT)
    `binning(CDSC_i, CDSC, LCDSC, NCDSC, PCDSC, WCDSC, P2CDSC)
    `binning(CDSCD_i, CDSCD, LCDSCD, NCDSCD, PCDSCD, WCDSCD, P2CDSCD)
    `binning(DVT0_i, DVT0, LDVT0, NDVT0, PDVT0, WDVT0, P2DVT0)
    `binning(DVT1_i, DVT1, LDVT1, NDVT1, PDVT1, WDVT1, P2DVT1)
    `binning(DVT1SS_i, DVT1SS, LDVT1SS, NDVT1SS, PDVT1SS, WDVT1SS, P2DVT1SS)
    `binning(PHIN_i, PHIN, LPHIN, NPHIN, PPHIN, WPHIN, P2PHIN)
    `binning(ETA0_i, ETA0, LETA0, NETA0, PETA0, WETA0, P2ETA0)
    `binning(DSUB_i, DSUB, LDSUB, NDSUB, PDSUB, WDSUB, P2DSUB)
    `binning(K1RSCE_i, K1RSCE, LK1RSCE, NK1RSCE, PK1RSCE, WK1RSCE, P2K1RSCE)
    `binning(LPE0_i, LPE0, LLPE0, NLPE0, PLPE0, WLPE0, P2LPE0)
    `binning(DVTSHIFT_i, DVTSHIFT, LDVTSHIFT, NDVTSHIFT, PDVTSHIFT, WDVTSHIFT, P2DVTSHIFT)
    `binning(K0_i, K0, LK0, NK0, PK0, WK0, P2K0)
    `binning(K01_i, K01, LK01, NK01, PK01, WK01, P2K01)
    `binning(K0SI_i, K0SI, LK0SI, NK0SI, PK0SI, WK0SI, P2K0SI)
    `binning(K0SI1_i, K0SI1, LK0SI1, NK0SI1, PK0SI1, WK0SI1, P2K0SI1)
    `binning(K2SI_i, K2SI, LK2SI, NK2SI, PK2SI, WK2SI, P2K2SI)
    `binning(K2SI1_i, K2SI1, LK2SI1, NK2SI1, PK2SI1, WK2SI1, P2K2SI1)
    `binning(K0SISAT_i, K0SISAT, LK0SISAT, NK0SISAT, PK0SISAT, WK0SISAT, P2K0SISAT)
    `binning(K0SISAT1_i, K0SISAT1, LK0SISAT1, NK0SISAT1, PK0SISAT1, WK0SISAT1, P2K0SISAT1)
    `binning(K2SISAT_i, K2SISAT, LK2SISAT, NK2SISAT, PK2SISAT, WK2SISAT, P2K2SISAT )
    `binning(K2SISAT1_i, K2SISAT1, LK2SISAT1, NK2SISAT1, PK2SISAT1, WK2SISAT1, P2K2SISAT1)
    `binning(QMFACTOR_i, QMFACTOR, LQMFACTOR, NQMFACTOR, PQMFACTOR, WQMFACTOR, P2QMFACTOR)
    `binning(QMTCENCV_i, QMTCENCV, LQMTCENCV, NQMTCENCV, PQMTCENCV, WQMTCENCV, P2QMTCENCV)
    `binning(QMTCENCVA_i, QMTCENCVA, LQMTCENCVA, NQMTCENCVA, PQMTCENCVA, WQMTCENCVA, P2QMTCENCVA)
    `binning(VSAT_i, VSAT, LVSAT, NVSAT, PVSAT, WVSAT, P2VSAT)
    `binning(VSAT1_i, VSAT1, LVSAT1, NVSAT1, PVSAT1, WVSAT1, P2VSAT1)
    `binning(VSATCV_i, VSATCV, LVSATCV, NVSATCV, PVSATCV, WVSATCV, P2VSATCV)
    `binning(DELTAVSAT_i, DELTAVSAT, LDELTAVSAT, NDELTAVSAT, PDELTAVSAT, WDELTAVSAT, P2DELTAVSAT)
    `binning(PSAT_i, PSAT, LPSAT, NPSAT, PPSAT, WPSAT, P2PSAT)
    `binning(DELTAVSATCV_i, DELTAVSATCV, LDELTAVSATCV, NDELTAVSATCV, PDELTAVSATCV, WDELTAVSATCV, P2DELTAVSATCV)
    `binning(PSATCV_i, PSATCV, LPSATCV, NPSATCV, PPSATCV, WPSATCV, P2PSATCV)
    `binning(KSATIV_i, KSATIV, LKSATIV, NKSATIV, PKSATIV, WKSATIV, P2KSATIV)
    `binning(MEXP_i, MEXP, LMEXP, NMEXP, PMEXP, WMEXP, P2MEXP)
    `binning(PTWG_i, PTWG, LPTWG, NPTWG, PPTWG, WPTWG, P2PTWG)
    `binning(U0_i, U0, LU0, NU0, PU0, WU0, P2U0)
    `binning(ETAMOB_i, ETAMOB, LETAMOB, NETAMOB, PETAMOB, WETAMOB, P2ETAMOB)
    `binning(UP_i, UP, LUP, NUP, PUP, WUP, P2UP)
    `binning(UA_i, UA, LUA, NUA, PUA, WUA, P2UA)
    `binning(EU_i, EU, LEU, NEU, PEU, WEU, P2EU)
    `binning(UD_i, UD, LUD, NUD, PUD, WUD, P2UD)
    `binning(UCS_i, UCS, LUCS, NUCS, PUCS, WUCS, P2UCS)
    `binning(UDS_i, UDS, LUDS, NUDS, PUDS, WUDS, P2UDS)
    `binning(UDS1_i, UDS1, LUDS1, NUDS1, PUDS1, WUDS1, P2UDS1)
    `binning(UDD_i, UDD, LUDD, NUDD, PUDD, WUDD, P2UDD)
    `binning(UDD1_i, UDD1, LUDD1, NUDD1, PUDD1, WUDD1, P2UDD1)
    `binning(PCLM_i, PCLM, LPCLM, NPCLM, PPCLM, WPCLM, P2PCLM)
    `binning(PCLMG_i, PCLMG, LPCLMG, NPCLMG, PPCLMG, WPCLMG, P2PCLMG)
    `binning(PCLMCV_i, PCLMCV, LPCLMCV, NPCLMCV, PPCLMCV, WPCLMCV, P2PCLMCV)
    `binning(A1_i, A1, LA1, NA1, PA1, WA1, P2A1)
    `binning(A11_i, A11, LA11, NA11, PA11, WA11, P2A11)
    `binning(A2_i, A2, LA2, NA2, PA2, WA2, P2A2)
    `binning(A21_i, A21, LA21, NA21, PA21, WA21, P2A21)
    `binning(RDSW_i, RDSW, LRDSW, NRDSW, PRDSW, WRDSW, P2RDSW)
    `binning(RSW_i, RSW, LRSW, NRSW, PRSW, WRSW, P2RSW)
    `binning(RDW_i, RDW, LRDW, NRDW, PRDW, WRDW, P2RDW)
    `binning(PRWGD_i, PRWGD, LPRWGD, NPRWGD, PPRWGD, WPRWGD, P2PRWGD)
    `binning(PRWGS_i, PRWGS, LPRWGS, NPRWGS, PPRWGS, WPRWGS, P2PRWGS)
    `binning(WR_i, WR, LWR, NWR, PWR, WWR, P2WR)
    `binning(PDIBL1_i, PDIBL1, LPDIBL1, NPDIBL1, PPDIBL1, WPDIBL1, P2PDIBL1)
    `binning(PDIBL2_i, PDIBL2, LPDIBL2, NPDIBL2, PPDIBL2, WPDIBL2, P2PDIBL2)
    `binning(DROUT_i, DROUT, LDROUT, NDROUT, PDROUT, WDROUT, P2DROUT)
    `binning(PVAG_i, PVAG, LPVAG, NPVAG, PPVAG, WPVAG, P2PVAG)
    `binning(AIGBINV_i, AIGBINV, LAIGBINV, NAIGBINV, PAIGBINV, WAIGBINV, P2AIGBINV)
    `binning(AIGBINV1_i, AIGBINV1, LAIGBINV1, NAIGBINV1, PAIGBINV1, WAIGBINV1, P2AIGBINV1)
    `binning(BIGBINV_i, BIGBINV, LBIGBINV, NBIGBINV, PBIGBINV, WBIGBINV, P2BIGBINV)
    `binning(CIGBINV_i, CIGBINV, LCIGBINV, NCIGBINV, PCIGBINV, WCIGBINV, P2CIGBINV)
    `binning(EIGBINV_i, EIGBINV, LEIGBINV, NEIGBINV, PEIGBINV, WEIGBINV, P2EIGBINV)
    `binning(NIGBINV_i, NIGBINV, LNIGBINV, NNIGBINV, PNIGBINV, WNIGBINV, P2NIGBINV)
    `binning(AIGBACC_i, AIGBACC, LAIGBACC, NAIGBACC, PAIGBACC, WAIGBACC, P2AIGBACC)
    `binning(AIGBACC1_i, AIGBACC1, LAIGBACC1, NAIGBACC1, PAIGBACC1, WAIGBACC1, P2AIGBACC1)
    `binning(BIGBACC_i, BIGBACC, LBIGBACC, NBIGBACC, PBIGBACC, WBIGBACC, P2BIGBACC)
    `binning(CIGBACC_i, CIGBACC, LCIGBACC, NCIGBACC, PCIGBACC, WCIGBACC, P2CIGBACC)
    `binning(NIGBACC_i, NIGBACC, LNIGBACC, NNIGBACC, PNIGBACC, WNIGBACC, P2NIGBACC)
    `binning(AIGC_i, AIGC, LAIGC, NAIGC, PAIGC, WAIGC, P2AIGC)
    `binning(AIGC1_i, AIGC1, LAIGC1, NAIGC1, PAIGC1, WAIGC1, P2AIGC1)
    `binning(BIGC_i, BIGC, LBIGC, NBIGC, PBIGC, WBIGC, P2BIGC)
    `binning(CIGC_i, CIGC, LCIGC, NCIGC, PCIGC, WCIGC, P2CIGC)
    `binning(PIGCD_i, PIGCD, LPIGCD, NPIGCD, PPIGCD, WPIGCD, P2PIGCD)
    `binning(AIGS_i, AIGS, LAIGS, NAIGS, PAIGS, WAIGS, P2AIGS)
    `binning(AIGS1_i, AIGS1, LAIGS1, NAIGS1, PAIGS1, WAIGS1, P2AIGS1)
    `binning(BIGS_i, BIGS, LBIGS, NBIGS, PBIGS, WBIGS, P2BIGS)
    `binning(CIGS_i, CIGS, LCIGS, NCIGS, PCIGS, WCIGS, P2CIGS)
    `binning(AIGD_i, AIGD, LAIGD, NAIGD, PAIGD, WAIGD, P2AIGD)
    `binning(AIGD1_i, AIGD1, LAIGD1, NAIGD1, PAIGD1, WAIGD1, P2AIGD1)
    `binning(BIGD_i, BIGD, LBIGD, NBIGD, PBIGD, WBIGD, P2BIGD)
    `binning(CIGD_i, CIGD, LCIGD, NCIGD, PCIGD, WCIGD, P2CIGD)
    `binning(NTOX_i, NTOX, LNTOX, NNTOX, PNTOX, WNTOX, P2NTOX)
    `binning(POXEDGE_i, POXEDGE, LPOXEDGE, NPOXEDGE, PPOXEDGE, WPOXEDGE, P2POXEDGE)
    `binning(AGIDL_i, AGIDL, LAGIDL, NAGIDL, PAGIDL, WAGIDL, P2AGIDL)
    `binning(BGIDL_i, BGIDL, LBGIDL, NBGIDL, PBGIDL, WBGIDL, P2BGIDL)
    `binning(CGIDL_i, CGIDL, LCGIDL, NCGIDL, PCGIDL, WCGIDL, P2CGIDL)
    `binning(EGIDL_i, EGIDL, LEGIDL, NEGIDL, PEGIDL, WEGIDL, P2EGIDL)
    `binning(PGIDL_i, PGIDL, LPGIDL, NPGIDL, PPGIDL, WPGIDL, P2PGIDL)
    `binning(AGISL_i, AGISL, LAGISL, NAGISL, PAGISL, WAGISL, P2AGISL)
    `binning(BGISL_i, BGISL, LBGISL, NBGISL, PBGISL, WBGISL, P2BGISL)
    `binning(CGISL_i, CGISL, LCGISL, NCGISL, PCGISL, WCGISL, P2CGISL)
    `binning(EGISL_i, EGISL, LEGISL, NEGISL, PEGISL, WEGISL, P2EGISL)
    `binning(PGISL_i, PGISL, LPGISL, NPGISL, PPGISL, WPGISL, P2PGISL)
    `binning(ALPHA0_i, ALPHA0, LALPHA0, NALPHA0, PALPHA0, WALPHA0, P2ALPHA0)
    `binning(ALPHA1_i, ALPHA1, LALPHA1, NALPHA1, PALPHA1, WALPHA1, P2ALPHA1)
    `binning(ALPHAII0_i, ALPHAII0, LALPHAII0, NALPHAII0, PALPHAII0, WALPHAII0, P2ALPHAII0)
    `binning(ALPHAII1_i, ALPHAII1, LALPHAII1, NALPHAII1, PALPHAII1, WALPHAII1, P2ALPHAII1)
    `binning(BETA0_i, BETA0, LBETA0, NBETA0, PBETA0, WBETA0, P2BETA0)
    `binning(BETAII0_i, BETAII0, LBETAII0, NBETAII0, PBETAII0, WBETAII0, P2BETAII0)
    `binning(BETAII1_i, BETAII1, LBETAII1, NBETAII1, PBETAII1, WBETAII1, P2BETAII1)
    `binning(BETAII2_i, BETAII2, LBETAII2, NBETAII2, PBETAII2, WBETAII2, P2BETAII2)
    `binning(ESATII_i, ESATII, LESATII, NESATII, PESATII, WESATII, P2ESATII)
    `binning(LII_i, LII, LLII, NLII, PLII, WLII, P2LII)
    `binning(SII0_i, SII0, LSII0, NSII0, PSII0, WSII0, P2SII0)
    `binning(SII1_i, SII1, LSII1, NSII1, PSII1, WSII1, P2SII1)
    `binning(SII2_i, SII2, LSII2, NSII2, PSII2, WSII2, P2SII2)
    `binning(SIID_i, SIID, LSIID, NSIID, PSIID, WSIID, P2SIID)
    `binning(TII_i, TII, LTII, NTII, PTII, WTII, P2TII)
    `binning(CFS_i, CFS, LCFS, NCFS, PCFS, WCFS, P2CFS)
    `binning(CFD_i, CFD, LCFD, NCFD, PCFD, WCFD, P2CFD)
    `binning(COVS_i, COVS, LCOVS, NCOVS, PCOVS, WCOVS, P2COVS)
    `binning(COVD_i, COVD, LCOVD, NCOVD, PCOVD, WCOVD, P2COVD)
    `binning(CGSL_i, CGSL, LCGSL, NCGSL, PCGSL, WCGSL, P2CGSL)
    `binning(CGDL_i, CGDL, LCGDL, NCGDL, PCGDL, WCGDL, P2CGDL)
    `binning(CGBL_i, CGBL, LCGBL, NCGBL, PCGBL, WCGBL, P2CGBL)
    `binning(CKAPPAS_i, CKAPPAS, LCKAPPAS, NCKAPPAS, PCKAPPAS, WCKAPPAS, P2CKAPPAS)
    `binning(CKAPPAD_i, CKAPPAD, LCKAPPAD, NCKAPPAD, PCKAPPAD, WCKAPPAD, P2CKAPPAD)
    `binning(CKAPPAB_i, CKAPPAB, LCKAPPAB, NCKAPPAB, PCKAPPAB, WCKAPPAB, P2CKAPPAB)
    `binning(NTGEN_i, NTGEN, LNTGEN, NNTGEN, PNTGEN, WNTGEN, P2NTGEN)
    `binning(AIGEN_i, AIGEN, LAIGEN, NAIGEN, PAIGEN, WAIGEN, P2AIGEN)
    `binning(BIGEN_i, BIGEN, LBIGEN, NBIGEN, PBIGEN, WBIGEN, P2BIGEN)
    `binning(UTE_i, UTE, LUTE, NUTE, PUTE, WUTE, P2UTE)
    `binning(UTE1_i, UTE1, LUTE1, NUTE1, PUTE1, WUTE1, P2UTE1)
    `binning(UTL_i, UTL, LUTL, NUTL, PUTL, WUTL, P2UTL)
    `binning(EMOBT_i, EMOBT, LEMOBT, NEMOBT, PEMOBT, WEMOBT, P2EMOBT)
    `binning(UA1_i, UA1, LUA1, NUA1, PUA1, WUA1, P2UA1)
    `binning(UA2_i, UA2, LUA2, NUA2, PUA2, WUA2, P2UA2)
    `binning(EU1_i, EU1, LEU1, NEU1, PEU1, WEU1, P2EU1)
    `binning(UD1_i, UD1, LUD1, NUD1, PUD1, WUD1, P2UD1)
    `binning(UD2_i, UD2, LUD2, NUD2, PUD2, WUD2, P2UD2)
    `binning(UCSTE_i, UCSTE, LUCSTE, NUCSTE, PUCSTE, WUCSTE, P2UCSTE)
    `binning(UCSTE1_i, UCSTE1, LUCSTE1, NUCSTE1, PUCSTE1, WUCSTE1, P2UCSTE1)
    `binning(PTWGT_i, PTWGT, LPTWGT, NPTWGT, PPTWGT, WPTWGT, P2PTWGT)
    `binning(AT_i, AT, LAT, NAT, PAT, WAT, P2AT)
    `binning(ATCV_i, ATCV, LATCV, NATCV, PATCV, WATCV, P2ATCV)
    `binning(PRT_i, PRT, LPRT, NPRT, PPRT, WPRT, P2PRT)
    `binning(PRT1_i, PRT1, LPRT1, NPRT1, PPRT1, WPRT1, P2PRT1)
    `binning(TR0_i, TR0, LTR0, NTR0, PTR0, WTR0, P2TR0)
    `binning(SPRT_i, SPRT, LSPRT, NSPRT, PSPRT, WSPRT, P2SPRT)
    `binning(KT1_i, KT1, LKT1, NKT1, PKT1, WKT1, P2KT1)
    `binning(TSS_i, TSS, LTSS, NTSS, PTSS, WTSS, P2TSS)
    `binning(IIT_i, IIT, LIIT, NIIT, PIIT, WIIT, P2IIT)
    `binning(TGIDL_i, TGIDL, LTGIDL, NTGIDL, PTGIDL, WTGIDL, P2TGIDL)
    `binning(IGT_i, IGT, LIGT, NIGT, PIGT, WIGT, P2IGT)
    `binning(DVTP0_i, DVTP0, LDVTP0, NDVTP0, PDVTP0, WDVTP0, P2DVTP0)
    `binning(DVTP1_i, DVTP1, LDVTP1, NDVTP1, PDVTP1, WDVTP1, P2DVTP1)
    `binning(NOIA2_i, NOIA2, LNOIA2, NNOIA2, PNOIA2, WNOIA2, P2NOIA2)
    `binning(QSREF_i, QSREF, LQSREF, NQSREF, PQSREF, WQSREF, P2QSREF)
    `binning(MPOWER_i, MPOWER, LMPOWER, NMPOWER, PMPOWER, WMPOWER, P2MPOWER)
    if (BULKMOD != 0) begin
        `binning(PHIBE_i, PHIBE, LPHIBE, NPHIBE, PPHIBE, WPHIBE, P2PHIBE)
        `binning(K1_i, K1, LK1, NK1, PK1, WK1, P2K1)
        `binning(K11_i, K11, LK11, NK11, PK11, WK11, P2K11)
        `binning(UC_i, UC, LUC, NUC, PUC, WUC, P2UC)
        `binning(UC1_i, UC1, LUC1, NUC1, PUC1, WUC1, P2UC1)
        if (BULKMOD == 2) begin
            `binning(K2_i, K2, LK2, NK2, PK2, WK2, P2K2)
            `binning(K21_i, K21, LK21, NK21, PK21, WK21, P2K21)
            `binning(K2SAT_i, K2SAT, LK2SAT, NK2SAT, PK2SAT, WK2SAT, P2K2SAT)
            `binning(K2SAT1_i, K2SAT1, LK2SAT1, NK2SAT1, PK2SAT1, WK2SAT1, P2K2SAT1)
        end
        if (GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
            `binning(AGIDLB_i, AGIDLB, LAGIDLB, NAGIDLB, PAGIDLB, WAGIDLB, P2AGIDLB)
            `binning(BGIDLB_i, BGIDLB, LBGIDLB, NBGIDLB, PBGIDLB, WBGIDLB, P2BGIDLB)
            `binning(CGIDLB_i, CGIDLB, LCGIDLB, NCGIDLB, PCGIDLB, WCGIDLB, P2CGIDLB)
            `binning(EGIDLB_i, EGIDLB, LEGIDLB, NEGIDLB, PEGIDLB, WEGIDLB, P2EGIDLB)
            `binning(PGIDLB_i, PGIDLB, LPGIDLB, NPGIDLB, PPGIDLB, WPGIDLB, P2PGIDLB)
            `binning(AGISLB_i, AGISLB, LAGISLB, NAGISLB, PAGISLB, WAGISLB, P2AGISLB)
            `binning(BGISLB_i, BGISLB, LBGISLB, NBGISLB, PBGISLB, WBGISLB, P2BGISLB)
            `binning(CGISLB_i, CGISLB, LCGISLB, NCGISLB, PCGISLB, WCGISLB, P2CGISLB)
            `binning(EGISLB_i, EGISLB, LEGISLB, NEGISLB, PEGISLB, WEGISLB, P2EGISLB)
            `binning(PGISLB_i, PGISLB, LPGISLB, NPGISLB, PPGISLB, WPGISLB, P2PGISLB)
        end
    end
    if (ASYMMOD != 0) begin
        `binning(CDSCDR_i, CDSCDR, LCDSCDR, NCDSCDR, PCDSCDR, WCDSCDR, P2CDSCDR)
        `binning(CITR_i, CITR, LCITR, NCITR, PCITR, WCITR, P2CITR)
        `binning(ETA0R_i, ETA0R, LETA0R, NETA0R, PETA0R, WETA0R, P2ETA0R)
        `binning(VSAT1R_i, VSAT1R, LVSAT1R, NVSAT1R, PVSAT1R, WVSAT1R, P2VSAT1R)
        `binning(MEXPR_i, MEXPR, LMEXPR, NMEXPR, PMEXPR, WMEXPR, P2MEXPR)
        `binning(PTWGR_i, PTWGR, LPTWGR, NPTWGR, PPTWGR, WPTWGR, P2PTWGR)
        `binning(PDIBL1R_i, PDIBL1R, LPDIBL1R, NPDIBL1R, PPDIBL1R, WPDIBL1R, P2PDIBL1R)
        `binning(PDIBL2R_i, PDIBL2R, LPDIBL2R, NPDIBL2R, PPDIBL2R, WPDIBL2R, P2PDIBL2R)
        `binning(PCLMR_i, PCLMR, LPCLMR, NPCLMR, PPCLMR, WPCLMR, P2PCLMR)
        `binning(DVTSHIFTR_i, DVTSHIFTR, LDVTSHIFTR, NDVTSHIFTR, PDVTSHIFTR, WDVTSHIFTR, P2DVTSHIFTR)
        `binning(VSATR_i, VSATR, LVSATR, NVSATR, PVSATR, WVSATR, P2VSATR)
        `binning(KSATIVR_i, KSATIVR, LKSATIVR, NKSATIVR, PKSATIVR, WKSATIVR, P2KSATIVR)
        `binning(U0R_i, U0R, LU0R, NU0R, PU0R, WU0R, P2U0R)
        `binning(UAR_i, UAR, LUAR, NUAR, PUAR, WUAR, P2UAR)
        `binning(UPR_i, UPR, LUPR, NUPR, PUPR, WUPR, P2UPR)
        `binning(EUR_i, EUR, LEUR, NEUR, PEUR, WEUR, P2EUR)
        `binning(UDR_i, UDR, LUDR, NUDR, PUDR, WUDR, P2UDR)
        `binning(UTER_i, UTER, LUTER, NUTER, PUTER, WUTER, P2UTER)
        `binning(UTLR_i, UTLR, LUTLR, NUTLR, PUTLR, WUTLR, P2UTLR)
        `binning(UA1R_i, UA1R, LUA1R, NUA1R, PUA1R, WUA1R, P2UA1R)
        `binning(UD1R_i, UD1R, LUD1R, NUD1R, PUD1R, WUD1R, P2UD1R)
        `binning(ATR_i, ATR, LATR, NATR, PATR, WATR, P2ATR)
        if (BULKMOD != 0) begin
            `binning(UCR_i, UCR, LUCR, NUCR, PUCR, WUCR, P2UCR)
            `binning(UC1R_i, UC1R, LUC1R, NUC1R, PUC1R, WUC1R, P2UC1R)
        end
    end
    if (CVMOD == 1) begin
        `binning(U0CV_i, U0CV, LU0CV, NU0CV, PU0CV, WU0CV, P2U0CV)
        `nfin_scaling(U0CV_i, U0N1CV, U0N2CV)
        `binning(UACV_i, UACV, LUACV, NUACV, PUACV, WUACV, P2UACV)
        `binning(UDCV_i, UDCV, LUDCV, NUDCV, PUDCV, WUDCV, P2UDCV)
        `binning(UTECV_i, UTECV, LUTECV, NUTECV, PUTECV, WUTECV, P2UTECV)
        `binning(UTE1CV_i, UTE1CV, LUTE1CV, NUTE1CV, PUTE1CV, WUTE1CV, P2UTE1CV)
        `binning(UTLCV_i, UTLCV, LUTLCV, NUTLCV, PUTLCV, WUTLCV, P2UTLCV)
        `binning(UA1CV_i, UA1CV, LUA1CV, NUA1CV, PUA1CV, WUA1CV, P2UA1CV)
        `binning(UA2CV_i, UA2CV, LUA2CV, NUA2CV, PUA2CV, WUA2CV, P2UA2CV)
        `binning(UD1CV_i, UD1CV, LUD1CV, NUD1CV, PUD1CV, WUD1CV, P2UD1CV)
        `binning(UD2CV_i, UD2CV, LUD2CV, NUD2CV, PUD2CV, WUD2CV, P2UD2CV)
        if (BULKMOD != 0) begin
            `binning(UCCV_i, UCCV, LUCCV, NUCCV, PUCCV, WUCCV, P2UCCV)
            `binning(UC1CV_i, UC1CV, LUC1CV, NUC1CV, PUC1CV, WUC1CV, P2UC1CV)
        end
        `binning(ETA0CV_i, ETA0CV, LETA0CV, NETA0CV, PETA0CV, WETA0CV, P2ETA0CV)
        `nfin_scaling(ETA0CV_i, ETA0N1CV, ETA0N2CV)
        if (NFINNOM != 0.0) begin
            `nfinnom_scaling(U0CV_i, U0LTCV)
            `nfinnom_scaling(ETA0CV_i, ETA0LTCV)
        end
    end
    if (NQSMOD != 0 && XRCRG1 != 0.0) begin
        `binning(XRCRG1_i, XRCRG1, LXRCRG1, NXRCRG1, PXRCRG1, WXRCRG1, P2XRCRG1)
        `binning(XRCRG2_i, XRCRG2, LXRCRG2, NXRCRG2, PXRCRG2, WXRCRG2, P2XRCRG2)
    end
    if (SUBBANDMOD == 1) begin
        `binning(DIMENSION1_i, DIMENSION1, LDIMENSION1, NDIMENSION1, PDIMENSION1, WDIMENSION1, P2DIMENSION1)
        `binning(DIMENSION2_i, DIMENSION2, LDIMENSION2, NDIMENSION2, PDIMENSION2, WDIMENSION2, P2DIMENSION2)
        `binning(DIMENSION3_i, DIMENSION3, LDIMENSION3, NDIMENSION3, PDIMENSION3, WDIMENSION3, P2DIMENSION3)
        `binning(SSP1_i, SSP1, LSSP1, NSSP1, PSSP1, WSSP1, P2SSP1)
        `binning(SSP2_i, SSP2, LSSP2, NSSP2, PSSP2, WSSP2, P2SSP2)
        `binning(SSP3_i, SSP3, LSSP3, NSSP3, PSSP3, WSSP3, P2SSP3)
        `binning(E2NOM_i, E2NOM, LE2NOM, NE2NOM, PE2NOM, WE2NOM, P2E2NOM)
        `binning(E3NOM_i, E3NOM, LE3NOM, NE3NOM, PE3NOM, WE3NOM, P2E3NOM)
        `binning(MFQ1NOM_i, MFQ1NOM, LMFQ1NOM, NMFQ1NOM, PMFQ1NOM, WMFQ1NOM, P2MFQ1NOM)
        `binning(MFQ2NOM_i, MFQ2NOM, LMFQ2NOM, NMFQ2NOM, PMFQ2NOM, WMFQ2NOM, P2MFQ2NOM)
        `binning(MFQ3NOM_i, MFQ3NOM, LMFQ3NOM, NMFQ3NOM, PMFQ3NOM, WMFQ3NOM, P2MFQ3NOM)
    end

    // NFIN scaling
    `nfin_scaling(PHIG_i, PHIGN1, PHIGN2)
    `nfin_scaling(ETA0_i, ETA0N1, ETA0N2)
    `nfin_scaling(CDSC_i, CDSCN1, CDSCN2)
    `nfin_scaling(CDSCD_i, CDSCDN1, CDSCDN2)
    `nfin_scaling(CDSCDR_i, CDSCDRN1, CDSCDRN2)
    `nfin_scaling(VSAT_i, VSATN1, VSATN2)
    `nfin_scaling(VSAT1_i, VSAT1N1, VSAT1N2)
    `nfin_scaling(VSAT1R_i, VSAT1RN1, VSAT1RN2)
    `nfin_scaling(U0_i, U0N1, U0N2)
    `nfin_scaling(U0R_i, U0N1R, U0N2R)
    if (NFINNOM != 0.0) begin
        `nfinnom_scaling(PHIG_i, PHIGLT)
        `nfinnom_scaling(ETA0_i, ETA0LT)
        `nfinnom_scaling(U0_i, U0LT)
    end

    // Length scaling
    Leff_ln = ln(Leff);
    PHIG_i = PHIG_i + PHIGL * Leff;
    if (LPA > 0.0) begin
        U0_i = U0_i * (1.0 - UP_i * exp(-LPA * Leff_ln));
    end else begin
        U0_i = U0_i * (1.0 - UP_i);
    end
    `length_scaling(UA_i, AUA, BUA)
    `length_scaling(UD_i, AUD, BUD)
    `length_scaling(EU_i, AEU, BEU)
    if (ASYMMOD != 0) begin
        `length_scaling(UAR_i, AUAR, BUAR)
        `length_scaling(UDR_i, AUDR, BUDR)
        `length_scaling(EUR_i, AEUR, BEUR)
        if (LPAR > 0.0) begin
            U0R_i = U0R_i * (1.0 - UPR_i * exp(-LPAR * Leff_ln));
        end else begin
            U0R_i = U0R_i * (1.0 - UPR_i);
        end
    end
    if (RDSMOD == 1) begin
        `length_scaling(RSW_i, ARSW, BRSW)
        `length_scaling(RDW_i, ARDW, BRDW)
    end else begin
        `length_scaling(RDSW_i, ARDSW, BRDSW)
    end
    `length_scaling(PCLM_i, APCLM, BPCLM)
    if (ASYMMOD != 0) begin
        PCLMR_i = PCLMR_i + APCLMR * exp(-BPCLMR * Leff_ln);
    end
    MEXP_i = MEXP_i + AMEXP * exp(-BMEXP * Leff_ln);
    if (ASYMMOD != 0) begin
        MEXPR_i = MEXPR_i + AMEXPR * exp(-BMEXPR * Leff_ln);
    end
    `length_scaling(PTWG_i, APTWG, BPTWG)
    if (ASYMMOD != 0) begin
        `length_scaling(PTWGR_i, APTWG, BPTWG)
    end
    `length_scaling(VSAT_i, AVSAT, BVSAT)
    `length_scaling(VSAT1_i, AVSAT1, BVSAT1)
    if (ASYMMOD != 0) begin
        `length_scaling(VSAT1R_i, AVSAT1, BVSAT1)
    end
    `length_scaling(PSAT_i, APSAT, BPSAT)
    `length_scaling(PSATCV_i, APSATCV, BPSATCV)
    `length_scaling(VSATCV_i, AVSATCV, BVSATCV)
    DVTP0_i = DVTP0_i + ADVTP0 * `lexp(-Leff / BDVTP0);
    DVTP1_i = DVTP1_i + ADVTP1 * `lexp(-Leff / BDVTP1);
    // Geometric scaling for Toxeff / charge centroid Tcen
    if (QMTCENCV_i > 0.0 || QMTCENCVA_i > 0.0) begin
        MTcen = 1.0 + AQMTCEN * `lexp(-(2.0 * Ach / Weff_UFCM) / BQMTCEN);
        Tcen0 = (2.0 * Ach / Weff_UFCM) * MTcen;
    end

    // Parameter checking
    `include "bsimcmg_checking.include"

    // Self-heating
    if (SHMOD != 0 && RTH0 > 0.0) begin
        if (BSHEXP != 0.0) begin
            T1 = WTH0 * pow(NF, BSHEXP);
        end else begin
            T1 = WTH0;
        end
        if (ASHEXP != 0.0) begin
            T2 = FPITCH * pow(NFINtotal, ASHEXP);
        end else begin
            T2 = FPITCH;
        end
        gth = (T1 + T2) / RTH0;
        cth = CTH0 * (T1 + T2);
    end

    // Gate electrode resistance
    if (RGATEMOD != 0) begin
        Rgeltd = (RGEXT / NGCON + (RGFIN * NFIN) / (NGCON == 2 ? 12.0 : 3.0)) / NF;
        ggeltd = 1.0 / max(1.0e-3, Rgeltd);
    end

    // Geometry-dependent source/drain resistances
    if (RGEOMOD == 0) begin
        RSourceGeo = RSHS * NRS;
        RDrainGeo = RSHD * NRD;
    end else begin
        // Area and perimeter calculation
        if (HEPI > 0.0) begin
            Arsd = FPITCH * HFIN + (TFIN + (FPITCH - TFIN) * CRATIO) * HEPI;
        end else begin
            Arsd = FPITCH * max(1.0e-9, HFIN + HEPI);
        end
        Prsd = FPITCH + DELTAPRSD;
        // Resistivity calculation
        if ($param_given(RHORSD)) begin
            rhorsd = RHORSD;
        end else begin
            mu_max = (TYPE == `ntype) ? 1417.0 : 470.5;
            if (TYPE == `ntype) begin
                T0 = pow((NSD / 9.68e22), 0.68);
                T1 = 3.43e26 / NSD;
                mu_rsd = (52.2 + (mu_max - 52.2) / (1.0 + T0) - 43.4 / (1.0 + T1 * T1)) * 1.0e-4;
            end else begin
                T0 = pow((NSD / 2.23e22), 0.719);
                T1 = 6.10e26 / NSD;
                mu_rsd = (44.9 + (mu_max - 44.9) / (1.0 + T0) - 29.0 / (1.0 + T1 * T1)) * 1.0e-4;
            end
            rhorsd = 1.0 / (`q * NSD * mu_rsd);
        end
        // Component: spreading resistance
        thetarsp = 55.0 * `M_PI / 180.0;
        afin = min(Arsd, max(1.0e-18, TFIN * (HFIN + min(0.0, HEPI))));
        Rsp = rhorsd / tan(thetarsp) / (sqrt(`M_PI) * NFIN) * (1.0 / sqrt(afin) - 2.0 / sqrt(Arsd) + sqrt(afin / (Arsd * Arsd)));
        // Component: contact resistance
        arsd_total = Arsd * NFIN + ARSDEND;
        prsd_total = Prsd * NFIN + PRSDEND;
        lt = sqrt(RHOC * arsd_total / (rhorsd * prsd_total));
        alpha = LRSD / lt;
        T0 = `lexp(2.0 * alpha);
        if (SDTERM == 1.0) begin
            eta = rhorsd * lt / RHOC;
            T1 = T0 * (1.0 + eta);
            T2 = T1 + 1.0 - eta;
            T3 = T1 - 1.0 + eta;
        end else begin
            T2 = T0 + 1.0;
            T3 = T0 - 1.0;
        end
        RrsdTML = rhorsd * lt * T2 / (arsd_total * T3);
        if (HEPI < -1.0e-10) begin
            Rrsdside = RHOC / (-HEPI * TFIN * NFIN);
            Rrsd = (RrsdTML + Rsp) * Rrsdside / ((RrsdTML + Rsp) + Rrsdside);
        end else begin
            Rrsd = RrsdTML + Rsp;
        end
        Rdsgeo = Rrsd / NF * max(0.0, RGEOA + RGEOB * TFIN + RGEOC * FPITCH + RGEOD * LRSD + RGEOE * HEPI);
        RSourceGeo = Rdsgeo;
        RDrainGeo = Rdsgeo;
    end

    // Clamping of source/drain resistances
    if (RDSMOD == 0) begin
        if (RSourceGeo < minr) begin
            RSourceGeo = 0;
        end
        if (RDrainGeo < minr) begin
            RDrainGeo = 0;
        end
    end else begin
        if (RSourceGeo <= minr) begin
            RSourceGeo = minr;
        end
        if (RDrainGeo <= minr) begin
            RDrainGeo = minr;
        end
    end
    if (CGEOMOD != 1) begin
        if ($param_given(CGSO)) begin
            CGSO_i = CGSO;
        end else begin
            if ($param_given(DLC) && DLC > 0.0) begin
                CGSO_i = max(0.0, DLC * cox - CGSL_i);
            end else begin
                if (CGEOMOD == 3) begin
                    CGSO_i = 0.3 * WGAA * cox;
                end else begin
                    CGSO_i = 0.3 * TFIN * cox;
                end
            end
        end
        if ($param_given(CGDO)) begin
            CGDO_i = CGDO;
        end else begin
            if ($param_given(DLC) && DLC > 0.0) begin
                CGDO_i = max(0.0, DLC * cox - CGDL_i);
            end else begin
                if (CGEOMOD == 3) begin
                    CGDO_i = 0.3 * WGAA * cox;
                end else begin
                    CGDO_i = 0.3 * TFIN * cox;
                end
            end
        end
    end

    // Parasitic source/drain-to-gate fringe capacitance
    if (CGEOMOD == 2) begin
        Hg = TGATE + TMASK;
        Trsd = 0.5 * (FPITCH - TFIN);
        Wg = max(0.0, Trsd - TOXP);
        Hrsd = max(0.0, HEPI + TSILI);
        // Top component
        if (TMASK > 0.0) begin
            T0 = 3.467e-11 * `lln(1.0e-7 * EPSRSP / (3.9 * LSP));
            T1 = 0.942 * Hrsd * epssp / LSP;
            Cgg_top = (T0 + T1) * (TFIN + (FPITCH - TFIN) * CRATIO);
        end else begin
            `cfringe_2d(Hg, Hrsd, TFIN, 0.85, Cgg_top)
        end
        // Side component
        if (TMASK > 0.0) begin
            `cfringe_2d(Wg, Trsd, HFIN, 0.70, Cgg_side)
        end else begin
            `cfringe_2d(Wg, Trsd, HFIN, 0.85, Cgg_side)
        end
        // Corner component
        if (TMASK > 0.0) begin
            Acorner = 0.0;
        end else begin
            if (HEPI > 0.0) begin
                Acorner = (FPITCH - TFIN) * (HEPI * CRATIO + TSILI);
            end else begin
                Acorner = (FPITCH - TFIN) * Hrsd;
            end
        end
        Ccorner = (NFIN * Acorner + ARSDEND + ASILIEND) * epssp / LSP;
        Cfr_geo = (Ccorner + Cgg_top * NFIN + CGEOE * Cgg_side * NFIN * 2.0) * NF;
        Cfr_geo = Cfr_geo * max(0.0, CGEOA + CGEOB * TFIN + CGEOC * FPITCH + CGEOD * LRSD);
    end
    //Gate-All-Around FET fringe capacitance model
    if (CGEOMOD == 3) begin
        Hg = TGATE + TMASK;
        Trsd = 0.5 * (FPITCH - WGAA);
        Wg = max(0.0, Trsd - TOXP);
        Hrsd = max(0.0, HEPI + TSILI);
        Hrsd2 = 0.5 * TSUS;
        // Topmost component: topmost GAA body
        if (TMASK > 0.0) begin
            T0 = 3.467e-11 * `lln(1.0e-7 * EPSRSP / (3.9 * LSP));
            T1 = 0.942 * Hrsd * epssp / LSP;
            Cgg_topm = (T0 + T1) * (WGAA + (FPITCH - WGAA) * CRATIO);
        end else begin
            `cfringe_2d(Hg, Hrsd, WGAA, 0.85, Cgg_topm)
        end
        // Top or bottom component: intermeditate GAA bodies
        `cfringe_2d(TGATE, Hrsd2, WGAA, 0.85, Cgg_tb)
        // Topmost side component
        if (TMASK > 0.0) begin
            `cfringe_2d(Wg, Trsd, TGAA, 0.70, Cgg_sidetopm)
        end else begin
            `cfringe_2d(Wg, Trsd, TGAA, 0.85, Cgg_sidetopm)
        end
        // Intermediate side component
        `cfringe_2d(Wg, Trsd, TGAA, 0.85, Cgg_sidetb)
        // Parasitic FinFET side component
        `cfringe_2d(Wg, Trsd, HPFF, 0.85, Cgg_sidepff)
        // Topmost corner component
        if (TMASK > 0.0) begin
            Acorner_topm  =  0.0;
        end else begin
            if (HEPI > 0.0) begin
                Acorner_topm = (FPITCH - WGAA) * (HEPI * CRATIO + TSILI);
            end else begin
                Acorner_topm = (FPITCH - WGAA) * Hrsd;
            end
        end
        // Intermediate corner component
        Acorner_tb = (FPITCH - WGAA) * Hrsd2;
        Ccorner = (NFIN * (Acorner_topm + 2 * NGAA * Acorner_tb) + ARSDEND + ASILIEND) * epssp / LSP;
        Cfr_geo = (Ccorner + (Cgg_topm + 2 * NGAA * Cgg_tb) * NFIN + CGEOE * (Cgg_sidetopm + Cgg_sidetb * (NGAA - 1) + Cgg_sidepff) * NFIN * 2.0) * NF;
        Cfr_geo = Cfr_geo * max(0.0, CGEOA + CGEOB * WGAA + CGEOC * FPITCH + CGEOD * LRSD);
    end
    // Source/gate/drain-to-substrate parasitic capacitances
    T0 = CSDESW * `lln(1.0 + HFIN / EOTBOX);
    csbox = cbox * ASEO + T0 * max(0.0, PSEO - FPITCH * NFINtotal);
    cdbox = cbox * ADEO + T0 * max(0.0, PDEO - FPITCH * NFINtotal);
    if (GEOMOD != 5) begin
        cgbox = (CGBO * NF * NGCON + CGBN * NFINtotal) * Lg;
    end else begin
        cgbox = (CGBO * NF * NGCON + (CGBN + CGBW * WGAAeff) * NFINtotal) * Lg;
    end

    // Mobility degradation
    EeffFactor = 1.0e-8 / (epsratio * EOT);
    WeffWRFactor = 1.0 / (NFINtotal * pow((Weff0 * 1.0e6), WR_i));
    litl = sqrt(epsratio * EOT * 0.5 * TFIN);
    scl = sqrt((epssub * Ach / Cins) * (1.0 + Ach * Cins / (2.0 * epssub * Weff_UFCM * Weff_UFCM)));
    if (!$param_given(THETASCE)) begin
        tmp = DVT1_i * Leff / scl + 1.0e-6;
        if (tmp < 40.0) begin
            Theta_SCE = 0.5 / (cosh(tmp) - 1.0);
        end else begin
            Theta_SCE = `lexp(-tmp);
        end
    end else begin
        Theta_SCE = THETASCE;
    end
    if (!$param_given(THETASW)) begin
        tmp = DVT1SS_i * Leff / scl + 1.0e-6;
        if (tmp < 40.0) begin
            Theta_SW = 0.5 / (cosh(tmp) - 1.0);
        end else begin
            Theta_SW = `lexp(-tmp);
        end
    end else begin
        Theta_SW = THETASW;
    end
    if (!$param_given(THETADIBL)) begin
        tmp = DSUB_i * Leff / scl + 1.0e-6;
        if (tmp < 40.0) begin
            Theta_DIBL = 0.5 / (cosh(tmp) - 1.0);
        end else begin
            Theta_DIBL = `lexp(-tmp);
        end
    end else begin
        Theta_DIBL = THETADIBL;
    end
    Theta_RSCE = sqrt(1.0 + LPE0_i / Leff) - 1.0;
    tmp = DSUB_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        Theta_DITS = 1.0 / max((1.0 + DVTP2 * (cosh(tmp) - 2.0)), 1.0e-6);
    end else begin
        Theta_DITS = `lexp(-tmp) / max((DVTP2 + `lexp(-tmp)), 1.0e-6);
    end
    qbs = `q * NBODY_i * Ach / Cins;

    // Gate current
    if (TYPE == `ntype) begin
        Aechvb = 4.97232e-7;
        Bechvb = 7.45669e11;
    end else begin
        Aechvb = 3.42537e-7;
        Bechvb = 1.16645e12;
    end
    T0 = TOXG * TOXG;
    T1 = TOXG * POXEDGE_i;
    T2 = T1 * T1;
    Toxratio = pow((TOXREF / TOXG), NTOX_i) / T0;
    Toxratioedge = pow((TOXREF / T1), NTOX_i) / T2;
    igsd_mult0 = Weff0 * Aechvb * Toxratioedge;
    if (TNOM < -`P_CELSIUS0) begin
        $strobe("Warning: (TNOM = %g) < -`P_CELSIUS0. Set to 27 C.", TNOM);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `CONSTCtoK;
    end

    //Gate-All-Around (GAA) FET quantum subband model: Geometry dependent calculations
    // (Ref: A. Dasgupta et.al., IEEE TED, vol. 67, no. 2, 2020.)
    if (SUBBANDMOD == 1) begin
        //Dimension scaling
        d1 = (DIM1H - DIMENSION1_i) / (1 + `lexp((WDIM0 * 1e9 - WGAA * 1e9) / WDIMR)) + DIMENSION1_i;
        d2 = (DIM2H - DIMENSION2_i) / (1 + `lexp((WDIM0 * 1e9 - WGAA * 1e9) / WDIMR)) + DIMENSION2_i;
        d3 = (DIM3H - DIMENSION3_i) / (1 + `lexp((WDIM0 * 1e9 - WGAA * 1e9) / WDIMR)) + DIMENSION3_i;
        p1 = `smoothminx(-DSSP1 / (1 + `lexp((WSSP0 * 1e9 - WGAA * 1e9) / WSSPR)) + SSP1_i, 0.0, 0.001);
        p2 = `smoothminx(-DSSP2 / (1 + `lexp((WSSP0 * 1e9 - WGAA * 1e9) / WSSPR)) + SSP2_i, 0.0, 0.001);
        p3 = `smoothminx(-DSSP3 / (1 + `lexp((WSSP0 * 1e9 - WGAA * 1e9) / WSSPR)) + SSP3_i, 0.0, 0.001);

        //Effect of dimension on capacitance normalizations
        Wp1 = `smoothmaxx(`smoothminx(1.001 * (d1 - 1.001), 0, 0.001), 1, 0.001);
        Tp1 = `smoothmaxx(`smoothminx(1.001 * (d1 - 2.001), 0, 0.001), 1, 0.001);
        Wp2 = `smoothmaxx(`smoothminx(1.001 * (d2 - 1.001), 0, 0.001), 1, 0.001);
        Tp2 = `smoothmaxx(`smoothminx(1.001 * (d2 - 2.001), 0, 0.001), 1, 0.001);
        Wp3 = `smoothmaxx(`smoothminx(1.001 * (d3 - 1.001), 0, 0.001), 1, 0.001);
        Tp3 = `smoothmaxx(`smoothminx(1.001 * (d3 - 2.001), 0, 0.001), 1, 0.001);
        VnD1 = pow(Weff0, Wp1) * pow(Ach / Weff0, Tp1);
        qndnf1 = VnD1 / Cins;
        VnD2 = pow(Weff0, Wp2) * pow(Ach / Weff0, Tp2);
        qndnf2 = VnD2 / Cins;
        VnD3 = pow(Weff0, Wp3) * pow(Ach / Weff0, Tp3);
        qndnf3 = VnD3 / Cins;

        nc3d0 = `smoothminx(1 / (1 + `lexp((2.75 - TGAA * 1e9) / 0.78)), 0.5, 0.003);
        nc3d = (1 - nc3d0) * (d1 - DIMENSION1_i) / (DIM1H - DIMENSION1_i) + nc3d0;
        ncq = 1 / (1 + `lexp((nc3d - 0.999) / 1e-4));
        //TGAA scaling model for subband energies
        QT0= 0.5 * TGAA * TGAA * 1e18 - 1.5 * TGAA * 1e9 + 2;
        QT1= `smoothmaxx(QT0, 4, 0.01);
        ne2h = `smoothmaxx(`smoothminx(T0 + pow(TGAA * 1e9 - QT1, TSRE2) * (9.24e5 - 1.81e4) / pow(2, TSRE2) , 1.81e4, 0.01), 9.24e5, 9.24e3);
        pe2h = `smoothmaxx(`smoothminx(5.5 + pow(TGAA * 1e9 - QT1, TDWSE2) * (8 - 5.5) / pow(2, TDWSE2), 0, 0.01), 8, 0.01);
        ne3h = (120.66 * pow(4, TSRE3)) / pow(TGAA * 1e9, TSRE3);
        pe3h = 2 * pow(4, TDWSE3) / pow(TGAA * 1e9, TDWSE3);
        //TGAA scaling model for subband contributions
        nc1l0 = 107 * pow(4, TSRQ1) / pow(TGAA * 1e9, TSRQ1);
        pnc1l = `smoothmaxx(`smoothminx(0.7 + pow(TGAA * 1e9 - QT1, TDWSQ1) * 0.1, 0.5, 0.01), 1, 0.01);
        nc2l0 = 103 * pow(4, TSRQ2) / pow(TGAA * 1e9, TSRQ2);
        pnc2l = 1.5 * pow(4, TDWSQ2) / pow(TGAA * 1e9, TDWSQ2);
        nc3l0 = 833 * pow(4, TSRQ3) / pow(TGAA * 1e9, TSRQ3);
        pnc3l = 3.4 * pow(4, TDWSQ3) / pow(TGAA * 1e9, TDWSQ3);
        //WGAA scaling model for subband energies
        qe2n = ne2h / pow(WGAANOM * 1e9, WSFE2 * pe2h);
        qe3n = ne3h / pow(WGAANOM * 1e9, WSFE3 * pe3h);
        qe2 = `smoothminx(E2NOM_i + MFE2 * (ne2h / pow(WGAA * 1e9, WSFE2 * pe2h)-qe2n), 0, 0.01);
        qe3 = `smoothminx(E3NOM_i + MFE3 * (ne3h / pow(WGAA * 1e9, WSFE3 * pe3h)-qe3n), 0, 0.01);
        //WGAA scaling model for subband contributions
        nc1l = `smoothminx(nc1l0 / pow(1 + 5 * pow(WGAA * 1e9, WSFQ1 * pnc1l), 0.5), 0, 0.1);
        nc1ln = `smoothminx(nc1l0 / pow(1 + 5 * pow(WGAANOM * 1e9, WSFQ1 * pnc1l), 0.5), 0, 0.1);
        nc1 = MFQ1NOM_i + MFQ1 * (nc1l-nc1ln);
        nc2l = `smoothminx(nc2l0 / pow(1 + 5 * pow(WGAA * 1e9, WSFQ2 * pnc2l), 0.5), 0, 0.1);
        nc2ln = `smoothminx(nc2l0 / pow(1 + 5 * pow(WGAANOM * 1e9, WSFQ2 * pnc2l), 0.5), 0, 0.1);
        nc2 = MFQ2NOM_i + MFQ2 * (nc2l-nc2ln);
        nc3l = `smoothminx(nc3l0 / pow(1 + 5 * pow(WGAA * 1e9, WSFQ3 * pnc3l), 0.5), 0, 0.1);
        nc3ln = `smoothminx(nc3l0 / pow(1 + 5 * pow(WGAANOM * 1e9, WSFQ3 * pnc3l), 0.5), 0, 0.1);
        nc3 = MFQ3NOM_i + MFQ3 * (nc3l-nc3ln);
        //Pre-factors for charge
        qnd10 = `q * (d1 / 2) * (pow(3.14, d1 / 2) / `gammafunc(1 + d1 / 2)) * pow(nc1 * 1e6, d1) * qndnf1;
        qnd20 = `q * (d2 / 2) * (pow(3.14, d2 / 2) / `gammafunc(1 + d2 / 2)) * pow(nc2 * 1e6, d2) * qndnf2;
        qnd30 = `q * (d3 / 2) * (pow(3.14, d3 / 2) / `gammafunc(1 + d3 / 2)) * pow(nc3 * 1e6, d3) * qndnf3;
    end

    // Geometry dependent mobility scaling
    // (Ref: A. Dasgupta et.al., IEEE EDL, vol. 41, no. 3, 2020.)
    if (MOBSCMOD == 1) begin
        ETAMOB_i=ETAMOBTHIN + (ETAMOB_i-ETAMOBTHIN) / (`lexp((ETAMOBTNI*1e9 - TGAA*1e9) / ETAMOBIR) + 1);

        mut0 =UA_i - UATHIN - UATSAT*1e9*UARTSC;
        mut1 = (mut0 + TGAA*1e9*UARTSC )/ (1+`lexp((UATNI*1e9 - TGAA*1e9)/UAIR));
        UA_i = `smoothmaxx2(mut1 + UATHIN, UA_i + 0.2, 0.6);

        mut2 = (EUTHIN-EU_i)*370/pow(TGAA*1e9,EUPTSC) + (EUTHIN-EU_i)/(1+`lexp((TGAA*1e9-EUTNI*1e9)/EUIR)) + EU_i;
        EU_i = `smoothmaxx2(mut2, EUTHIN, 0.2);

        mut3 = WGAA/(WGAA + TGAA);
        mut4 = EGBULK*TGAA*TGAA*1e18 - U0EMSM1*1e-3;
        mut5 = (mut4 + pow(mut4*mut4 + 4*U0EMSM1*1e-3*(EGBULK+0.24)*TGAA*TGAA*1e18, 0.5))/(2*(EGBULK+0.24)*TGAA*TGAA*1e18);
        mut6 = `smoothmaxx2(1e-4/(mut5 - 0.8208 - U0EMSM2*1e-5), 1, 0.06);
        U0_i = U0_i * (mut3 + U0ETAWSC * (1 - mut3)) * mut6;

        UD_i = (UDTHIN-UD_i) * pow(`smoothminx(UDTSAT*1e9-TGAA*1e9,0,1),UDPTSC) + UD_i;
    end
  end // end of initial_instance and/or CMGBiasIndepCalc

    // Temperature dependence calculations
    if (SHMOD != 0 && RTH0 > 0.0) begin
        DevTemp = $temperature + Temp(t) + DTEMP;
    end else begin
        DevTemp = $temperature + DTEMP;
    end
    if (DevTemp != TempLast)     begin : CMGTempDepCalc
      TempLast =  DevTemp;

      TRatio = DevTemp / Tnom;
      TRatio_m1 = TRatio - 1.0;
      delTemp = DevTemp - Tnom;
      Vtm = `KboQ * DevTemp;
      Vtm0 = `KboQ * Tnom;
      Tlow = TLOW;
      if (CRYOMOD != 0) begin
          // Effective temperature for core model charge calculation at low temperatures
          DevTemplow0 = `smoothminx(DevTemp, Tlow, DTLOW);
          DevTemplow1 = `smoothminx((-KLOW1 * (DevTemp - TLOW1)), 0.0, DTLOW1);
          if (CRYOMOD == 1) begin
              T1 = `smoothminx(Tnom, Tlow, DTLOW);
              T2 = `smoothminx((-KLOW1 * (Tnom - TLOW1)), 0.0, DTLOW1);
              if (Tnom > Tlow) begin
                  T3 = DevTemplow0 + DevTemplow1 - T1 - T2 + Tnom;
              end else begin
                  T3 = DevTemplow0 + DevTemplow1 - T1 - T2 + Tlow;
              end
              DevTempeff = `smoothminx(DevTemp, T3, 0.2);
          end else begin
              if (Tlow > 210) begin
                  $strobe("Warning: TLOW = %e is greater than 210 K. Set to 210 K", TLOW);
                  Tlow = 210;
              end
              wh = 0.5 + 0.5 * tanh(0.5 * (DevTemp - 210));
              wl = 1.0 - wh;
              if (Tnom > 210) begin
                  T1 = `smoothminx(210, Tlow, DTLOW);
                  T2 = `smoothminx((-KLOW1 * (210 - TLOW1)), 0.0, DTLOW1);
                  T3 = DevTemplow0 + DevTemplow1 - T1 - T2 + 210;
                  DevTempeff = `smoothminx(DevTemp, T3, 0.2);
              end else begin
                  T1 = `smoothminx(Tnom, Tlow, DTLOW);
                  T2 = `smoothminx((-KLOW1 * (Tnom - TLOW1)), 0.0, DTLOW1);
                  if (Tnom > Tlow) begin
                      T3 = DevTemplow0 + DevTemplow1 - T1 - T2 + Tnom;
                  end else begin
                      T3 = DevTemplow0 + DevTemplow1 - T1 - T2 + Tlow;
                  end
                  T4 = `smoothminx(DevTemp, T3, 0.2);
                  DevTempeff = wl * T4 + wh * DevTemp;
              end
              DevTemp1 = `smoothmaxx2(DevTemp, 210, 0.2);
              delTemp1 = DevTemp1 - `smoothmaxx2(Tnom, 210, 0.2);
              delTRatio1 = (DevTemp1 - 210) / Tnom;
          end
          Vtmeff = `KboQ * DevTempeff;
      end
      Eg = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
      Eg0 = BG0SUB - TBGASUB * Tnom * Tnom / (Tnom + TBGBSUB);
      T1 = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
      ni = NI0SUB * T1 * `lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
      if (CRYOMOD == 0) begin
          Nc = NC0SUB * T1;
      end else begin
          Nc = NC0SUB * (DevTempeff / 300.15) * sqrt(DevTempeff / 300.15);
          niln = `lln(NI0SUB * T1) + BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm);
      end
      ThetaSS = `hypsmooth((1.0 + TSS_i * delTemp - 1.0e-6), 1.0e-3);

      // Quantum mechanical Vth correction
      kT = Vtm * `q;
      T0 = `HBAR * `M_PI / (2.0 * Ach / Weff_UFCM);
      E0 = T0 * T0 / (2.0 * mx);
      E0prime = T0 * T0 / (2.0 * mxprime);
      E1 = 4.0 * E0;
      E1prime = 4.0 * E0prime;
      T1 = gprime * mdprime / (gfactor * md);
      gam0 = 1.0 + T1 * `lexp((E0 - E0prime) / kT);
      gam1 = gam0 + `lexp((E0 - E1) / kT) + T1 * `lexp((E0 - E1prime) / kT);
      T2 = -Vtm * `lln(gfactor * md / (`M_PI * `HBAR * `HBAR * Nc) * kT / (2.0 * Ach / Weff_UFCM) * gam1);
      dvch_qm = QMFACTOR_i * (E0 / `q + T2);

      // Temperature dependence
      Trat_ln = ln(TRatio);
      if (CRYOMOD == 0) begin
          T1 = U0_i * exp(UTE_i * Trat_ln);
          u0 = T1 + `hypmax(UTL_i * delTemp, -0.9 * T1, 1.0e-4);
          if (ASYMMOD == 1) begin
              T1 = U0R_i * exp(UTER_i * Trat_ln);
              U0R_t = T1 + `hypmax(UTLR_i * delTemp, -0.9 * T1, 1.0e-4);
              u0r = U0R_t;
          end
          UA_t = UA_i + `hypmax(UA1_i * delTemp, -UA_i, 1.0e-6);
          EU_t = EU_i;
          if (ASYMMOD != 0) begin
              UAR_t = UAR_i + `hypmax(UA1R_i * delTemp, -UAR_i, 1.0e-6);
          end
          UD_t = UD_i * exp(UD1_i * Trat_ln);
          if (ASYMMOD != 0) begin
              UDR_t = UDR_i * exp(UD1R_i * Trat_ln);
          end
          UCS_t = UCS_i * exp(UCSTE_i * Trat_ln);
          rdstemp = `hypsmooth((1.0 + PRT_i * delTemp - 1.0e-6), 1.0e-3);
          `tempdep(VSAT_t, VSAT_i, -AT_i)
          if (ASYMMOD != 0) begin
              `tempdep(VSATR_t, VSATR_i, -ATR_i)
              if (VSATR_t < 1000) begin
                  $strobe("Warning: VSATR(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSATR_t);
                  VSATR_t = 1000;
              end
          end
          if (CVMOD == 1) begin
              T1 = U0CV_i * exp(UTECV_i * Trat_ln);
              u0_cv = T1 + `hypmax(UTLCV_i * delTemp, -0.9 * T1, 1.0e-4);
              UACV_t = UACV_i + `hypmax(UA1CV_i * delTemp, -UACV_i, 1.0e-6);
              UDCV_t = UDCV_i * exp(UD1CV_i * Trat_ln);
          end
          `tempdep(VSAT1_t, VSAT1_i, -AT_i)
          if (ASYMMOD != 0) begin
              `tempdep(VSAT1R_t, VSAT1R_i, -AT_i)
              if (VSAT1R_t < 1000) begin
                  $strobe("Warning: VSAT1R(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSAT1R_t);
                  VSAT1R_t = 1000;
              end
          end
          `tempdep(VSATCV_t, VSATCV_i, -ATCV_i)
          MEXP_t = `hypsmooth((MEXP_i * (1.0 + TMEXP * delTemp) - 2.0), 1.0e-3) + 2.0;
          if (ASYMMOD != 0) begin
              MEXPR_t = `hypsmooth((MEXPR_i * (1.0 + TMEXPR * delTemp) - 2.0), 1.0e-3) + 2.0;
          end
          KSATIV_t = KSATIV_i;
          PCLM_t = PCLM_i;
          dvth_temp = (KT1_i + KT1L / Leff) * TRatio_m1;
      end else if (CRYOMOD == 1) begin
          T1 = U0_i * exp((UTE_i + UTE1_i * TRatio) * Trat_ln);
          u0 = T1 + `hypmax(UTL_i * delTemp, -0.9 * T1, 1.0e-4);
          if (ASYMMOD == 1) begin
              T1 = U0R_i * exp((UTER_i + UTE1_i * TRatio) * Trat_ln);
              U0R_t = T1 + `hypmax(UTLR_i * delTemp, -0.9 * T1, 1.0e-4);
              u0r = U0R_t;
          end
          UA_t = UA_i * exp((UA1_i + UA2_i * TRatio) * Trat_ln);
          if (ASYMMOD != 0) begin
              UAR_t = UAR_i * exp((UA1R_i + UA2_i * TRatio) * Trat_ln);
          end
          UD_t = UD_i * exp((UD1_i + UD2_i * TRatio) * Trat_ln);
          if (ASYMMOD != 0) begin
              UDR_t = UDR_i * exp((UD1R_i + UD2_i * TRatio) * Trat_ln);
          end
          UCS_t = UCS_i * exp((UCSTE_i + UCSTE1 * TRatio) * Trat_ln);
          UDS_t = UDS_i * (`lexp(UDS1_i * TRatio_m1) - 1);
          UDD_t = UDD_i * (`lexp(UDD1_i * TRatio_m1) - 1);
          UDSeff_t = 0.5 + UDS_t;
          UDDeff_t = 0.5 + UDD_t;
          `tempdep(EU_t, EU_i, EU1_i)
          if (CVMOD == 1) begin
              T1 = U0CV_i * exp((UTECV_i + UTE1CV_i * TRatio) * Trat_ln);
              u0_cv = T1 + `hypmax(UTLCV_i * delTemp, -0.9 * T1, 1.0e-4);
              UACV_t = UACV_i * exp((UA1CV_i + UA2CV_i * TRatio) * Trat_ln);
              UDCV_t = UDCV_i * exp((UD1CV_i + UD2CV_i * TRatio) * Trat_ln);
          end
          if (PRT_i == PRT1_i) begin
              T2 = 1.0 + PRT_i * delTemp;
          end else if (TR0_i < Tnom) begin
              rdstemp0 = 1 + PRT_i * delTemp;
              rdstemp1 = 1 + PRT1_i * (DevTemp - TR0_i) + PRT_i * (TR0_i - Tnom);
              T3 = (PRT_i - PRT1_i) * (TR0_i - Tnom);
              if (PRT1_i < PRT_i) begin
                  T2 = `smoothminx(rdstemp0, rdstemp1, SPRT_i) - `smoothminx(T3, 0, SPRT_i);
              end else begin
                  T2 = `smoothmaxx2(rdstemp0, rdstemp1, SPRT_i) - `smoothmaxx2(T3, 0, SPRT_i);
              end
          end else begin
              rdstemp1 = 1 + PRT1_i * (DevTemp - Tnom);
              rdstemp0 = 1 + PRT_i * (DevTemp - TR0_i) + PRT1_i * (TR0_i - Tnom);
              T3 = (PRT1_i - PRT_i) * (TR0_i - Tnom);
              if (PRT1_i < PRT_i) begin
                  T2 = `smoothminx(rdstemp1, rdstemp0, SPRT_i) - `smoothminx(T3, 0, SPRT_i);
              end else begin
                  T2 = `smoothmaxx2(rdstemp1, rdstemp0, SPRT_i) - `smoothmaxx2(T3, 0, SPRT_i);
              end
          end
          rdstemp = `hypsmooth((T2 - 1.0e-6), 1.0e-3);
          `tempdep2(VSAT_t, VSAT_i, -AT_i, AT2)
          if (ASYMMOD != 0) begin
              `tempdep2(VSATR_t, VSATR_i, -ATR_i, AT2)
              if (VSATR_t < 1000) begin
                  $strobe("Warning: VSATR(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSATR_t);
                  VSATR_t = 1000;
              end
          end
          `tempdep2(VSAT1_t, VSAT1_i, -AT_i, AT2)
          if (ASYMMOD != 0) begin
              `tempdep2(VSAT1R_t, VSAT1R_i, -AT_i, AT2)
              if (VSAT1R_t < 1000) begin
                  $strobe("Warning: VSAT1R(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSAT1R_t);
                  VSAT1R_t = 1000;
              end
          end
          `tempdep2(VSATCV_t, VSATCV_i, -ATCV_i, AT2CV)
          MEXP_t = `hypsmooth((MEXP_i * (1.0 + TMEXP * delTemp + TMEXP2 * delTemp * delTemp) - 2.0), 1.0e-3) + 2.0;
          if (ASYMMOD != 0) begin
              MEXPR_t = `hypsmooth((MEXPR_i * (1.0 + TMEXPR * delTemp + TMEXP2 * delTemp * delTemp) - 2.0), 1.0e-3) + 2.0;
          end
          `tempdep2(KSATIV_t, KSATIV_i, KSATIVT1, KSATIVT2)
          `tempdep(PCLM_t, PCLM_i, PCLMT)
          dvth_temp = (KT1_i + KT1L / Leff) * TRatio_m1 + KT11 / (1 + `lexp(KT12 * (DevTemp - TVTH))) - KT11 / (1 + `lexp(KT12 * (Tnom - TVTH)));
      end else begin
          T1 = U0_i * exp((UTE_i + UTE1_i * delTRatio1) * Trat_ln);
          u0 = T1 + `hypmax(UTL_i * delTemp, -0.9 * T1, 1.0e-4);
          if (ASYMMOD == 1) begin
              T1 = U0R_i * exp((UTER_i + UTE1_i * delTRatio1) * Trat_ln);
              U0R_t = T1 + `hypmax(UTLR_i * delTemp, -0.9 * T1, 1.0e-4);
              u0r = U0R_t;
          end
          if (Tnom > 210) begin
              T2 = 210 * (UA1_i / (UA_i + UA1_i * (210 - Tnom)) - UA2_i * (`lln(210 / Tnom) + 1) / Tnom);
              T1 = (UA_i + UA1_i * (210 - Tnom)) / pow(210 / Tnom, T2 + UA2_i * (210 / Tnom));
              UA_tl = T1 * pow(TRatio, T2 + UA2_i * TRatio);
              UA_th = UA_i + UA1_i * delTemp;
          end else begin
              T2 = UA_i * pow(210 / Tnom, UA1_i + UA2_i * (210 / Tnom)) * (UA1_i / 210 + UA2_i * (`lln(210 / Tnom) + 1) / Tnom);
              T1 = UA_i * pow(210 / Tnom, UA1_i + UA2_i * (210 / Tnom)) - T2 * (210 - Tnom);
              UA_tl = UA_i * pow(TRatio, UA1_i + UA2_i * TRatio);
              UA_th = T1 + T2 * delTemp;
          end
          T0 = wl * UA_tl + wh * UA_th;
          UA_t = `hypsmooth(T0, 1.0e-6);
          if (ASYMMOD != 0) begin
              if (Tnom > 210) begin
                  T2 = 210 * (UA1R_i / (UAR_i + UA1R_i * (210 - Tnom)) - UA2_i * (`lln(210 / Tnom) + 1) / Tnom);
                  T1 = (UAR_i + UA1R_i * (210 - Tnom)) / pow(210 / Tnom, T2 + UA2_i * (210 / Tnom));
                  UAR_tl = T1 * pow(TRatio, T2 + UA2_i * TRatio);
                  UAR_th = UAR_i + UA1R_i * delTemp;
              end else begin
                  T2 = UAR_i * pow(210 / Tnom, UA1R_i + UA2_i * (210 / Tnom)) * (UA1R_i / 210 + UA2_i * (`lln(210 / Tnom) + 1) / Tnom);
                  T1 = UAR_i * pow(210 / Tnom, UA1R_i + UA2_i * (210 / Tnom)) - T2 * (210 - Tnom);
                  UAR_tl = UAR_i * pow(TRatio, UA1R_i + UA2_i * TRatio);
                  UAR_th = T1 + T2 * delTemp;
              end
              T0 = wl * UAR_tl + wh * UAR_th;
              UAR_t = `hypsmooth(T0, 1.0e-6);
          end
          UD_t = UD_i * exp((UD1_i + UD2_i * delTRatio1) * Trat_ln);
          if (ASYMMOD != 0) begin
              UDR_t = UDR_i * exp((UD1R_i + UD2_i * delTRatio1) * Trat_ln);
          end
          UCS_t = UCS_i * exp((UCSTE_i + UCSTE1_i * delTRatio1) * Trat_ln);
          if (abs(UDS1_i * (Tnom - 210) / Tnom) < 1.0e-6) begin
              UDS_t = UDS_i * (`lexp(UDS1_i * delTRatio1) - 1);
          end else begin
              UDS_t = UDS_i * (`lexp(UDS1_i * delTRatio1) - 1) / abs(`lexp(UDS1_i * (Tnom - 210) / Tnom) - 1);
          end
          if (abs(UDD1_i * (Tnom - 210) / Tnom) < 1.0e-6) begin
              UDD_t = UDD_i * (`lexp(UDD1_i * delTRatio1) - 1);
          end else begin
              UDD_t = UDD_i * (`lexp(UDD1_i * delTRatio1) - 1) / abs(`lexp(UDD1_i * (Tnom - 210) / Tnom) - 1);
          end
          UDSeff_t = 0.5 + UDS_t;
          UDDeff_t = 0.5 + UDD_t;
          if (TEMPMOD != 0) begin
              EU_t = EU_i + `hypmax((EU1_i * delTemp1), -EU_i, 1.0e-6);
              VSAT_t = VSAT_i + `hypmax((-AT_i * delTemp + AT2 * delTemp1* delTemp1), -VSAT_i, 1.0e-6);
              if (ASYMMOD != 0) begin
                  VSATR_t = VSATR_i + `hypmax((-ATR_i * delTemp + AT2 * delTemp1* delTemp1), -VSATR_i, 1.0e-6);
                  if (VSATR_t < 1000) begin
                      $strobe("Warning: VSATR(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSATR_t);
                      VSATR_t = 1000;
                  end
              end
              VSAT1_t = VSAT1_i + `hypmax((-AT_i * delTemp + AT2 * delTemp1 * delTemp1), -VSAT1_i, 1.0e-6);
              if (ASYMMOD != 0) begin
                  VSAT1R_t = VSAT1R_i + `hypmax((-AT_i * delTemp + AT2 * delTemp1 * delTemp1), -VSAT1R_i, 1.0e-6);
                  if (VSAT1R_t < 1000) begin
                      $strobe("Warning: VSAT1R(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSAT1R_t);
                      VSAT1R_t = 1000;
                  end
              end
              VSATCV_t = VSATCV_i + `hypmax((-ATCV_i * delTemp + AT2CV * delTemp1 * delTemp1), -VSATCV_i, 1.0e-6);
              KSATIV_t = KSATIV_i + `hypmax((KSATIVT1 * delTemp1 + KSATIVT2 * delTemp1 * delTemp1), -KSATIV_i, 1.0e-6);
              PCLM_t = PCLM_i + `hypmax((PCLMT * delTemp1), -PCLM_i, 1.0e-6);
          end else begin
              EU_t = EU_i * `hypsmooth((1.0 + EU1_i * delTemp1 - 1.0e-6), 1.0e-3);
              VSAT_t = VSAT_i * `hypsmooth((1.0 - AT_i * delTemp + AT2 * delTemp1 * delTemp1 - 1.0e-6), 1.0e-3);
              if (ASYMMOD != 0) begin
                  VSATR_t = VSATR_i * `hypsmooth((1.0 - ATR_i * delTemp + AT2 * delTemp1 * delTemp1 - 1.0e-6), 1.0e-3);
                  if (VSATR_t < 1000) begin
                      $strobe("Warning: VSATR(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSATR_t);
                      VSATR_t = 1000;
                  end
              end
              VSAT1_t = VSAT1_i * `hypsmooth((1.0 - AT_i * delTemp + AT2 * delTemp1 * delTemp1 - 1.0e-6), 1.0e-3);
              if (ASYMMOD != 0) begin
                  VSAT1R_t = VSAT1R_i * `hypsmooth((1.0 - AT_i * delTemp + AT2 * delTemp1 * delTemp1 - 1.0e-6), 1.0e-3);
                  if (VSAT1R_t < 1000) begin
                      $strobe("Warning: VSAT1R(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSAT1R_t);
                      VSAT1R_t = 1000;
                  end
              end
              VSATCV_t = VSATCV_i * `hypsmooth((1.0 - ATCV_i * delTemp + AT2CV * delTemp1 * delTemp1 - 1.0e-6), 1.0e-3);
              KSATIV_t = KSATIV_i * `hypsmooth((1.0 + KSATIVT1 * delTemp1 + KSATIVT2 * delTemp1 * delTemp1 - 1.0e-6), 1.0e-3);
              PCLM_t = PCLM_i * `hypsmooth((1.0 + PCLMT * delTemp1 - 1.0e-6), 1.0e-3);
          end
          MEXP_t = `hypsmooth((MEXP_i * (1.0 + TMEXP * delTemp + TMEXP2 * delTemp1 * delTemp1) - 2.0), 1.0e-3) + 2.0;
          if (ASYMMOD != 0) begin
              MEXPR_t = `hypsmooth((MEXPR_i * (1.0 + TMEXPR * delTemp + TMEXP2 * delTemp1 * delTemp1) - 2.0), 1.0e-3) + 2.0;
          end
          if (CVMOD == 1) begin
              T1 = U0CV_i * exp((UTECV_i + UTE1CV_i * delTRatio1) * Trat_ln);
              u0_cv = T1 + `hypmax(UTLCV_i * delTemp, -0.9 * T1, 1.0e-4);
              if (Tnom > 210) begin
                  T2 = 210 * (UA1CV_i / (UACV_i + UA1CV_i * (210 - Tnom)) - UA2CV_i * (`lln(210 / Tnom) + 1) / Tnom);
                  T1 = (UACV_i + UA1CV_i * (210 - Tnom)) / pow(210 / Tnom, T2 + UA2CV_i * (210 / Tnom));
                  UACV_tl = T1 * pow(TRatio, T2 + UA2CV_i * TRatio);
                  UACV_th = UACV_i + UA1CV_i * delTemp;
              end else begin
                  T2 = UACV_i * pow(210 / Tnom, UA1CV_i + UA2CV_i * (210 / Tnom)) * (UA1CV_i / 210 + UA2CV_i * (`lln(210 / Tnom) + 1) / Tnom);
                  T1 = UACV_i * pow(210 / Tnom, UA1CV_i + UA2CV_i * (210 / Tnom)) - T2 * (210 - Tnom);
                  UACV_tl = UACV_i * pow(TRatio, UA1CV_i + UA2CV_i * TRatio);
                  UACV_th = T1 + T2 * delTemp;
              end
              T0 = wl * UACV_tl + wh * UACV_th;
              UACV_t = `hypsmooth(T0, 1.0e-6);
              UDCV_t = UDCV_i * exp((UD1CV_i + UD2CV_i * delTRatio1) * Trat_ln);
          end
          if (PRT_i == PRT1_i) begin
              T2 = 1.0 + PRT_i * delTemp;
          end else if (TR0_i < 210) begin
              if (Tnom > 210) begin
                  rdstemp0 = 1 + PRT_i * delTemp;
                  rdstemp1 = 1 + PRT1_i * (DevTemp - TR0_i) + PRT_i * (TR0_i - Tnom);
                  T3 = 1 + PRT_i * (210 - Tnom);
                  T4 = 1 + PRT1_i * (210 - TR0_i) + PRT_i * (TR0_i - Tnom);
                  if (PRT1_i < PRT_i) begin
                      T5 = `smoothminx(rdstemp0, rdstemp1, SPRT_i) - `smoothminx(T3, T4, SPRT_i) + T3;
                      T2 = `smoothminx(T5, rdstemp0, 1.0e-3);
                  end else begin
                      T5 = `smoothmaxx2(rdstemp0, rdstemp1, SPRT_i) - `smoothmaxx2(T3, T4, SPRT_i) + T3;
                      T2 = `smoothmaxx2(T5, rdstemp0, 1.0e-3);
                  end
              end else if (Tnom > TR0_i) begin
                  rdstemp0 = 1 + PRT_i * delTemp;
                  rdstemp1 = 1 + PRT1_i * (DevTemp - TR0_i) + PRT_i * (TR0_i - Tnom);
                  T3 = (PRT_i - PRT1_i) * (TR0_i - Tnom);
                  T4 = 1 + PRT_i * (210 - Tnom);
                  T5 = 1 + PRT1_i * (210 - TR0_i) + PRT_i * (TR0_i - Tnom);
                  if (PRT1_i < PRT_i) begin
                      T6 = `smoothminx(rdstemp0, rdstemp1, SPRT_i) - `smoothminx(T3, 0, SPRT_i);
                      T7 = `smoothminx(T4, T5, SPRT_i) - `smoothminx(T3, 0, SPRT_i);
                      T8 = T7 + PRT_i * (DevTemp - 210);
                      T2 = `smoothminx(T6, T8, 1.0e-3);
                  end else begin
                      T6 = `smoothmaxx2(rdstemp0, rdstemp1, SPRT_i) - `smoothmaxx2(T3, 0, SPRT_i);
                      T7 = `smoothmaxx2(T4, T5, SPRT_i) - `smoothmaxx2(T3, 0, SPRT_i);
                      T8 = T7 + PRT_i * (DevTemp - 210);
                      T2 = `smoothmaxx2(T6, T8, 1.0e-3);
                  end
              end else begin
                  rdstemp1 = 1 + PRT1_i * delTemp;
                  rdstemp0 = 1 + PRT_i * (DevTemp - TR0_i) + PRT1_i * (TR0_i - Tnom);
                  T3 = (PRT1_i - PRT_i) * (TR0_i - Tnom);
                  T4 = 1 + PRT1_i * (210 - Tnom);
                  T5 = 1 + PRT_i * (210 - TR0_i) + PRT1_i * (TR0_i - Tnom);
                  if (PRT1_i < PRT_i) begin
                      T6 = `smoothminx(rdstemp0, rdstemp1, SPRT_i) - `smoothminx(T3, 0, SPRT_i);
                      T7 = `smoothminx(T4, T5, SPRT_i) - `smoothminx(T3, 0, SPRT_i);
                      T8 = T7 + PRT_i * (DevTemp - 210);
                      T2 = `smoothminx(T6, T8, 1.0e-3);
                  end else begin
                      T6 = `smoothmaxx2(rdstemp0, rdstemp1, SPRT_i) - `smoothmaxx2(T3, 0, SPRT_i);
                      T7 = `smoothmaxx2(T4, T5, SPRT_i) - `smoothmaxx2(T3, 0, SPRT_i);
                      T8 = T7 + PRT_i * (DevTemp - 210);
                      T2 = `smoothmaxx2(T6, T8, 1.0e-3);
                  end
              end
          end else begin
              if (Tnom > 210) begin
                  rdstemp0 = 1 + PRT_i * delTemp;
                  rdstemp1 = 1 + PRT1_i * (DevTemp - 210) + PRT_i * (210 - Tnom);
                  if (PRT1_i < PRT_i) begin
                      T2 = `smoothminx(rdstemp0, rdstemp1, 1.0e-2);
                  end else begin
                      T2 = `smoothmaxx2(rdstemp0, rdstemp1, 1.0e-2);
                  end
              end else begin
                  rdstemp1 = 1 + PRT1_i * delTemp;
                  rdstemp0 = 1 + PRT_i * (DevTemp - 210) + PRT1_i * (210 - Tnom);
                  if (PRT1_i < PRT_i) begin
                      T2 = `smoothminx(rdstemp0, rdstemp1, 1.0e-2);
                  end else begin
                      T2 = `smoothmaxx2(rdstemp0, rdstemp1, 1.0e-2);
                  end
              end
          end
          rdstemp = `hypsmooth((T2 - 1.0e-6), 1.0e-3);
          T4 = `smoothmaxx2(Tnom, 210, 0.2);
          dvth_temp = (KT1_i + KT1L / Leff) * TRatio_m1 + KT11 / (1 + `lexp(KT12 * (DevTemp1 - TVTH))) - KT11 / (1 + `lexp(KT12 * (T4 - TVTH)));
      end
      if (VSAT_t < 1000) begin
          $strobe("Warning: VSAT(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSAT_t);
          VSAT_t = 1000;
      end
      if (VSAT1_t < 1000) begin
          $strobe("Warning: VSAT1(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSAT1_t);
          VSAT1_t = 1000;
      end
      if (VSATCV_t < 1000) begin
          $strobe("Warning: VSATCV(%g) = %g is less than 1K, setting it to 1K.", DevTemp, VSATCV_t);
          VSATCV_t = 1000;
      end
      if (BULKMOD != 0) begin
          if (TEMPMOD == 0) begin
              `tempdep(UC_t, UC_i, UC1_i)
              if (CVMOD == 1) begin
                  `tempdep(UCCV_t, UCCV_i, UC1CV_i)
              end
              if (ASYMMOD != 0) begin
                  `tempdep(UCR_t, UCR_i, UC1R_i)
              end
          end else begin
              UC_t = UC_i + UC1_i * delTemp;
              if (CVMOD == 1) begin
                  UCCV_t = UCCV_i + UC1CV_i * delTemp;
              end
              if (ASYMMOD != 0) begin
                  UCR_t = UCR_i + UC1R_i * delTemp;
              end
          end
      end
      `tempdep(ETA0_t, ETA0_i, TETA0)
      if (CVMOD == 1) begin
          `tempdep(ETA0CV_t, ETA0CV_i, TETA0CV)
      end
      `tempdep(ETA0R_t, ETA0R_i, TETA0R)
      `tempdep(ETAMOB_t, ETAMOB_i, EMOBT_i)
      `tempdep(RSDR_t, RSDR, TRSDR)
      if (ASYMMOD != 0) begin
          `tempdep(RSDRR_t, RSDRR, TRSDR)
      end
      `tempdep(RDDR_t, RDDR, TRDDR)
      if (ASYMMOD != 0) begin
          `tempdep(RDDRR_t, RDDRR, TRDDR)
      end
      `tempdep(PTWG_t, PTWG_i, -PTWGT_i)
      if (ASYMMOD != 0) begin
          `tempdep(PTWGR_t, PTWGR_i, -PTWGT_i)
      end
      BETA0_t = BETA0_i * exp(IIT_i * Trat_ln);
      SII0_t = SII0_i * (`hypsmooth((1.0 + TII_i * TRatio_m1 - 0.01), 1.0e-3) + 0.01);
      K0_t = K0_i + K01_i * delTemp;
      K0SI_t = K0SI_i + `hypmax(K0SI1_i * delTemp, -K0SI_i, 1.0e-6);
      K2SI_t = K2SI_i + `hypmax(K2SI1_i * delTemp, -K2SI_i, 1.0e-6);
      K1_t = K1_i + `hypmax(K11_i * delTemp, -K1_i, 1.0e-6);
      K2SAT_t = K2SAT_i + K2SAT1_i * delTemp;
      A1_t = A1_i + A11_i * delTemp;
      A2_t = A2_i + A21_i * delTemp;
      K2_t = K2_i + `hypmax(K21_i * delTemp, -K2_i, 1.0e-6);
      K0SISAT_t = K0SISAT_i + K0SISAT1_i * delTemp;
      K2SISAT_t = K2SISAT_i + K2SISAT1_i * delTemp;
      AIGBINV_t = AIGBINV_i + `hypmax(AIGBINV1_i * delTemp, -AIGBINV_i, 1.0e-6);
      AIGBACC_t = AIGBACC_i + `hypmax(AIGBACC1_i * delTemp, -AIGBACC_i, 1.0e-6);
      AIGC_t = AIGC_i + `hypmax(AIGC1_i * delTemp, -AIGC_i, 1.0e-6);
      AIGS_t = AIGS_i + `hypmax(AIGS1_i * delTemp, -AIGS_i, 1.0e-6);
      AIGD_t = AIGD_i + `hypmax(AIGD1_i * delTemp, -AIGD_i, 1.0e-6);
      BGIDL_t = BGIDL_i * `hypsmooth((1.0 + TGIDL_i * delTemp - 1.0e-6), 1.0e-3);
      BGISL_t = BGISL_i * `hypsmooth((1.0 + TGIDL_i * delTemp - 1.0e-6), 1.0e-3);
      ALPHA0_t = ALPHA0_i + `hypmax(ALPHA01 * delTemp, -ALPHA0_i, 1.0e-6);
      ALPHA1_t = ALPHA1_i + `hypmax(ALPHA11 * delTemp, -ALPHA1_i, 1.0e-6);
      ALPHAII0_t = ALPHAII0_i + `hypmax(ALPHAII01 * delTemp, -ALPHAII0_i, 1.0e-25);
      ALPHAII1_t = ALPHAII1_i + `hypmax(ALPHAII11 * delTemp, -ALPHAII1_i, 1.0e-20);
      igtemp = exp(IGT_i * Trat_ln);
      igsd_mult = igsd_mult0 * igtemp;
      if (BULKMOD != 0) begin
          `tempdep(CJS_t, CJS, TCJ)
          `tempdep(CJD_t, CJD, TCJ)
          `tempdep(CJSWS_t, CJSWS, TCJSW)
          `tempdep(CJSWD_t, CJSWD, TCJSW)
          `tempdep(CJSWGS_t, CJSWGS, TCJSWG)
          `tempdep(CJSWGD_t, CJSWGD, TCJSWG)
          PBS_t = `hypsmooth((PBS - TPB * delTemp - 0.01), 1.0e-3) + 0.01;
          PBD_t = `hypsmooth((PBD - TPB * delTemp - 0.01), 1.0e-3) + 0.01;
          PBSWS_t = `hypsmooth((PBSWS - TPBSW * delTemp - 0.01), 1.0e-3) + 0.01;
          PBSWD_t = `hypsmooth((PBSWD - TPBSW * delTemp - 0.01), 1.0e-3) + 0.01;
          PBSWGS_t = `hypsmooth((PBSWGS - TPBSWG * delTemp - 0.01), 1.0e-3) + 0.01;
          PBSWGD_t = `hypsmooth((PBSWGD - TPBSWG * delTemp - 0.01), 1.0e-3) + 0.01;
          T0 = Eg0 / Vtm0 - Eg / Vtm;
          T3 = `lexp((T0 + XTIS * Trat_ln) / NJS);
          JSS_t = JSS * T3;
          JSWS_t = JSWS * T3;
          JSWGS_t = JSWGS * T3;
          T3 = `lexp((T0 + XTID * Trat_ln) / NJD);
          JSD_t = JSD * T3;
          JSWD_t = JSWD * T3;
          JSWGD_t = JSWGD * T3;
          JTSS_t = JTSS * `lexp(Eg0 * XTSS * TRatio_m1 / Vtm);
          JTSD_t = JTSD * `lexp(Eg0 * XTSD * TRatio_m1 / Vtm);
          JTSSWS_t = JTSSWS * `lexp(Eg0 * XTSSWS * TRatio_m1 / Vtm);
          JTSSWD_t = JTSSWD * `lexp(Eg0 * XTSSWD * TRatio_m1 / Vtm);
          JTSSWGS_t = JTSSWGS * (sqrt(JTWEFF / Weff0) + 1.0) * `lexp(Eg0 * XTSSWGS * TRatio_m1 / Vtm);
          JTSSWGD_t = JTSSWGD * (sqrt(JTWEFF / Weff0) + 1.0) * `lexp(Eg0 * XTSSWGD * TRatio_m1 / Vtm);
          NJTS_t = `hypsmooth((NJTS * (1.0 + TNJTS * TRatio_m1) - 0.01), 1.0e-3) + 0.01;
          NJTSD_t = `hypsmooth((NJTSD * (1.0 + TNJTSD * TRatio_m1) - 0.01), 1.0e-3) + 0.01;
          NJTSSW_t = `hypsmooth((NJTSSW * (1.0 + TNJTSSW * TRatio_m1) - 0.01), 1.0e-3) + 0.01;
          NJTSSWD_t = `hypsmooth((NJTSSWD * (1.0 + TNJTSSWD * TRatio_m1) - 0.01), 1.0e-3) + 0.01;
          NJTSSWG_t = `hypsmooth((NJTSSWG * (1.0 + TNJTSSWG * TRatio_m1) - 0.01), 1.0e-3) + 0.01;
          NJTSSWGD_t = `hypsmooth((NJTSSWGD * (1.0 + TNJTSSWGD * TRatio_m1) - 0.01), 1.0e-3) + 0.01;
      end

      if (!$param_given(VFBSD)) begin
          if (NGATE > 0.0) begin
              if (CRYOMOD == 0) begin
                  vfbsd = devsign * (`hypsmooth((0.5 * Eg - Vtm * `lln(NGATE / ni)), 1.0e-4) - (0.5 * Eg - devsign * (0.5 * Eg - `hypsmooth((0.5 * Eg - Vtm * `lln(NSD / ni)), 1.0e-4))));
              end else begin
                  vfbsd = devsign * (`hypsmooth((0.5 * Eg - Vtm * (`lln(NGATE) - niln)), 1.0e-4) - (0.5 * Eg - devsign * (0.5 * Eg - `hypsmooth((0.5 * Eg - Vtm * (`lln(NSD) - niln)), 1.0e-4))));
              end
          end else begin
              if (CRYOMOD == 0) begin
                  vfbsd = devsign * (PHIG_i - (EASUB + 0.5 * Eg - devsign * (0.5 * Eg - `hypsmooth((0.5 * Eg - Vtm * `lln(NSD / ni)), 1.0e-4))));
              end else begin
                  vfbsd = devsign * (PHIG_i - (EASUB + 0.5 * Eg - devsign * (0.5 * Eg - `hypsmooth((0.5 * Eg - Vtm * (`lln(NSD) - niln)), 1.0e-4))));
              end
          end
      end else begin
          vfbsd = VFBSD;
      end
      if (!$param_given(VFBSDCV)) begin
          vfbsdcv = vfbsd;
      end else begin
          vfbsdcv = VFBSDCV;
      end
      if (CRYOMOD == 0) begin
          phib = Vtm * `lln(NBODY_i / ni);
          vbi = Vtm * `lln(NBODY_i * NSD / (ni * ni));
      end else begin
          phib = Vtm * (`lln(NBODY_i) - niln);
          vbi = Vtm * (`lln(NBODY_i * NSD) - 2 * niln);
      end

      // Workfunction difference between gate and n+ source.
      deltaPhi = devsign * (PHIG_i - (EASUB + (TYPE == `ntype ? 0.0 : Eg)));

      // Mobility degradation
      eta_mu = 0.5 * ETAMOB_t;
      eta_mu_cv = 0.5;
      if (TYPE != `ntype) begin
          eta_mu = `ONE_OV_3 * ETAMOB_t;
          eta_mu_cv = `ONE_OV_3;
      end

      // Junction current and capacitance
      if (BULKMOD != 0) begin
          // Source-side junction current
          Isbs = ASEJ * JSS_t + PSEJ * JSWS_t + TFIN * NFINtotal * JSWGS_t;
          if (Isbs > 0.0) begin
              Nvtms = Vtm * NJS;
              XExpBVS = `lexp(-BVS / Nvtms) * XJBVS;
              T2 = max(IJTHSFWD / Isbs, 10.0);
              Tb = 1.0 + T2 - XExpBVS;
              VjsmFwd = Nvtms * `lln(0.5 * (Tb + sqrt(Tb * Tb + 4.0 * XExpBVS)));
              T0 = `lexp(VjsmFwd / Nvtms);
              IVjsmFwd = Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
              SslpFwd = Isbs * (T0 + XExpBVS / T0) / Nvtms;
              T2 = `hypsmooth((IJTHSREV / Isbs - 10.0), 1.0e-3) + 10.0;
              VjsmRev = -BVS - Nvtms * `lln((T2 - 1.0) / XJBVS);
              T1 = XJBVS * `lexp(-(BVS + VjsmRev) / Nvtms);
              IVjsmRev = Isbs * (1.0 + T1);
              SslpRev = -Isbs * T1 / Nvtms;
          end
          // Drain-side junction current
          Isbd = ADEJ * JSD_t + PDEJ * JSWD_t + TFIN * NFINtotal * JSWGD_t;
          if (Isbd > 0.0) begin
              Nvtmd = Vtm * NJD;
              XExpBVD = `lexp(-BVD / Nvtmd) * XJBVD;
              T2 = max(IJTHDFWD / Isbd, 10.0);
              Tb = 1.0 + T2 - XExpBVD;
              VjdmFwd = Nvtmd * `lln(0.5 * (Tb + sqrt(Tb * Tb + 4.0 * XExpBVD)));
              T0 = `lexp(VjdmFwd / Nvtmd);
              IVjdmFwd = Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
              DslpFwd = Isbd * (T0 + XExpBVD / T0) / Nvtmd;
              T2 = `hypsmooth((IJTHDREV / Isbd - 10.0), 1.0e-3) + 10.0;
              VjdmRev = -BVD - Nvtmd * `lln((T2 - 1.0) / XJBVD);
              T1 = XJBVD * `lexp(-(BVD + VjdmRev) / Nvtmd);
              IVjdmRev = Isbd * (1.0 + T1);
              DslpRev = -Isbd * T1 / Nvtmd;
          end
          // Junction capacitance
          Czbs = CJS_t * ASEJ;
          Czbssw = CJSWS_t * PSEJ;
          Czbsswg = CJSWGS_t * Weff0 * NFINtotal;
          Czbd = CJD_t * ADEJ;
          Czbdsw = CJSWD_t * PDEJ;
          Czbdswg = CJSWGD_t * Weff0 * NFINtotal;
          // Bias-independent part
          `juncap_bias_indep(SJS, PBS_t, MJS, MJS2, vec1s, pb21s)
          `juncap_bias_indep(SJSWS, PBSWS_t, MJSWS, MJSWS2, vec2s, pb22s)
          `juncap_bias_indep(SJSWGS, PBSWGS_t, MJSWGS, MJSWGS2, vec3s, pb23s)
          `juncap_bias_indep(SJD, PBD_t, MJD, MJD2, vec1d, pb21d)
          `juncap_bias_indep(SJSWD, PBSWD_t, MJSWD, MJSWD2, vec2d, pb22d)
          `juncap_bias_indep(SJSWGD, PBSWGD_t, MJSWGD, MJSWGD2, vec3d, pb23d)
      end

      // Generation-recombination current
      igentemp = `lexp(Eg * TRatio_m1 / Vtm / NTGEN_i);
    end // end of CMGTempDepCalc

    // Bias-dependent calculations
    vgs_noswap = devsign * V(gi, si);
    vds_noswap = devsign * V(di, si);
    vgd_noswap = devsign * V(gi, di);
    ves_jct = devsign * V(e, si);
    ved_jct = devsign * V(e, di);
    vge = devsign * V(gi, e);

    // Source/drain swap
    sigvds = 1.0;
    if (vds_noswap < 0.0) begin
        sigvds = -1.0;
        vgs = vgs_noswap - vds_noswap;
        vds = -1.0 * vds_noswap;
        ves = ved_jct;
    end else begin
        vgs = vgs_noswap;
        vds = vds_noswap;
        ves = ves_jct;
    end
    vgsfb = vgs - deltaPhi;

    // Vds smoothing
    vdsx = sqrt(vds * vds + 0.01) - 0.1;

    // Ves Smoothing
    if (BULKMOD != 0) begin
        vesx = ves - 0.5 * (vds - vdsx);
        vesmax = 0.95 * PHIBE_i;
        T2 = vesmax - vesx - 1.0e-3;
        veseff = vesmax - 0.5 * (T2 + sqrt(T2 * T2 + 0.004 * vesmax));
    end

    // Asymmetry model
    T0 = tanh(0.6 * vds_noswap / Vtm);
    wf = 0.5 + 0.5 * T0;
    wr = 1.0 - wf;
    if (ASYMMOD != 0) begin
        CDSCD_a = CDSCDR_i * wr + CDSCD_i * wf;
        ETA0_a = ETA0R_t * wr + ETA0_t * wf;
        PDIBL1_a = PDIBL1R_i * wr + PDIBL1_i * wf;
        PDIBL2_a = PDIBL2R_i * wr + PDIBL2_i * wf;
        MEXP_a = MEXPR_t * wr + MEXP_t * wf;
        PTWG_a = PTWGR_t * wr + PTWG_t * wf;
        VSAT1_a = VSAT1R_t * wr + VSAT1_t * wf;
        RSDR_a = RSDRR_t * wr + RSDR_t * wf;
        RDDR_a = RDDRR_t * wr + RDDR_t * wf;
        PCLM_a = PCLMR_i * wr + PCLM_t * wf;
        VSAT_a = VSATR_t * wr + VSAT_t * wf;
        KSATIV_a = KSATIVR_i * wr + KSATIV_t * wf;
        DVTSHIFT_a = DVTSHIFTR_i * wr + DVTSHIFT_i * wf;
        CIT_a = CITR_i * wr + CIT_i * wf;
        u0_a = u0r * wr + u0 * wf;
        UA_a = UAR_t * wr + UA_t * wf;
        UD_a = UDR_t * wr + UD_t * wf;
        UC_a = UCR_t * wr + UC_t * wf;
        EU_a = EUR_i * wr + EU_t * wf;
    end else begin
        CDSCD_a = CDSCD_i;
        ETA0_a = ETA0_t;
        PDIBL1_a = PDIBL1_i;
        PDIBL2_a = PDIBL2_i;
        MEXP_a = MEXP_t;
        PTWG_a = PTWG_t;
        VSAT1_a = VSAT1_t;
        RSDR_a = RSDR_t;
        RDDR_a = RDDR_t;
        PCLM_a = PCLM_t;
        VSAT_a = VSAT_t;
        KSATIV_a = KSATIV_t;
        DVTSHIFT_a = DVTSHIFT_i;
        CIT_a = CIT_i;
        u0_a = u0;
        UA_a = UA_t;
        UD_a = UD_t;
        UC_a = UC_t;
        EU_a = EU_t;
    end

    // Drain saturation voltage
    inv_MEXP = 1.0 / MEXP_a;

    // SCE, DIBL, SS degradation, Ref: BSIM4
    phist = 0.4 + phib + PHIN_i;
    T1 = 2.0 * (Cins / Weff_UFCM) / (rc + 2.0);
    cdsc = Theta_SW * (CDSC_i + CDSCD_a * vdsx);
    if (NVTM == 0.0) begin
        if (CRYOMOD == 0) begin
            nVtm = Vtm * ThetaSS * (1.0 + (CIT_a + cdsc) / T1);
        end else begin
            nVtm = Vtmeff * ThetaSS * (1.0 + (CIT_a + cdsc) / T1);
        end
    end else begin
        nVtm = NVTM;
    end

    // Unified FinFET compact model
    qdep = Qdep_ov_Cins / nVtm;
    vth_fixed_factor_SI = `lln(Cins * nVtm / (`q * Nc * 2.0 * Ach));
    vth_fixed_factor_Sub = `lln((qdep * rc) * (qdep * rc) / ((`lexp(qdep * rc) - qdep * rc - 1.0))) + vth_fixed_factor_SI;
    q0 = 10.0 * nVtm / rc + 2.0 * qbs;

    // New QM parameter calculation
    fieldnormalizationfactor = Vtm * Cins / (Weff_UFCM * epssub);
    auxQMfact = pow(4.5 * `HBAR * `M_PI * `q / (4.0 * sqrt(2.0 * mx)), `TWO_OV_3);
    QMFACTORCVfinal = QMFACTORCV * auxQMfact * pow(fieldnormalizationfactor, `TWO_OV_3) / (`q * Vtm);

    // Delta Vth
    dvth_vtroll = -DVT0_i * Theta_SCE * (vbi - phist);
    dvth_dibl = -ETA0_a * Theta_DIBL * vdsx + (DVTP0_i * Theta_DITS * pow(vdsx+0.01, DVTP1_i));
    dvth_rsce = K1RSCE_i * Theta_RSCE * sqrt(phist);
    dvth_all = dvth_vtroll + dvth_dibl + dvth_rsce + dvth_temp + DVTSHIFT_a;
    vgsfb = vgsfb - dvth_all;

    // Vgs clamping for inversion region
    beta0 = u0_a * cox * Weff0 / Leff;
    if (CRYOMOD == 0) begin
        T0 = -(dvch_qm + nVtm * `lln(2.0 * cox * IMIN / (beta0 * nVtm * `q * Nc * TFIN)));
        T1 = vgsfb + T0 + DELVTRAND;
        vgsfbeff = `hypsmooth(T1, 1.0e-4) - T0;
    end else begin
        T0 = -nVtm * `lln(2.0 * cox * IMIN / (beta0 * nVtm * `q * Nc * TFIN));
        T1  = -dvch_qm + `smoothminx(T0, 0.01, 1e-4);
        T2 = vgsfb + T1 + DELVTRAND;
        vgsfbeff = `hypsmooth(T2, 1.0e-4) - T1;
    end

    // Core model calculation at source
    vch = dvch_qm;
    T4 = pow(-qdep, `TWO_OV_3);
    if (BULKMOD != 0) begin
        T1 = `hypsmooth((2.0 * phib + vch - ves), 0.1);
        T3 = -K1_t / (2.0 * nVtm) * (sqrt(T1) - sqrt(2.0 * phib));
        T0 = -qdep - T3 + vth_fixed_factor_Sub + QMFACTORCVfinal * T4;
        T1 = -qdep - T3 + vth_fixed_factor_SI;
    end else begin
        T0 = -qdep + vth_fixed_factor_Sub + QMFACTORCVfinal * T4;
        T1 = -qdep + vth_fixed_factor_SI;
    end
    T2 = (vgsfbeff - vch) / nVtm;
    F0 = -T2 + T1;
    T3 = 0.5 * (T2 - T0);
    qm = `lexp(T3);
    if (qm > 1.0e-7) begin
        T7 = ln(1.0 + qm);
        qm = 2.0 * (1.0 - sqrt(1.0 + T7 * T7));
        T8 = (qm * ALPHA_UFCM + qdep) * rc;
        T4 = T8 / (`lexp(T8) - T8 - 1.0);
        T5 = T8 * T4;
        qm_ln = ln(-(qm + qdep));
        e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
        e1 = -1.0 + 1.0 / qm + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
        e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
        qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
        T8 = (qm * ALPHA_UFCM + qdep) * rc;
        T4 = T8 / (`lexp(T8) - T8 - 1.0);
        T5 = T8 * T4;
        qm_ln = ln(-(qm + qdep));
        e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
        e1 = -1.0 + 1.0 / qm + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
        e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
        qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
    end else begin
        qm = -qm * qm;
    end
    qis = -qm * nVtm;

    //Gate-All-Around FET quantum subband model: source side
    if (SUBBANDMOD == 1) begin
        QT2 = (vgsfb - vch) / nVtm;
        QT3 = `smoothminx(QT2, 0, p1);
        QT4 = pow(QT3, d1 / 2);
        qnds1 = qnd10 * QT4 * `lexp(QT2 - QT3);

        QT5 = (vgsfb - vch - qe2) / nVtm;
        QT6 = `smoothminx(QT5, 0, p2);
        QT7 = pow(QT6, d2 / 2);
        qnds2 = qnd20 * QT7 * `lexp(QT5 - QT6);

        QT8 = (vgsfb - vch - qe3) / nVtm;
        QT9 = `smoothminx(QT8, 0, p3);
        QT10 = pow(QT9, d3 / 2);
        qnds3 = qnd30 * QT10 * `lexp(QT8 - QT9) ;

        qis = nc3d * qis + ncq * (qnds1 + qnds2 + qnds3);
    end

    // Drain-to-source saturation voltage
    Eeffs = EeffFactor * (qbs + eta_mu * qis);
    qb0 = 1.0e-2 / cox;
    T2 = pow((0.5 * (1.0 + qis / qb0)), UCS_t);
    T3 = pow(Eeffs, EU_a);
    if (BULKMOD != 0) begin
        T3 = (UA_a + UC_a * veseff) * T3 + UD_a / T2;
    end else begin
        T3 = UA_a * T3 + UD_a / T2;
    end
    Dmobs = 1.0 + T3;
    Dmobs = `smoothminx(Dmobs, 1.0, DMOBCLAMP);
    Dmobs = Dmobs / U0MULT;
    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else if (RDSMOD == 0) begin
        T4 = 1.0 + PRWGS_i * qis;
        T1 = 1.0 / T4;
        T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RDSWMIN + RDSW_i * T0) * WeffWRFactor * NFINtotal * rdstemp;
    end else begin
        T4 = 1.0 + PRWGS_i * qis;
        T1 = 1.0 / T4;
        T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RSourceGeo + RDrainGeo + (RDSWMIN + RDSW_i * T0) * WeffWRFactor * NFINtotal) * rdstemp;
    end
    Esat = 2.0 * VSAT_a / u0_a * Dmobs;
    EsatL = Esat * Leff;
    if (CRYOMOD == 0) begin
        T6 = KSATIV_a * (qis + 2.0 * Vtm);
    end else begin
        T6 = KSATIV_a * (qis + 2.0 * Vtmeff);
    end
    if (Rdss > 0.0) begin
        WVCox = Weff0 * VSAT_a * cox;
        T0 = WVCox * Rdss;
        Ta = 2.0 * T0;
        Tb = T6 + EsatL + 3.0 * T6 * T0;
        Tc = T6 * (EsatL + 2.0 * T6 * T0);
        Vdsat = (Tb - sqrt(Tb * Tb - 2.0 * Ta * Tc)) / Ta;
    end else begin
        Vdsat = EsatL * T6 / (EsatL + T6);
    end
    Vdsat = `hypsmooth((Vdsat - 1.0e-3), 1.0e-5) + 1.0e-3;
    T7 = pow((vds / Vdsat)+1e-6, MEXP_a);
    T8 = pow((1.0 + T7), inv_MEXP);
    Vdseff = min((vds / T8), vds);

    // Core model calculation at drain side
    vch = Vdseff + dvch_qm;
    T2 = pow(-qdep, `TWO_OV_3);
    if (BULKMOD != 0) begin
        T1 = `hypsmooth((2.0 * phib + vch - ves), 0.1);
        T3 = -K1_t / (2.0 * nVtm) * (sqrt(T1) - sqrt(2.0 * phib));
        T0 = -qdep - T3 + vth_fixed_factor_Sub + QMFACTORCVfinal * T2;
        T1 = -qdep - T3 + vth_fixed_factor_SI;
    end else begin
        T0 = -qdep + vth_fixed_factor_Sub + QMFACTORCVfinal * T2;
        T1 = -qdep + vth_fixed_factor_SI;
    end
    T2 = (vgsfbeff - vch) / nVtm;
    F0 = -T2 + T1;
    T3 = (T2 - T0) * 0.5;
    qm = `lexp(T3);
    if (qm > 1.0e-7) begin
        T7 = ln(1.0 + qm);
        qm = 2.0 * (1.0 - sqrt(1.0 + T7 * T7));
        T8 = (qm * ALPHA_UFCM + qdep) * rc;
        T4 = T8 / (`lexp(T8) - T8 - 1.0);
        T5 = T8 * T4;
        qm_ln = ln(-(qm + qdep));
        e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
        e1 = -1.0 + (1.0 / qm) + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
        e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
        qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
        T8 = (qm * ALPHA_UFCM + qdep) * rc;
        T4 = T8 / (`lexp(T8) - T8 - 1.0);
        T5 = T8 * T4;
        qm_ln = ln(-(qm + qdep));
        e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
        e1 = -1.0 + (1.0 / qm) + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
        e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
        qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
    end else begin
        qm = -qm * qm;
    end
    qid = -qm * nVtm;

    //Gate-All-Around quantum subband model: drain side
    if (SUBBANDMOD == 1) begin
        QT2 = (vgsfb - vch) / nVtm;
        QT3 = `smoothminx(QT2, 0, p1);
        QT4 = pow(QT3, d1 / 2);
        qndd1 = qnd10 * QT4 * `lexp(QT2 - QT3);

        QT5 = (vgsfb - vch - qe2) / nVtm;
        QT6 = `smoothminx(QT5, 0, p2);
        QT7 = pow(QT6, d2 / 2);
        qndd2 = qnd20 * QT7 * `lexp(QT5 - QT6);

        QT8 = (vgsfb - vch - qe3) / nVtm;
        QT9 = `smoothminx(QT8, 0, p3);
        QT10 = pow(QT9, d3 / 2);
        qndd3 = qnd30 * QT10 * `lexp(QT8 - QT9);

        qid = nc3d * qid + ncq * (qndd1 + qndd2 + qndd3);
    end

    // Core model calculation for C-V
    if (CVMOD == 1) begin
        // Delta Vth_cv
        dvth_dibl_cv = -ETA0CV_t * Theta_DIBL * vdsx + (DVTP0_i * Theta_DITS * pow(vdsx + 0.01, DVTP1_i));
        dvth_all_cv = dvth_vtroll + dvth_dibl_cv + dvth_rsce + dvth_temp + DVTSHIFT_a;
        vgsfb_cv = vgs - deltaPhi - dvth_all_cv;

        // Vgs clamping for inversion region
        beta0_cv = u0_cv * cox * Weff0 / Leff;
        if (CRYOMOD == 0) begin
            T0 = -(dvch_qm + nVtm * `lln(2.0 * cox * IMIN / (beta0_cv * nVtm * `q * Nc * TFIN)));
            T1 = vgsfb_cv + T0 + DELVTRAND;
            vgsfbeff_cv = `hypsmooth(T1, 1.0e-4) - T0;
        end else begin
            T0 = -nVtm * `lln(2.0 * cox * IMIN / (beta0_cv * nVtm * `q * Nc * TFIN));
            T1  = -dvch_qm + `smoothminx(T0, 0.01, 1e-4);
            T2 = vgsfb_cv + T1 + DELVTRAND;
            vgsfbeff_cv = `hypsmooth(T2, 1.0e-4) - T1;
        end

        // Core model calculation at source
        vch_cv = dvch_qm;
        T4 = pow(-qdep, `TWO_OV_3);
        if (BULKMOD != 0) begin
            T1 = `hypsmooth((2.0 * phib + vch_cv - ves), 0.1);
            T3 = -K1_t / (2.0 * nVtm) * (sqrt(T1) - sqrt(2.0 * phib));
            T0 = -qdep - T3 + vth_fixed_factor_Sub + QMFACTORCVfinal * T4;
            T1 = -qdep - T3 + vth_fixed_factor_SI;
        end else begin
            T0 = -qdep + vth_fixed_factor_Sub + QMFACTORCVfinal * T4;
            T1 = -qdep + vth_fixed_factor_SI;
        end
        T2 = (vgsfbeff_cv - vch_cv) / nVtm;
        F0 = -T2 + T1;
        T3 = 0.5 * (T2 - T0);
        qm = `lexp(T3);
        if (qm > 1.0e-7) begin
            T7 = ln(1.0 + qm);
            qm = 2.0 * (1.0 - sqrt(1.0 + T7 * T7));
            T8 = (qm * ALPHA_UFCM + qdep) * rc;
            T4 = T8 / (`lexp(T8) - T8 - 1.0);
            T5 = T8 * T4;
            qm_ln = ln(-(qm + qdep));
            e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
            e1 = -1.0 + 1.0 / qm + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
            e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
            qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
            T8 = (qm * ALPHA_UFCM + qdep) * rc;
            T4 = T8 / (`lexp(T8) - T8 - 1.0);
            T5 = T8 * T4;
            qm_ln = ln(-(qm + qdep));
            e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
            e1 = -1.0 + 1.0 / qm + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
            e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
            qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
        end else begin
            qm = -qm * qm;
        end
        qis_cv = -qm * nVtm;

        //Gate-All-Around FET quantum subband model: source side
        if (SUBBANDMOD == 1) begin
            QT2 = (vgsfb_cv - vch_cv) / nVtm;
            QT3 = `smoothminx(QT2, 0, p1);
            QT4 = pow(QT3, d1 / 2);
            qnds1 = qnd10 * QT4 * `lexp(QT2 - QT3);

            QT5 = (vgsfb_cv - vch_cv - qe2) / nVtm;
            QT6 = `smoothminx(QT5, 0, p2);
            QT7 = pow(QT6, d2 / 2);
            qnds2 = qnd20 * QT7 * `lexp(QT5 - QT6);

            QT8 = (vgsfb_cv - vch_cv - qe3) / nVtm;
            QT9 = `smoothminx(QT8, 0, p3);
            QT10 = pow(QT9, d3 / 2);
            qnds3 = qnd30 * QT10 * `lexp(QT8 - QT9) ;

            qis_cv = nc3d * qis_cv + ncq * (qnds1 + qnds2 + qnds3);
        end

        // Drain-to-source saturation voltage
        Eeffs_cv = EeffFactor * (qbs + eta_mu * qis_cv);
        T2 = pow((0.5 * (1.0 + qis_cv / qb0)), UCS_t);
        T3 = pow(Eeffs_cv, EU_a);
        if (BULKMOD != 0) begin
            T3 = (UACV_t + UCCV_t * veseff) * T3 + UDCV_t / T2;
        end else begin
            T3 = UACV_t * T3 + UDCV_t / T2;
        end
        Dmobs_cv = 1.0 + T3;
        Dmobs_cv = `smoothminx(Dmobs_cv, 1.0, DMOBCLAMP);
        Dmobs_cv = Dmobs_cv / U0MULT;
        if (RDSMOD == 1) begin
            Rdss_cv = 0.0;
        end else if (RDSMOD == 0) begin
            T4 = 1.0 + PRWGS_i * qis_cv;
            T1 = 1.0 / T4;
            T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdss_cv = (RDSWMIN + RDSW_i * T0) * WeffWRFactor * NFINtotal * rdstemp;
        end else begin
            T4 = 1.0 + PRWGS_i * qis_cv;
            T1 = 1.0 / T4;
            T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdss_cv = (RSourceGeo + RDrainGeo + (RDSWMIN + RDSW_i * T0) * WeffWRFactor * NFINtotal) * rdstemp;
        end
        Esats_cv = 2.0 * VSATCV_t / u0_cv * Dmobs_cv;
        EsatLs_cv = Esats_cv * Leff;
        if (CRYOMOD == 0) begin
            T6 = KSATIV_a * (qis_cv + 2.0 * Vtm);
        end else begin
            T6 = KSATIV_a * (qis_cv + 2.0 * Vtmeff);
        end
        if (Rdss_cv > 0.0) begin
            T0 = Weff0 * VSATCV_t * cox * Rdss_cv;
            Ta = 2.0 * T0;
            Tb = T6 + EsatLs_cv + 3.0 * T6 * T0;
            Tc = T6 * (EsatLs_cv + 2.0 * T6 * T0);
            Vdsat_cv = (Tb - sqrt(Tb * Tb - 2.0 * Ta * Tc)) / Ta;
        end else begin
            Vdsat_cv = EsatLs_cv * T6 / (EsatLs_cv + T6);
        end
        Vdsat_cv = `hypsmooth((Vdsat_cv - 1.0e-3), 1.0e-5) + 1.0e-3;
        T7 = pow((vds / Vdsat_cv) + 1e-6, MEXP_a);
        T8 = pow((1.0 + T7), inv_MEXP);
        Vdseff_cv = min((vds / T8), vds);

        // Core model calculation at drain side
        vch_cv = Vdseff_cv + dvch_qm;
        T2 = pow(-qdep, `TWO_OV_3);
        if (BULKMOD != 0) begin
            T1 = `hypsmooth((2.0 * phib + vch_cv - ves), 0.1);
            T3 = -K1_t / (2.0 * nVtm) * (sqrt(T1) - sqrt(2.0 * phib));
            T0 = -qdep - T3 + vth_fixed_factor_Sub + QMFACTORCVfinal * T2;
            T1 = -qdep - T3 + vth_fixed_factor_SI;
        end else begin
            T0 = -qdep + vth_fixed_factor_Sub + QMFACTORCVfinal * T2;
            T1 = -qdep + vth_fixed_factor_SI;
        end
        T2 = (vgsfbeff_cv - vch_cv) / nVtm;
        F0 = -T2 + T1;
        T3 = (T2 - T0) * 0.5;
        qm = `lexp(T3);
        if (qm > 1.0e-7) begin
            T7 = ln(1.0 + qm);
            qm = 2.0 * (1.0 - sqrt(1.0 + T7 * T7));
            T8 = (qm * ALPHA_UFCM + qdep) * rc;
            T4 = T8 / (`lexp(T8) - T8 - 1.0);
            T5 = T8 * T4;
            qm_ln = ln(-(qm + qdep));
            e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
            e1 = -1.0 + (1.0 / qm) + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
            e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
            qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
            T8 = (qm * ALPHA_UFCM + qdep) * rc;
            T4 = T8 / (`lexp(T8) - T8 - 1.0);
            T5 = T8 * T4;
            qm_ln = ln(-(qm + qdep));
            e0 = F0 - qm + `lln(-qm) + `lln(T5) + QMFACTORCVfinal * exp(`TWO_OV_3 * qm_ln);
            e1 = -1.0 + (1.0 / qm) + (2.0 / T8 - T4 - 1.0) * rc - `TWO_OV_3 * QMFACTORCVfinal * exp(-`ONE_OV_3 * qm_ln);
            e2 = -1.0 / (qm * qm) - (2.0 / 9.0) * QMFACTORCVfinal * exp(-`FOUR_OV_3 * qm_ln);
            qm = qm - (e0 / e1) * (1.0 + (e0 * e2) / (2.0 * e1 * e1));
        end else begin
            qm = -qm * qm;
        end
        qid_cv = -qm * nVtm;

        //Gate-All-Around quantum subband model: drain side
        if (SUBBANDMOD == 1) begin
            QT2 = (vgsfb_cv - vch_cv) / nVtm;
            QT3 = `smoothminx(QT2, 0, p1);
            QT4 = pow(QT3, d1 / 2);
            qndd1 = qnd10 * QT4 * `lexp(QT2 - QT3);

            QT5 = (vgsfb_cv - vch_cv - qe2) / nVtm;
            QT6 = `smoothminx(QT5, 0, p2);
            QT7 = pow(QT6, d2 / 2);
            qndd2 = qnd20 * QT7 * `lexp(QT5 - QT6);

            QT8 = (vgsfb_cv - vch_cv - qe3) / nVtm;
            QT9 = `smoothminx(QT8, 0, p3);
            QT10 = pow(QT9, d3 / 2);
            qndd3 = qnd30 * QT10 * `lexp(QT8 - QT9);

            qid_cv = nc3d * qid_cv + ncq * (qndd1 + qndd2 + qndd3);
        end
        qia_cv = 0.5 * (qis_cv + qid_cv);
        dqi_cv = qis_cv - qid_cv;
        T0 = Vdseff_cv * Vdseff_cv / 6.25e-4;
        if (CHARGEWF != 0.0) begin
            qia2_cv = 0.5 * (qis_cv + qid_cv) + CHARGEWF * (1.0 - `lexp(-T0)) * 0.5 * dqi_cv;
        end else begin
            qia2_cv = 0.5 * (qis_cv + qid_cv);
        end
        if (qis_cv < 0.0) begin
            $strobe("Warning: Negative source-side inversion carrier density for C-V. Vgs = %g Vds = %g Vbs = %g qis_cv = %g", V(g, s), V(d, s), V(e, s), qis_cv);
        end
        if (qid_cv < 0.0) begin
            $strobe("Warning: Negative drain-side inversion carrier density for C-V. Vgs = %g Vds = %g Vbs = %g qid_cv = %g", V(g, s), V(d, s), V(e, s), qid_cv);
        end
    end

    if (BULKMOD != 0) begin
        T9 = K1_t / (2.0 * nVtm) * sqrt(Vtm);
        T0 = T9 / 2.0;
        T2 = (vge - (deltaPhi - Eg - Vtm * `lln(NBODY_i / Nc) + DELVFBACC)) / Vtm;
        if ((T2 * Vtm) > phib + T9 * sqrt(phib * Vtm)) begin
            T1 = sqrt(T2 - 1.0 + T0 * T0) - T0;
            T10 = 1.0 + T1 * T1;
            T6 = `lexp(-T10) - 1.0;
        end else begin
            T3 = T2 * 0.5 - 3.0 * (1.0 + T9 / sqrt(2.0));
            T10 = T3 + sqrt(T3 * T3 + 6.0 * T2);
            if (T2 < 0.0) begin
                T4 = (T2 - T10) / T9;
                T6 = -T10 + T4 * T4;
                T10 = -`lln(1.0 - T10 + T4 * T4);
            end else begin
                T11 = `lexp(-T10);
                T4 = sqrt(T2 - 1.0 + T11 + T0 * T0) - T0;
                T10 = 1.0 - T11 + T4 * T4;
                T6  = `lexp(-T10) - 1.0;
            end
        end
        T7 = sqrt(T6 + T10);
        if (T10 > 1.0e-15) begin
            e0 = -(T2 - T10) + T9 * T7;
            e1 = 1.0 - T9 * 0.5 * T6 / T7;
            T8 = T10 - (e0 / e1);
            T11 = `lexp(-T8) - 1.0;
            T12 = sqrt(T11 + T8);
            qba = -T9 * T12 * Vtm;
        end else begin
            if (T10 < -1.0e-15) begin
                e0 = -(T2 - T10) - T9 * T7;
                e1 = 1.0 + T9 * 0.5 * T6 / T7;
                T8 = T10 - e0 / e1;
                T12a = `lexp(-T8) + T8 - 1.0;
                if (T12a <= 0) begin
                    T12 = 0.0;
                end else begin
                    T12 = T9 * sqrt(T12a);
                end

            end else begin
                T8 = 0.0;
                T12 = 0.0;
            end
            qba = T12 * Vtm;
        end
        qi_acc_for_QM = T9 * `lexp(-T8 / 2.0) * Vtm;
        psipclamp = 0.5 * (T8 + 1.0 + sqrt((T8 - 1.0) * (T8 - 1.0) + 0.25 * 2.0 * 2.0));
        sqrtpsip = sqrt(psipclamp);
        nq = 1.0 + T9 / sqrtpsip;
    end

    // Average surface potential / charge
    qia = 0.5 * (qis + qid);
    dqi = qis - qid;
    T0 = Vdseff * Vdseff / 6.25e-4;
    if (CHARGEWF != 0.0) begin
        qia2 = 0.5 * (qis + qid) + CHARGEWF * (1.0 - `lexp(-T0)) * 0.5 * dqi;
    end else begin
        qia2 = 0.5 * (qis + qid);
    end
    if (qis < 0.0) begin
        $strobe("Warning: Negative source-side inversion carrier density. Vgs = %g Vds = %g Vbs = %g qis = %g", V(g, s), V(d, s), V(e, s), qis);
    end
    if (qid < 0.0) begin
        $strobe("Warning: Negative drain-side inversion carrier density. Vgs = %g Vds = %g Vbs = %g qid = %g", V(g, s), V(d, s), V(e, s), qid);
    end

    // Toxeff model for quantum mechanical effects
    if (QMTCENCV_i > 0.0) begin
        T4 = qia / QM0;
        T5 = 1.0 + pow(T4, PQM);
        Tcen = Tcen0 / T5;
        coxeff = 1.0 / (1.0 / (cox * EOT / TOXP) + Tcen * QMTCENCV_i / epssub);
    end else begin
        coxeff = cox;
    end
    // Quantum mechanical effect correction for accumulation
    if (BULKMOD != 0 && QMTCENCVA_i != 0.0) begin
        T6 = 1.0 + pow((qi_acc_for_QM / QM0ACC), PQMACC);
        Tcen = Tcen0 / T6;
        cox_acc = 1.0 / (1.0 / cox_acc + Tcen * QMTCENCVA_i / epssub);
    end

    // Multiplication factor for I-V
    beta = u0_a * cox * Weff0 / Leff;

    // Mobility degradation
    Eeffm = EeffFactor * (qbs + eta_mu * qia2);
    if (CRYOMOD == 0) begin
        T2 = pow((0.5 * (1.0 + qia2 / qb0)), UCS_t);
    end else begin
        T0 = UDSeff_t * qis + UDDeff_t * qid;
        T1 = `hypsmooth(T0, 1.0e-12);
        T2 = pow((0.5 * (1.0 + T1 / qb0)), UCS_t);
    end
    T0 = pow(Eeffm, EU_a);
    if (BULKMOD != 0) begin
        T3 = (UA_a + UC_a * veseff) * T0 + UD_a / T2;
    end else begin
        T3 = UA_a * T0 + UD_a / T2;
    end
    Dmob = 1.0 + T3;
    Dmob = `smoothminx(Dmob, 1.0, DMOBCLAMP);
    Dmob = Dmob / U0MULT;
    ueff = u0_a / Dmob;

    // Mobility degradation for C-V
    if (CVMOD == 1) begin
        if (CRYOMOD == 0) begin
            T2 = pow((0.5 * (1.0 + qia2_cv / qb0)), UCS_t);
        end else begin
            T0 = UDSeff_t * qis_cv + UDDeff_t * qid_cv;
            T1 = `hypsmooth(T0, 1.0e-12);
            T2 = pow((0.5 * (1.0 + T1 / qb0)), UCS_t);
        end
        Eeffm_cv = EeffFactor * (qbs + eta_mu_cv * qia2_cv);
        T3 = UACV_t * pow(Eeffm_cv, EU_a) + UDCV_t / T2;
    end else begin
        Eeffm_cv = EeffFactor * (qbs + eta_mu_cv * qia2);
        T3 = UA_a * pow(Eeffm_cv, EU_a) + UD_a / T2;
    end
    Dmob_cv = 1.0 + T3;
    Dmob_cv = `smoothminx(Dmob_cv, 1.0, DMOBCLAMP);
    Dmob_cv = Dmob_cv / U0MULT;

    // CLM and DIBL effects
    tmp = DROUT_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        DIBLfactor = 0.5 * PDIBL1_a / (cosh(tmp) - 1.0) + PDIBL2_a;
    end else begin
        DIBLfactor = PDIBL1_a * `lexp(-tmp) + PDIBL2_a;
    end
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end
    diffVds = vds - Vdseff;
    if (CRYOMOD == 0) begin
        Vgst2Vtm = qia + 2.0 * Vtm;
    end else begin
        Vgst2Vtm = qia + 2.0 * Vtmeff;
    end
    if (DIBLfactor > 0.0) begin
        T1 = Vgst2Vtm;
        T3 = T1 / (Vdsat + T1);
        VaDIBL = T1 / DIBLfactor * T3 * PVAGfactor;
        Moc = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end
    if (PCLM_a > 0.0) begin
        if (PCLMG_i < 0.0) begin
            T1 = 1.0 / (1.0 / PCLM_a - PCLMG_i * qia);
        end else begin
            T1 = PCLM_a + PCLMG_i * qia;
        end
        Mclm = 1.0 + T1 * `lln(1.0 + (vds - Vdseff) / T1 / (Vdsat + EsatL));
    end else begin
        Mclm = 1.0;
    end
    Moc = Moc * Mclm;

    // Current degradation due to velocity saturation
    Esat1 = 2.0 * VSAT1_a / ueff;
    Esat1L = Esat1 * Leff;
    T0 = `lexp(PSAT_i * `lln(dqi / Esat1L));
    T1 = 1.0 / PSAT_i;
    Ta = 1.0 + `lexp(T1 * `lln(DELTAVSAT_i));
    Dvsat = (1.0 + `lexp(T1 * `lln(DELTAVSAT_i + T0))) / Ta;
    Dvsat = Dvsat + 0.5 * PTWG_a * qia * dqi * dqi;

    // Non-saturation effect
    T0 = A1_t + A2_t / (qia + 2.0 * nVtm);
    T1 = T0 * dqi * dqi;
    T2 = T1 + 1.0 - 0.001;
    T3 = -1.0 + 0.5 * (T2 + sqrt(T2 * T2 + 0.004));
    Nsat = 0.5 * (1.0 + sqrt(1.0 + T3));
    Dvsat = Dvsat * Nsat;
    Dvsat = `smoothminx(Dvsat, 1.0, DVSATCLAMP);

    // Lateral non-uniform doping effect (Vth shift between I-V and C-V)
    T1 = K0_t / (max(0.0, K0SI_t + K0SISAT_t * dqi * dqi) * qia + 2.0 * nVtm);
    Mnud = `lexp(-T1);

    // Body effect for BULKMOD = 2
    if (BULKMOD == 2) begin
        T0 = `hypsmooth((K2_t + K2SAT_t * vdsx), 1.0e-6);
        T1 = T0 / (max(0.0, K2SI_t + K2SISAT_t * dqi * dqi) * qia + 2.0 * nVtm);
        T3 = sqrt(PHIBE_i - veseff) - sqrt(PHIBE_i);
        Mob = `lexp(-T1 * T3);
    end else begin
        Mob = 1.0;
    end

    // Velocity saturation for C-V
    if (CVMOD == 1) begin
        EsatCV = 2.0 * VSATCV_t * Dmob_cv / u0_cv;
    end else begin
        EsatCV = 2.0 * VSATCV_t * Dmob_cv / u0_a;
    end
    EsatCVL = EsatCV * LeffCV;
    if (CVMOD == 1) begin
        T0 = pow((dqi_cv / EsatCVL), PSATCV_i);
    end else begin
        T0 = pow((dqi / EsatCVL), PSATCV_i);
    end
    T1 = 1.0 / PSATCV_i;
    Ta = 1.0 + pow(DELTAVSATCV_i, T1);
    DvsatCV = (1.0 + pow((DELTAVSATCV_i + T0), T1)) / Ta;

    // Channel Length Modulation for C-V
    if (PCLMCV_i != 0.0) begin
        MclmCV = 1.0 + PCLMCV_i * `lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL));
    end else begin
        MclmCV = 1.0;
    end

    // Fixed body charge qb
    qb = -`q * NBODY_i * Ach * LeffCV;

    // Quasi-static I-V model
    etaiv = q0 / (q0 + qia);
    ids0_ov_dqi = qia + (2.0 - etaiv) * nVtm;
    ids0 = ids0_ov_dqi * dqi;

    // Source/drain series resistance
    case (RDSMOD)
        // Bias-dependent part of parasitic resistances is internal, bias-independent part is external
        0: begin
            Rsource = RSourceGeo;
            Rdrain = RDrainGeo;
            T4 = 1.0 + PRWGS_i * qia;
            T1 = 1.0 / T4;
            T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi = rdstemp * (RDSWMIN + RDSW_i * T0) * WeffWRFactor;
            Dr = 1.0 + NFINtotal * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi;
        end
        // Both bias-dependent and bias-independent parts of parasitic resistances are external
        1: begin
            Rdsi = 0.0;
            Dr = 1.0;
            T2 = devsign * V(gi, si1) - vfbsd;
            T3 = sqrt(T2 * T2 + 0.1);
            vgs_eff = 0.5 * (T2 + T3);
            T4 = 1.0 + PRWGS_i * vgs_eff;
            T1 = 1.0 / T4;
            T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            T5 = RSW_i * (1.0 + RSDR_a * pow((V(s, si1) * V(s, si1) + 1.0e-6), (0.5 * PRSDR)));
            Rsource = rdstemp * (RSourceGeo + (RSWMIN + T5 * T0) * WeffWRFactor);
            T2 = devsign * V(gi, di1) - vfbsd;
            T3 = sqrt(T2 * T2 + 0.1);
            vgd_eff = 0.5 * (T2 + T3);
            T4 = 1.0 + PRWGD_i * vgd_eff;
            T1 = 1.0 / T4;
            T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            T5 = RDW_i * (1.0 + RDDR_a * pow((V(d, di1) * V(d, di1) + 1.0e-6), (0.5 * PRDDR)));
            Rdrain = rdstemp * (RDrainGeo + (RDWMIN + T5 * T0) * WeffWRFactor);
        end
        // Both bias-dependent and bias-independent parts of parasitic resistances are internal
        2: begin
            T4 = 1.0 + PRWGS_i * qia;
            T1 = 1.0 / T4;
            T0 = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi = rdstemp * ((RDSWMIN + RDSW_i * T0) * WeffWRFactor + RSourceGeo + RDrainGeo) ;
            Dr = 1.0 + NFINtotal * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi;
            Rsource = 0.0;
            Rdrain = 0.0;
        end
    endcase

    // Drain current
    ids = NFINtotal * beta * ids0 * Moc * Mnud * Mob / (Dmob * Dvsat * Dr);
    ids = ids * IDS0MULT;

    // Quasi-static C-V model
    if (CVMOD == 1) begin
        T11 = (2.0 * qia_cv + nVtm) / DvsatCV;
        qg = qia_cv + dqi_cv * dqi_cv / (6.0 * T11);
        qd = -0.5 * (qia_cv - (dqi_cv / 6.0) * (1.0 - (dqi_cv / T11) * (1.0 + dqi_cv / (5.0 * T11))));
    end else begin
        T11 = (2.0 * qia + nVtm) / DvsatCV;
        qg = qia + dqi * dqi / (6.0 * T11);
        qd = -0.5 * (qia - (dqi / 6.0) * (1.0 - (dqi / T11) * (1.0 + dqi / (5.0 * T11))));
    end

    // CLM in qg and qd
    inv_MclmCV = 1.0 / MclmCV;
    qg = inv_MclmCV * qg + (MclmCV - 1.0) * qid;
    qd = inv_MclmCV * inv_MclmCV * qd + 0.5 * (MclmCV - inv_MclmCV) * qid;

    if (NQSMOD == 2) begin
        xdpart = qd / qg;
    end else begin
        xdpart = 0.0;
    end

    qs = -qg - qd;
    T6 = NFINtotal * WeffCV0 * LeffCV * coxeff;
    qg = T6 * qg;
    qd = T6 * qd;
    qs = T6 * qs;
    qinv = qg;

    if (BULKMOD != 0) begin
        if (GEOMOD == 5) begin
            T1 = NFINtotal * WeffCV_acc * LeffCV_acc * cox_acc;
        end else begin
            T1 = NFINtotal * WeffCV0 * LeffCV_acc * cox_acc;
        end
        T7 = qi_acc_for_QM;
        T10 = T7 * T1;
        qg_acc = -T10;
        qb_acc = T10;
        T1 = NFINtotal * WeffCV0 * LeffCV * cox;
        T2 = qba - qi_acc_for_QM;
        T10 = T1 * T2;
        qg_acc = qg_acc - T10;
        qb_acc = qb_acc + T10;
        T1 = NFINtotal * WeffCV0 * LeffCV * cox;
        T2 = (nq - 1.0) * 0.5 * (qia + (dqi * dqi / (6.0 * T11)));
        T10 = T1 * T2;
        qg_acc = qg_acc - T10;
        qb_acc = qb_acc + T10;
    end

    if (sigvds < 0.0) begin
        T1 = qd;
        qd = qs;
        qs = T1;
    end

    // Bias-dependent overlap capacitances
    if (CGEOMOD != 1) begin
        T1 = NFINtotal * WeffCV0 * devsign;
        T2 = devsign * V(ge, si);
        T0 = T2 - vfbsdcv + `DELTA_1;
        vgs_overlap = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
        qgs_ov = T1 * (CGSL_i * (T2 - vfbsdcv - vgs_overlap - 0.5 * CKAPPAS_i * (sqrt(1.0 - 4.0 * vgs_overlap / CKAPPAS_i) - 1.0)) + CGSO_i * T2);
        T2 = devsign * V(ge, di);
        T0 = T2 - vfbsdcv + `DELTA_1;
        vgd_overlap = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
        qgd_ov = T1 * (CGDL_i * (T2 - vfbsdcv - vgd_overlap - 0.5 * CKAPPAD_i * (sqrt(1.0 - 4.0 * vgd_overlap / CKAPPAD_i) - 1.0)) + CGDO_i * T2);
    end
    if (CGEOMOD == 0) begin
        T1 = NFINtotal * WeffCV0;
        qgs_fr = T1 * CFS_i * V(ge, si);
        qgd_fr = T1 * CFD_i * V(ge, di);
        qgs_parasitic = qgs_ov + qgs_fr;
        qgd_parasitic = qgd_ov + qgd_fr;
    end else if (CGEOMOD == 1) begin
        if (CGEO1SW == 1) begin
            T0 = NFINtotal * WeffCV0;
            COVS_i = T0 * COVS_i;
            COVD_i = T0 * COVD_i;
            cgsp = T0 * CGSP;
            cgdp = T0 * CGDP;
        end else begin
            cgsp = CGSP;
            cgdp = CGDP;
        end
        qgs_ov = COVS_i * V(ge, si);
        qgd_ov = COVD_i * V(ge, di);
        qgs_parasitic = qgs_ov;
        qgd_parasitic = qgd_ov;
        qgs_fr = cgsp * V(ge, s);
        qgd_fr = cgdp * V(ge, d);
    end else begin
        qgs_fr = Cfr_geo * V(ge, si);
        qgd_fr = Cfr_geo * V(ge, di);
        qgs_parasitic = qgs_ov + qgs_fr;
        qgd_parasitic = qgd_ov + qgd_fr;
    end

    // Drain-to-source fringe capacitance
    qds_fr = CDSP * V(d, s);

    // Impact ionization current
    if (IIMOD == 1) begin
        T0 = (ALPHA0_t + ALPHA1_t * Leff) / Leff;
        if ((T0 <= 0.0) || (BETA0_t <= 0.0))
            Iii = 0.0;
        else begin
            T1 = -BETA0_t / (diffVds + 1.0e-30);
            Iii = T0 * diffVds * ids * `lexp(T1);
        end
    end else if (IIMOD == 2) begin
        ALPHAII = (ALPHAII0_t + ALPHAII1_t * Leff) / Leff;
        if (ALPHAII <= 0.0) begin
            Iii = 0.0;
        end else begin
            T0 = ESATII_i * Leff;
            T1 = SII0_t * T0 / (1.0 + T0);
            T0 = 1.0 / (1.0 + `hypsmooth((SII1_i * vgsfbeff), IIMOD2CLAMP1));
            T3 = T0 + SII2_i;
            T2 = `hypsmooth((vgsfbeff * T3), IIMOD2CLAMP2);
            T3 = 1.0 / (1.0 + SIID_i * vds);
            VgsStep = T1 * T2 * T3;
            Vdsatii = VgsStep * (1.0 - LII_i / Leff);
            Vdiff = vds - Vdsatii;
            T0 = BETAII2_i + BETAII1_i * Vdiff + BETAII0_i * Vdiff * Vdiff;
            T1 = sqrt(T0 * T0 + 1.0e-10);
            Ratio = -`hypmax(-ALPHAII * `lexp(Vdiff / T1), -10.0, IIMOD2CLAMP3);
            Iii = Ratio * ids;
        end
    end

    // Gate currents, Ref: BSIM4
    // Igb calculation
    if (IGBMOD != 0) begin
        // Igbinv
        T1 = (qia - EIGBINV_i) / NIGBINV_i / Vtm;
        Vaux_Igbinv = NIGBINV_i * Vtm * ln_one_plus_exp(T1);
        T2 = `hypmax(AIGBINV_t - BIGBINV_i * qia, -IGBINVCLAMP, 1.0e-6);
        T3 = 1.0 + CIGBINV_i * qia;
        T4 = -9.82222e11 * TOXG * T2 * T3;
        T5 = `lexp(T4);
        T6 = 3.75956e-7;
        igbinv = Weff0 * Leff * T6 * Toxratio * vge * Vaux_Igbinv * T5;
        igbinv = IGB0MULT * igbinv * igtemp;
        // Igbacc
        vfbzb = deltaPhi - (Eg / 2.0) - phib;
        T0 = vfbzb - vge;
        T1 = T0 / NIGBACC_i / Vtm;
        Vaux_Igbacc = NIGBACC_i * Vtm * ln_one_plus_exp(T1);
        if (BULKMOD != 0) begin
            Voxacc = qi_acc_for_QM;
        end else begin
            if (vfbzb <= 0.0) begin
                Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) - 0.08 * vfbzb));
            end else begin
                Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) + 0.08 * vfbzb));
            end
        end
        T2 = `hypmax(AIGBACC_t - BIGBACC_i * Voxacc, -IGBACCCLAMP, 1.0e-6);
        T3 = 1.0 + CIGBACC_i * Voxacc;
        T4 = -7.45669e11 * TOXG * T2 * T3;
        T5 = `lexp(T4);
        T6 = 4.97232e-7;
        igbacc = Weff0 * Leff * T6 * Toxratio * vge * Vaux_Igbacc * T5;
        igbacc = IGB0MULT * igbacc * igtemp;
    end
    // Igc calculation
    if (IGCMOD != 0) begin
        // Igcinv
        T1 = `hypmax(AIGC_t - BIGC_i * qia, -IGCINVCLAMP, 1.0e-6);
        T2 = 1.0 + CIGC_i * qia;
        T3 = -Bechvb * TOXG * T1 * T2;
        T4 = qia * `lexp(T3);
        T5 = (vge + 0.5 * vdsx + 0.5 * (ves_jct + ved_jct));
        igc0 = IGC0MULT * Weff0 * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;
        // Gate-current partitioning
        Vdseffx = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1 = PIGCD_i * Vdseffx;
        T1_exp = `lexp(-T1);
        T3 = T1 + T1_exp - 1.0 + 1.0e-4;
        T4 = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5 = T1 * T1 + 2.0e-4;
        igcd = igc0 * T4 / T5;
        igcs = igc0 * T3 / T5;
        // Igs
        T0 = vgs_noswap - vfbsd;
        vgs_eff = sqrt(T0 * T0 + 1.0e-4);
        if (IGCLAMP == 1) begin
            T1 = `hypsmooth((AIGS_t - BIGS_i * vgs_eff), 1.0e-6);
            if (CIGS_i < 0.01) begin
                CIGS_i = 0.01;
            end
        end else begin
            T1 = AIGS_t - BIGS_i * vgs_eff;
        end
        T2 = 1.0 + CIGS_i * vgs_eff;
        T3 = -Bechvb * TOXG * POXEDGE_i * T1 * T2;
        T4 = `lexp(T3);
        if (sigvds > 0.0) begin
            igs = igsd_mult * DLCIGS * vgs_noswap * vgs_eff * T4;
        end else begin
            igd = igsd_mult * DLCIGS * vgs_noswap * vgs_eff * T4;
        end
        // Igd
        T0 = vgd_noswap - vfbsd;
        vgd_eff = sqrt(T0 * T0 + 1.0e-4);
        if (IGCLAMP == 1) begin
            T1 = `hypsmooth((AIGD_t - BIGD_i * vgd_eff), 1.0e-6);
            if (CIGD_i < 0.01) begin
                CIGD_i = 0.01;
            end
        end else begin
            T1 = AIGD_t - BIGD_i * vgd_eff;
        end
        T2 = 1.0 + CIGD_i * vgd_eff;
        T3 = -Bechvb * TOXG * POXEDGE_i * T1 * T2;
        T4 = `lexp(T3);
        if (sigvds > 0.0) begin
            igd = igsd_mult * DLCIGD * vgd_noswap * vgd_eff * T4;
        end else begin
            igs = igsd_mult * DLCIGD * vgd_noswap * vgd_eff * T4;
        end
    end

    // GIDL, GISL currents, Ref: BSIM4
    if (GIDLMOD != 0) begin
        T0 = epsratio * EOT;
        // GIDL current
        if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgd_noswap - EGIDL_i + vfbsd) / T0;
            T1 = `hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            T3 = pow(T1, PGIDL_i);
            if (BULKMOD != 0) begin
                T4 = -ved_jct * ved_jct * ved_jct;
                T4a = CGIDL_i + abs(T4) + 1.0e-5;
                T5 = `hypsmooth((T4 / T4a), 1.0e-6) - 1.0e-6;
                T6 = AGIDL_i * Weff0 * T3 * `lexp(-T2) * T5;
            end else begin
                T6 = AGIDL_i * Weff0 * T3 * `lexp(-T2) * vds_noswap;
            end
        end
        if (BULKMOD != 0 && GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
            BGIDLB_t = BGIDLB_i * `hypsmooth((1.0 + TGIDL_i * delTemp - 1.0e-6), 1.0e-3);
            if ((AGIDLB_i <= 0.0) || (BGIDLB_t <= 0.0)) begin
                T7 = 0.0;
            end else begin
                T1 = (-vgd_noswap - EGIDLB_i + vfbsd) / T0;
                T1 = `hypsmooth(T1, 1.0e-2);
                T2 = BGIDLB_t / (T1 + 1.0e-3);
                T3 = pow(T1, PGIDLB_i);
                T4 = -ved_jct * ved_jct * ved_jct;
                T4a = CGIDLB_i + abs(T4) + 1.0e-5;
                T5 = `hypsmooth((T4 / T4a), 1.0e-6) - 1.0e-6;
                T7 = AGIDLB_i * WeffB * T3 * `lexp(-T2) * T5;
            end
        end
        if (sigvds > 0.0) begin
            igidl = T6;
            igidlb = T7;
        end else begin
            igisl = T6;
            igislb = T7;
        end
        // GISL current
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgs_noswap - EGISL_i + vfbsd) / T0;
            T1 = `hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            T3 = pow(T1, PGISL_i);
            if (BULKMOD != 0) begin
                T4 = -ves_jct * ves_jct * ves_jct;
                T4a = CGISL_i + abs(T4) + 1.0e-5;
                T5 = `hypsmooth((T4 / T4a), 1.0e-6) - 1.0e-6;
                T6 = AGISL_i * Weff0 * T3 * `lexp(-T2) * T5;
            end else begin
                T6 = AGISL_i * Weff0 * T3 * `lexp(-T2) * (-vds_noswap);
            end
        end
        if (BULKMOD != 0 && GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
            BGISLB_t = BGISLB_i * `hypsmooth((1.0 + TGIDL_i * delTemp - 1.0e-6), 1.0e-3);
            if ((AGISLB_i <= 0.0) || (BGISLB_t <= 0.0)) begin
                T7 = 0.0;
            end else begin
                T1 = (-vgs_noswap - EGISLB_i + vfbsd) / T0;
                T1 = `hypsmooth(T1, 1.0e-2);
                T2 = BGISLB_t / (T1 + 1.0e-3);
                T3 = pow(T1, PGISLB_i);
                T4 = -ves_jct * ves_jct * ves_jct;
                T4a = CGISLB_i + abs(T4) + 1.0e-5;
                T5 = `hypsmooth((T4 / T4a), 1.0e-6) - 1.0e-6;
                T7 = AGISLB_i * WeffB * T3 * `lexp(-T2) * T5;
            end
        end
        if (sigvds > 0.0) begin
            igisl = T6;
            igislb = T7;
        end else begin
            igidl = T6;
            igidlb = T7;
        end
    end

    // Junction currents
    if (BULKMOD != 0) begin
        // Source-side junction current
        if (Isbs > 0.0) begin
            if (ves_jct < VjsmRev) begin
                T0 = ves_jct / Nvtms;
                T1 = `lexp(T0) - 1.0;
                T2 = IVjsmRev + SslpRev * (ves_jct - VjsmRev);
                Ies = T1 * T2;
            end else if (ves_jct <= VjsmFwd) begin
                T0 = ves_jct / Nvtms;
                T1 = (BVS + ves_jct) / Nvtms;
                T2 = `lexp(-T1);
                Ies = Isbs * (`lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
            end else begin
                Ies = IVjsmFwd + SslpFwd * (ves_jct - VjsmFwd);
            end
        end else begin
            Ies = 0.0;
        end
        // Source-side junction tunneling current
        if (JTSS_t > 0.0) begin
            if ((VTSS - ves_jct) < (VTSS * 1.0e-3)) begin
                T0 = -ves_jct / Vtm0 / NJTS_t;
                T1 = `lexp(T0 * 1.0e3) - 1.0;
                Ies = Ies - ASEJ * JTSS_t * T1;
            end else begin
                T0 = -ves_jct / Vtm0 / NJTS_t;
                T1 = `lexp(T0 * VTSS / (VTSS - ves_jct)) - 1.0;
                Ies = Ies - ASEJ * JTSS_t * T1;
            end
        end
        if (JTSSWS_t > 0.0) begin
            if ((VTSSWS - ves_jct) < (VTSSWS * 1.0e-3)) begin
                T0 = -ves_jct / Vtm0 / NJTSSW_t;
                T1 = `lexp(T0 * 1.0e3) - 1.0;
                Ies = Ies - PSEJ * JTSSWS_t * T1;
            end else begin
                T0 = -ves_jct / Vtm0 / NJTSSW_t;
                T1 = `lexp(T0 * VTSSWS / (VTSSWS - ves_jct)) - 1.0;
                Ies = Ies - PSEJ * JTSSWS_t * T1;
            end
        end
        if (JTSSWGS_t > 0.0) begin
            if ((VTSSWGS - ves_jct) < (VTSSWGS * 1.0e-3)) begin
                T0 = -ves_jct / Vtm0 / NJTSSWG_t;
                T1 = `lexp(T0 * 1.0e3) - 1.0;
                Ies = Ies - Weff0 * NFINtotal * JTSSWGS_t * T1;
            end else begin
                T0 = -ves_jct / Vtm0 / NJTSSWG_t;
                T1 = `lexp(T0 * VTSSWGS / (VTSSWGS - ves_jct)) - 1.0;
                Ies = Ies - Weff0 * NFINtotal * JTSSWGS_t * T1;
            end
        end
        // Drain-side junction current
        if (Isbd > 0.0) begin
            if (ved_jct < VjdmRev) begin
                T0 = ved_jct / Nvtmd;
                T1 = `lexp(T0) - 1.0;
                T2 = IVjdmRev + DslpRev * (ved_jct - VjdmRev);
                Ied = T1 * T2;
            end else if (ved_jct <= VjdmFwd) begin
                T0 = ved_jct / Nvtmd;
                T1 = (BVD + ved_jct) / Nvtmd;
                T2 = `lexp(-T1);
                Ied = Isbd * (`lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
            end else begin
                Ied = IVjdmFwd + DslpFwd * (ved_jct - VjdmFwd);
            end
        end else begin
            Ied = 0.0;
        end
        // Drain-side junction tunneling current
        if (JTSD_t > 0.0) begin
            if ((VTSD - ved_jct) < (VTSD * 1.0e-3)) begin
                T0 = -ved_jct / Vtm0 / NJTSD_t;
                T1 = `lexp(T0 * 1.0e3) - 1.0;
                Ied = Ied - ADEJ * JTSD_t * T1;
            end else begin
                T0 = -ved_jct / Vtm0 / NJTSD_t;
                T1 = `lexp(T0 * VTSD/ (VTSD - ved_jct)) - 1.0;
                Ied = Ied - ADEJ * JTSD_t * T1;
            end
        end
        if (JTSSWD_t > 0.0) begin
            if ((VTSSWD - ved_jct) < (VTSSWD * 1.0e-3)) begin
                T0 = -ved_jct / Vtm0 / NJTSSWD_t;
                T1 = `lexp(T0 * 1.0e3) - 1.0;
                Ied = Ied - PDEJ * JTSSWD_t * T1;
            end else begin
                T0 = -ved_jct / Vtm0 / NJTSSWD_t;
                T1 = `lexp(T0 * VTSSWD / (VTSSWD - ved_jct)) - 1.0;
                Ied = Ied - PDEJ * JTSSWD_t * T1;
            end
        end
        if (JTSSWGD_t > 0.0) begin
            if ((VTSSWGD - ved_jct) < (VTSSWGD * 1.0e-3)) begin
                T0 = -ved_jct / Vtm0 / NJTSSWGD_t;
                T1 = `lexp(T0 * 1.0e3) - 1.0;
                Ied = Ied - Weff0 * NFINtotal * JTSSWGD_t * T1;
            end else begin
                T0 = -ved_jct / Vtm0 / NJTSSWGD_t;
                T1 = `lexp(T0 * VTSSWGD / (VTSSWGD - ved_jct)) - 1.0;
                Ied = Ied - Weff0 * NFINtotal * JTSSWGD_t * T1;
            end
        end
        // Source-to-substrate junction capacitance
        `junction_cap(ves_jct, vec1s, pb21s, Czbs, PBS_t, SJS, MJS, MJS2, Qesj1)
        `junction_cap(ves_jct, vec2s, pb22s, Czbssw, PBSWS_t, SJSWS, MJSWS, MJSWS2, Qesj2)
        `junction_cap(ves_jct, vec3s, pb23s, Czbsswg, PBSWGS_t, SJSWGS, MJSWGS, MJSWGS2, Qesj3)
        Qesj = Qesj1 + Qesj2 + Qesj3;
        // Drain-to-substrate junction capacitance
        `junction_cap(ved_jct, vec1d, pb21d, Czbd, PBD_t, SJD, MJD, MJD2, Qedj1)
        `junction_cap(ved_jct, vec2d, pb22d, Czbdsw, PBSWD_t, SJSWD, MJSWD, MJSWD2, Qedj2)
        `junction_cap(ved_jct, vec3d, pb23d, Czbdswg, PBSWGD_t, SJSWGD, MJSWGD, MJSWGD2, Qedj3)
        Qedj = Qedj1 + Qedj2 + Qedj3;
    end
    Qes = Qesj + csbox * ves_jct;
    Qed = Qedj + cdbox * ved_jct;

    // Gate-to-substrate parasitic capacitance
    // Bias-independent component
    Qeg = cgbox * devsign * V(e, ge);
    // Bias-dependent component
    if (BULKMOD != 0) begin
        T2 = devsign * V(ge, e);
        T3 = T2 - deltaPhi + Eg / 2.0 + phib - DELVFBACC;
        T0 = T3 + `DELTA_1;
        vge_overlap = 0.5 * (T0 + sqrt(T0 * T0 + 4.0 * `DELTA_1));
        Qeg = Qeg - NFINtotal * LeffCV * (CGBL_i * (T3 - vge_overlap + 0.5 * CKAPPAB_i * (sqrt(1.0 + 4.0 * vge_overlap / CKAPPAB_i) - 1.0)));
    end

    // Generation-recombination component
    T1 = vds * (AIGEN_i + BIGEN_i * vds * vds);
    idsgen = HFIN * TFIN * (Leff - 2.0 * LINTIGEN_i) * igentemp * T1;

    // NQS gate resistance, Ref: BSIM4
    T0 = ueff * coxeff * Weff0 / Leff;
    if (NQSMOD != 0 && XRCRG1_i != 0.0) begin
        IdovVds = beta * ids0_ov_dqi * Moc / (Dmob * Dvsat * Dr);
        gcrg = NFINtotal * XRCRG1_i * (IdovVds + XRCRG2_i * Vtm * T0);
    end
    if (NQSMOD == 2) begin
        gtau = 1e-9 * gcrg / (cox * Weff0 * Leff);
    end

    // Multiply all current and charge components by NFINtotal
    igidl = NFINtotal * igidl;
    igisl = NFINtotal * igisl;
    igidlb = NFINtotal * igidlb;
    igislb = NFINtotal * igislb;
    igcd = NFINtotal * igcd;
    igcs = NFINtotal * igcs;
    igs = NFINtotal * igs;
    igd = NFINtotal * igd;
    igbinv = NFINtotal * igbinv;
    igbacc = NFINtotal * igbacc;
    idsgen = NFINtotal * idsgen;

    // Gate-to-substrate tunneling current empirical partition
    if (BULKMOD == 0) begin
        igbs = (igbinv + igbacc) * wf;
        igbd = (igbinv + igbacc) * wr;
    end

    // Noise model
    `include "bsimcmg_noise.include"

    // Loading Ids, gate and drain charges
    if (sigvds > 0.0) begin
        I(di, si) <+ `MFACTOR_USE * devsign * ids;
    end else begin
        I(si, di) <+ `MFACTOR_USE * devsign * ids;
    end
    if (NQSMOD == 2) begin
        I(gi, si) <+ `MFACTOR_USE * devsign * gtau * -V(q);
        I(di, si) <+ `MFACTOR_USE * devsign * xdpart * gtau * V(q);
    end else begin
        I(di, si) <+ `MFACTOR_USE * devsign * ddt(qd);
        I(gi, si) <+ `MFACTOR_USE * devsign * ddt(qg);
    end

    // Loading other currents
    if (sigvds > 0.0) begin
        I(di, si) <+ `MFACTOR_USE * devsign * idsgen;
        I(gi, si) <+ `MFACTOR_USE * devsign * (igcs + igs);
        I(gi, di) <+ `MFACTOR_USE * devsign * (igcd + igd);
        if (BULKMOD != 0) begin
            if (GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
                I(di, si) <+ `MFACTOR_USE * devsign * (igidl + Iii);
                I(si, di) <+ `MFACTOR_USE * devsign * igisl;
                I(di, e) <+ `MFACTOR_USE * devsign * igidlb;
                I(si, e) <+ `MFACTOR_USE * devsign * igislb;
            end else begin
                I(di, e) <+ `MFACTOR_USE * devsign * (igidl + Iii);
                I(si, e) <+ `MFACTOR_USE * devsign * igisl;
            end
            I(gi, e) <+ `MFACTOR_USE * devsign * (igbinv + igbacc);
        end else begin
            I(di, si) <+ `MFACTOR_USE * devsign * (igidl + Iii);
            I(si, di) <+ `MFACTOR_USE * devsign * igisl;
        end
    end else begin
        I(si, di) <+ `MFACTOR_USE * devsign * idsgen;
        I(gi, di) <+ `MFACTOR_USE * devsign * (igcs + igs);
        I(gi, si) <+ `MFACTOR_USE * devsign * (igcd + igd);
        if (BULKMOD != 0) begin
            if (GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
                I(si, di) <+ `MFACTOR_USE * devsign * (igidl + Iii);
                I(di, si) <+ `MFACTOR_USE * devsign * igisl;
                I(si, e) <+ `MFACTOR_USE * devsign * igidlb;
                I(di, e) <+ `MFACTOR_USE * devsign * igislb;
            end else begin
                I(si, e) <+ `MFACTOR_USE * devsign * (igidl + Iii);
                I(di, e) <+ `MFACTOR_USE * devsign * igisl;
            end
            I(gi, e) <+ `MFACTOR_USE * devsign * (igbinv + igbacc);
        end else begin
            I(si, di) <+ `MFACTOR_USE * devsign * (igidl + Iii);
            I(di, si) <+ `MFACTOR_USE * devsign * igisl;
        end
    end
    if (BULKMOD == 0) begin
        I(gi, si) <+ `MFACTOR_USE * devsign * igbs;
        I(gi, di) <+ `MFACTOR_USE * devsign * igbd;
    end
    if (BULKMOD != 0) begin
        I(e, si) <+ `MFACTOR_USE * devsign * Ies + `MFACTOR_USE * V(e, si) * gmin;
        I(e, di) <+ `MFACTOR_USE * devsign * Ied + `MFACTOR_USE * V(e, di) * gmin;
    end
    I(e, si) <+ `MFACTOR_USE * devsign * ddt(Qes);
    I(e, di) <+ `MFACTOR_USE * devsign * ddt(Qed);
    I(e, ge) <+ `MFACTOR_USE * devsign * ddt(Qeg);

    // Loading other charges
    I(ge, si) <+ `MFACTOR_USE * ddt(qgs_parasitic);
    I(ge, di) <+ `MFACTOR_USE * ddt(qgd_parasitic);
    I(d, s) <+ `MFACTOR_USE * ddt(qds_fr);
    if (CGEOMOD == 1) begin
        I(ge, s) <+ `MFACTOR_USE * ddt(qgs_fr);
        I(ge, d) <+ `MFACTOR_USE * ddt(qgd_fr);
    end

    // Accumulation charge for bulk FET
    if (BULKMOD != 0) begin
        I(gi, si) <+ `MFACTOR_USE * devsign * ddt(qg_acc);
        I(e, si) <+ `MFACTOR_USE * devsign * ddt(qb_acc);
    end

    // Velocity saturation in source/drain resistances
    if (RDSMOD == 1) begin
        if (RDLCW > 0) begin
            rdstempvs = `hypsmooth((1.0 + PRTVSRSD * delTemp - 1.0e-6), 1.0e-3);
            `tempdep(VSATRSD_t, VSATRSD, -ATVSRSD)
            T0 = qis - PTWG1VSRSD;
            T0 = `smoothminx(T0, 0.1, 2.0);
            T1  = 10.0 * PSATXVSRSD * T0 / (10.0 * PSATXVSRSD + T0);
            vsatrsd_eff = VSATRSD_t * (1.0 + PTWGVSRSD * T1);
            vsatrsd_eff = `hypsmooth(vsatrsd_eff, 10.0);
            T2 = NFINtotal * Weff0 * `q * vsatrsd_eff;
            T5 = abs(V(di1, di));
            if (GAVSRD == 0) begin
                T3 = 1.0;
            end else begin
                T3 = `smoothminx((T5 - RDVDS), 0, 0.5);
                T3 = 1.0 + T3 * GAVSRD;
            end
            isat_rd = T2 * NVSRD * T3;
            T4 = rdstempvs * RDLCW * WeffWRFactor;
            vsat_rd = isat_rd * T4;
            delta_vsrd = pow(T5, 4 - MVSRSD) / (pow(T5, 4 - MVSRSD) + VSRDFACTOR * pow(vsat_rd, 4 - MVSRSD));
            T6 = pow(delta_vsrd, 1.0 / MVSRSD) * T5 / vsat_rd;
            Rvs_d = T4 * pow((1.0 + pow(T6, MVSRSD)), 1 / MVSRSD);
        end
        if (RSLCW > 0) begin
            if (RDLCW == 0.0) begin
                rdstempvs = `hypsmooth((1.0 + PRTVSRSD * delTemp - 1.0e-6), 1.0e-3);
                `tempdep(VSATRSD_t, VSATRSD, -ATVSRSD)
                T0 = qis - PTWG1VSRSD;
                T0 = `smoothminx(T0, 0.1, 2.0);
                T1  = 10.0 * PSATXVSRSD * T0 / (10.0 * PSATXVSRSD + T0);
                vsatrsd_eff = VSATRSD_t * (1.0 + PTWGVSRSD * T1);
                vsatrsd_eff = `hypsmooth(vsatrsd_eff, 10.0);
                T2 = NFINtotal * Weff0 * `q * vsatrsd_eff;
            end
            isat_rs = T2 * NVSRS;
            T4 = rdstempvs * RSLCW * WeffWRFactor;
            vsat_rs = isat_rs * T4;
            T5 = abs(V(si, si1));
            delta_vsrs = pow(T5, 4 - MVSRSD) / (pow(T5, 4 - MVSRSD) + VSRSFACTOR * pow(vsat_rs, 4 - MVSRSD));
            T6 = pow(delta_vsrs, 1.0 / MVSRSD) * T5 / vsat_rs;
            Rvs_s = T4 * pow((1.0 + pow(T6, MVSRSD)), 1 / MVSRSD);
        end
    end

    // External source/drain resistance
    if (RDSMOD != 2 && RDrainGeo > 0) begin
        gdpr = 1.0 / Rdrain;
        I(d, di1) <+ `MFACTOR_USE * V(d, di1) * gdpr;
        if (RDSMOD == 1 && RDLCW > 0) begin
            gvs_d = 1.0 / Rvs_d;
            I(di1, di) <+ `MFACTOR_USE * V(di1, di) * gvs_d;
        end else begin
            V(di1, di) <+ 0.0;
        end
    end else begin
        V(d, di1) <+ 0.0;
        V(di1, di) <+ 0.0;
    end
    if (RDSMOD != 2 && RSourceGeo > 0) begin
        gspr = 1.0 / Rsource;
        I(s, si1) <+ `MFACTOR_USE * V(s, si1) * gspr;
        if (RDSMOD == 1 && RSLCW > 0) begin
            gvs_s = 1.0 / Rvs_s;
            I(si1, si) <+ `MFACTOR_USE * V(si1, si) * gvs_s;
        end else begin
            V(si1, si) <+ 0.0;
        end
    end else begin
        V(s, si1) <+ 0.0;
        V(si1, si) <+ 0.0;
    end

    // NQS gate resistance model
    if (NQSMOD == 1 && XRCRG1_i != 0.0) begin
        I(ge, gi) <+ `MFACTOR_USE * V(ge, gi) * gcrg;
    end else begin
        V(ge, gi) <+ 0.0;
    end
    if (NQSMOD == 2) begin
        I(q) <+ `MFACTOR_USE * ddt(qg - qb);
        I(q) <+ `MFACTOR_USE * V(q) * gtau;
        I(q) <+ `MFACTOR_USE * 1.0e-9 * ddt(V(q));
    end else begin
        V(q) <+ 0.0;
    end

    // Gate electrode resistance
    if (RGATEMOD != 0) begin
        I(g, ge) <+ `MFACTOR_USE * V(g, ge) * ggeltd;
    end else begin
        V(g, ge) <+ 0.0;
    end

    // Flicker noise
    I(di, si) <+ flicker_noise(`MFACTOR_USE * sigvds * FNPowerAt1Hz, EF, "1overf");

    // Thermal noise for parasitics
    if (RDSMOD != 2 && RDrainGeo > 0) begin
        I(d, di1) <+ white_noise(`MFACTOR_USE * 4.0 * Vtm * `q * gdpr, "rd");
        if (RDSMOD == 1 && RDLCW > 0) begin
            I(di1, di) <+ white_noise(`MFACTOR_USE * 4.0 * Vtm * `q * gvs_d, "rd");
        end
    end
    if (RDSMOD != 2 && RSourceGeo > 0) begin
        I(s, si1) <+ white_noise(`MFACTOR_USE * 4.0 * Vtm * `q * gspr, "rs");
        if (RDSMOD == 1 && RSLCW > 0) begin
            I(si1, si) <+ white_noise(`MFACTOR_USE * 4.0 * Vtm * `q * gvs_s, "rs");
        end
    end
    if (RGATEMOD != 0) begin
        I(g, ge) <+ white_noise(`MFACTOR_USE * 4.0 * Vtm * `q * ggeltd, "rg");
    end

    // Channel thermal noise and induced gate noise stamping
    if (TNOIMOD == 0) begin
        I(di, si) <+ white_noise(`MFACTOR_USE * sid, "id");
        V(n) <+ 0.0;
    end else begin
        // Additional node for correlated noise
        I(n) <+ `MFACTOR_USE * V(n);
        I(n) <+ white_noise(`MFACTOR_USE * sid, "corl");
        I(di, si) <+ white_noise(`MFACTOR_USE * sid * (1.0 - ctnoi * ctnoi), "id");
        I(di, si) <+ `MFACTOR_USE * ctnoi * V(n);
        // Correlated Sig noise to S/D through capacitive coupling
        I(gi, si) <+ ddt(`MFACTOR_USE * 0.7071 * sigrat * V(n));
        I(gi, di) <+ ddt(`MFACTOR_USE * 0.7071 * sigrat * V(n));
    end

    // Gate current shot noise
    if (IGCMOD != 0) begin
        if (sigvds > 0.0) begin
            I(gi, si) <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igcs + igs), "igs");
            I(gi, di) <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igcd + igd), "igd");
        end else begin
            I(gi, di) <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igcs + igs), "igd");
            I(gi, si) <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igcd + igd), "igs");
        end
    end
    if (IGBMOD != 0) begin
        if (BULKMOD != 0) begin
            I(gi, e)  <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igbinv + igbacc), "igb");
        end else begin
            I(gi, si) <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igbs), "igbs");
            I(gi, di) <+ white_noise(`MFACTOR_USE * 2.0 * `q * abs(igbd), "igbd");
        end
    end

    // Self-heating
    if (SHMOD != 0 && RTH0 > 0.0) begin
        Pwr(t) <+ -(`MFACTOR_USE * devsign * sigvds * V(di, si) * ids);
        if (RDSMOD != 2 && RDrainGeo > 0) begin
            Pwr(t) <+ `MFACTOR_USE * -V(d, di1) * V(d, di1) * gdpr;
            if (RDSMOD == 1 && RDLCW > 0) begin
                Pwr(t) <+ `MFACTOR_USE * -V(di1, di) * V(di1, di) * gvs_d;
            end
        end
        if (RDSMOD != 2 && RSourceGeo > 0) begin
            Pwr(t) <+ `MFACTOR_USE * -V(s, si1) * V(s, si1) * gspr;
            if (RDSMOD == 1 && RSLCW > 0) begin
                Pwr(t) <+ `MFACTOR_USE * -V(si1, si) * V(si1, si) * gvs_s;
            end
        end
        Pwr(t) <+ `MFACTOR_USE * Temp(t) * gth;
        Pwr(t) <+ `MFACTOR_USE * ddt(Temp(t) * cth);
    end else begin
        Temp(t) <+ 0.0;
    end

    // Operating-point information
    // W & L
    WEFF = Weff0;
    LEFF = Leff;
    WEFFCV = WeffCV0;
    LEFFCV = LeffCV;
    // Intrinsic drain current
    IDS = devsign * ids;
    // Total drain and source currents
    if (sigvds > 0.0) begin
        if (BULKMOD != 0) begin
            if (GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
                IDEFF = IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl + igidlb) - devsign * Ied;
                ISEFF = -IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * (igisl + igislb) - devsign * Ies;
            end else begin
                IDEFF = IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl) - devsign * Ied;
                ISEFF = -IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * igisl - devsign * Ies;
            end
        end else begin
            IDEFF = IDS + devsign * idsgen - devsign * (igd + igcd + igbd) + devsign * (Iii + igidl - igisl);
            ISEFF = -IDS - devsign * idsgen - devsign * (igs + igcs + igbs) + devsign * (igisl - igidl - Iii);
        end
    end else begin
        if (BULKMOD != 0) begin
            if (GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
                IDEFF = -IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * (igisl + igislb) - devsign * Ied;
                ISEFF = IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl + igidlb) - devsign * Ies;
            end else begin
                IDEFF = -IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * igisl - devsign * Ied;
                ISEFF = IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl) - devsign * Ies;
            end
        end else begin
            IDEFF = -IDS - devsign * idsgen - devsign * (igs + igcs + igbd) + devsign * (igisl - igidl - Iii);
            ISEFF = IDS + devsign * idsgen - devsign * (igd + igcd + igbs) + devsign * (Iii + igidl - igisl);
        end
    end
    // Total gate current
    if (BULKMOD == 0) begin
        IGTOT = devsign * (igs + igd + igcs + igcd + igbs + igbd);
    end else begin
        IGTOT = devsign * (igs + igd + igcs + igcd + igbacc + igbinv);
    end
    // Generation-recombination current
    IDSGEN = sigvds * devsign * idsgen;
    // Impact ionization current
    III = devsign * Iii;
    // GIDL, GISL currents
    if (sigvds > 0.0) begin
        if (BULKMOD != 0 && GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
            IGIDL = devsign * (igidl + igidlb);
            IGISL = devsign * (igisl + igislb);
        end else begin
            IGIDL = devsign * igidl;
            IGISL = devsign * igisl;
        end
    end else begin
        if (BULKMOD != 0 && GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
            IGIDL = devsign * (igisl + igislb);
            IGISL = devsign * (igidl + igidlb);
        end else begin
            IGIDL = devsign * igisl;
            IGISL = devsign * igidl;
        end
    end
    // Source-to-substrate and drain-to-substrate junction currents
    if (BULKMOD != 0) begin
        IJSB = -devsign * Ies;
        IJDB = -devsign * Ied;
    end else begin
        IJSB = 0.0;
        IJDB = 0.0;
    end
    // Substrate current
    if (BULKMOD != 0) begin
        if (GIDLMOD == 2 && (GEOMOD == 2 || GEOMOD == 3 || GEOMOD == 5)) begin
            ISUB = -III - devsign * (igidlb + igislb) - IJSB - IJDB - devsign * (igbinv + igbacc);
        end else begin
            ISUB = -III - IGIDL - IGISL - IJSB - IJDB - devsign * (igbinv + igbacc);
        end
    end else begin
        ISUB = 0.0;
    end
    // Drain current prefactor per fin per finger
    BETA = beta;
    // Drain-to-source saturation voltage
    Lterm0 = 0.15 * (Lg-10e-9) / 10e-9 + 1.12;
    Lterm = Lterm0 / pow(1 + pow(Lterm0 / 1.45, 3), 0.33);
    VDSSAT = Vdsat * Lterm / pow(1 + pow(Vdsat / 0.5, 1.8), 1 / 1.8);
    // Effective drain-to-source voltage
    VDSEFF = Vdseff;
    // Flatband voltage
    if (NGATE_i > 0.0) begin
        if (CRYOMOD == 0) begin
            VFB = -devsign * (phib + Vtm * `lln(NGATE_i / ni));
        end else begin
            VFB = -devsign * (phib + Vtm * (`lln(NGATE_i) - niln));
        end
    end else begin
        VFB = PHIG_i - (EASUB + 0.5 * Eg + devsign * phib);
    end
    // Threshold voltage calculation
    q0 = 10.0 * Vtm / rc + 2.0 * qbs;
    T1 = Vtm * (Vtm + q0);
    T2 = cox * cox * T1;
    T3 = 2.0 * `q * ni * epssub * Vtm;
    VTH = VFB + devsign * (Vtm * `lln(T2 / T3) + dvch_qm + phib + qbs + Vtm + dvth_all - DELVTRAND);
    // Transconductance
    GM = ddx(IDS, V(gi));
    // Output conductance
    if (sigvds > 0) begin
        GDS = ddx(IDS, V(di));
    end else begin
        GDS = ddx(IDS, V(si));
    end

    // Body transconductance
    if (BULKMOD != 0) begin
        GMBS = ddx(IDS, V(e));
    end else begin
        GMBS = 0.0;
    end
    // Intrinsic charges
    QGI = devsign * (qg + qg_acc);
    QDI = devsign * qd;
    QSI = devsign * qs;
    QBI = devsign * (qb + qb_acc);
    // Total charges
    QG = devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0.0) + devsign * qg_acc - devsign * Qeg;
    QD = devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0.0) - devsign * Qed +  qds_fr;
    QS = devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0.0) - devsign * Qes -  qds_fr;
    QB = devsign * (qb + qb_acc) + devsign * (Qeg + Qes + Qed);
    // Intrinsic capacitances
    CGGI = ddx(QGI, V(gi));
    CGSI = -ddx(QGI, V(si));
    CGDI = -ddx(QGI, V(di));
    CGEI = -ddx(QGI, V(e));
    CSGI = -ddx(QSI, V(gi));
    CSDI = -ddx(QSI, V(di));
    CSSI = ddx(QSI, V(si));
    CSEI = -ddx(QSI, V(e));
    CDGI = -ddx(QDI, V(gi));
    CDDI = ddx(QDI, V(di));
    CDSI = -ddx(QDI, V(si));
    CDEI = -ddx(QDI, V(e));
    CEGI = -ddx(QBI, V(gi));
    CEDI = -ddx(QBI, V(di));
    CESI = -ddx(QBI, V(si));
    CEEI = ddx(QBI, V(e));
    // Total capacitances
    CGG = CGGI + ddx(qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0.0) - devsign * Qeg, V(ge));
    CGS = -ddx(QG, V(si));
    CGD = -ddx(QG, V(di));
    CGE = -ddx(QG, V(e));
    CSG = CSGI + ddx(qgs_parasitic + (CGEOMOD == 1 ? qgs_fr : 0.0), V(ge));
    CSD = -ddx(QS, V(di)) + CDSP;
    CSS = ddx(QS, V(si))  + CDSP;
    CSE = -ddx(QS, V(e));
    CDG = CDGI + ddx(qgd_parasitic + (CGEOMOD == 1 ? qgd_fr : 0.0), V(ge));
    CDD = ddx(QD, V(di))  + CDSP;
    CDS = -ddx(QD, V(si)) + CDSP;
    CDE = -ddx(QD, V(e));
    CEG = CEGI - ddx(devsign * Qeg, V(ge));
    CED = -ddx(QB, V(di));
    CES = -ddx(QB, V(si));
    CEE = ddx(QB, V(e));
    // Gate-to-source overlap and outer fringe capacitance
    CGSEXT = -ddx(qgs_parasitic + (CGEOMOD == 1 ? qgs_fr : 0.0), V(si));
    // Gate-to-drain overlap and outer fringe capacitance
    CGDEXT = -ddx(qgd_parasitic + (CGEOMOD == 1 ? qgd_fr : 0.0), V(di));
    // Gate-to-substrate overlap capacitance
    CGBOV = -devsign * ddx(Qeg, V(e));
    // Total junction and source/drain-to-substrate overlap capacitances
    CJST = -devsign * ddx(Qes, V(si));
    CJDT = -devsign * ddx(Qed, V(di));
    // External bias-independent source resistance
    RSGEO = RSourceGeo;
    // External bias-independent drain resistance
    RDGEO = RDrainGeo;
    // Geometric parasitic capacitance
    CFGEO = Cfr_geo;
    // Output for self-heating temperature
    T_TOTAL_K = DevTemp;
    T_TOTAL_C = DevTemp - `P_CELSIUS0;
    T_DELTA_SH = Temp(t);
    // Gate current components
    IGS = devsign * igs;
    IGD = devsign * igd;
    IGCS = devsign * igcs;
    IGCD = devsign * igcd;
    if (BULKMOD == 0) begin
        IGBS = devsign * igbs;
        IGBD = devsign * igbd;
        IGBINV = 0.0;
        IGBACC = 0.0;
    end else begin
        IGBINV = devsign * igbinv;
        IGBACC = devsign * igbacc;
        IGBS = 0.0;
        IGBD = 0.0;
    end
    DIDSDVG = devsign * sigvds * ddx(ids, V(gi));
    DIDSDVS = devsign * sigvds * ddx(ids, V(si));
    DIDSDVD = devsign * sigvds * ddx(ids, V(di));
    DIGSDVG = devsign * ddx(igs + igcs, V(gi));
    DIGSDVS = devsign * ddx(igs + igcs, V(si));
    DIGSDVD = devsign * ddx(igs + igcs, V(di));
    DIGDDVG = devsign * ddx(igd + igcd, V(gi));
    DIGDDVS = devsign * ddx(igd + igcd, V(si));
    DIGDDVD = devsign * ddx(igd + igcd, V(di));
    DIIIDVG = devsign * ddx(Iii, V(gi));
    DIIIDVS = devsign * ddx(Iii, V(si));
    DIIIDVD = devsign * ddx(Iii, V(di));
    DIGIDLDVG = devsign * ddx(igidl, V(gi));
    DIGIDLDVS = devsign * ddx(igidl, V(si));
    DIGIDLDVD = devsign * ddx(igidl, V(di));
    DIGISLDVG = devsign * ddx(igisl, V(gi));
    DIGISLDVS = devsign * ddx(igisl, V(si));
    DIGISLDVD = devsign * ddx(igisl, V(di));
    CGT = ddx(QG, Temp(t));
    CST = ddx(QS, Temp(t));
    CDT = ddx(QD, Temp(t));
    DIDSDVTH = devsign * sigvds * ddx(ids, Temp(t));
    DIGSDVTH = devsign * ddx(igs + igcs, Temp(t));
    DIGDDVTH = devsign * ddx(igd + igcd, Temp(t));
    DIIIDVTH = devsign * ddx(Iii, Temp(t));
    DIGIDLDVTH = devsign * ddx(igidl, Temp(t));
    DIGISLDVTH = devsign * ddx(igisl, Temp(t));
    if (RDSMOD != 2) begin
        if (RDSMOD == 1 && (RDLCW > 0 || RSLCW > 0)) begin
            ITH = V(di, si) * ids + V(di1, di) * V(di1, di) * gvs_d + V(d, di1) * V(d, di1) * gdpr + V(si1, si) * V(si1, si) * gvs_s + V(s, si1) * V(s, si1) * gspr;
        end else begin
            ITH = V(di, si) * ids + V(d, di1) * V(d, di1) * gdpr + V(s, si1) * V(s, si1) * gspr;
        end
    end else begin
        ITH = V(di, si) * ids;
    end
    DITHDVTH = ddx(ITH, Temp(t));
    DITHDVG = ddx(ITH, V(gi));
    DITHDVS = ddx(ITH, V(si));
    DITHDVD = ddx(ITH, V(di));

    `ifdef __XYCE__
    VDSAT  =  Vdsat;                               // Drain-Source saturation Voltage (user-requested synonym)
    VDS = vds;
    VGS = vgs;
    VBS = V(e,s);
    `endif
end
