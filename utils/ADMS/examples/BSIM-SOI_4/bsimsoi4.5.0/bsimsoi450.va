/*  bsimsoi.va
 *
 * A Verilog-A implementation of BSIMSOI version 4.5.0 by Navid Paydavosi 20/11/2013

 
 * This implementation is  Copyright (C) 2010, Analog Devices, Inc.  All rights reserved.
 * Members of the Compact Model Council of the TechAmerica organization and
 * Tiburon Design Automation, Inc. are acknowledged for assistance.
 *
 * The original C source code is
 * Copyright (C) 2009, Regents of the University of California.  All rights reserved.
 *
 * The terms under which this software is provided are:

The Regents of the University of California and Analog Devices, Inc.
("Authors") own the copyright but shall not be liable for any
infringement of copyright or other proprietary rights brought by third
parties against the users of the software.

The Authors jointly grant the users the right to modify, copy, and
redistribute the software and documentation, both within the user's
organization and externally, subject to the following conditions:

1. The users agree not to charge for the original source code itself
   but may charge for additions, extensions, or support.

2. In any product based on the software, the users agree to acknowledge
   the UC Berkeley BSIM Research Group that developed the software. This
   acknowledgment shall appear in the product documentation.

3. The users agree to obey all U.S. Government restrictions governing
   redistribution or export of the software.

4. Redistributions of source code must retain the above copyright
   notices, this list of conditions and the following disclaimer.

5. Redistributions in binary form must reproduce the above copyright
   notices, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

6. Users may not claim authorship of the original software. Modified
   versions of the software must be plainly marked as such.

7. Users may not suggest any sponsorship or endorsement by the Authors
   of users' product.

THIS SOFTWARE IS PROVIDED BY AUTHORS AS IS AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND
NONINFRINGEMENT OF THIRD PARTY RIGHTS ARE DISCLAIMED.  IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/


`include "disciplines.vams"
`include "constants.vams"

// DEFINE THIS IF IN XYCE!
`define __XYCE__

// These constants are part of the model
`define Kb 1.3806226e-23
`define KboQ 8.617087e-5  /* Kb / q  where q = 1.60219e-19 */
`define EPSOX 3.453133e-11
`define EPSSI 1.03594e-10
`define EPS0 8.85418e-12
`define Charge_q 1.60219e-19
`define Eg300 1.115   /*  energy gap at 300K  */
`define MAX_EXPL 2.688117142e+43
`define MIN_EXPL 3.720075976e-44
`define EXPL_THRESHOLD 100.0
`define DELTA_ 1.0E-9
`define DELTA_1 0.02
`define DELTA_2 0.02
`define DELTA_3 0.02
`define DELTA_3_SOI 0.08
`define DELTA_4 0.02
`define DELTA_VFB  0.02
`define OFF_Vbsitf 0.02

`define N_MINLOG 1.0e-38
`define NMOS 1

`define DEXP(A,B) \
    if (A > `EXPL_THRESHOLD) begin \
        B = `MAX_EXPL*(1.0+(A)-`EXPL_THRESHOLD); \
    end else if (A < -`EXPL_THRESHOLD) begin \
        B = `MIN_EXPL; \
    end else begin \
        B = exp(A); \
    end

`define PORT_CONNECTED
`ifdef PORT_CONNECTED

	module bsimsoi450(d, g, s, e, p, b, t) (* xyceModelGroup="MOSFET" xyceLevelNumber="70450" xyceDeviceName="BSIM-SOI 4.5.0" xyceTypeVariable="TYPE" *) ;
	inout      g, d, s, e, p, b, t;
`else

	module bsimsoi450(d, g, s, e) (* xyceModelGroup="MOSFET" xyceLevelNumber="70450" xyceDeviceName="BSIM-SOI 4.5.0" xyceTypeVariable="TYPE" *) ;
	inout      g, d, s, e;
`endif

electrical g, d, s, e, p, b;
thermal t;
electrical di, si, gi, gm, sb, db;

// Correlated Thermal Noise Switch
//`define _TNOIMOD3_

// Internal node controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
	electrical N;
`endif


// Hypsmooth function  
analog function real hypsmooth;

       input x,c; 
       real x, c; 
       begin 
             hypsmooth = 0.5*(x +  sqrt(x*x+4.0*c*c )); 
       end
      
endfunction


parameter integer TYPE = `NMOS from [-1:1] exclude 0; // +1 = NMOS, -1 = PMOS
parameter real VERSION  = 4.40; // parameter for model version
parameter real DTEMP    = 0.0 (*type="instance"*); // device temperature offset from ambient
parameter real L        = 5e-6 from (0:inf) (*type="instance" xyceAlsoModel="yes"*); // Length
parameter real W        = 5e-6 from (0:inf) (*type="instance" xyceAlsoModel="yes"*); // Width
parameter real NF       = 1.0 from [1:inf) (*type="instance" xyceAlsoModel="yes"*); // Number of fingers
parameter real SA       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // distance between  OD edge to poly of one side
parameter real SB       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // distance between  OD edge to poly of the other side
parameter real SD       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // distance between neighbor fingers
parameter real AD       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Drain area
parameter real AS       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Source area
parameter real PD       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Drain perimeter
parameter real PS       = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Source perimeter
parameter real NRD      = 1.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Number of squares in drain
parameter real NRS      = 1.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Number of squares in source
parameter integer OFF      = 0 (*type="instance" xyceAlsoModel="yes"*); // Device is initially off
parameter integer BJTOFF   = 0 (*type="instance" xyceAlsoModel="yes"*); // BJT on/off flag
parameter integer DEBUG    = 0; // DEBUG on/off flag
parameter real RTH0     = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Instance Thermal Resistance
parameter real CTH0     = 1e-5 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Instance Thermal Capacitance
parameter real NRB      = 1.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Number of squares in body
parameter real FRBODY   = 1.0 (*type="instance" xyceAlsoModel="yes"*); // layout dependent body-resistance coefficient
parameter real RBDB     = 50.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Body resistance
parameter real RBSB     = 50.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Body resistance
parameter real DELVTO   = 0.0 (*type="instance" xyceAlsoModel="yes"*); // Zero bias threshold voltage variation
parameter integer SOIMOD   = 0 from [0:3] (*type="instance" xyceAlsoModel="yes"*); // Instance model selector for PD/FD operation /* v3.2 */
parameter real NBC      = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Number of body contact isolation edge
parameter real NSEG     = 1 from [1:inf) (*type="instance" xyceAlsoModel="yes"*); // Number segments for width partitioning
parameter real PDBCP    = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Perimeter length for bc parasitics at drain side
parameter real PSBCP    = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Perimeter length for bc parasitics at source side
parameter real AGBCP    = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Gate to body overlap area for bc parasitics
parameter real AGBCP2   = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Parasitic Gate to body overlap area for bc parasitics /* v4.1 improvement on BC */
parameter real AGBCPD   = AGBCP from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Gate to body overlap area for bc parasitics in DC
parameter real AEBCP    = 0.0 from [0:inf) (*type="instance" xyceAlsoModel="yes"*); // Substrate to body overlap area for bc parasitics
parameter real VBSUSR   = 0.0; // Vbs specified by user
parameter integer TNODEOUT = 0 from [0:1] (*type="instance"*); // Flag indicating external temp node
parameter integer RGATEMOD = 0 from [0:3]; // Gate resistance model selector
parameter integer RBODYMOD = 0 from [0:1]; // Body R model selector /* v4.0 */
parameter integer MTRLMOD  = 0; // parameter for non-silicon substrate or metal gate selector
parameter integer VGSTCVMOD = (VERSION>=4.2) ? 1 : 0 from [0:2]; // Improved VgsteffCV selector
parameter integer GIDLMOD  = 0; // parameter for GIDL selector
parameter integer IIIMOD   = 0; // parameter for III selector
parameter real EOT      = 100.0e-10; // Effective SiO2 thickness
parameter real EPSROX   = 3.9; // Dielectric constant of the gate oxide relative to vacuum
parameter real EPSRSUB  = 11.7 from (0:inf); // Dielectric constant of substrate relative to vacuum
parameter real NI0SUB   = 1.45e10; // Intrinsic carrier concentration of substrate at Tnom
parameter real BG0SUB   = 1.16; // Band-gap of substrate at T=0K
parameter real TBGASUB  = 7.02e-4; // First parameter of band-gap change due to temperature
parameter real TBGBSUB  = 1108.0; // Second parameter of band-gap change due to temperature
parameter real PHIG     = 4.05; // Work function of gate
parameter real EASUB    = 4.05; // Electron affinity of substrate
parameter real LEFFEOT  = 1.0 from (0:inf); // Effective length for extraction of EOT
parameter real WEFFEOT  = 10.0; // Effective width for extraction of EOT
parameter real VDDEOT   = (TYPE == `NMOS) ? 1.5 : -1.5; // Voltage for extraction of EOT
parameter real TEMPEOT  = 300.15; // Temperature for extraction of EOT
parameter real ADOS     = 1.0; // Charge centroid parameter
parameter real BDOS     = 1.0; // Charge centroid parameter
parameter real EPSRGATE = 11.7 from (0:inf); // Dielectric constant of gate relative to vacuum
parameter integer CAPMOD   = 2 from [2:3]; // Capacitance model selector
parameter integer MOBMOD   = 1 from [1:4]; // Mobility model selector
parameter integer PARAMCHK = 0; // Model parameter checking selector
parameter integer BINUNIT  = 1; // Bin  unit  selector
parameter real TOX      = 100.0e-10 from (0:inf); // Gate oxide thickness in meters
parameter real TOXP     = TOX from (0:inf); // Physical gate oxide thickness
parameter real TOXM     = TOX from (0:inf); // Gate oxide thickness used in extraction /* v3.2 */
parameter real DTOXCV   = 0.0; // Delta oxide thickness in meters in CapMod3 /* v2.2.3 */
parameter real CDSC     = 2.4e-4; // Drain/Source and channel coupling capacitance
parameter real CDSCB    = 0.0; // Body-bias dependence of cdsc
parameter real CDSCD    = 0.0; // Drain-bias dependence of cdsc
parameter real CIT      = 0.0; // Interface state capacitance
parameter real NFACTOR  = 1; // Subthreshold swing Coefficient
parameter real VSAT     = 8.0e4 from (0:inf); // Saturation velocity at tnom
parameter real AT       = 3.3e4; // Temperature coefficient of vsat
parameter real A0       = 1.0; // Non-uniform depletion width effect coefficient.
parameter real AGS      = 0.0; // Gate bias  coefficient of Abulk.
parameter real A1       = 0.0; // Non-saturation effect coefficient
parameter real A2       = 1.0; // Non-saturation effect coefficient
parameter real KETA     = -0.6; // Body-bias coefficient of non-uniform depletion width effect.
parameter real NSUB     = 6.0e16 from (0:inf); // Substrate doping concentration with polarity
parameter real NCH      = 1.7e17 from (0:inf); // Channel doping concentration
parameter real NGATE    = 0.0 from [0:inf); // Poly-gate doping concentration
parameter real NSD      = 1.0e20 from (0:inf); // S/D doping concentration
parameter real GAMMA1   = 0.0; // Vth body coefficient
parameter real GAMMA2   = 0.0; // Vth body coefficient
parameter real VBX      = 0.0; // Vth transition body Voltage
parameter real VBM      = -3.0; // Maximum body voltage
parameter real XT       = 1.55e-7; // Doping depth
parameter real K1       = 0.53; // Bulk effect coefficient 1
parameter real KT1      = -0.11; // Temperature coefficient of Vth
parameter real KT1L     = 0.0; // Temperature coefficient of Vth
parameter real KT2      = 0.022; // Body-coefficient of kt1
parameter real K2       = -0.0186; // Bulk effect coefficient 2
parameter real K3       = 0.0; // Narrow width effect coefficient
parameter real K3B      = 0.0; // Body effect coefficient of k3
parameter real W0       = 2.5e-6; // Narrow width effect parameter
parameter real LPEB     = 0.0; // Lateral non-uniform doping effect for body bias
parameter real DVT0     = 2.2; // Short channel effect coeff. 0
parameter real DVT1     = 0.53; // Short channel effect coeff. 1
parameter real DVT2     = -0.032; // Short channel effect coeff. 2
parameter real DVT0W    = 0.0; // Narrow Width coeff. 0
parameter real DVT1W    = 5.3e6; // Narrow Width effect coeff. 1
parameter real DVT2W    = -0.032; // Narrow Width effect coeff. 2
parameter real DROUT    = 0.56; // DIBL coefficient of output resistance
parameter real DSUB     = DROUT; // DIBL coefficient in the subthreshold region
parameter real VTHO     = (TYPE == `NMOS) ? 0.7 : -0.7; // Threshold voltage
parameter real VTH0     = VTHO; // Threshold voltage
parameter real VFB      = -1.0; // Flat Band Voltage /* v4.1 */
parameter real UA       = 2.25e-9; // Linear gate dependence of mobility
parameter real UA1      = 4.31e-9; // Temperature coefficient of ua
parameter real UB       = 5.87e-19; // Quadratic gate dependence of mobility
parameter real UB1      = -7.61e-18; // Temperature coefficient of ub
parameter real UC       = (MOBMOD == 3) ? -0.0465 : -0.0465e-9; // Body-bias dependence of mobility
parameter real UC1      = (MOBMOD == 3) ? -0.056 : -0.056e-9; // Temperature coefficient of uc
parameter real U0       = (TYPE == `NMOS) ? 0.067 : 0.025; // Low-field mobility at Tnom
parameter real EU       = (TYPE == `NMOS) ? 1.67 : 1.0; // Mobility exponent
parameter real UTE      = -1.5; // Temperature coefficient of mobility
parameter real UCS      = (TYPE == `NMOS) ? 1.67 : 1.0; // Mobility exponent
parameter real UCSTE    = -4.775e-3; // Temperature coefficient of UCS
parameter real UD       = 0.0; // Coulomb scattering factor of mobility
parameter real UD1      = 0.0; // Temperature coefficient of ud
parameter real VOFF     = -0.08; // Threshold voltage offset
parameter real TNOM     = 27.0; // Parameter measurement temperature
parameter real CGSO     = 0.0 from [0:inf); // Gate-source overlap capacitance per width
parameter real CGDO     = 0.0 from [0:inf); // Gate-drain overlap capacitance per width
parameter real XPART    = 0.0; // Channel charge partitioning
parameter real DELTA    = 0.01; // Effective Vds parameter
parameter real RSH      = 0.0 from [0:inf); // Source-drain sheet resistance
parameter real RDSW     = 100 from [0:inf); // Source-drain resistance per width
parameter real RSW      = 50 from [0:inf); // Source resistance per width /* v4.0 */
parameter real RDW      = 50 from [0:inf); // Drain resistance per width /* v4.0 */
parameter real RSWMIN   = 0.0 from [0:inf); // Source resistance per width at high Vg
parameter real RDWMIN   = 0.0 from [0:inf); // Drain resistance per width at hight Vg
parameter real PRWG     = 0.0; // Gate-bias effect on parasitic resistance
parameter real PRWB     = 0.0; // Body-effect on parasitic resistance
parameter real PRT      = 0.0; // Temperature coefficient of parasitic resistance
parameter real ETA0     = 0.08; // Subthreshold region DIBL coefficient for I-V
parameter real ETAB     = -0.07; // Subthreshold region DIBL coefficient for I-V
parameter real ETA0CV   = ETA0; // Subthreshold region DIBL coefficient for C-V
parameter real ETABCV   = ETAB; // Subthreshold region DIBL coefficient for C-V
parameter real PCLM     = 1.3; // Channel length modulation Coefficient
parameter real PDIBLC1  = 0.39; // Drain-induced barrier lowering coefficient
parameter real PDIBLC2  = 0.0086; // Drain-induced barrier lowering coefficient
parameter real PDIBLCB  = 0.0; // Body-effect on drain-induced barrier lowering
parameter real PVAG     = 0.0; // Gate dependence of output resistance parameter
parameter integer SHMOD    = 0 (*type="instance" xyceAlsoModel="yes"*); // Self heating mode selector
parameter real TBOX     = 3e-7 from (0:inf); // Back gate oxide thickness in meters
parameter real TSI      = 1e-7 from (0:inf); // Silicon-on-insulator thickness in meters
parameter real ETSI     = 1e-7 from (0:inf); // Effective Silicon-on-insulator thickness in meters
parameter real XJ       = TSI from (0:inf); // Junction Depth
parameter real AGIDL    = 0.0; // GIDL second parameter
parameter real BGIDL    = 2.3e9; // GIDL third parameter
parameter real CGIDL    = 0.5; // GIDL vb parameter
parameter real RGIDL    = 1.0; // GIDL vg parameter
parameter real KGIDL    = 0.0; // GIDL vb parameter
parameter real FGIDL    = 0.0; // GIDL vb parameter
parameter real AGISL    = AGIDL; // GISL second parameter
parameter real BGISL    = BGIDL; // GISL third parameter
parameter real CGISL    = CGIDL; // GISL vb parameter
parameter real RGISL    = RGIDL; // GISL vg parameter
parameter real KGISL    = KGIDL; // GISL vb parameter
parameter real FGISL    = FGIDL; // GISL vb parameter
parameter real NDIODE   = 1.0; // Diode non-ideality factor /*v4.0*/
parameter real NDIODED  = NDIODE; // Diode non-ideality factor /*v4.0*/
parameter real XBJT     = 1.0; // Temperature coefficient for Isbjt
parameter real XDIF     = XBJT; // Temperature coefficient for Isdif
parameter real XREC     = 1.0; // Temperature coefficient for Isrec
parameter real XTUN     = 0.0; // Temperature coefficient for Istun
parameter real XDIFD    = XDIF; // Temperature coefficient for Iddif
parameter real XRECD    = XREC; // Temperature coefficient for Idrec
parameter real XTUND    = XTUN; // Temperature coefficient for Idtun
parameter real PBSWG    = 0.7; // Source(gate side) sidewall junction capacitance built in potential /* v4.0 */
parameter real PBSWGD   = PBSWG; // Drain(gate side) sidewall junction capacitance built in potential /* v4.0 */
parameter real MJSWG    = 0.5; // Source (gate side) sidewall junction capacitance grading coefficient /* v4.0 */
parameter real MJSWGD   = MJSWG; // Drain (gate side) sidewall junction capacitance grading coefficient /* v4.0 */
parameter real CJSWG    = 1e-10 from (0:inf); // Source(gate side) sidewall junction capacitance per unit width /* v4.0 */
parameter real CJSWGD   = CJSWG from (0:inf); // Drain (gate side) sidewall junction capacitance per unit width /* v4.0 */
parameter real LINT     = 0.0; // Length reduction parameter
parameter real LL       = 0.0; // Length reduction parameter
parameter real LLC      = 0.0; // Length reduction parameter /* v2.2.3 */
parameter real LLN      = 1.0; // Length reduction parameter
parameter real LW       = 0.0; // Length reduction parameter
parameter real LWC      = 0.0; // Length reduction parameter /* v2.2.3 */
parameter real LWN      = 1.0; // Length reduction parameter
parameter real LWL      = 0.0; // Length reduction parameter
parameter real LWLC     = 0.0; // Length reduction parameter /* v2.2.3 */
parameter real WR       = 1.0; // Width dependence of rds
parameter real WINT     = 0.0; // Width reduction parameter
parameter real DWG      = 0.0; // Width reduction parameter
parameter real DWB      = 0.0; // Width reduction parameter
parameter real WL       = 0.0; // Width reduction parameter
parameter real WLC      = 0.0; // Width reduction parameter /* v2.2.3 */
parameter real WLN      = 1.0; // Width reduction parameter
parameter real WW       = 0.0; // Width reduction parameter
parameter real WWC      = 0.0; // Width reduction parameter /* v2.2.3 */
parameter real WWN      = 1.0; // Width reduction parameter
parameter real WWL      = 0.0; // Width reduction parameter
parameter real WWLC     = 0.0; // Width reduction parameter /* v2.2.3 */
parameter real B0       = 0.0; // Abulk narrow width parameter
parameter real B1       = 0.0; // Abulk narrow width parameter
parameter real CGSL     = 0.0; // New C-V model parameter
parameter real CGDL     = 0.0; // New C-V model parameter
parameter real CKAPPA   = 0.6 from (0:inf); // New C-V model parameter
parameter real CF       = 0.0; // Fringe capacitance parameter
parameter real CLC      = 0.1e-7; // Vdsat parameter for C-V model
parameter real CLE      = 0.0; // Vdsat parameter for C-V model
parameter real DWC      = WINT; // Delta W for C-V model
parameter real DLC      = LINT; // Delta L for C-V model
parameter real ALPHA0   = 0.0; // substrate current model parameter
parameter real NOIA     = (TYPE == `NMOS) ? 6.25e41 : 6.188e40; // Flicker noise parameter
parameter real NOIB     = (TYPE == `NMOS) ? 3.125e26 : 1.5e25; // Flicker noise parameter
parameter real NOIC     = 8.75e9; // Flicker noise parameter
parameter integer FNOIMOD  = 1 from [0:1]; // Flicker noise model selector
parameter integer TNOIMOD  = 0 from [0:3]; // Thermal noise model selector

//Parameters controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
	parameter real TNOIC    = 3.5;    // Thermal noise parameter for TNOIMOD=3
	parameter real RNOIC    = 0.395;  // Thermal noise coefficient for TNOIMOD=3
	parameter real SCALEN   = 1e5;    //Thermal noise scaling factor for TNOIMOD=3
`endif

//parameter integer NOIMOD   = 1 from [1:4]; // carry-over from v. 3.x
parameter real TNOIA    = 1.5; // Thermal noise parameter
parameter real TNOIB    = 3.5; // Thermal noise parameter 
parameter real RNOIA    = 0.577; // Thermal noise coefficient
parameter real RNOIB    = 0.37; // Thermal noise coefficient

parameter real NTNOI    = 1.0 from [0:inf); // Thermal noise parameter
parameter real SAREF    = 1e-6 from (0:inf); // Reference distance between OD edge to poly of one side
parameter real SBREF    = 1e-6 from (0:inf); // Reference distance between OD edge to poly of the other side
parameter real WLOD     = 0.0; // Width parameter for stress effect
parameter real KU0      = 0.0; // Mobility degradation/enhancement coefficient for LOD
parameter real KVSAT    = 0.0; // Saturation velocity degradation/enhancement parameter for LOD
parameter real KVTH0    = 0.0; // Threshold degradation/enhancement parameter for LOD
parameter real TKU0     = 0.0; // Temperature coefficient of KU0
parameter real LLODKU0  = 0.0; // Length parameter for u0 LOD effect
parameter real WLODKU0  = 0.0; // Width parameter for u0 LOD effect
parameter real LLODVTH  = 0.0; // Length parameter for vth LOD effect
parameter real WLODVTH  = 0.0; // Width parameter for vth LOD effect
parameter real LKU0     = 0.0; // Length dependence of ku0
parameter real WKU0     = 0.0; // Width dependence of ku0
parameter real PKU0     = 0.0; // Cross-term dependence of ku0
parameter real LKVTH0   = 0.0; // Length dependence of kvth0
parameter real WKVTH0   = 0.0; // Width dependence of kvth0
parameter real PKVTH0   = 0.0; // Cross-term dependence of kvth0
parameter real STK2     = 0.0; // K2 shift factor related to stress effect on vth
parameter real LODK2    = 1.0; // K2 shift modification factor for stress effect
parameter real STETA0   = 0.0; // eta0 shift factor related to stress effect on vth
parameter real LODETA0  = 1.0; // eta0 shift modification factor for stress effect
parameter real STETA0CV  = STETA0; // eta0cv shift factor related to stress effect on vth
parameter real LODETA0CV = LODETA0; // eta0cv shift modification factor for stress effect
parameter real GBMIN    = 1.0e-12; // Minimum body conductance
parameter real BF       = 2.0; // Flicker noise length dependence exponent
parameter real W0FLK    = 10.0e-6; // Flicker noise width dependence
parameter real DVTP0    = 0.0; // First parameter for Vth shift due to pocket
parameter real LDVTP0   = 0.0; // Length dependence of dvtp0
parameter real WDVTP0   = 0.0; // Width dependence of dvtp0
parameter real PDVTP0   = 0.0; // Cross-term dependence of dvtp0
parameter real DVTP1    = 0.0; // Second parameter for Vth shift due to pocket
parameter real LDVTP1   = 0.0; // Length dependence of dvtp1
parameter real WDVTP1   = 0.0; // Width dependence of dvtp1
parameter real PDVTP1   = 0.0; // Cross-term dependence of dvtp1
parameter real DVTP2    = 0.0; // Third parameter for Vth shift due to pocket
parameter real LDVTP2   = 0.0; // Length dependence of dvtp2
parameter real WDVTP2   = 0.0; // Width dependence of dvtp2
parameter real PDVTP2   = 0.0; // Cross-term dependence of dvtp2
parameter real DVTP3    = 0.0; // Third parameter for Vth shift due to pocket
parameter real LDVTP3   = 0.0; // Length dependence of dvtp3
parameter real WDVTP3   = 0.0; // Width dependence of dvtp3
parameter real PDVTP3   = 0.0; // Cross-term dependence of dvtp3
parameter real DVTP4    = 0.0; // Forth parameter for Vth shift due to pocket
parameter real LDVTP4   = 0.0; // Length dependence of dvtp4
parameter real WDVTP4   = 0.0; // Width dependence of dvtp4
parameter real PDVTP4   = 0.0; // Cross-term dependence of dvtp4
parameter real MINV     = 0.0; // For moderate inversion in Vgsteff
parameter real LMINV    = 0.0; // Length dependence of minv
parameter real WMINV    = 0.0; // width dependence of minv
parameter real PMINV    = 0.0; // Cross-term dependence of minv
parameter real PDITS    = 1e-20; // Coefficient for drain-induced Vth shifts
parameter real PDITSL   = 0.0; // Length dependence of drain-induced Vth shifts
parameter real PDITSD   = 0.0; // Vds dependence of drain-induced Vth shifts
parameter real FPROUT   = 0.0; // Rout degradation coefficient for pocket devices
parameter real LFPROUT  = 0.0; // Length dependence of pdiblcb
parameter real LPDITS   = 0.0; // Length dependence of pdits
parameter real LPDITSD  = 0.0; // Length dependence of pditsd
parameter real WFPROUT  = 0.0; // Width dependence of pdiblcb
parameter real WPDITS   = 0.0; // Width dependence of pdits
parameter real WPDITSD  = 0.0; // Width dependence of pditsd
parameter real PFPROUT  = 0.0; // Cross-term dependence of pdiblcb
parameter real PPDITS   = 0.0; // Cross-term dependence of pdits
parameter real PPDITSD  = 0.0; // Cross-term dependence of pditsd
parameter real EM       = 4.1e7; // Flicker noise parameter
parameter real EF       = 1.0; // Flicker noise frequency exponent
parameter real AF       = 1.0; // Flicker noise exponent
parameter real KF       = 0.0; // Flicker noise coefficient
parameter real NOIF     = 1.0 from [0:inf); // Floating body excess noise ideality factor
parameter real K1W1     = 0.0; // First Body effect width dependent parameter
parameter real K1W2     = 0.0; // Second Body effect width dependent parameter
parameter real KETAS    = 0.0; // Surface potential adjustment for bulk charge effect
parameter real DWBC     = 0.0; // Width offset for body contact isolation edge
parameter real BETA0    = 0.0; // First Vds dependent parameter of impact ionization current
parameter real BETA1    = 0.0; // Second Vds dependent parameter of impact ionization current
parameter real BETA2    = 0.1; // Third Vds dependent parameter of impact ionization current
parameter real VDSATII0 = 0.9; // Nominal drain saturation voltage at threshold for impact ionization current
parameter real TII      = 0.0; // Temperature dependent parameter for impact ionization
parameter real LII      = 0.0; // Channel length dependent parameter at threshold for impact ionization current
parameter real SII0     = 0.5; // First Vgs dependent parameter for impact ionization current
parameter real SII1     = 0.1; // Second Vgs dependent parameter for impact ionization current
parameter real SII2     = 0.0; // Third Vgs dependent parameter for impact ionization current
parameter real SIID     = 0.0; // Vds dependent parameter of drain saturation voltage for impact ionization current
parameter real FBJTII   = 0.0; // Fraction of bipolar current affecting the impact ionization
parameter real EBJTII   = 0.0; // Impact ionization parameter for BJT part
parameter real CBJTII   = 0.0; // Length scaling parameter for II BJT part
parameter real VBCI     = 0.0; // Internal B-C built-in potential
parameter real ABJTII   = 0.0; // Exponent factor for avalanche current
parameter real MBJTII   = 0.4; // Internal B-C grading coefficient
parameter real TVBCI    = 0.0; // Temperature coefficient for VBCI
parameter real ESATII   = 1e7; // Saturation electric field for impact ionization
parameter real NTUN     = 10.0 from [0:inf); // Reverse tunneling non-ideality factor
parameter real NTUND    = NTUN from [0:inf); // Reverse tunneling non-ideality factor
parameter real NRECF0   = 2.0 from [0:inf); // Recombination non-ideality factor at forward bias
parameter real NRECF0D  = NRECF0 from [0:inf); // Recombination non-ideality factor at forward bias
parameter real NRECR0   = 10.0 from [0:inf); // Recombination non-ideality factor at reversed bias
parameter real NRECR0D  = NRECR0 from [0:inf); // Recombination non-ideality factor at reversed bias
parameter real ISBJT    = 1e-6 from [0:inf); // BJT injection saturation current
parameter real IDBJT    = ISBJT from [0:inf); // BJT injection saturation current
parameter real ISDIF    = 0.0 from [0:inf); // Body to source/drain injection saturation current
parameter real IDDIF    = ISDIF from [0:inf); // Body to source/drain injection saturation current /* v4.0 */
parameter real ISREC    = 1e-5 from [0:inf); // Recombination in depletion saturation current
parameter real IDREC    = ISREC from [0:inf); // Recombination in depletion saturation current
parameter real ISTUN    = 0.0 from [0:inf); // Reverse tunneling saturation current
parameter real IDTUN    = ISTUN from [0:inf); // Reverse tunneling saturation current
parameter real LN       = 2e-6 from [0:inf); // Electron/hole diffusion length
parameter real VREC0    = 0.0; // Voltage dependent parameter for recombination current
parameter real VREC0D   = VREC0; // Voltage dependent parameter for recombination current
parameter real VTUN0    = 0.0; // Voltage dependent parameter for tunneling current
parameter real VTUN0D   = VTUN0; // Voltage dependent parameter for tunneling current
parameter real NBJT     = 1.0; // Power coefficient of channel length dependency for bipolar current
parameter real LBJT0    = 0.20e-6; // Reference channel length for bipolar current
parameter real LDIF0    = 1.0; // Channel-length dependency coefficient of diffusion cap
parameter real VABJT    = 10.0; // Early voltage for bipolar current
parameter real AELY     = 0.0; // Channel length dependency of early voltage for bipolar current
parameter real AHLI     = 0.0; // High level injection parameter for bipolar current /* v4.0 */
parameter real AHLID    = AHLI; // High level injection parameter for bipolar current /* v4.0 */
parameter real RBODY    = 0.0; // Intrinsic body contact sheet resistance
parameter real RBSH     = 0.0; // Extrinsic body contact sheet resistance
parameter real CGEO     = 0.0; // Gate substrate overlap capacitance per unit channel length
parameter real TT       = 1e-12 from [0:inf); // Diffusion capacitance transit time coefficient
parameter real NDIF     = -1.0; // Power coefficient of channel length dependency for diffusion capacitance
parameter real VSDFB    = 0.0; // Source/drain bottom diffusion capacitance flatband voltage
parameter real VSDTH    = 0.0; // Source/drain bottom diffusion capacitance threshold voltage
parameter real CSDMIN   = 0.0; // Source/drain bottom diffusion minimum capacitance
parameter real ASD      = 0.3 from (0:inf); // Source/drain bottom diffusion smoothing parameter
parameter real CSDESW   = 0.0; // Source/drain sidewall fringing capacitance per unit length
parameter real NTRECF   = 0.0; // Temperature coefficient for Nrecf
parameter real NTRECR   = 0.0; // Temperature coefficient for Nrecr
parameter real DLCB     = 0.0; // Length offset fitting parameter for body charge
parameter real FBODY    = 1.0; // Scaling factor for body charge
parameter real TCJSWG   = 0.0; // Temperature coefficient of Cjswgs
parameter real TPBSWG   = 0.0; // Temperature coefficient of Pbswgs
parameter real TCJSWGD  = TCJSWG; // Temperature coefficient of Cjswgd
parameter real TPBSWGD  = TPBSWG; // Temperature coefficient of Pbswgd
parameter real ACDE     = 1.0; // Exponential coefficient for charge thickness in capMod=3 for accumulation and depletion regions
parameter real MOIN     = 15.0; // Coefficient for the gate-bias dependent surface potential
parameter real NOFF     = 1.0; // C-V turn-on/off parameter /* v3.2 */
parameter real DELVT    = 0.0; // Threshold voltage adjust for CV
parameter real KB1      = 1.0; // Scaling factor for backgate charge
parameter real DLBG     = 0.0; // Length offset fitting parameter for backgate charge
parameter real CFRCOEFF = 1.0; // Fringe Cap parameter /* v4.4 */
parameter integer IGBMOD   = 0; // gate-body tunneling current model selector /* v3.0 */
parameter integer IGMOD    = IGBMOD; // gate-body tunneling current model selector /* v3.1.1 */
parameter integer IGCMOD   = 0; // gate-channel tunneling current model selector /* v3.0 */
parameter real TOXQM    = TOX; // effective oxide thickness considering quantum effect
parameter real WTH0     = 0.0; // Minimum width for thermal resistance calculation
parameter real RHALO    = 1e15; // body halo sheet resistance
parameter real NTOX     = 1; // power term of gate current
parameter real TOXREF   = 2.5e-9 from [0:inf); // target oxide thickness
parameter real EBG      = 1.2; // effective bandgap in gate current calculation
parameter real VEVB     = 0.075 from (0:inf); // Vaux parameter for valence-band electron tunneling
parameter real ALPHAGB1 = 0.35; // First Vox dependent parameter for gate current in inversion
parameter real BETAGB1  = 0.03; // Second Vox dependent parameter for gate current in inversion
parameter real VGB1     = 300; // Third Vox dependent parameter for gate current in inversion
parameter real VECB     = 0.026 from (0:inf); // Vaux parameter for conduction-band electron tunneling
parameter real ALPHAGB2 = 0.43; // First Vox dependent parameter for gate current in accumulation
parameter real BETAGB2  = 0.05; // Second Vox dependent parameter for gate current in accumulation
parameter real VGB2     = 17; // Third Vox dependent parameter for gate current in accumulation
parameter real AIGBCP2  = 0.043; // First Vgp dependent parameter for gate current in accumulation in AGBCP2 region
parameter real BIGBCP2  = 0.0054; // Second Vgp dependent parameter for gate current in accumulation in AGBCP2 region
parameter real CIGBCP2  = 0.0075; // Third Vgp dependent parameter for gate current in accumulation in AGBCP2 region
parameter real VOXH     = 5.0; // the limit of Vox in gate current calculation
parameter real DELTAVOX = 0.005; // the smoothing parameter in the Vox smoothing function
parameter real AIGC     = (TYPE == `NMOS) ? 0.43 : 0.31; // Parameter for Igc
parameter real BIGC     = (TYPE == `NMOS) ? 0.054 : 0.024; // Parameter for Igc
parameter real CIGC     = (TYPE == `NMOS) ? 0.075 : 0.03; // Parameter for Igc
parameter real AIGSD    = (TYPE == `NMOS) ? 0.43 : 0.31; // Parameter for Igs,d
parameter real BIGSD    = (TYPE == `NMOS) ? 0.054 : 0.024; // Parameter for Igs,d
parameter real CIGSD    = (TYPE == `NMOS) ? 0.075 : 0.03; // Parameter for Igs,d
parameter real NIGC     = 1.0; // Parameter for Igc slope
parameter real PIGCD    = 1.0; // Parameter for Igc partition
parameter real POXEDGE  = 1.0; // Factor for the gate edge Tox
parameter real DLCIG    = LINT; // Delta L for Ig model
parameter real VBS0PD   = 0.0; // Upper bound of built-in potential lowering for PD operation /* v3.2 */
parameter real VBS0FD   = 0.5; // Lower bound of built-in potential lowering for FD operation /* v3.2 */
parameter real VBSA     = 0.0; // Vbs0t offset voltage
parameter real NOFFFD   = 1.0; // smoothing parameter in FD module
parameter real VOFFFD   = 0.0; // smoothing parameter in FD module
parameter real K1B      = 1.0; // first backgate body effect parameter
parameter real K2B      = 0.0; // second backgate body effect parameter for short channel effect
parameter real DK2B     = 0.0; // third backgate body effect parameter for short channel effect
parameter real DVBD0    = 0.0; // first short-channel effect parameter in FD module
parameter real DVBD1    = 0.0; // second short-channel effect parameter in FD module
parameter real MOINFD   = 1e3; // Coefficient for the gate-bias dependent surface potential in FD
parameter real XRCRG1   = 12.0; // First fitting parameter the bias-dependent Rg
parameter real XRCRG2   = 1.0; // Second fitting parameter the bias-dependent Rg
parameter real RSHG     = 0.1; // Gate sheet resistance
parameter real NGCON    = 1.0 from [1:inf); // Number of gate contacts
parameter real XGW      = 0.0; // Distance from gate contact center to device edge
parameter real XGL      = 0.0; // Variation in Ldrawn
parameter integer RDSMOD   = 0; // Bias-dependent S/D resistance model selector /* v4.0 */
parameter integer FDMOD    = 0; // Improved dVbi model selector
parameter real VSCE     = 0.0; // SCE parameter for improved dVbi model
parameter real CDSBS    = 0.0; // coupling from Vd to Vbs for improved dVbi model
parameter real MINVCV   = 0.0; // For moderate inversion in VgsteffCV
parameter real LMINVCV  = 0.0; // Length dependence of minvcv
parameter real WMINVCV  = 0.0; // width dependence of minvcv
parameter real PMINVCV  = 0.0; // Cross-term dependence of minvcv
parameter real VOFFCV   = 0.0; // CV Threshold voltage offset // NOT -0.08 for backwards-compatibility
parameter real LVOFFCV  = 0.0; // Length dependence of voffcv
parameter real WVOFFCV  = 0.0; // Width dependence of voffcv
parameter real PVOFFCV  = 0.0; // Cross-term dependence of voffcv
parameter real LXJ      = 0.0; // Length dependence of xj
parameter real LALPHAGB1 = 0.0; // Length dependence of alphagb1
parameter real LBETAGB1 = 0.0; // Length dependence of betagb1
parameter real LALPHAGB2 = 0.0; // Length dependence of alphagb2
parameter real LBETAGB2 = 0.0; // Length dependence of betagb2
parameter real LAIGBCP2 = 0.0; // Length dependence of aigbcp2
parameter real LBIGBCP2 = 0.0; // Length dependence of bigbcp2
parameter real LCIGBCP2 = 0.0; // Length dependence of cigbcp2
parameter real LCGSL    = 0.0; // Length dependence of cgsl
parameter real LCGDL    = 0.0; // Length dependence of cgdl
parameter real LCKAPPA  = 0.0; // Length dependence of ckappa
parameter real LNDIF    = 0.0; // Length dependence of ndif
parameter real LUTE     = 0.0; // Length dependence of ute
parameter real LKT1     = 0.0; // Length dependence of kt1
parameter real LKT1L    = 0.0; // Length dependence of kt1l
parameter real LKT2     = 0.0; // Length dependence of kt2
parameter real LUA1     = 0.0; // Length dependence of ua1
parameter real LUB1     = 0.0; // Length dependence of ub1
parameter real LUC1     = 0.0; // Length dependence of uc1
parameter real LAT      = 0.0; // Length dependence of at
parameter real LPRT     = 0.0; // Length dependence of prt
parameter real LNTRECF  = 0.0; // Length dependence of ntrecf
parameter real LNTRECR  = 0.0; // Length dependence of ntrecr
parameter real LXBJT    = 0.0; // Length dependence of xbjt
parameter real LXDIF    = 0.0; // Length dependence of xdif
parameter real LXREC    = 0.0; // Length dependence of xrec
parameter real LXTUN    = 0.0; // Length dependence of xtun
parameter real LXDIFD   = LXDIF; // Length dependence of xdifd
parameter real LXRECD   = LXREC; // Length dependence of xrecd
parameter real LXTUND   = LXTUN; // Length dependence of xtund
parameter real LAIGC    = 0.0; // Length dependence of aigc
parameter real LBIGC    = 0.0; // Length dependence of bigc
parameter real LCIGC    = 0.0; // Length dependence of cigc
parameter real LAIGSD   = 0.0; // Length dependence of aigsd
parameter real LBIGSD   = 0.0; // Length dependence of bigsd
parameter real LCIGSD   = 0.0; // Length dependence of cigsd
parameter real LNIGC    = 0.0; // Length dependence of nigc
parameter real LPIGCD   = 0.0; // Length dependence for pigcd
parameter real LPOXEDGE = 0.0; // Length dependence for poxedge
parameter real LNCH     = 0.0; // Length dependence of nch
parameter real LNSUB    = 0.0; // Length dependence of nsub
parameter real LNGATE   = 0.0; // Length dependence of ngate
parameter real LNSD     = 0.0; // Length dependence of nsd
parameter real LVTH0    = 0.0; // Length dependence of vto
parameter real LVFB     = 0.0; // Length dependence of vfb /* v4.1 */
parameter real LK1      = 0.0; // Length dependence of k1
parameter real LK1W1    = 0.0; // Length dependence of k1w1
parameter real LK1W2    = 0.0; // Length dependence of k1w2
parameter real LK2      = 0.0; // Length dependence of k2
parameter real LK3      = 0.0; // Length dependence of k3
parameter real LK3B     = 0.0; // Length dependence of k3b
parameter real LKB1     = 0.0; // Length dependence of kb1
parameter real LW0      = 0.0; // Length dependence of w0
parameter real LLPEB    = 0.0; // Length dependence of lpeb
parameter real LDVT0    = 0.0; // Length dependence of dvt0
parameter real LDVT1    = 0.0; // Length dependence of dvt1
parameter real LDVT2    = 0.0; // Length dependence of dvt2
parameter real LDVT0W   = 0.0; // Length dependence of dvt0w
parameter real LDVT1W   = 0.0; // Length dependence of dvt1w
parameter real LDVT2W   = 0.0; // Length dependence of dvt2w
parameter real LU0      = 0.0; // Length dependence of u0
parameter real LEU      = 0.0; // Length dependence of eu
parameter real LUA      = 0.0; // Length dependence of ua
parameter real LUB      = 0.0; // Length dependence of ub
parameter real LUC      = 0.0; // Length dependence of uc
parameter real LUD      = 0.0; // Length dependence of ud /* Bug fix # 32 Jul 09 */
parameter real LUD1     = 0.0; // Length dependence of ud1
parameter real LUCSTE   = 0.0; // Length dependence of ucste
parameter real LUCS     = 0.0; // Length dependence of lucs
parameter real LVSAT    = 0.0; // Length dependence of vsat
parameter real LA0      = 0.0; // Length dependence of a0
parameter real LAGS     = 0.0; // Length dependence of ags
parameter real LB0      = 0.0; // Length dependence of b0
parameter real LB1      = 0.0; // Length dependence of b1
parameter real LKETA    = 0.0; // Length dependence of keta
parameter real LKETAS   = 0.0; // Length dependence of ketas
parameter real LA1      = 0.0; // Length dependence of a1
parameter real LA2      = 0.0; // Length dependence of a2
parameter real LRDSW    = 0.0; // Length dependence of rdsw
parameter real LRSW     = 0.0; // Length dependence of rsw /* v4.0 */
parameter real LRDW     = 0.0; // Length dependence of rdw /* v4.0 */
parameter real LPRWB    = 0.0; // Length dependence of prwb
parameter real LPRWG    = 0.0; // Length dependence of prwg
parameter real LWR      = 0.0; // Length dependence of wr
parameter real LNFACTOR = 0.0; // Length dependence of nfactor
parameter real LDWG     = 0.0; // Length dependence of dwg
parameter real LDWB     = 0.0; // Length dependence of dwb
parameter real LVOFF    = 0.0; // Length dependence of voff
parameter real LETA0    = 0.0; // Length dependence of eta0
parameter real LETAB    = 0.0; // Length dependence of etab
parameter real LETA0CV  = LETA0; // Length dependence of eta0cv
parameter real LETABCV  = LETAB; // Length dependence of etabcv
parameter real LDSUB    = 0.0; // Length dependence of dsub
parameter real LCIT     = 0.0; // Length dependence of cit
parameter real LCDSC    = 0.0; // Length dependence of cdsc
parameter real LCDSCB   = 0.0; // Length dependence of cdscb
parameter real LCDSCD   = 0.0; // Length dependence of cdscd
parameter real LPCLM    = 0.0; // Length dependence of pclm
parameter real LPDIBLC1 = 0.0; // Length dependence of pdiblc1
parameter real LPDIBLC2 = 0.0; // Length dependence of pdiblc2
parameter real LPDIBLCB = 0.0; // Length dependence of pdiblcb
parameter real LDROUT   = 0.0; // Length dependence of drout
parameter real LPVAG    = 0.0; // Length dependence of pvag
parameter real LDELTA   = 0.0; // Length dependence of delta
parameter real LALPHA0  = 0.0; // Length dependence of alpha0
parameter real LFBJTII  = 0.0; // Length dependence of fbjtii
parameter real LABJTII  = 0.0; // Length dependence of abjtii /*Bug fix # 32 Jul 09*/
parameter real LCBJTII  = 0.0; // Length dependence of cbjtii /*Bug fix # 32 Jul 09*/
parameter real LEBJTII  = 0.0; // Length dependence of ebjtii /*Bug fix # 32 Jul 09*/
parameter real LMBJTII  = 0.0; // Length dependence of mbjtii /*Bug fix # 32 Jul 09*/
parameter real LVBCI    = 0.0; // Length dependence of vbci /*Bug fix # 32 Jul 09*/
parameter real LBETA0   = 0.0; // Length dependence of beta0
parameter real LBETA1   = 0.0; // Length dependence of beta1
parameter real LBETA2   = 0.0; // Length dependence of beta2
parameter real LVDSATII0 = 0.0; // Length dependence of vdsatii0
parameter real LLII     = 0.0; // Length dependence of lii
parameter real LESATII  = 0.0; // Length dependence of esatii
parameter real LSII0    = 0.0; // Length dependence of sii0
parameter real LSII1    = 0.0; // Length dependence of sii1
parameter real LSII2    = 0.0; // Length dependence of sii2
parameter real LSIID    = 0.0; // Length dependence of siid
parameter real LAGIDL   = 0.0; // Length dependence of agidl
parameter real LBGIDL   = 0.0; // Length dependence of bgidl
parameter real LCGIDL   = 0.0; // Length dependence of cgidl
parameter real LRGIDL   = 0.0; // Length dependence of rgidl
parameter real LKGIDL   = 0.0; // Length dependence of kgidl
parameter real LFGIDL   = 0.0; // Length dependence of fgidl
parameter real LAGISL   = LAGIDL; // Length dependence of agisl
parameter real LBGISL   = LBGIDL; // Length dependence of bgisl
parameter real LCGISL   = LCGIDL; // Length dependence of cgisl
parameter real LRGISL   = LRGIDL; // Length dependence of rgisl
parameter real LKGISL   = LKGIDL; // Length dependence of kgisl
parameter real LFGISL   = LFGIDL; // Length dependence of fgisl
parameter real LNTUN    = 0.0; // Length dependence of ntun
parameter real LNTUND   = LNTUN; // Length dependence of ntund
parameter real LNDIODE  = 0.0; // Length dependence of ndiode
parameter real LNDIODED = LNDIODE; // Length dependence of ndioded
parameter real LNRECF0  = 0.0; // Length dependence of nrecf0
parameter real LNRECF0D = LNRECF0; // Length dependence of nrecf0d
parameter real LNRECR0  = 0.0; // Length dependence of nrecr0
parameter real LNRECR0D = LNRECR0; // Length dependence of nrecr0d
parameter real LISBJT   = 0.0; // Length dependence of isbjt
parameter real LIDBJT   = LISBJT; // Length dependence of idbjt
parameter real LISDIF   = 0.0; // Length dependence of isdif
parameter real LIDDIF   = LISDIF; // Length dependence of iddif
parameter real LISREC   = 0.0; // Length dependence of isrec
parameter real LIDREC   = LISREC; // Length dependence of idrec
parameter real LISTUN   = 0.0; // Length dependence of istun
parameter real LIDTUN   = LISTUN; // Length dependence of idtun
parameter real LVREC0   = 0.0; // Length dependence of vrec0
parameter real LVREC0D  = LVREC0; // Length dependence of vrec0d
parameter real LVTUN0   = 0.0; // Length dependence of vtun0
parameter real LVTUN0D  = LVTUN0; // Length dependence of vtun0d
parameter real LNBJT    = 0.0; // Length dependence of nbjt
parameter real LLBJT0   = 0.0; // Length dependence of lbjt0
parameter real LVABJT   = 0.0; // Length dependence of vabjt
parameter real LAELY    = 0.0; // Length dependence of aely
parameter real LAHLI    = 0.0; // Length dependence of ahli /*v4.0*/
parameter real LAHLID   = LAHLI; // Length dependence of ahlid /*v4.0*/
parameter real LVSDFB   = 0.0; // Length dependence of vsdfb
parameter real LVSDTH   = 0.0; // Length dependence of vsdth
parameter real LDELVT   = 0.0; // Length dependence of delvt
parameter real LACDE    = 0.0; // Length dependence of acde
parameter real LMOIN    = 0.0; // Length dependence of moin
parameter real LNOFF    = 0.0; // Length dependence of noff /* v3.2 */
parameter real LXRCRG1  = 0.0; // Length dependence of xrcrg1
parameter real LXRCRG2  = 0.0; // Length dependence of xrcrg2
parameter real WXJ      = 0.0; // Width dependence of xj
parameter real WALPHAGB1 = 0.0; // Width dependence of alphagb1
parameter real WBETAGB1 = 0.0; // Width dependence of betagb1
parameter real WALPHAGB2 = 0.0; // Width dependence of alphagb2
parameter real WBETAGB2 = 0.0; // Width dependence of betagb2
parameter real WAIGBCP2 = 0.0; // Width dependence of aigbcp2
parameter real WBIGBCP2 = 0.0; // Width dependence of bigbcp2
parameter real WCIGBCP2 = 0.0; // Width dependence of cigbcp2
parameter real WCGSL    = 0.0; // Width dependence of cgsl
parameter real WCGDL    = 0.0; // Width dependence of cgdl
parameter real WCKAPPA  = 0.0; // Width dependence of ckappa
parameter real WNDIF    = 0.0; // Width dependence of ndif
parameter real WUTE     = 0.0; // Width dependence of ute
parameter real WKT1     = 0.0; // Width dependence of kt1
parameter real WKT1L    = 0.0; // Width dependence of kt1l
parameter real WKT2     = 0.0; // Width dependence of kt2
parameter real WUA1     = 0.0; // Width dependence of ua1
parameter real WUB1     = 0.0; // Width dependence of ub1
parameter real WUC1     = 0.0; // Width dependence of uc1
parameter real WAT      = 0.0; // Width dependence of at
parameter real WPRT     = 0.0; // Width dependence of prt
parameter real WNTRECF  = 0.0; // Width dependence of ntrecf
parameter real WNTRECR  = 0.0; // Width dependence of ntrecr
parameter real WXBJT    = 0.0; // Width dependence of xbjt
parameter real WXDIF    = 0.0; // Width dependence of xdif
parameter real WXREC    = 0.0; // Width dependence of xrec
parameter real WXTUN    = 0.0; // Width dependence of xtun
parameter real WXDIFD   = WXDIF; // Width dependence of xdifd
parameter real WXRECD   = WXREC; // Width dependence of xrecd
parameter real WXTUND   = WXTUN; // Width dependence of xtund
parameter real WAIGC    = 0.0; // Width dependence of aigc
parameter real WBIGC    = 0.0; // Width dependence of bigc
parameter real WCIGC    = 0.0; // Width dependence of cigc
parameter real WAIGSD   = 0.0; // Width dependence of aigsd
parameter real WBIGSD   = 0.0; // Width dependence of bigsd
parameter real WCIGSD   = 0.0; // Width dependence of cigsd
parameter real WNIGC    = 0.0; // Width dependence of nigc
parameter real WPIGCD   = 0.0; // Width dependence for pigcd
parameter real WPOXEDGE = 0.0; // Width dependence for poxedge
parameter real WNCH     = 0.0; // Width dependence of nch
parameter real WNSUB    = 0.0; // Width dependence of nsub
parameter real WNGATE   = 0.0; // Width dependence of ngate
parameter real WNSD     = 0.0; // Width dependence of nsd
parameter real WVTH0    = 0.0; // Width dependence of vto
parameter real WVFB     = 0.0; // Width dependence of vfb /* v4.1 */
parameter real WK1      = 0.0; // Width dependence of k1
parameter real WK1W1    = 0.0; // Width dependence of k1w1
parameter real WK1W2    = 0.0; // Width dependence of k1w2
parameter real WK2      = 0.0; // Width dependence of k2
parameter real WK3      = 0.0; // Width dependence of k3
parameter real WK3B     = 0.0; // Width dependence of k3b
parameter real WKB1     = 0.0; // Width dependence of kb1
parameter real WW0      = 0.0; // Width dependence of w0
parameter real WLPEB    = 0.0; // Width dependence of lpeb
parameter real WDVT0    = 0.0; // Width dependence of dvt0
parameter real WDVT1    = 0.0; // Width dependence of dvt1
parameter real WDVT2    = 0.0; // Width dependence of dvt2
parameter real WDVT0W   = 0.0; // Width dependence of dvt0w
parameter real WDVT1W   = 0.0; // Width dependence of dvt1w
parameter real WDVT2W   = 0.0; // Width dependence of dvt2w
parameter real WU0      = 0.0; // Width dependence of u0
parameter real WEU      = 0.0; // Width dependence of eu
parameter real WUA      = 0.0; // Width dependence of ua
parameter real WUB      = 0.0; // Width dependence of ub
parameter real WUC      = 0.0; // Width dependence of uc
parameter real WUD      = 0.0; // Width dependence of ud /* Bug fix # 32 Jul 09 */
parameter real WUD1     = 0.0; // Width dependence of ud1 /* Bug fix # 32 Jul 09 */
parameter real WUCSTE   = 0.0; // Width dependence of ucste
parameter real WUCS     = 0.0; // Width dependence of ucs
parameter real WVSAT    = 0.0; // Width dependence of vsat
parameter real WA0      = 0.0; // Width dependence of a0
parameter real WAGS     = 0.0; // Width dependence of ags
parameter real WB0      = 0.0; // Width dependence of b0
parameter real WB1      = 0.0; // Width dependence of b1
parameter real WKETA    = 0.0; // Width dependence of keta
parameter real WKETAS   = 0.0; // Width dependence of ketas
parameter real WA1      = 0.0; // Width dependence of a1
parameter real WA2      = 0.0; // Width dependence of a2
parameter real WRDSW    = 0.0; // Width dependence of rdsw
parameter real WRSW     = 0.0; // Width dependence of rsw /* v4.0 */
parameter real WRDW     = 0.0; // Width dependence of rdw /* v4.0 */
parameter real WPRWB    = 0.0; // Width dependence of prwb
parameter real WPRWG    = 0.0; // Width dependence of prwg
parameter real WWR      = 0.0; // Width dependence of wr
parameter real WNFACTOR = 0.0; // Width dependence of nfactor
parameter real WDWG     = 0.0; // Width dependence of dwg
parameter real WDWB     = 0.0; // Width dependence of dwb
parameter real WVOFF    = 0.0; // Width dependence of voff
parameter real WETA0    = 0.0; // Width dependence of eta0
parameter real WETAB    = 0.0; // Width dependence of etab
parameter real WETA0CV  = WETA0; // Width dependence of eta0cv
parameter real WETABCV  = WETAB; // Width dependence of etabcv
parameter real WDSUB    = 0.0; // Width dependence of dsub
parameter real WCIT     = 0.0; // Width dependence of cit
parameter real WCDSC    = 0.0; // Width dependence of cdsc
parameter real WCDSCB   = 0.0; // Width dependence of cdscb
parameter real WCDSCD   = 0.0; // Width dependence of cdscd
parameter real WPCLM    = 0.0; // Width dependence of pclm
parameter real WPDIBLC1 = 0.0; // Width dependence of pdiblc1
parameter real WPDIBLC2 = 0.0; // Width dependence of pdiblc2
parameter real WPDIBLCB = 0.0; // Width dependence of pdiblcb
parameter real WDROUT   = 0.0; // Width dependence of drout
parameter real WPVAG    = 0.0; // Width dependence of pvag
parameter real WDELTA   = 0.0; // Width dependence of delta
parameter real WALPHA0  = 0.0; // Width dependence of alpha0
parameter real WFBJTII  = 0.0; // Width dependence of fbjtii
parameter real WABJTII  = 0.0; // Width dependence of abjtii /*Bug fix # 32 Jul 09 */
parameter real WCBJTII  = 0.0; // Width dependence of cbjtii /*Bug fix # 32 Jul 09 */
parameter real WEBJTII  = 0.0; // Width dependence of ebjtii /*Bug fix # 32 Jul 09 */
parameter real WMBJTII  = 0.0; // Width dependence of mbjtii /*Bug fix # 32 Jul 09 */
parameter real WVBCI    = 0.0; // Width dependence of vbci /*Bug fix # 32 Jul 09*/
parameter real WBETA0   = 0.0; // Width dependence of beta0
parameter real WBETA1   = 0.0; // Width dependence of beta1
parameter real WBETA2   = 0.0; // Width dependence of beta2
parameter real WVDSATII0 = 0.0; // Width dependence of vdsatii0
parameter real WLII     = 0.0; // Width dependence of lii
parameter real WESATII  = 0.0; // Width dependence of esatii
parameter real WSII0    = 0.0; // Width dependence of sii0
parameter real WSII1    = 0.0; // Width dependence of sii1
parameter real WSII2    = 0.0; // Width dependence of sii2
parameter real WSIID    = 0.0; // Width dependence of siid
parameter real WAGIDL   = 0.0; // Width dependence of agidl
parameter real WBGIDL   = 0.0; // Width dependence of bgidl
parameter real WCGIDL   = 0.0; // Width dependence of cgidl
parameter real WRGIDL   = 0.0; // Width dependence of rgidl
parameter real WKGIDL   = 0.0; // Width dependence of kgidl
parameter real WFGIDL   = 0.0; // Width dependence of fgidl
parameter real WAGISL   = WAGIDL; // Width dependence of agisl
parameter real WBGISL   = WBGIDL; // Width dependence of bgisl
parameter real WCGISL   = WCGIDL; // Width dependence of cgisl
parameter real WRGISL   = WRGIDL; // Width dependence of rgisl
parameter real WKGISL   = WKGIDL; // Width dependence of kgisl
parameter real WFGISL   = WFGIDL; // Width dependence of fgisl
parameter real WNTUN    = 0.0; // Width dependence of ntun
parameter real WNTUND   = WNTUN; // Width dependence of ntund
parameter real WNDIODE  = 0.0; // Width dependence of ndiode
parameter real WNDIODED = WNDIODE; // Width dependence of ndioded
parameter real WNRECF0  = 0.0; // Width dependence of nrecf0
parameter real WNRECF0D = WNRECF0; // Width dependence of nrecf0d
parameter real WNRECR0  = 0.0; // Width dependence of nrecr0
parameter real WNRECR0D = WNRECR0; // Width dependence of nrecr0d
parameter real WISBJT   = 0.0; // Width dependence of isbjt
parameter real WIDBJT   = WISBJT; // Width dependence of idbjt
parameter real WISDIF   = 0.0; // Width dependence of isdif
parameter real WIDDIF   = WISDIF; // Width dependence of iddif
parameter real WISREC   = 0.0; // Width dependence of isrec
parameter real WIDREC   = WISREC; // Width dependence of idrec
parameter real WISTUN   = 0.0; // Width dependence of istun
parameter real WIDTUN   = WISTUN; // Width dependence of idtun
parameter real WVREC0   = 0.0; // Width dependence of vrec0
parameter real WVREC0D  = WVREC0; // Width dependence of vrec0d
parameter real WVTUN0   = 0.0; // Width dependence of vtun0
parameter real WVTUN0D  = WVTUN0; // Width dependence of vtun0d
parameter real WNBJT    = 0.0; // Width dependence of nbjt
parameter real WLBJT0   = 0.0; // Width dependence of lbjt0
parameter real WVABJT   = 0.0; // Width dependence of vabjt
parameter real WAELY    = 0.0; // Width dependence of aely
parameter real WAHLI    = 0.0; // Width dependence of ahli /* v4.0 */
parameter real WAHLID   = WAHLI; // Width dependence of ahlid /* v4.0 */
parameter real WVSDFB   = 0.0; // Width dependence of vsdfb
parameter real WVSDTH   = 0.0; // Width dependence of vsdth
parameter real WDELVT   = 0.0; // Width dependence of delvt
parameter real WACDE    = 0.0; // Width dependence of acde
parameter real WMOIN    = 0.0; // Width dependence of moin
parameter real WNOFF    = 0.0; // Width dependence of noff /* v3.2 */
parameter real WXRCRG1  = 0.0; // Width dependence of xrcrg1
parameter real WXRCRG2  = 0.0; // Width dependence of xrcrg2
parameter real PXJ      = 0.0; // Cross-term dependence of xj
parameter real PALPHAGB1 = 0.0; // Cross-term dependence of alphagb1
parameter real PBETAGB1 = 0.0; // Cross-term dependence of betagb1
parameter real PALPHAGB2 = 0.0; // Cross-term dependence of alphagb2
parameter real PBETAGB2 = 0.0; // Cross-term dependence of betagb2
parameter real PAIGBCP2 = 0.0; // Cross-term dependence of aigbcp2
parameter real PBIGBCP2 = 0.0; // Cross-term dependence of bigbcp2
parameter real PCIGBCP2 = 0.0; // Cross-term dependence of cigbcp2
parameter real PCGSL    = 0.0; // Cross-term dependence of cgsl
parameter real PCGDL    = 0.0; // Cross-term dependence of cgdl
parameter real PCKAPPA  = 0.0; // Cross-term dependence of ckappa
parameter real PNDIF    = 0.0; // Cross-term dependence of ndif
parameter real PUTE     = 0.0; // Cross-term dependence of ute
parameter real PKT1     = 0.0; // Cross-term dependence of kt1
parameter real PKT1L    = 0.0; // Cross-term dependence of kt1l
parameter real PKT2     = 0.0; // Cross-term dependence of kt2
parameter real PUA1     = 0.0; // Cross-term dependence of ua1
parameter real PUB1     = 0.0; // Cross-term dependence of ub1
parameter real PUC1     = 0.0; // Cross-term dependence of uc1
parameter real PAT      = 0.0; // Cross-term dependence of at
parameter real PPRT     = 0.0; // Cross-term dependence of prt
parameter real PNTRECF  = 0.0; // Cross-term dependence of ntrecf
parameter real PNTRECR  = 0.0; // Cross-term dependence of ntrecr
parameter real PXBJT    = 0.0; // Cross-term dependence of xbjt
parameter real PXDIF    = 0.0; // Cross-term dependence of xdif
parameter real PXREC    = 0.0; // Cross-term dependence of xrec
parameter real PXTUN    = 0.0; // Cross-term dependence of xtun
parameter real PXDIFD   = PXDIF; // Cross-term dependence of xdifd
parameter real PXRECD   = PXREC; // Cross-term dependence of xrecd
parameter real PXTUND   = PXTUN; // Cross-term dependence of xtund
parameter real PAIGC    = 0.0; // Cross-term dependence of aigc
parameter real PBIGC    = 0.0; // Cross-term dependence of bigc
parameter real PCIGC    = 0.0; // Cross-term dependence of cigc
parameter real PAIGSD   = 0.0; // Cross-term dependence of aigsd
parameter real PBIGSD   = 0.0; // Cross-term dependence of bigsd
parameter real PCIGSD   = 0.0; // Cross-term dependence of cigsd
parameter real PNIGC    = 0.0; // Cross-term dependence of nigc
parameter real PPIGCD   = 0.0; // Cross-term dependence for pigcd
parameter real PPOXEDGE = 0.0; // Cross-term dependence for poxedge
parameter real PNCH     = 0.0; // Cross-term dependence of nch
parameter real PNSUB    = 0.0; // Cross-term dependence of nsub
parameter real PNSD     = 0.0; // Cross-term dependence of nsd
parameter real PNGATE   = 0.0; // Cross-term dependence of ngate
parameter real PVTH0    = 0.0; // Cross-term dependence of vto
parameter real PVFB     = 0.0; // Cross-term dependence of vfb /* v4.1 */
parameter real PK1      = 0.0; // Cross-term dependence of k1
parameter real PK1W1    = 0.0; // Cross-term dependence of k1w1
parameter real PK1W2    = 0.0; // Cross-term dependence of k1w2
parameter real PK2      = 0.0; // Cross-term dependence of k2
parameter real PK3      = 0.0; // Cross-term dependence of k3
parameter real PK3B     = 0.0; // Cross-term dependence of k3b
parameter real PKB1     = 0.0; // Cross-term dependence of kb1
parameter real PW0      = 0.0; // Cross-term dependence of w0
parameter real PLPEB    = 0.0; // Cross-term dependence of lpeb
parameter real PDVT0    = 0.0; // Cross-term dependence of dvt0
parameter real PDVT1    = 0.0; // Cross-term dependence of dvt1
parameter real PDVT2    = 0.0; // Cross-term dependence of dvt2
parameter real PDVT0W   = 0.0; // Cross-term dependence of dvt0w
parameter real PDVT1W   = 0.0; // Cross-term dependence of dvt1w
parameter real PDVT2W   = 0.0; // Cross-term dependence of dvt2w
parameter real PU0      = 0.0; // Cross-term dependence of u0
parameter real PEU      = 0.0; // Cross-term dependence of eu
parameter real PUA      = 0.0; // Cross-term dependence of ua
parameter real PUB      = 0.0; // Cross-term dependence of ub
parameter real PUC      = 0.0; // Cross-term dependence of uc
parameter real PUD      = 0.0; // Cross-term dependence of ud /*Bug fix # 32 Jul 09 */
parameter real PUD1     = 0.0; // Cross-term dependence of ud1 /*Bug fix # 32 Jul 09 */
parameter real PUCSTE   = 0.0; // Cross-term dependence of ucste
parameter real PUCS     = 0.0; // Cross-term dependence of ucs
parameter real PVSAT    = 0.0; // Cross-term dependence of vsat
parameter real PA0      = 0.0; // Cross-term dependence of a0
parameter real PAGS     = 0.0; // Cross-term dependence of ags
parameter real PB0      = 0.0; // Cross-term dependence of b0
parameter real PB1      = 0.0; // Cross-term dependence of b1
parameter real PKETA    = 0.0; // Cross-term dependence of keta
parameter real PKETAS   = 0.0; // Cross-term dependence of ketas
parameter real PA1      = 0.0; // Cross-term dependence of a1
parameter real PA2      = 0.0; // Cross-term dependence of a2
parameter real PRDSW    = 0.0; // Cross-term dependence of rdsw
parameter real PRSW     = 0.0; // Cross-term dependence of rsw /*v4.0*/
parameter real PRDW     = 0.0; // Cross-term dependence of rdw /*v4.0*/
parameter real PPRWB    = 0.0; // Cross-term dependence of prwb
parameter real PPRWG    = 0.0; // Cross-term dependence of prwg
parameter real PWR      = 0.0; // Cross-term dependence of wr
parameter real PNFACTOR = 0.0; // Cross-term dependence of nfactor
parameter real PDWG     = 0.0; // Cross-term dependence of dwg
parameter real PDWB     = 0.0; // Cross-term dependence of dwb
parameter real PVOFF    = 0.0; // Cross-term dependence of voff
parameter real PETA0    = 0.0; // Cross-term dependence of eta0
parameter real PETAB    = 0.0; // Cross-term dependence of etab
parameter real PETA0CV  = PETA0; // Cross-term dependence of eta0cv
parameter real PETABCV  = PETAB; // Cross-term dependence of etabcv
parameter real PDSUB    = 0.0; // Cross-term dependence of dsub
parameter real PCIT     = 0.0; // Cross-term dependence of cit
parameter real PCDSC    = 0.0; // Cross-term dependence of cdsc
parameter real PCDSCB   = 0.0; // Cross-term dependence of cdscb
parameter real PCDSCD   = 0.0; // Cross-term dependence of cdscd
parameter real PPCLM    = 0.0; // Cross-term dependence of pclm
parameter real PPDIBLC1 = 0.0; // Cross-term dependence of pdiblc1
parameter real PPDIBLC2 = 0.0; // Cross-term dependence of pdiblc2
parameter real PPDIBLCB = 0.0; // Cross-term dependence of pdiblcb
parameter real PDROUT   = 0.0; // Cross-term dependence of drout
parameter real PPVAG    = 0.0; // Cross-term dependence of pvag
parameter real PDELTA   = 0.0; // Cross-term dependence of delta
parameter real PALPHA0  = 0.0; // Cross-term dependence of alpha0
parameter real PFBJTII  = 0.0; // Cross-term dependence of fbjtii
parameter real PABJTII  = 0.0; // Cross-term dependence of abjtii /* Bug fix # 32 Jul 09 */
parameter real PCBJTII  = 0.0; // Cross-term dependence of cbjtii /* Bug fix # 32 Jul 09 */
parameter real PEBJTII  = 0.0; // Cross-term dependence of ebjtii /* Bug fix # 32 Jul 09 */
parameter real PMBJTII  = 0.0; // Cross-term dependence of mbjtii /* Bug fix # 32 Jul 09 */
parameter real PVBCI    = 0.0; // Cross-term dependence of vbci /* Bug fix # 32 Jul 09 */
parameter real PBETA0   = 0.0; // Cross-term dependence of beta0
parameter real PBETA1   = 0.0; // Cross-term dependence of beta1
parameter real PBETA2   = 0.0; // Cross-term dependence of beta2
parameter real PVDSATII0 = 0.0; // Cross-term dependence of vdsatii0
parameter real PLII     = 0.0; // Cross-term dependence of lii
parameter real PESATII  = 0.0; // Cross-term dependence of esatii
parameter real PSII0    = 0.0; // Cross-term dependence of sii0
parameter real PSII1    = 0.0; // Cross-term dependence of sii1
parameter real PSII2    = 0.0; // Cross-term dependence of sii2
parameter real PSIID    = 0.0; // Cross-term dependence of siid
parameter real PAGIDL   = 0.0; // Cross-term dependence of agidl
parameter real PBGIDL   = 0.0; // Cross-term dependence of bgidl
parameter real PCGIDL   = 0.0; // Cross-term dependence of cgidl
parameter real PRGIDL   = 0.0; // Cross-term dependence of rgidl
parameter real PKGIDL   = 0.0; // Cross-term dependence of kgidl
parameter real PFGIDL   = 0.0; // Cross-term dependence of fgidl
parameter real PAGISL   = PAGIDL; // Cross-term dependence of agisl
parameter real PBGISL   = PBGIDL; // Cross-term dependence of bgisl
parameter real PCGISL   = PCGIDL; // Cross-term dependence of cgisl
parameter real PRGISL   = PRGIDL; // Cross-term dependence of rgisl
parameter real PKGISL   = PKGIDL; // Cross-term dependence of kgisl
parameter real PFGISL   = PFGIDL; // Cross-term dependence of fgisl
parameter real PNTUN    = 0.0; // Cross-term dependence of ntun
parameter real PNTUND   = PNTUN; // Cross-term dependence of ntund
parameter real PNDIODE  = 0.0; // Cross-term dependence of ndiode
parameter real PNDIODED = PNDIODE; // Cross-term dependence of ndiode
parameter real PNRECF0  = 0.0; // Cross-term dependence of nrecf0
parameter real PNRECF0D = PNRECF0; // Cross-term dependence of nrecf0
parameter real PNRECR0  = 0.0; // Cross-term dependence of nrecr0
parameter real PNRECR0D = PNRECR0; // Cross-term dependence of nrecr0
parameter real PISBJT   = 0.0; // Cross-term dependence of isbjt
parameter real PIDBJT   = PISBJT; // Cross-term dependence of idbjt
parameter real PISDIF   = 0.0; // Cross-term dependence of isdif
parameter real PIDDIF   = PISDIF; // Cross-term dependence of iddif
parameter real PISREC   = 0.0; // Cross-term dependence of isrec
parameter real PIDREC   = PISREC; // Cross-term dependence of idrec
parameter real PISTUN   = 0.0; // Cross-term dependence of istun
parameter real PIDTUN   = PISTUN; // Cross-term dependence of idtun
parameter real PVREC0   = 0.0; // Cross-term dependence of vrec0
parameter real PVREC0D  = PVREC0; // Cross-term dependence of vrec0d
parameter real PVTUN0   = 0.0; // Cross-term dependence of vtun0
parameter real PVTUN0D  = PVTUN0; // Cross-term dependence of vtun0d
parameter real PNBJT    = 0.0; // Cross-term dependence of nbjt
parameter real PLBJT0   = 0.0; // Cross-term dependence of lbjt0
parameter real PVABJT   = 0.0; // Cross-term dependence of vabjt
parameter real PAELY    = 0.0; // Cross-term dependence of aely
parameter real PAHLI    = 0.0; // X-term dependence of ahli /* v4.0 */
parameter real PAHLID   = PAHLI; // X-term dependence of ahlid /* v4.0 */
parameter real PVSDFB   = 0.0; // Cross-term dependence of vsdfb
parameter real PVSDTH   = 0.0; // Cross-term dependence of vsdth
parameter real PDELVT   = 0.0; // Cross-term dependence of delvt
parameter real PACDE    = 0.0; // Cross-term dependence of acde
parameter real PMOIN    = 0.0; // Cross-term dependence of moin
parameter real PNOFF    = 0.0; // Cross-term dependence of noff /* v3.2 */
parameter real PXRCRG1  = 0.0; // Cross-term dependence of xrcrg1
parameter real PXRCRG2  = 0.0; // Cross-term dependence of xrcrg2
parameter real NLX      = 1.74e-7; // Lateral non-uniform doping effect
parameter real LNLX     = 0.0; // Length dependence of nlx
parameter real WNLX     = 0.0; // Width dependence of nlx
parameter real PNLX     = 0.0; // Cross-term dependence of nlx
parameter real NGIDL    = 1.2; // GIDL first parameter
parameter real LNGIDL   = 0.0; // Length dependence of ngidl
parameter real WNGIDL   = 0.0; // Width dependence of ngidl
parameter real PNGIDL   = 0.0; // Cross-term dependence of ngidl
parameter real LPE0     = NLX; // Lateral non-uniform doping effect
parameter real EGIDL    = NGIDL; // GIDL first parameter
parameter real EGISL    = EGIDL; // GISL first parameter
parameter real LLPE0    = LNLX; // Length dependence of lpe0
parameter real LEGIDL   = LNGIDL; // Length dependence of egidl
parameter real LEGISL   = LEGIDL; // Length dependence of egisl
parameter real WLPE0    = WNLX; // Width dependence of lpe0
parameter real WEGIDL   = WNGIDL; // Width dependence of egidl
parameter real WEGISL   = WEGIDL; // Width dependence of egisl
parameter real PLPE0    = PNLX; // Cross-term dependence of lpe0
parameter real PEGIDL   = PNGIDL; // Cross-term dependence of egidl
parameter real PEGISL   = PEGIDL; // Cross-term dependence of egisl

/* New parameters added corresponding to the various material properties for mtrlMod=1 by Pankaj in May 2012*/
parameter real EGGBCP2  = 1.12; // Bandgap in Agbcp2 region
parameter real EGGDEP   = 1.12; // Bandgap for gate depletion effect
parameter real AGB1     = 3.7622e-7; // 'A' for Igb1 Tunneling current model
parameter real BGB1     = -3.1051e10; // 'B' for Igb1 Tunneling current model 
parameter real AGB2     = 4.9758e-7; // 'A' for Igb2 Tunneling current model
parameter real BGB2     = -2.357e10; // 'B' for Igb2 Tunneling current model 
parameter real AGBC2N   = 3.4254e-7; // NMOS 'A' for tunneling current model
parameter real AGBC2P   = 4.9723e-7; // PMOS 'A' for tunneling current model
parameter real BGBC2N   = 1.1665e12; // NMOS 'B' for tunneling current model
parameter real BGBC2P   = 7.4567e11; // PMOS 'B' for tunneling current model
parameter real VTM00    = 0.026; // Hard coded 25 degC thermal voltage 

`ifdef __XYCE__
  // XYCE MOD:  Add explicit multiplicity factor
  parameter real m=1.0 from (0.0:inf) (*type="instance" desc="multiplicity factor"*);
  `define MFACTOR_USE m
`else
  `define MFACTOR_USE 1.0
`endif

// Output variables
(* desc="VDSAT" *) real VDSAT;
(* desc="VTH"   *) real VTH;
(* desc="IDS"   *) real IDS;
(* desc="GM"    *) real GM;
(* desc="GDS"   *) real GDS;
(* desc="GMBS"  *) real GMBS;
(* desc="IC"    *) real IC;
(* desc="IBD"   *) real IBD;
(* desc="IBS"   *) real IBS;
(* desc="IGIDL" *) real IGIDL;
(* desc="IGISL" *) real IGISL;
(* desc="IGS"   *) real IGS;
(* desc="IGD"   *) real IGD;
(* desc="IGB"   *) real IGB;
(* desc="IGCS"  *) real IGCS;
(* desc="IGCD"  *) real IGCD;
(* desc="CGG"   *) real CGG;
(* desc="CGS"   *) real CGS;
(* desc="CGD"   *) real CGD;
(* desc="CBG"   *) real CBG;
(* desc="CBD"   *) real CBD;
(* desc="CBS"   *) real CBS;
(* desc="CDG"   *) real CDG;
(* desc="CDD"   *) real CDD;
(* desc="CDS"   *) real CDS;
(* desc="CAPBD" *) real CAPBD;
(* desc="CAPBS" *) real CAPBS;
(* desc="QG"    *) real QG;
(* desc="QB"    *) real QB;
(* desc="QD"    *) real QD;
(* desc="QS"    *) real QS;
(* desc="QJD"   *) real QJD;
(* desc="QJS"   *) real QJS;


`ifndef __XYCE__
analog begin : the_module
`endif
    integer B4SOItype;
    real B4SOIl;
    real B4SOIw;
    real B4SOInf;
    real B4SOIsa;
    real B4SOIsb;
    real B4SOIsd;
    real B4SOIdrainArea;
    real B4SOIsourceArea;
    real B4SOIdrainPerimeter;
    real B4SOIsourcePerimeter;
    real B4SOIdrainSquares;
    real B4SOIsourceSquares;
    integer B4SOIbjtoff;
    real B4SOIrth0;
    real B4SOIcth0;
    real B4SOIbodySquares;
    real B4SOIfrbody;
    real B4SOIrbdb;
    real B4SOIrbsb;
    real B4SOIdelvto;
    integer B4SOIsoiMod;
    real B4SOInbc;
    real B4SOInseg;
    real B4SOIpdbcp;
    real B4SOIpsbcp;
    real B4SOIagbcp;
    real B4SOIagbcp2;
    real B4SOIagbcpd;
    real B4SOIaebcp;
    integer B4SOIrgateMod;
    integer B4SOIrbodyMod;
    integer B4SOImtrlMod;
    integer B4SOIvgstcvMod;
    integer B4SOIgidlMod;
    integer B4SOIiiiMod;
    real B4SOIeot;
    real B4SOIepsrox;
    real B4SOIepsrsub;
    real B4SOIni0sub;
    real B4SOIbg0sub;
    real B4SOItbgasub;
    real B4SOItbgbsub;
    real B4SOIphig;
    real B4SOIeasub;
    real B4SOIleffeot;
    real B4SOIweffeot;
    real B4SOIvddeot;
    real B4SOItempeot;
    real B4SOIados;
    real B4SOIbdos;
    real B4SOIepsrgate;
    integer B4SOIcapMod;
    integer B4SOImobMod;
    integer B4SOIbinUnit;
    real B4SOItox;
    real B4SOItoxp;
    real B4SOItoxm;
    real B4SOIdtoxcv;
    real B4SOIcdsc;
    real B4SOIcdscb;
    real B4SOIcdscd;
    real B4SOIcit;
    real B4SOInfactor;
    real B4SOIvsat;
    real B4SOIat;
    real B4SOIa0;
    real B4SOIags;
    real B4SOIa1;
    real B4SOIa2;
    real B4SOIketa;
    real B4SOInsub;
    real B4SOInpeak;
    real B4SOIngate;
    real B4SOInsd;
    real B4SOIgamma1;
    real B4SOIgamma2;
    real B4SOIvbx;
    real B4SOIvbm;
    real B4SOIxt;
    real B4SOIk1;
    real B4SOIkt1;
    real B4SOIkt1l;
    real B4SOIkt2;
    real B4SOIk2;
    real B4SOIk3;
    real B4SOIk3b;
    real B4SOIw0;
    real B4SOIlpe0;
    real B4SOIlpeb;
    real B4SOIdvt0;
    real B4SOIdvt1;
    real B4SOIdvt2;
    real B4SOIdvt0w;
    real B4SOIdvt1w;
    real B4SOIdvt2w;
    real B4SOIdrout;
    real B4SOIdsub;
    real B4SOIvth0;
    real B4SOIvfb;
    real B4SOIua;
    real B4SOIua1;
    real B4SOIub;
    real B4SOIub1;
    real B4SOIuc;
    real B4SOIuc1;
    real B4SOIu0;
    real B4SOIeu;
    real B4SOIute;
    real B4SOIucs;
    real B4SOIucste;
    real B4SOIud;
    real B4SOIud1;
    real B4SOIvoff;
    real B4SOItnom;
    real B4SOIcgso;
    real B4SOIcgdo;
    real B4SOIxpart;
    real B4SOIdelta;
    real B4SOIsheetResistance;
    real B4SOIrdsw;
    real B4SOIrsw;
    real B4SOIrdw;
    real B4SOIrswmin;
    real B4SOIrdwmin;
    real B4SOIprwg;
    real B4SOIprwb;
    real B4SOIprt;
    real B4SOIeta0;
    real B4SOIetab;
    real B4SOIeta0cv; 
    real B4SOIetabcv;
    real B4SOIpclm;
    real B4SOIpdibl1;
    real B4SOIpdibl2;
    real B4SOIpdiblb;
    real B4SOIpvag;
    real B4SOItbox;
    real B4SOItsi;
    real B4SOIetsi;
    real B4SOIxj;
    real B4SOIegidl;
    real B4SOIagidl;
    real B4SOIbgidl;
    real B4SOIcgidl;
    real B4SOIrgidl;
    real B4SOIkgidl;
    real B4SOIfgidl;
    real B4SOIegisl;
    real B4SOIagisl;
    real B4SOIbgisl;
    real B4SOIcgisl;
    real B4SOIrgisl;
    real B4SOIkgisl;
    real B4SOIfgisl;
    real B4SOIndiode;
    real B4SOIndioded;
    real B4SOIxbjt;
    real B4SOIxdif;
    real B4SOIxrec;
    real B4SOIxtun;
    real B4SOIxdifd;
    real B4SOIxrecd;
    real B4SOIxtund;
    real B4SOIGatesidewallJctSPotential;
    real B4SOIGatesidewallJctDPotential;
    real B4SOIbodyJctGateSideSGradingCoeff;
    real B4SOIbodyJctGateSideDGradingCoeff;
    real B4SOIunitLengthGateSidewallJctCapS;
    real B4SOIunitLengthGateSidewallJctCapD;
    real B4SOILint;
    real B4SOILl;
    real B4SOILlc;
    real B4SOILln;
    real B4SOILw;
    real B4SOILwc;
    real B4SOILwn;
    real B4SOILwl;
    real B4SOILwlc;
    real B4SOIwr;
    real B4SOIWint;
    real B4SOIdwg;
    real B4SOIdwb;
    real B4SOIWl;
    real B4SOIWlc;
    real B4SOIWln;
    real B4SOIWw;
    real B4SOIWwc;
    real B4SOIWwn;
    real B4SOIWwl;
    real B4SOIWwlc;
    real B4SOIb0;
    real B4SOIb1;
    real B4SOIcgsl;
    real B4SOIcgdl;
    real B4SOIckappa;
    real B4SOIcf;
    real B4SOIclc;
    real B4SOIcle;
    real B4SOIdwc;
    real B4SOIdlc;
    real B4SOIalpha0;
    real B4SOIoxideTrapDensityA;
    real B4SOIoxideTrapDensityB;
    real B4SOIoxideTrapDensityC;
    real B4SOItnoia;
    real B4SOItnoib;

//Variables controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
    real B4SOItnoic; // for TNOIMOD=3
    real B4SOIrnoic; // for TNOIMOD=3
`endif

    real B4SOIrnoia;
    real B4SOIrnoib;
    real B4SOIntnoi;
    real B4SOIsaref;
    real B4SOIsbref;
    real B4SOIwlod;
    real B4SOIku0;
    real B4SOIkvsat;
    real B4SOIkvth0;
    real B4SOItku0;
    real B4SOIllodku0;
    real B4SOIwlodku0;
    real B4SOIllodvth;
    real B4SOIwlodvth;
    real B4SOIstk2;
    real B4SOIlodk2;
    real B4SOIsteta0;
    real B4SOIlodeta0;
    real B4SOIsteta0cv;
    real B4SOIlodeta0cv;
    real B4SOIgbmin;
    real B4SOIbf;
    real B4SOIw0flk;
    real B4SOIdvtp0;
    real B4SOIdvtp1;
    real B4SOIdvtp2;
    real B4SOIdvtp3;
    real B4SOIdvtp4;
    real B4SOIminv;
    real B4SOIpdits;
    real B4SOIpditsl;
    real B4SOIpditsd;
    real B4SOIfprout;
    real B4SOIem;
    real B4SOIef;
    real B4SOIaf;
    real B4SOIkf;
    real B4SOInoif;
    real B4SOIk1w1;
    real B4SOIk1w2;
    real B4SOIketas;
    real B4SOIdwbc;
    real B4SOIbeta0;
    real B4SOIbeta1;
    real B4SOIbeta2;
    real B4SOIvdsatii0;
    real B4SOItii;
    real B4SOIlii;
    real B4SOIsii0;
    real B4SOIsii1;
    real B4SOIsii2;
    real B4SOIsiid;
    real B4SOIfbjtii;
    real B4SOIebjtii;
    real B4SOIcbjtii;
    real B4SOIvbci;
    real B4SOIabjtii;
    real B4SOImbjtii;
    real B4SOItvbci;
    real B4SOIesatii;
    real B4SOIntun;
    real B4SOIntund;
    real B4SOInrecf0;
    real B4SOInrecf0d;
    real B4SOInrecr0;
    real B4SOInrecr0d;
    real B4SOIisbjt;
    real B4SOIidbjt;
    real B4SOIisdif;
    real B4SOIiddif;
    real B4SOIisrec;
    real B4SOIidrec;
    real B4SOIistun;
    real B4SOIidtun;
    real B4SOIln;
    real B4SOIvrec0;
    real B4SOIvrec0d;
    real B4SOIvtun0;
    real B4SOIvtun0d;
    real B4SOInbjt;
    real B4SOIlbjt0;
    real B4SOIldif0;
    real B4SOIvabjt;
    real B4SOIaely;
    real B4SOIahli;
    real B4SOIahlid;
    real B4SOIrbody;
    real B4SOIrbsh;
    real B4SOIcgeo;
    real B4SOItt;
    real B4SOIndif;
    real B4SOIvsdfb;
    real B4SOIvsdth;
    real B4SOIcsdmin;
    real B4SOIasd;
    real B4SOIcsdesw;
    real B4SOIntrecf;
    real B4SOIntrecr;
    real B4SOIdlcb;
    real B4SOIfbody;
    real B4SOItcjswg;
    real B4SOItpbswg;
    real B4SOItcjswgd;
    real B4SOItpbswgd;
    real B4SOIacde;
    real B4SOImoin;
    real B4SOInoff;
    real B4SOIdelvt;
    real B4SOIkb1;
    real B4SOIdlbg;
    real B4SOIcfrcoeff;
    integer B4SOIigbMod;
    integer B4SOIigcMod;
    real B4SOItoxqm;
    real B4SOIwth0;
    real B4SOIrhalo;
    real B4SOIntox;
    real B4SOItoxref;
    real B4SOIebg;
    real B4SOIvevb;
    real B4SOIalphaGB1;
    real B4SOIbetaGB1;
    real B4SOIvgb1;
    real B4SOIvecb;
    real B4SOIalphaGB2;
    real B4SOIbetaGB2;
    real B4SOIvgb2;
    real B4SOIaigbcp2;
    real B4SOIbigbcp2;
    real B4SOIcigbcp2;
    real B4SOIvoxh;
    real B4SOIdeltavox;
    real B4SOIaigc;
    real B4SOIbigc;
    real B4SOIcigc;
    real B4SOIaigsd;
    real B4SOIbigsd;
    real B4SOIcigsd;
    real B4SOInigc;
    real B4SOIpigcd;
    real B4SOIpoxedge;
    real B4SOIdlcig;
    real B4SOIvbs0pd;
    real B4SOIvbs0fd;
    real B4SOIvbsa;
    real B4SOInofffd;
    real B4SOIvofffd;
    real B4SOIk1b;
    real B4SOIk2b;
    real B4SOIdk2b;
    real B4SOIdvbd0;
    real B4SOIdvbd1;
    real B4SOImoinFD;
    real B4SOIxrcrg1;
    real B4SOIxrcrg2;
    real B4SOIrshg;
    real B4SOIngcon;
    real B4SOIxgw;
    real B4SOIxgl;
    integer B4SOIrdsMod;
    integer B4SOIfdMod;
    real B4SOIvsce;
    real B4SOIcdsbs;
    real B4SOIminvcv;
    real B4SOIvoffcv;
    real B4SOIvtm;
    real B4SOIueff;
    real B4SOIthetavth;
    real B4SOIig;
    real B4SOIgcrg;
    real B4SOIInv_ODeff;
    real B4SOIgrbsb;
    real B4SOIgrbdb;
    real B4SOIgstot;
    real B4SOIgdtot;
    real B4SOIigp;
    real B4SOITempSH;
    real B4SOIigidl;
    real B4SOIigisl;
    real B4SOIgrgeltd;
    real B4SOIsourceConductance;
    real B4SOIdrainConductance;
    real B4SOIsourceResistance;
    real B4SOIdrainResistance;
    real B4SOIvfbzb;
    real B4SOIvtfbphi1;
    real B4SOIvgsteffvth;
    real B4SOIrbodyext;
    real B4SOIcsesw;
    real B4SOIcdesw;
    real B4SOIcsbox;
    real B4SOIcdbox;
    real B4SOIcsmin;
    real B4SOIcdmin;
    real B4SOIst4;
    real B4SOIdt4;
    real B4SOInstar;
    real B4SOIAbulk;
    real B4SOIqinv;
    real B4SOIgm;
    real B4SOIgds;
    real B4SOIgmbs;
    real B4SOIIgcs;
    real B4SOIIgcd;
    real B4SOIIgs;
    real B4SOIIgd;
    real B4SOIqdrn;
    real B4SOIqsrc;
    real B4SOIqse;
    real B4SOIqde;
    real B4SOIrds;
    real B4SOIVgsteff;
    real B4SOIVdseff;
    real B4SOIAbovVgst2Vtm;
    real B4SOIidovVds;
    
    /* New variables added corresponding to the various material properties for mtrlMod=1 by Pankaj in May 2012*/
    real B4SOIEGGBCP2;  
    real B4SOIEGGDEP;   
    real B4SOIAGB1;     
    real B4SOIBGB1;     
    real B4SOIAGB2;     
    real B4SOIBGB2;     
    real B4SOIAGBC2N;   
    real B4SOIAGBC2P;   
    real B4SOIBGBC2N;   
    real B4SOIBGBC2P;   
    real B4SOIVTM00;    

    real pParam_B4SOIcdsc;
    real pParam_B4SOIcdscb;
    real pParam_B4SOIcdscd;
    real pParam_B4SOIcit;
    real pParam_B4SOInfactor;
    real pParam_B4SOIvsat;
    real pParam_B4SOIat;
    real pParam_B4SOIa0;
    real pParam_B4SOIags;
    real pParam_B4SOIa1;
    real pParam_B4SOIa2;
    real pParam_B4SOIketa;
    real pParam_B4SOInpeak;
    real pParam_B4SOInsub;
    real pParam_B4SOIngate;
    real pParam_B4SOInsd;
    real pParam_B4SOIgamma1;
    real pParam_B4SOIgamma2;
    real pParam_B4SOIvbx;
    real pParam_B4SOIvbi;
    real pParam_B4SOIvbm;
    real pParam_B4SOIxt;
    real pParam_B4SOIphi;
    real pParam_B4SOIlitl;
    real pParam_B4SOIk1;
    real pParam_B4SOIkt1;
    real pParam_B4SOIkt1l;
    real pParam_B4SOIkt2;
    real pParam_B4SOIk2;
    real pParam_B4SOIk3;
    real pParam_B4SOIk3b;
    real pParam_B4SOIw0;
    real pParam_B4SOIlpe0;
    real pParam_B4SOIdvt0;
    real pParam_B4SOIdvt1;
    real pParam_B4SOIdvt2;
    real pParam_B4SOIdvt0w;
    real pParam_B4SOIdvt1w;
    real pParam_B4SOIdvt2w;
    real pParam_B4SOIdrout;
    real pParam_B4SOIdsub;
    real pParam_B4SOIvth0;
    real pParam_B4SOIua;
    real pParam_B4SOIua1;
    real pParam_B4SOIub;
    real pParam_B4SOIub1;
    real pParam_B4SOIuc;
    real pParam_B4SOIuc1;
    real pParam_B4SOIu0;
    real pParam_B4SOIute;
    real pParam_B4SOIud;
    real pParam_B4SOIud1;
    real pParam_B4SOIeu;
    real pParam_B4SOIucs;
    real pParam_B4SOIucste;
    real pParam_B4SOIvoff;
    real pParam_B4SOIvfb;
    real pParam_B4SOIuatemp;
    real pParam_B4SOIubtemp;
    real pParam_B4SOIuctemp;
    real pParam_B4SOIrbody;
    real pParam_B4SOIrth;
    real pParam_B4SOIcth;
    real pParam_B4SOIrds0denom;
    real pParam_B4SOIvfbb;
    real pParam_B4SOIjbjts;
    real pParam_B4SOIjbjtd;
    real pParam_B4SOIjdifs;
    real pParam_B4SOIjdifd;
    real pParam_B4SOIjrecs;
    real pParam_B4SOIjrecd;
    real pParam_B4SOIjtuns;
    real pParam_B4SOIjtund;
    real pParam_B4SOIrdw;
    real pParam_B4SOIrsw;
    real pParam_B4SOIrdwmin;
    real pParam_B4SOIrswmin;
    real pParam_B4SOIrd0;
    real pParam_B4SOIrs0;
    real pParam_B4SOIsdt1;
    real pParam_B4SOIst2;
    real pParam_B4SOIst3;
    real pParam_B4SOIdt2;
    real pParam_B4SOIdt3;
    real pParam_B4SOIdelta;
    real pParam_B4SOIrdsw;
    real pParam_B4SOIrds0;
    real pParam_B4SOIprwg;
    real pParam_B4SOIprwb;
    real pParam_B4SOIprt;
    real pParam_B4SOIeta0;
    real pParam_B4SOIetab;
    real pParam_B4SOIeta0cv;
    real pParam_B4SOIetabcv;
    real pParam_B4SOIpclm;
    real pParam_B4SOIpdibl1;
    real pParam_B4SOIpdibl2;
    real pParam_B4SOIpdiblb;
    real pParam_B4SOIpvag;
    real pParam_B4SOIwr;
    real pParam_B4SOIdwg;
    real pParam_B4SOIdwb;
    real pParam_B4SOIb0;
    real pParam_B4SOIb1;
    real pParam_B4SOIalpha0;
    real pParam_B4SOIbeta0;
    real pParam_B4SOIaigc;
    real pParam_B4SOIbigc;
    real pParam_B4SOIcigc;
    real pParam_B4SOIaigsd;
    real pParam_B4SOIbigsd;
    real pParam_B4SOIcigsd;
    real pParam_B4SOInigc;
    real pParam_B4SOIpigcd;
    real pParam_B4SOIpoxedge;
    real pParam_B4SOIdlcig;
    real pParam_B4SOIxrcrg1;
    real pParam_B4SOIxrcrg2;
    real pParam_B4SOIku0;
    real pParam_B4SOIkvth0;
    real pParam_B4SOIku0temp;
    real pParam_B4SOIrho_ref;
    real pParam_B4SOIinv_od_ref;
    real pParam_B4SOIcgsl;
    real pParam_B4SOIcgdl;
    real pParam_B4SOIckappa;
    real pParam_B4SOIcf;
    real pParam_B4SOIclc;
    real pParam_B4SOIcle;
    real pParam_B4SOIxj;
    real pParam_B4SOIalphaGB1;
    real pParam_B4SOIbetaGB1;
    real pParam_B4SOIalphaGB2;
    real pParam_B4SOIbetaGB2;
    real pParam_B4SOIaigbcp2;
    real pParam_B4SOIbigbcp2;
    real pParam_B4SOIcigbcp2;
    real pParam_B4SOIndif;
    real pParam_B4SOIntrecf;
    real pParam_B4SOIntrecr;
    real pParam_B4SOIxbjt;
    real pParam_B4SOIxdif;
    real pParam_B4SOIxrec;
    real pParam_B4SOIxtun;
    real pParam_B4SOIxdifd;
    real pParam_B4SOIxrecd;
    real pParam_B4SOIxtund;
    real pParam_B4SOIkb1;
    real pParam_B4SOIk1w1;
    real pParam_B4SOIk1w2;
    real pParam_B4SOIketas;
    real pParam_B4SOIfbjtii;
    real pParam_B4SOIebjtii;
    real pParam_B4SOIcbjtii;
    real pParam_B4SOIvbci;
    real pParam_B4SOIabjtii;
    real pParam_B4SOImbjtii;
    real pParam_B4SOIbeta1;
    real pParam_B4SOIbeta2;
    real pParam_B4SOIvdsatii0;
    real pParam_B4SOIlii;
    real pParam_B4SOIesatii;
    real pParam_B4SOIsii0;
    real pParam_B4SOIsii1;
    real pParam_B4SOIsii2;
    real pParam_B4SOIsiid;
    real pParam_B4SOIagidl;
    real pParam_B4SOIbgidl;
    real pParam_B4SOIcgidl;
    real pParam_B4SOIegidl;
    real pParam_B4SOIrgidl;
    real pParam_B4SOIkgidl;
    real pParam_B4SOIfgidl;
    real pParam_B4SOIagisl;
    real pParam_B4SOIbgisl;
    real pParam_B4SOIcgisl;
    real pParam_B4SOIegisl;
    real pParam_B4SOIrgisl;
    real pParam_B4SOIkgisl;
    real pParam_B4SOIfgisl;
    real pParam_B4SOIntun;
    real pParam_B4SOIntund;
    real pParam_B4SOIndiode;
    real pParam_B4SOIndioded;
    real pParam_B4SOInrecf0;
    real pParam_B4SOInrecf0d;
    real pParam_B4SOInrecr0;
    real pParam_B4SOInrecr0d;
    real pParam_B4SOIisbjt;
    real pParam_B4SOIidbjt;
    real pParam_B4SOIisdif;
    real pParam_B4SOIiddif;
    real pParam_B4SOIisrec;
    real pParam_B4SOIidrec;
    real pParam_B4SOIistun;
    real pParam_B4SOIidtun;
    real pParam_B4SOIvrec0;
    real pParam_B4SOIvrec0d;
    real pParam_B4SOIvtun0;
    real pParam_B4SOIvtun0d;
    real pParam_B4SOInbjt;
    real pParam_B4SOIlbjt0;
    real pParam_B4SOIvabjt;
    real pParam_B4SOIaely;
    real pParam_B4SOIvsdfb;
    real pParam_B4SOIvsdth;
    real pParam_B4SOIdelvt;
    real pParam_B4SOIdw;
    real pParam_B4SOIdl;
    real pParam_B4SOIleff;
    real pParam_B4SOIweff;
    real pParam_B4SOIdwc;
    real pParam_B4SOIdlc;
    real pParam_B4SOIleffCV;
    real pParam_B4SOIweffCV;
    real pParam_B4SOIabulkCVfactor;
    real pParam_B4SOIcgso;
    real pParam_B4SOIcgdo;
    real pParam_B4SOIcgeo;
    real pParam_B4SOIu0temp;
    real pParam_B4SOIvsattemp;
    real pParam_B4SOIsqrtPhi;
    real pParam_B4SOIXdep0;
    real pParam_B4SOIsqrtXdep0;
    real pParam_B4SOItheta0vb0;
    real pParam_B4SOIthetaRout;
    real pParam_B4SOIqsi;
    real pParam_B4SOIoxideRatio;
    real pParam_B4SOIk1eff;
    real pParam_B4SOIwdios;
    real pParam_B4SOIwdiod;
    real pParam_B4SOIwdiodCV;
    real pParam_B4SOIwdiosCV;
    real pParam_B4SOIarfabjt;
    real pParam_B4SOIlratio;
    real pParam_B4SOIlratiodif;
    real pParam_B4SOIvearly;
    real pParam_B4SOIahli;
    real pParam_B4SOIahlid;
    real pParam_B4SOIahli0s;
    real pParam_B4SOIahli0d;
    real pParam_B4SOIvfbzb;
    real pParam_B4SOIldeb;
    real pParam_B4SOIacde;
    real pParam_B4SOImoin;
    real pParam_B4SOInoff;
    real pParam_B4SOIleffCVb;
    real pParam_B4SOIleffCVbg;
    real pParam_B4SOIcdep0;
    real pParam_B4SOIToxRatio;
    real pParam_B4SOIAechvb;
    real pParam_B4SOIBechvb;
    real pParam_B4SOIToxRatioEdge;
    real pParam_B4SOIAechvbEdges;
    real pParam_B4SOIAechvbEdged;
    real pParam_B4SOIBechvbEdge;
    real pParam_B4SOIvfbsd;
    real pParam_B4SOIk1ox;
    real pParam_B4SOIlpeb;
    real pParam_B4SOIdvtp0;
    real pParam_B4SOIdvtp1;
    real pParam_B4SOIdvtp2;
    real pParam_B4SOIdvtp3;
    real pParam_B4SOIdvtp4;
    real pParam_B4SOIminv;
    real pParam_B4SOImstar;
    real pParam_B4SOIfprout;
    real pParam_B4SOIpdits;
    real pParam_B4SOIpditsd;
    real pParam_B4SOImstarcv;
    real pParam_B4SOIminvcv;
    real pParam_B4SOIvoffcv;
    real pParam_B4SOIdvtp2factor;
    real B4SOIcbox;
    real B4SOIcsi;
    real B4SOIeg0;
    real B4SOIeg;
    real B4SOIcox;
    real B4SOIfactor1;
    integer B4SOImode;
    integer B4SOIbodyMod; // >0 when b and/or p terminals are connected


    // instance values for sti stress effect
    real here_B4SOIeta0, here_B4SOIeta0cv, here_B4SOIk2, here_B4SOIk2ox, here_B4SOIu0temp;
    real here_B4SOIvfb, here_B4SOIvsattemp, here_B4SOIvth0;

    real DevTemp, delTemp, TempRatio, TempRatioMinus1;
    real fourkt, gdnoise, gsnoise;
    real toxe, epsrox, epssub, epsgate, sqrt2qeps;

    real eggbcp2, eggdep, Vtm00;
    real agb1, bgb1, agb2, bgb2, agbc2n, agbc2p, bgbc2n, bgbc2p;

    real Qsi, Vbs0t;

`ifdef __XYCE__
analog begin : the_module
`endif
    real NchMax;
 
`ifdef __XYCE__
@(initial_instance)
    begin: initialize_instance
`endif
    DevTemp = $temperature + DTEMP;

    B4SOItype = TYPE;
    B4SOIl = L;
    B4SOIw = W;
    B4SOInf = NF;
    B4SOIsa = SA;
    B4SOIsb = SB;
    B4SOIsd = SD;
    B4SOIdrainArea = AD;
    B4SOIsourceArea = AS;
    B4SOIdrainPerimeter = PD;
    B4SOIsourcePerimeter = PS;
    B4SOIdrainSquares = NRD;
    B4SOIsourceSquares = NRS;
    B4SOIbjtoff = BJTOFF;
    B4SOIrth0 = RTH0;
    B4SOIcth0 = CTH0;
    B4SOIbodySquares = NRB;
    B4SOIfrbody = FRBODY;
    B4SOIrbdb = RBDB;
    B4SOIrbsb = RBSB;
    B4SOIdelvto = DELVTO;
    B4SOIsoiMod = SOIMOD;
    B4SOInbc = NBC;
    B4SOInseg = NSEG;
    B4SOIpdbcp = PDBCP;
    B4SOIpsbcp = PSBCP;
    B4SOIagbcp = AGBCP;
    B4SOIagbcp2 = AGBCP2;
    B4SOIagbcpd = AGBCPD;
    B4SOIaebcp = AEBCP;
    B4SOIrgateMod = RGATEMOD;
    B4SOIrbodyMod = RBODYMOD;
    B4SOImtrlMod = MTRLMOD;
    B4SOIvgstcvMod = VGSTCVMOD;
    B4SOIgidlMod = GIDLMOD;
    B4SOIiiiMod = IIIMOD;
    B4SOIeot = EOT;
    B4SOIepsrox = EPSROX;
    B4SOIepsrsub = EPSRSUB;
    B4SOIni0sub = NI0SUB;
    B4SOIbg0sub = BG0SUB;
    B4SOItbgasub = TBGASUB;
    B4SOItbgbsub = TBGBSUB;
    B4SOIphig = PHIG;
    B4SOIeasub = EASUB;
    B4SOIleffeot = LEFFEOT;
    B4SOIweffeot = WEFFEOT;
    B4SOIvddeot = VDDEOT;
    B4SOItempeot = TEMPEOT;
    B4SOIados = ADOS;
    B4SOIbdos = BDOS;
    B4SOIepsrgate = EPSRGATE;
    B4SOIcapMod = CAPMOD;
    B4SOImobMod = MOBMOD;
    B4SOIbinUnit = BINUNIT;
    B4SOItox = TOX;
    B4SOItoxm = TOXM;
    B4SOIdtoxcv = DTOXCV;
    B4SOIcdsc = CDSC;
    B4SOIcdscb = CDSCB;
    B4SOIcdscd = CDSCD;
    B4SOIcit = CIT;
    B4SOInfactor = NFACTOR;
    B4SOIvsat = VSAT;
    B4SOIat = AT;
    B4SOIa0 = A0;
    B4SOIags = AGS;
    B4SOIa1 = A1;
    B4SOIa2 = A2;
    B4SOIketa = KETA;
    B4SOInsub = NSUB;
    B4SOInpeak = NCH;
    B4SOIngate = NGATE;
    B4SOInsd = NSD;
    B4SOIgamma1 = GAMMA1;
    B4SOIgamma2 = GAMMA2;
    B4SOIvbx = VBX;
    B4SOIvbm = VBM;
    B4SOIxt = XT;
    B4SOIk1 = K1;
    B4SOIkt1 = KT1;
    B4SOIkt1l = KT1L;
    B4SOIkt2 = KT2;
    B4SOIk2 = K2;
    B4SOIk3 = K3;
    B4SOIk3b = K3B;
    B4SOIw0 = W0;
    B4SOIlpe0 = LPE0;
    B4SOIlpeb = LPEB;
    B4SOIdvt0 = DVT0;
    B4SOIdvt1 = DVT1;
    B4SOIdvt2 = DVT2;
    B4SOIdvt0w = DVT0W;
    B4SOIdvt1w = DVT1W;
    B4SOIdvt2w = DVT2W;
    B4SOIdrout = DROUT;
    B4SOIdsub = DSUB;
    B4SOIvth0 = VTH0;
    B4SOIvfb = VFB;
    B4SOIua = UA;
    B4SOIua1 = UA1;
    B4SOIub = UB;
    B4SOIub1 = UB1;
    B4SOIuc = UC;
    B4SOIuc1 = UC1;
    B4SOIu0 = U0;
    B4SOIeu = EU;
    B4SOIute = UTE;
    B4SOIucs = UCS;
    B4SOIucste = UCSTE;
    B4SOIud = UD;
    B4SOIud1 = UD1;
    B4SOIvoff = VOFF;
    B4SOItnom = TNOM + `P_CELSIUS0;
    B4SOIxpart = XPART;
    B4SOIdelta = DELTA;
    B4SOIsheetResistance = RSH;
    B4SOIrdsw = RDSW;
    B4SOIrsw = RSW;
    B4SOIrdw = RDW;
    B4SOIrswmin = RSWMIN;
    B4SOIrdwmin = RDWMIN;
    B4SOIprwg = PRWG;
    B4SOIprwb = PRWB;
    B4SOIprt = PRT;
    B4SOIeta0 = ETA0;
    B4SOIetab = ETAB;
    B4SOIeta0cv = ETA0CV;
    B4SOIetabcv = ETABCV;
    B4SOIpclm = PCLM;
    B4SOIpdibl1 = PDIBLC1;
    B4SOIpdibl2 = PDIBLC2;
    B4SOIpdiblb = PDIBLCB;
    B4SOIpvag = PVAG;
    B4SOItbox = TBOX;
    B4SOItsi = TSI;
    B4SOIetsi = ETSI;
    B4SOIxj = XJ;
    B4SOIegidl = EGIDL;
    B4SOIagidl = AGIDL;
    B4SOIbgidl = BGIDL;
    B4SOIcgidl = CGIDL;
    B4SOIrgidl = RGIDL;
    B4SOIkgidl = KGIDL;
    B4SOIfgidl = FGIDL;
    B4SOIegisl = EGISL;
    B4SOIagisl = AGISL;
    B4SOIbgisl = BGISL;
    B4SOIcgisl = CGISL;
    B4SOIrgisl = RGISL;
    B4SOIkgisl = KGISL;
    B4SOIfgisl = FGISL;
    B4SOIndiode = NDIODE;
    B4SOIndioded = NDIODED;
    B4SOIxbjt = XBJT;
    B4SOIxdif = XDIF;
    B4SOIxrec = XREC;
    B4SOIxtun = XTUN;
    B4SOIxdifd = XDIFD;
    B4SOIxrecd = XRECD;
    B4SOIxtund = XTUND;
    B4SOIGatesidewallJctSPotential = PBSWG;
    B4SOIGatesidewallJctDPotential = PBSWGD;
    B4SOIbodyJctGateSideSGradingCoeff = MJSWG;
    B4SOIbodyJctGateSideDGradingCoeff = MJSWGD;
    B4SOIunitLengthGateSidewallJctCapS = CJSWG;
    B4SOIunitLengthGateSidewallJctCapD = CJSWGD;
    B4SOILint = LINT;
    B4SOILl = LL;
    B4SOILlc = LLC;
    B4SOILln = LLN;
    B4SOILw = LW;
    B4SOILwc = LWC;
    B4SOILwn = LWN;
    B4SOILwl = LWL;
    B4SOILwlc = LWLC;
    B4SOIwr = WR;
    B4SOIWint = WINT;
    B4SOIdwg = DWG;
    B4SOIdwb = DWB;
    B4SOIWl = WL;
    B4SOIWlc = WLC;
    B4SOIWln = WLN;
    B4SOIWw = WW;
    B4SOIWwc = WWC;
    B4SOIWwn = WWN;
    B4SOIWwl = WWL;
    B4SOIWwlc = WWLC;
    B4SOIb0 = B0;
    B4SOIb1 = B1;
    B4SOIcgsl = CGSL;
    B4SOIcgdl = CGDL;
    B4SOIckappa = CKAPPA;
    B4SOIclc = CLC;
    B4SOIcle = CLE;
    B4SOIdwc = DWC;
    B4SOIdlc = DLC;
    B4SOIalpha0 = ALPHA0;
    B4SOIoxideTrapDensityA = NOIA;
    B4SOIoxideTrapDensityB = NOIB;
    B4SOIoxideTrapDensityC = NOIC;
    B4SOItnoia = TNOIA;
    B4SOItnoib = TNOIB;

//Assignments controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
    B4SOItnoic = TNOIC; 
    B4SOIrnoic = RNOIC;
`endif 

    B4SOIrnoia = RNOIA;
    B4SOIrnoib = RNOIB;
    B4SOIntnoi = NTNOI;
    B4SOIsaref = SAREF;
    B4SOIsbref = SBREF;
    B4SOIwlod = WLOD;
    B4SOIku0 = KU0;
    B4SOIkvsat = KVSAT;
    B4SOIkvth0 = KVTH0;
    B4SOItku0 = TKU0;
    B4SOIllodku0 = LLODKU0;
    B4SOIwlodku0 = WLODKU0;
    B4SOIllodvth = LLODVTH;
    B4SOIwlodvth = WLODVTH;
    B4SOIstk2 = STK2;
    B4SOIlodk2 = LODK2;
    B4SOIsteta0 = STETA0;
    B4SOIlodeta0 = LODETA0;
    B4SOIsteta0cv = STETA0CV;
    B4SOIlodeta0cv = LODETA0CV;
    B4SOIgbmin = GBMIN;
    B4SOIbf = BF;
    B4SOIw0flk = W0FLK;
    B4SOIdvtp0 = DVTP0;
    B4SOIdvtp1 = DVTP1;
    B4SOIdvtp2 = DVTP2;
    B4SOIdvtp3 = DVTP3;
    B4SOIdvtp4 = DVTP4;
    B4SOIminv = MINV;
    B4SOIpdits = PDITS;
    B4SOIpditsl = PDITSL;
    B4SOIpditsd = PDITSD;
    B4SOIfprout = FPROUT;
    B4SOIem = EM;
    B4SOIef = EF;
    B4SOIaf = AF;
    B4SOIkf = KF;
    B4SOInoif = NOIF;
    B4SOIk1w1 = K1W1;
    B4SOIk1w2 = K1W2;
    B4SOIketas = KETAS;
    B4SOIdwbc = DWBC;
    B4SOIbeta0 = BETA0;
    B4SOIbeta1 = BETA1;
    B4SOIbeta2 = BETA2;
    B4SOIvdsatii0 = VDSATII0;
    B4SOItii = TII;
    B4SOIlii = LII;
    B4SOIsii0 = SII0;
    B4SOIsii1 = SII1;
    B4SOIsii2 = SII2;
    B4SOIsiid = SIID;
    B4SOIfbjtii = FBJTII;
    B4SOIebjtii = EBJTII;
    B4SOIcbjtii = CBJTII;
    B4SOIvbci = VBCI;
    B4SOIabjtii = ABJTII;
    B4SOImbjtii = MBJTII;
    B4SOItvbci = TVBCI;
    B4SOIesatii = ESATII;
    B4SOIntun = NTUN;
    B4SOIntund = NTUND;
    B4SOInrecf0 = NRECF0;
    B4SOInrecf0d = NRECF0D;
    B4SOInrecr0 = NRECR0;
    B4SOInrecr0d = NRECR0D;
    B4SOIisbjt = ISBJT;
    B4SOIidbjt = IDBJT;
    B4SOIisdif = ISDIF;
    B4SOIiddif = IDDIF;
    B4SOIisrec = ISREC;
    B4SOIidrec = IDREC;
    B4SOIistun = ISTUN;
    B4SOIidtun = IDTUN;
    B4SOIln = LN;
    B4SOIvrec0 = VREC0;
    B4SOIvrec0d = VREC0D;
    B4SOIvtun0 = VTUN0;
    B4SOIvtun0d = VTUN0D;
    B4SOInbjt = NBJT;
    B4SOIlbjt0 = LBJT0;
    B4SOIldif0 = LDIF0;
    B4SOIvabjt = VABJT;
    B4SOIaely = AELY;
    B4SOIahli = AHLI;
    B4SOIahlid = AHLID;
    B4SOIrbody = RBODY;
    B4SOIrbsh = RBSH;
    B4SOIcgeo = CGEO;
    B4SOItt = TT;
    B4SOIndif = NDIF;
    B4SOIvsdfb = VSDFB;
    B4SOIvsdth = VSDTH;
    B4SOIcsdmin = CSDMIN;
    B4SOIasd = ASD;
    B4SOIcsdesw = CSDESW;
    B4SOIntrecf = NTRECF;
    B4SOIntrecr = NTRECR;
    B4SOIdlcb = DLCB;
    B4SOIfbody = FBODY;
    B4SOItcjswg = TCJSWG;
    B4SOItpbswg = TPBSWG;
    B4SOItcjswgd = TCJSWGD;
    B4SOItpbswgd = TPBSWGD;
    B4SOIacde = ACDE;
    B4SOImoin = MOIN;
    B4SOInoff = NOFF;
    B4SOIdelvt = DELVT;
    B4SOIkb1 = KB1;
    B4SOIdlbg = DLBG;
    B4SOIcfrcoeff = CFRCOEFF;
    B4SOIigbMod = IGMOD;
    B4SOIigcMod = IGCMOD;
    B4SOItoxqm = TOXQM;
    B4SOIwth0 = WTH0;
    B4SOIrhalo = RHALO;
    B4SOIntox = NTOX;
    B4SOItoxref = TOXREF;
    B4SOIebg = EBG;
    B4SOIvevb = VEVB;
    B4SOIalphaGB1 = ALPHAGB1;
    B4SOIbetaGB1 = BETAGB1;
    B4SOIvgb1 = VGB1;
    B4SOIvecb = VECB;
    B4SOIalphaGB2 = ALPHAGB2;
    B4SOIbetaGB2 = BETAGB2;
    B4SOIvgb2 = VGB2;
    B4SOIaigbcp2 = AIGBCP2;
    B4SOIbigbcp2 = BIGBCP2;
    B4SOIcigbcp2 = CIGBCP2;
    B4SOIvoxh = VOXH;
    B4SOIdeltavox = DELTAVOX;
    B4SOIaigc = AIGC;
    B4SOIbigc = BIGC;
    B4SOIcigc = CIGC;
    B4SOIaigsd = AIGSD;
    B4SOIbigsd = BIGSD;
    B4SOIcigsd = CIGSD;
    B4SOInigc = NIGC;
    B4SOIpigcd = PIGCD;
    B4SOIpoxedge = POXEDGE;
    B4SOIdlcig = DLCIG;
    B4SOIvbs0pd = VBS0PD;
    B4SOIvbs0fd = VBS0FD;
    B4SOIvbsa = VBSA;
    B4SOInofffd = NOFFFD;
    B4SOIvofffd = VOFFFD;
    B4SOIk1b = K1B;
    B4SOIk2b = K2B;
    B4SOIdk2b = DK2B;
    B4SOIdvbd0 = DVBD0;
    B4SOIdvbd1 = DVBD1;
    B4SOImoinFD = MOINFD;
    B4SOIxrcrg1 = XRCRG1;
    B4SOIxrcrg2 = XRCRG2;
    B4SOIrshg = RSHG;
    B4SOIngcon = NGCON;
    B4SOIxgw = XGW;
    B4SOIxgl = XGL;
    B4SOIrdsMod = RDSMOD;
    B4SOIfdMod = FDMOD;
    B4SOIvsce = VSCE;
    B4SOIcdsbs = CDSBS;
    B4SOIminvcv = MINVCV;
    B4SOIvoffcv = VOFFCV;
    
    /* New varaibles added corresponding to the various material properties for mtrlMod=1 by Pankaj in May 2012*/
    B4SOIEGGBCP2=EGGBCP2;  
    B4SOIEGGDEP=EGGDEP;   
    B4SOIAGB1=AGB1;     
    B4SOIBGB1=BGB1;     
    B4SOIAGB2=AGB2;     
    B4SOIBGB2=BGB2;     
    B4SOIAGBC2N=AGBC2N;   
    B4SOIAGBC2P=AGBC2P;   
    B4SOIBGBC2N=BGBC2N;   
    B4SOIBGBC2P=BGBC2P;   
    B4SOIVTM00=VTM00;    


    if ($param_given(LPE0) && $param_given(NLX))
        $strobe("Warning: parameter LPE0 overrides NLX.");
    if ($param_given(LLPE0) && $param_given(LNLX))
        $strobe("Warning: parameter LLPE0 overrides LNLX.");
    if ($param_given(WLPE0) && $param_given(WNLX))
        $strobe("Warning: parameter WLPE0 overrides WNLX.");
    if ($param_given(PLPE0) && $param_given(PNLX))
        $strobe("Warning: parameter PLPE0 overrides PNLX.");
    if ($param_given(EGIDL) && $param_given(NGIDL))
        $strobe("Warning: parameter EGIDL overrides NGIDL.");
    if ($param_given(LEGIDL) && $param_given(LNGIDL))
        $strobe("Warning: parameter LEGIDL overrides LNGIDL.");
    if ($param_given(WEGIDL) && $param_given(WNGIDL))
        $strobe("Warning: parameter WEGIDL overrides WNGIDL.");
    if ($param_given(PEGIDL) && $param_given(PNGIDL))
        $strobe("Warning: parameter PEGIDL overrides PNGIDL.");

    /*B4SOIcox = 3.453133e-11 / B4SOItox;*/
    if (B4SOImtrlMod) begin
        epsrox = 3.9;
        toxe = B4SOIeot;
        epssub = `EPS0 * B4SOIepsrsub;
        sqrt2qeps = sqrt(2.0e6 * `Charge_q * epssub);
        //B4SOIcox = 3.453133e-11 / B4SOItox;
        B4SOIcox = epsrox * `EPS0 / toxe;

        /*These constants are replaced with model parameters by Pankaj in May 2012*/
        eggbcp2 = B4SOIEGGBCP2;
        eggdep = B4SOIEGGDEP;
        agb1 = B4SOIAGB1;
        bgb1 = B4SOIBGB1;
        agb2 = B4SOIAGB2;
        bgb2 = B4SOIBGB2;
        agbc2n = B4SOIAGBC2N;
        agbc2p = B4SOIAGBC2P;
        bgbc2n = B4SOIBGBC2N;
        bgbc2p = B4SOIBGBC2P;

    end else begin
        epsrox = B4SOIepsrox;
        toxe = B4SOItox;
        epssub = `EPSSI;
        sqrt2qeps = 5.753e-12; /* constant from v4.3.0 and earlier */
        //B4SOIcox = epsrox * `EPS0 / toxe;
        B4SOIcox = 3.453133e-11 / B4SOItox;

        /* following constants are valid for mtrlMod=0 -v4.3.1 Tanvir */

        eggbcp2 = 1.12;
        eggdep = 1.12;
        agb1 = 3.7622e-7;
        bgb1 = -3.1051e10;
        agb2 = 4.9758e-7;
        bgb2 = -2.357e10;
        agbc2n = 3.42537e-7;
        agbc2p = 4.97232e-7;
        bgbc2n = 1.16645e12;
        bgbc2p = 7.45669e11;
    end
   
    /* Check of Nch and Body thickness for SOIMOD = 2 */
    if (B4SOIsoiMod == 2) begin
        if (B4SOImtrlMod) begin
            NchMax = (B4SOIbg0sub - 0.1) / `Charge_q * 2e-6 * epssub / (B4SOIetsi * B4SOIetsi);
            if (B4SOInpeak > NchMax ) begin
                $strobe("SOIMOD=2 cannot support given Nch=%g cm^-3 and Etsi=%g m ",B4SOInpeak,B4SOIetsi);
                $strobe("Exceeds maximum allowed band bending of (Eg-0.1)eV");
                $strobe("Nch is set to  %g cm^-3", NchMax);
                B4SOInpeak = NchMax;
            end
        end else begin
            NchMax = (1.12 - 0.1) / `Charge_q * 2e-6 * epssub / (B4SOItsi * B4SOItsi);
            if (B4SOInpeak > NchMax ) begin               
                $strobe("SOIMOD=2 cannot support given Nch=%g cm^-3 and Tsi=%g m ",B4SOInpeak,B4SOItsi);
                $strobe("Exceeds maximum allowed band bending of (Eg-0.1)eV");
                $strobe("Nch is set to  %g cm^-3", NchMax);               
                B4SOInpeak = NchMax;
            end
        end
    end

    /* process effective silicon film thickness */
    B4SOIcbox = 3.453133e-11 / B4SOItbox;
    if (B4SOImtrlMod) begin
        B4SOIcsi = `EPSSI / B4SOIetsi;
    end else begin
        B4SOIcsi = `EPSSI / B4SOItsi;
    end
    // Cboxt = B4SOIcbox * B4SOIcsi / (B4SOIcbox + B4SOIcsi);

    /* v3.2 */
    if (B4SOImtrlMod) begin
        Qsi = `Charge_q * B4SOInpeak
                * (1.0 + B4SOIlpe0 / B4SOIl) * 1e6 * B4SOIetsi;
    end else begin
        Qsi = `Charge_q * B4SOInpeak
                * (1.0 + B4SOIlpe0 / B4SOIl) * 1e6 * B4SOItsi;
    end
    Vbs0t = 0.8 - 0.5 * Qsi / B4SOIcsi + B4SOIvbsa;

    if (B4SOIsoiMod == 3) /* auto selection */
       if (Vbs0t > B4SOIvbs0fd)
          B4SOIsoiMod = 2; /* ideal FD mode */
       else
          if (Vbs0t < B4SOIvbs0pd)
             B4SOIsoiMod = 0; /* BSIMPD */
          else
             B4SOIsoiMod = 1;

`ifdef PORT_CONNECTED
`ifndef __XYCE__
    if (B4SOIsoiMod == 2) begin /* v3.2 */
        // here->B4SOIbNode = here->B4SOIpNode = 0;
        B4SOIbodyMod = 0;
        /* For ideal FD, body contact is disabled and no body node */
    end else begin
        if ($port_connected(p) == 0) begin /* floating body case -- 4-node */
            // here->B4SOIbNode = tmp->number;
            // here->B4SOIpNode = 0;
            B4SOIbodyMod = 0;
            if ($port_connected(b)) begin
                $strobe("Warning: cannot connect to 'b' terminal without connecting 'p' terminal.");
            end
        end else begin
            if ($port_connected(t) == 0 && TNODEOUT==1) begin
               $strobe("Xyce does not implement the BSIM-SOI 4 model with TNODEOUT and fewer than 7 nodes.  Ignore any subsequent messages regarding node collapse, they are meaningless.");
               $finish(1);
            end
            if ($port_connected(b) == 0) begin
                /* 5-node body tie, bNode has not been assigned */
                if ((B4SOIrbody == 0.0) && (B4SOIrbsh == 0.0)) begin
                    /* ideal body tie, pNode is not used */
                    // here->B4SOIbNode = here->B4SOIpNode;
                    B4SOIbodyMod = 2;
                end else begin
                    /* nonideal body tie */
                    // here->B4SOIbNode = tmp->number;
                    B4SOIbodyMod = 1;
                end
            end else begin
                /* 6-node body tie, bNode has been assigned */
                if ((B4SOIrbody == 0.0) && (B4SOIrbsh == 0.0)) begin
                    $strobe("Warning: model parameter rbody=0!");
                    B4SOIrbody = 1e0;
                    B4SOIbodyMod = 1;
                end else begin
                    /* nonideal body tie */
                    B4SOIbodyMod = 1;
                end
            end
        end
    end
    if (TNODEOUT && $port_connected(t) == 0) begin
        $strobe("Warning: tnodeout !=0 but terminal 't' is not connected.");
    end
`else // __XYCE__
    // This is the port_connected stuff from 4.6.1, because Xyce
    // cannot possibly do what 4.5.0 tries to do (Xyce can only handle
    // optional nodes in order --- one cannot have "t" connected without
    // both p and b being connected, and so forth.  4.5.0 assumes that
    // one can tell the difference between 5-node with t connected and 5-node
    // with p connected. 4.6.1 doesn't make that mistake.
    // None of the NODECHK stuff has been copied
    if (B4SOIsoiMod == 2) begin /* v3.2 */
       if (SHMOD == 0) begin
          if (TNODEOUT == 0) begin //TNODEOUT = 0 starts here.
             if ($port_connected(p) && $port_connected(b)) begin
                //V(b) <+ 0;
                $strobe("Error:  you have specified a P and B node (5th and 6th node) when soimod=2 and TNODEOUT=0.  The P and B nodes are not used in this mode and Xyce cannot deal with them being externally specified.  Please remove the 5th and 6th nodes from the instance line.");
                $finish(1);
             end else begin
                if ($port_connected(p)) begin
                   $strobe("Error:  you have specified a P node (5th node) when soimod=2 and TNODEOUT=0.  P node is not used in this mode and Xyce cannot deal with it as an externally specified node.  Please remove the 5th node.");
                   $finish(1);
                   //V(p) <+ 0;
                end
             end
          end else begin //TNODEOUT = 0 for SHMOD = 0 ends here.
             if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                $strobe("Error:  you have specified a P and B node (5th and 6th node) when soimod=2 and TNODEOUT=1, and a seventh node for temperature. The P and B nodes are not used in this mode and Xyce cannot deal with them being externally specified.  Please remove the P and B nodes. With TNODEOUT=1, the fifth node should be the last one and will be used for temperature.");
                $finish(1);
                // V(b) <+ 0; //Case 8
             end
          end            //TNODEOUT = 1 for SHMOD = 0 ends here.
       end else begin     //SHMOD = 0 ends here.
          if (TNODEOUT == 0) begin
             if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                $strobe("Error:  you have specified a P and B node (fifth and 6th nodes) when soimod=2, and a temperature node (7th) with TNODEOUT=0.  None of these nodes are used in this mode and Xyce cannot deal with them being externally specified.  Please remove the 6th node.");
                $finish(1);
                //V(b) <+ 0;
             end else begin
                if ($port_connected(p) && $port_connected(b)) begin
                   $strobe("Error:  you have specified P and B nodes (5th and 6th node) when soimod=2 and TNODEOUT=0.  These nodes are not used in this mode and Xyce cannot deal with them being externally specified.  Please remove the 5th and 6th nodes.");
                   $finish(1);
                   //V(b) <+ 0;
                end else begin
                   if ($port_connected(p)) begin
                      $strobe("Error:  you have specified P node (5th node) when soimod=2 and TNODEOUT=0.  This nodes is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 5th node.");
                      $finish(1);
                      //V(p) <+ 0;
                   end
                end
             end
          end else begin //TNODEOUT = 0 for SHMOD = 1 ends here.
             if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                $strobe("Error:  you have specified a B node (6th node) when soimod=2 and TNODEOUT=1, and a seventh node for temperature. The B node is not used in this mode and Xyce cannot deal with it as an externally specified node.  Please remove the B node. With TNODEOUT=1, the 6th node should be the last one and will be used for temperature.");
                $finish(1);
                // V(b) <+ 0;
             end
          end //TNODEOUT = 1 for SHMOD = 1 ends here.
       end //SHMOD = 1 ends here.
       // here->B4SOIbNode = here->B4SOIpNode = 0;
       B4SOIbodyMod = 0;
       /* For ideal FD, body contact is disabled and no body node */
    end else begin
       if ($port_connected(p) == 0) begin /* floating body case -- 4-node */
          // here->B4SOIbNode = tmp->number;
          // here->B4SOIpNode = 0;
          B4SOIbodyMod = 0;
          if ($port_connected(b)) begin
             $strobe("Warning: cannot connect to 'b' terminal without connecting 'p' terminal.");
          end
       end else begin
          if ($port_connected(b) == 0) begin
             /* 5-node body tie, bNode has not been assigned */
             if ((B4SOIrbody == 0.0) && (B4SOIrbsh == 0.0)) begin
                /* ideal body tie, pNode is not used */
                // here->B4SOIbNode = here->B4SOIpNode;
                B4SOIbodyMod = 2;
             end else begin
                /* nonideal body tie */
                // here->B4SOIbNode = tmp->number;
                B4SOIbodyMod = 1;
             end
          end else begin
             /* 6-node body tie, bNode has been assigned */
             if ((B4SOIrbody == 0.0) && (B4SOIrbsh == 0.0)) begin
                $strobe("Warning: model parameter rbody=0!");
                B4SOIrbody = 1e0;
                B4SOIbodyMod = 1;
             end else begin
                /* nonideal body tie */
                B4SOIbodyMod = 1;
             end
          end
       end
    end
`endif
`else // PORT_CONNECTED
    // assume only d,g,s,e terminals connected
    B4SOIbodyMod = 0;
`endif

    if ($param_given(CF))
        B4SOIcf = CF;
    else
        B4SOIcf = 2.0 * `EPSOX / `M_PI * ln(1.0 + 0.4e-6 / B4SOItox);

    if ($param_given(CGDO))
        B4SOIcgdo = CGDO;
    else begin
        if ($param_given(DLC) && (B4SOIdlc > 0.0))
            B4SOIcgdo = B4SOIdlc * B4SOIcox - B4SOIcgdl;
        else
            B4SOIcgdo = 0.6 * B4SOIxj * B4SOIcox;
    end

    if ($param_given(CGSO))
        B4SOIcgso = CGSO;
    else begin
        if ($param_given(DLC) && (B4SOIdlc > 0.0))
            B4SOIcgso = B4SOIdlc * B4SOIcox - B4SOIcgsl;
        else
            B4SOIcgso = 0.6 * B4SOIxj * B4SOIcox;
    end

    begin : b4soi_temp // {
        real tmp, tmp1, tmp2, Eg, Eg0, ni, T0, T1, T2, T3, T4, T5, T6;
        real Ldrn, Wdrn;
        real TempRatio, Inv_L, Inv_W, Inv_LW, Vtm0, Tnom;
        real SDphi, SDgamma;
        real Inv_saref, Inv_sbref, Inv_sa, Inv_sb, rho, dvth0_lod;
        real W_tmp, Inv_ODeff, OD_offset, dk2_lod, deta0_lod, deta0cv_lod;
        integer i;
        real PowWeffWr, T10; /*v4.0 */
        real Vtm0eot, Vtmeot, vbieot, phieot, sqrtphieot, vddeot;
        real Vgs_eff, Vgsteff, V0, Vth, Vgst;
        real lt1, ltw;
        real TempRatioMinus1;
        real n, VgstNVt, ExpArg, sqrtPhisExt, ExpVgst, vtfbphi2eot;
        real DIBL_Sft, Lpe_Vb, DITS_Sft, DeltVthtemp, DITS_Sft2;
        real Theta0, Delt_vth, DeltVthw;
        real niter, toxpf, toxpi, Tcen;
        real n0;

        /* v2.0 release */
        real tmp3, T7;

        if (B4SOIGatesidewallJctSPotential < 0.1)   /* v4.0 */
            B4SOIGatesidewallJctSPotential = 0.1;
        if (B4SOIGatesidewallJctDPotential < 0.1)   /* v4.0 */
            B4SOIGatesidewallJctDPotential = 0.1;
        Tnom = B4SOItnom;
        TempRatio = DevTemp / Tnom;

        if (B4SOImtrlMod) begin
            B4SOIfactor1 = sqrt(epssub / (epsrox*`EPS0) * toxe);/*4.1*/
        end else begin
            B4SOIfactor1 = sqrt(`EPSSI / `EPSOX * B4SOItox);
        end

        /*Vtm00 replaced with model parameter B4SOIVTM00 by Pankaj in May 2012*/
        //Vtm00 = 0.026;  
        Vtm00=B4SOIVTM00;  
        if (B4SOImtrlMod == 0) begin
             Vtm0 = `KboQ * Tnom;
             Eg0 = 1.16 - 7.02e-4 * Tnom * Tnom / (Tnom + 1108.0);
             B4SOIeg0 = Eg0;
             B4SOIvtm = `KboQ * DevTemp;
             Eg = 1.16 - 7.02e-4 * DevTemp * DevTemp / (DevTemp + 1108.0);
             B4SOIeg = Eg;                /* Bug fix #11 Jun 09 Eg is evaluated at Temp, not Tnom. To be used if no selfheat */
             /* ni is in cm^-3 */
             ni = 1.45e10 * (DevTemp / 300.15) * sqrt(DevTemp / 300.15)
                    * exp(21.5565981 - Eg / (2.0 * B4SOIvtm));
        end else begin
            Vtm0 = `KboQ * Tnom;
            Eg0 = B4SOIbg0sub - B4SOItbgasub * Tnom * Tnom
                    / (Tnom + B4SOItbgbsub);
            B4SOIeg0 = Eg0;
            B4SOIvtm = `KboQ * DevTemp;
            Eg = B4SOIbg0sub - B4SOItbgasub * DevTemp * DevTemp
                    / (DevTemp + B4SOItbgbsub);
            B4SOIeg = Eg;        /* Bug fix #11 Jun 09 Eg is evaluated at Temp, not Tnom. To be used if no selfheat */
            ni = B4SOIni0sub * (DevTemp / Tnom) * sqrt(DevTemp / Tnom)
                    * exp(Eg0/(2.0*Vtm0) - Eg / (2.0 * B4SOIvtm));
        end

        B4SOIrbodyext = B4SOIbodySquares * B4SOIrbsh;

        Ldrn = B4SOIl;
        Wdrn = B4SOIw / B4SOInf; /* v4.0 */

        T0 = pow(Ldrn, B4SOILln);
        T1 = pow(Wdrn, B4SOILwn);
        tmp1 = B4SOILl / T0 + B4SOILw / T1 + B4SOILwl / (T0 * T1);
        pParam_B4SOIdl = B4SOILint + tmp1;

        /* v2.2.3 */
        tmp1 = B4SOILlc / T0 + B4SOILwc / T1 + B4SOILwlc / (T0 * T1);
        pParam_B4SOIdlc = B4SOIdlc + tmp1;

        /* v3.0 */
        pParam_B4SOIdlcig = B4SOIdlcig + tmp1;

        T2 = pow(Ldrn, B4SOIWln);
        T3 = pow(Wdrn, B4SOIWwn);
        tmp2 = B4SOIWl / T2 + B4SOIWw / T3 + B4SOIWwl / (T2 * T3);
        pParam_B4SOIdw = B4SOIWint + tmp2;

        /* v2.2.3 */
        tmp2 = B4SOIWlc / T2 + B4SOIWwc / T3 + B4SOIWwlc / (T2 * T3);
        pParam_B4SOIdwc = B4SOIdwc + tmp2;

        pParam_B4SOIleff = B4SOIl - 2.0 * pParam_B4SOIdl;
        if (pParam_B4SOIleff <= 0.0) begin
            $strobe("Effective channel length <= 0");
            $finish(0);
        end

        pParam_B4SOIweff = B4SOIw / B4SOInf  /* v4.0 */
                                  - B4SOInbc * B4SOIdwbc
                                  - (2.0 - B4SOInbc) * pParam_B4SOIdw;
        if (pParam_B4SOIweff <= 0.0) begin
            $strobe("Effective channel width <= 0");
            $finish(0);
        end

        pParam_B4SOIwdiod = pParam_B4SOIweff / B4SOInseg + B4SOIpdbcp;
        pParam_B4SOIwdios = pParam_B4SOIweff / B4SOInseg + B4SOIpsbcp;

        pParam_B4SOIleffCV = B4SOIl - 2.0 * pParam_B4SOIdlc;
        if (pParam_B4SOIleffCV <= 0.0) begin
            $strobe("Effective channel length for C-V <= 0");
            $finish(0);
        end

        pParam_B4SOIweffCV = B4SOIw / B4SOInf /* v4.0 */
                                    - B4SOInbc * B4SOIdwbc
                                    - (2.0 - B4SOInbc) * pParam_B4SOIdwc;
        if (pParam_B4SOIweffCV <= 0.0) begin
            $strobe("Effective channel width for C-V <= 0");
            $finish(0);
        end

        pParam_B4SOIwdiodCV = pParam_B4SOIweffCV / B4SOInseg + B4SOIpdbcp;
        pParam_B4SOIwdiosCV = pParam_B4SOIweffCV / B4SOInseg + B4SOIpsbcp;

        pParam_B4SOIleffCVb = B4SOIl - 2.0 * pParam_B4SOIdlc - B4SOIdlcb;
        if (pParam_B4SOIleffCVb <= 0.0) begin
            $strobe("Effective channel length for C-V (body) <= 0");
            $finish(0);
        end

        pParam_B4SOIleffCVbg = pParam_B4SOIleffCVb + 2 * B4SOIdlbg;
        if (pParam_B4SOIleffCVbg <= 0.0) begin
            $strobe("Effective channel length for C-V (backgate) <= 0");
            $finish(0);
        end

        /* Not binned - START */
        pParam_B4SOIgamma1 = B4SOIgamma1;
        pParam_B4SOIgamma2 = B4SOIgamma2;
        pParam_B4SOIvbx = B4SOIvbx;
        pParam_B4SOIvbm = B4SOIvbm;
        pParam_B4SOIxt = B4SOIxt;
        /* Not binned - END */

        /* CV model */
        pParam_B4SOIcf = B4SOIcf;
        pParam_B4SOIclc = B4SOIclc;
        pParam_B4SOIcle = B4SOIcle;
        pParam_B4SOIabulkCVfactor = 1.0 + pow((pParam_B4SOIclc / pParam_B4SOIleff),
                                            pParam_B4SOIcle);

        /* Added for binning - START */
        if (B4SOIbinUnit == 1) begin
            Inv_L = 1.0e-6 / pParam_B4SOIleff;
            Inv_W = 1.0e-6 / pParam_B4SOIweff;
            Inv_LW = 1.0e-12 / (pParam_B4SOIleff * pParam_B4SOIweff);
        end else begin
            Inv_L = 1.0 / pParam_B4SOIleff;
            Inv_W = 1.0 / pParam_B4SOIweff;
            Inv_LW = 1.0 / (pParam_B4SOIleff * pParam_B4SOIweff);
        end

        pParam_B4SOInpeak  = B4SOInpeak  + LNCH    * Inv_L + WNCH    * Inv_W + PNCH    * Inv_LW;
        pParam_B4SOInsub   = B4SOInsub   + LNSUB   * Inv_L + WNSUB   * Inv_W + PNSUB   * Inv_LW;
        pParam_B4SOIngate  = B4SOIngate  + LNGATE  * Inv_L + WNGATE  * Inv_W + PNGATE  * Inv_LW;
        /*4.1*/
        pParam_B4SOInsd    = B4SOInsd    + LNSD    * Inv_L + WNSD    * Inv_W + PNSD    * Inv_LW;

        pParam_B4SOIvth0   = B4SOIvth0   + LVTH0   * Inv_L + WVTH0   * Inv_W + PVTH0   * Inv_LW;
        pParam_B4SOIvfb    = B4SOIvfb    + LVFB    * Inv_L + WVFB    * Inv_W + PVFB    * Inv_LW;    /* v4.1 */
        pParam_B4SOIk1     = B4SOIk1     + LK1     * Inv_L + WK1     * Inv_W + PK1     * Inv_LW;
        pParam_B4SOIk2     = B4SOIk2     + LK2     * Inv_L + WK2     * Inv_W + PK2     * Inv_LW;
        pParam_B4SOIk1w1   = B4SOIk1w1   + LK1W1   * Inv_L + WK1W1   * Inv_W + PK1W1   * Inv_LW;
        pParam_B4SOIk1w2   = B4SOIk1w2   + LK1W2   * Inv_L + WK1W2   * Inv_W + PK1W2   * Inv_LW;
        pParam_B4SOIk3     = B4SOIk3     + LK3     * Inv_L + WK3     * Inv_W + PK3     * Inv_LW;
        pParam_B4SOIk3b    = B4SOIk3b    + LK3B    * Inv_L + WK3B    * Inv_W + PK3B    * Inv_LW;
        pParam_B4SOIkb1    = B4SOIkb1    + LKB1    * Inv_L + WKB1    * Inv_W + PKB1    * Inv_LW;
        pParam_B4SOIw0     = B4SOIw0     + LW0     * Inv_L + WW0     * Inv_W + PW0     * Inv_LW;
        pParam_B4SOIlpe0   = B4SOIlpe0   + LLPE0   * Inv_L + WLPE0   * Inv_W + PLPE0   * Inv_LW;
        pParam_B4SOIlpeb   = B4SOIlpeb   + LLPEB   * Inv_L + WLPEB   * Inv_W + PLPEB   * Inv_LW;  /* v4.0 */
        pParam_B4SOIdvt0   = B4SOIdvt0   + LDVT0   * Inv_L + WDVT0   * Inv_W + PDVT0   * Inv_LW;
        pParam_B4SOIdvt1   = B4SOIdvt1   + LDVT1   * Inv_L + WDVT1   * Inv_W + PDVT1   * Inv_LW;
        pParam_B4SOIdvt2   = B4SOIdvt2   + LDVT2   * Inv_L + WDVT2   * Inv_W + PDVT2   * Inv_LW;
        pParam_B4SOIdvt0w  = B4SOIdvt0w  + LDVT0W  * Inv_L + WDVT0W  * Inv_W + PDVT0W  * Inv_LW;
        pParam_B4SOIdvt1w  = B4SOIdvt1w  + LDVT1W  * Inv_L + WDVT1W  * Inv_W + PDVT1W  * Inv_LW;
        pParam_B4SOIdvt2w  = B4SOIdvt2w  + LDVT2W  * Inv_L + WDVT2W  * Inv_W + PDVT2W  * Inv_LW;
        pParam_B4SOIu0     = B4SOIu0     + LU0     * Inv_L + WU0     * Inv_W + PU0     * Inv_LW;
        pParam_B4SOIua     = B4SOIua     + LUA     * Inv_L + WUA     * Inv_W + PUA     * Inv_LW;
        pParam_B4SOIub     = B4SOIub     + LUB     * Inv_L + WUB     * Inv_W + PUB     * Inv_LW;
        pParam_B4SOIuc     = B4SOIuc     + LUC     * Inv_L + WUC     * Inv_W + PUC     * Inv_LW;
        pParam_B4SOIvsat   = B4SOIvsat   + LVSAT   * Inv_L + WVSAT   * Inv_W + PVSAT   * Inv_LW;
        pParam_B4SOIa0     = B4SOIa0     + LA0     * Inv_L + WA0     * Inv_W + PA0     * Inv_LW;
        pParam_B4SOIags    = B4SOIags    + LAGS    * Inv_L + WAGS    * Inv_W + PAGS    * Inv_LW;
        pParam_B4SOIb0     = B4SOIb0     + LB0     * Inv_L + WB0     * Inv_W + PB0     * Inv_LW;
        pParam_B4SOIb1     = B4SOIb1     + LB1     * Inv_L + WB1     * Inv_W + PB1     * Inv_LW;
        pParam_B4SOIketa   = B4SOIketa   + LKETA   * Inv_L + WKETA   * Inv_W + PKETA   * Inv_LW;
        pParam_B4SOIketas  = B4SOIketas  + LKETAS  * Inv_L + WKETAS  * Inv_W + PKETAS  * Inv_LW;
        pParam_B4SOIa1     = B4SOIa1     + LA1     * Inv_L + WA1     * Inv_W + PA1     * Inv_LW;
        pParam_B4SOIa2     = B4SOIa2     + LA2     * Inv_L + WA2     * Inv_W + PA2     * Inv_LW;
        pParam_B4SOIrdsw   = B4SOIrdsw   + LRDSW   * Inv_L + WRDSW   * Inv_W + PRDSW   * Inv_LW;
        pParam_B4SOIrsw    = B4SOIrsw    /* v4.0 */
                                         + LRSW    * Inv_L + WRSW    * Inv_W + PRSW    * Inv_LW;
        pParam_B4SOIrdw    = B4SOIrdw    /* v4.0 */
                                         + LRDW    * Inv_L + WRDW    * Inv_W + PRDW    * Inv_LW;
        pParam_B4SOIprwb   = B4SOIprwb   + LPRWB   * Inv_L + WPRWB   * Inv_W + PPRWB   * Inv_LW;
        pParam_B4SOIprwg   = B4SOIprwg   + LPRWG   * Inv_L + WPRWG   * Inv_W + PPRWG   * Inv_LW;
        pParam_B4SOIwr     = B4SOIwr     + LWR     * Inv_L + WWR     * Inv_W + PWR     * Inv_LW;
        pParam_B4SOInfactor = B4SOInfactor + LNFACTOR * Inv_L + WNFACTOR * Inv_W + PNFACTOR * Inv_LW;
        pParam_B4SOIdwg    = B4SOIdwg    + LDWG    * Inv_L + WDWG    * Inv_W + PDWG    * Inv_LW;
        pParam_B4SOIdwb    = B4SOIdwb    + LDWB    * Inv_L + WDWB    * Inv_W + PDWB    * Inv_LW;
        pParam_B4SOIvoff   = B4SOIvoff   + LVOFF   * Inv_L + WVOFF   * Inv_W + PVOFF   * Inv_LW;
        pParam_B4SOIeta0   = B4SOIeta0   + LETA0   * Inv_L + WETA0   * Inv_W + PETA0   * Inv_LW;
        pParam_B4SOIetab   = B4SOIetab   + LETAB   * Inv_L + WETAB   * Inv_W + PETAB   * Inv_LW;
        pParam_B4SOIeta0cv   = B4SOIeta0cv   + LETA0CV   * Inv_L + WETA0CV   * Inv_W + PETA0CV   * Inv_LW;
        pParam_B4SOIetabcv   = B4SOIetabcv   + LETABCV   * Inv_L + WETABCV   * Inv_W + PETABCV   * Inv_LW;

        pParam_B4SOIdsub   = B4SOIdsub   + LDSUB   * Inv_L + WDSUB   * Inv_W + PDSUB   * Inv_LW;
        pParam_B4SOIcit    = B4SOIcit    + LCIT    * Inv_L + WCIT    * Inv_W + PCIT    * Inv_LW;
        pParam_B4SOIcdsc   = B4SOIcdsc   + LCDSC   * Inv_L + WCDSC   * Inv_W + PCDSC   * Inv_LW;
        pParam_B4SOIcdscb  = B4SOIcdscb  + LCDSCB  * Inv_L + WCDSCB  * Inv_W + PCDSCB  * Inv_LW;
        pParam_B4SOIcdscd  = B4SOIcdscd  + LCDSCD  * Inv_L + WCDSCD  * Inv_W + PCDSCD  * Inv_LW;
        pParam_B4SOIpclm   = B4SOIpclm   + LPCLM   * Inv_L + WPCLM   * Inv_W + PPCLM   * Inv_LW;
        pParam_B4SOIpdibl1 = B4SOIpdibl1 + LPDIBLC1 * Inv_L + WPDIBLC1 * Inv_W + PPDIBLC1 * Inv_LW;
        pParam_B4SOIpdibl2 = B4SOIpdibl2 + LPDIBLC2 * Inv_L + WPDIBLC2 * Inv_W + PPDIBLC2 * Inv_LW;
        pParam_B4SOIpdiblb = B4SOIpdiblb + LPDIBLCB * Inv_L + WPDIBLCB * Inv_W + PPDIBLCB * Inv_LW;
        pParam_B4SOIdrout  = B4SOIdrout  + LDROUT  * Inv_L + WDROUT  * Inv_W + PDROUT  * Inv_LW;
        pParam_B4SOIpvag   = B4SOIpvag   + LPVAG   * Inv_L + WPVAG   * Inv_W + PPVAG   * Inv_LW;
        pParam_B4SOIdelta  = B4SOIdelta  + LDELTA  * Inv_L + WDELTA  * Inv_W + PDELTA  * Inv_LW;
        pParam_B4SOIalpha0 = B4SOIalpha0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_LW;
        pParam_B4SOIfbjtii = B4SOIfbjtii + LFBJTII * Inv_L + WFBJTII * Inv_W + PFBJTII * Inv_LW;
        /*4.1 Iii model*/
        pParam_B4SOIebjtii = B4SOIebjtii + LEBJTII * Inv_L + WEBJTII * Inv_W + PEBJTII * Inv_LW;
        pParam_B4SOIcbjtii = B4SOIcbjtii + LCBJTII * Inv_L + WCBJTII * Inv_W + PCBJTII * Inv_LW;
        pParam_B4SOIvbci   = B4SOIvbci   + LVBCI   * Inv_L + WVBCI   * Inv_W + PVBCI   * Inv_LW;
        pParam_B4SOIabjtii = B4SOIabjtii + LABJTII * Inv_L + WABJTII * Inv_W + PABJTII * Inv_LW;
        pParam_B4SOImbjtii = B4SOImbjtii + LMBJTII * Inv_L + WMBJTII * Inv_W + PMBJTII * Inv_LW;

        pParam_B4SOIbeta0  = B4SOIbeta0  + LBETA0  * Inv_L + WBETA0  * Inv_W + PBETA0  * Inv_LW;
        pParam_B4SOIbeta1  = B4SOIbeta1  + LBETA1  * Inv_L + WBETA1  * Inv_W + PBETA1  * Inv_LW;
        pParam_B4SOIbeta2  = B4SOIbeta2  + LBETA2  * Inv_L + WBETA2  * Inv_W + PBETA2  * Inv_LW;
        pParam_B4SOIvdsatii0 = B4SOIvdsatii0 + LVDSATII0 * Inv_L + WVDSATII0 * Inv_W + PVDSATII0 * Inv_LW;
        pParam_B4SOIlii    = B4SOIlii    + LLII    * Inv_L + WLII    * Inv_W + PLII    * Inv_LW;
        pParam_B4SOIesatii = B4SOIesatii + LESATII * Inv_L + WESATII * Inv_W + PESATII * Inv_LW;
        pParam_B4SOIsii0   = B4SOIsii0   + LSII0   * Inv_L + WSII0   * Inv_W + PSII0   * Inv_LW;
        pParam_B4SOIsii1   = B4SOIsii1   + LSII1   * Inv_L + WSII1   * Inv_W + PSII1   * Inv_LW;
        pParam_B4SOIsii2   = B4SOIsii2   + LSII2   * Inv_L + WSII2   * Inv_W + PSII2   * Inv_LW;
        pParam_B4SOIsiid   = B4SOIsiid   + LSIID   * Inv_L + WSIID   * Inv_W + PSIID   * Inv_LW;
        pParam_B4SOIagidl  = B4SOIagidl  + LAGIDL  * Inv_L + WAGIDL  * Inv_W + PAGIDL  * Inv_LW;
        pParam_B4SOIbgidl  = B4SOIbgidl  + LBGIDL  * Inv_L + WBGIDL  * Inv_W + PBGIDL  * Inv_LW;
        pParam_B4SOIcgidl  = B4SOIcgidl  + LCGIDL  * Inv_L + WCGIDL  * Inv_W + PCGIDL  * Inv_LW;
        pParam_B4SOIegidl  = B4SOIegidl  + LEGIDL  * Inv_L + WEGIDL  * Inv_W + PEGIDL  * Inv_LW;
        pParam_B4SOIrgidl  = B4SOIrgidl  + LRGIDL  * Inv_L + WRGIDL  * Inv_W + PRGIDL  * Inv_LW;
        pParam_B4SOIkgidl  = B4SOIkgidl  + LKGIDL  * Inv_L + WKGIDL  * Inv_W + PKGIDL  * Inv_LW;
        pParam_B4SOIfgidl  = B4SOIfgidl  + LFGIDL  * Inv_L + WFGIDL  * Inv_W + PFGIDL  * Inv_LW;
        pParam_B4SOIagisl  = B4SOIagisl  + LAGISL  * Inv_L + WAGISL  * Inv_W + PAGISL  * Inv_LW;
        pParam_B4SOIbgisl  = B4SOIbgisl  + LBGISL  * Inv_L + WBGISL  * Inv_W + PBGISL  * Inv_LW;
        pParam_B4SOIcgisl  = B4SOIcgisl  + LCGISL  * Inv_L + WCGISL  * Inv_W + PCGISL  * Inv_LW;
        pParam_B4SOIegisl  = B4SOIegisl  + LEGISL  * Inv_L + WEGISL  * Inv_W + PEGISL  * Inv_LW;
        pParam_B4SOIrgisl  = B4SOIrgisl  + LRGISL  * Inv_L + WRGISL  * Inv_W + PRGISL  * Inv_LW;
        pParam_B4SOIkgisl  = B4SOIkgisl  + LKGISL  * Inv_L + WKGISL  * Inv_W + PKGISL  * Inv_LW;
        pParam_B4SOIfgisl  = B4SOIfgisl  + LFGISL  * Inv_L + WFGISL  * Inv_W + PFGISL  * Inv_LW;

        pParam_B4SOIntun   = B4SOIntun   /* v4.0 */
                                         + LNTUN   * Inv_L + WNTUN   * Inv_W + PNTUN   * Inv_LW;
        pParam_B4SOIntund  = B4SOIntund  /* v4.0 */
                                         + LNTUND  * Inv_L + WNTUND  * Inv_W + PNTUND  * Inv_LW;
        pParam_B4SOIndiode = B4SOIndiode /* v4.0 */
                                         + LNDIODE * Inv_L + WNDIODE * Inv_W + PNDIODE * Inv_LW;
        pParam_B4SOIndioded = B4SOIndioded /* v4.0 */
                                         + LNDIODED * Inv_L + WNDIODED * Inv_W + PNDIODED * Inv_LW;
        pParam_B4SOInrecf0 = B4SOInrecf0 /* v4.0 */
                                         + LNRECF0 * Inv_L + WNRECF0 * Inv_W + PNRECF0 * Inv_LW;
        pParam_B4SOInrecf0d = B4SOInrecf0d /* v4.0 */
                                         + LNRECF0D * Inv_L + WNRECF0D * Inv_W + PNRECF0D * Inv_LW;
        pParam_B4SOInrecr0 = B4SOInrecr0 /* v4.0 */
                                         + LNRECR0 * Inv_L + WNRECR0 * Inv_W + PNRECR0 * Inv_LW;
        pParam_B4SOInrecr0d = B4SOInrecr0d /* v4.0 */
                                         + LNRECR0D * Inv_L + WNRECR0D * Inv_W + PNRECR0D * Inv_LW;
        pParam_B4SOIisbjt  = B4SOIisbjt  + LISBJT  * Inv_L + WISBJT  * Inv_W + PISBJT  * Inv_LW;
        pParam_B4SOIidbjt  = B4SOIidbjt  + LIDBJT  * Inv_L + WIDBJT  * Inv_W + PIDBJT  * Inv_LW;
        pParam_B4SOIisdif  = B4SOIisdif  + LISDIF  * Inv_L + WISDIF  * Inv_W + PISDIF  * Inv_LW;
        pParam_B4SOIiddif  = B4SOIiddif  + LIDDIF  * Inv_L + WIDDIF  * Inv_W + PIDDIF  * Inv_LW;
        pParam_B4SOIisrec  = B4SOIisrec  + LISREC  * Inv_L + WISREC  * Inv_W + PISREC  * Inv_LW;
        pParam_B4SOIistun  = B4SOIistun  + LISTUN  * Inv_L + WISTUN  * Inv_W + PISTUN  * Inv_LW;
        pParam_B4SOIidrec  = B4SOIidrec  + LIDREC  * Inv_L + WIDREC  * Inv_W + PIDREC  * Inv_LW;
        pParam_B4SOIidtun  = B4SOIidtun  + LIDTUN  * Inv_L + WIDTUN  * Inv_W + PIDTUN  * Inv_LW;
        pParam_B4SOIvrec0  = B4SOIvrec0  /* v4.0 */
                                         + LVREC0  * Inv_L + WVREC0  * Inv_W + PVREC0  * Inv_LW;
        pParam_B4SOIvrec0d = B4SOIvrec0d /* v4.0 */
                                         + LVREC0D * Inv_L + WVREC0D * Inv_W + PVREC0D * Inv_LW;
        pParam_B4SOIvtun0  = B4SOIvtun0  /* v4.0 */
                                         + LVTUN0  * Inv_L + WVTUN0  * Inv_W + PVTUN0  * Inv_LW;
        pParam_B4SOIvtun0d = B4SOIvtun0d /* v4.0 */
                                         + LVTUN0D * Inv_L + WVTUN0D * Inv_W + PVTUN0D * Inv_LW;
        pParam_B4SOInbjt   = B4SOInbjt   + LNBJT   * Inv_L + WNBJT   * Inv_W + PNBJT   * Inv_LW;
        pParam_B4SOIlbjt0  = B4SOIlbjt0  + LLBJT0  * Inv_L + WLBJT0  * Inv_W + PLBJT0  * Inv_LW;
        pParam_B4SOIvabjt  = B4SOIvabjt  + LVABJT  * Inv_L + WVABJT  * Inv_W + PVABJT  * Inv_LW;
        pParam_B4SOIaely   = B4SOIaely   + LAELY   * Inv_L + WAELY   * Inv_W + PAELY   * Inv_LW;
        pParam_B4SOIahli   = B4SOIahli   /* v4.0 */
                                         + LAHLI   * Inv_L + WAHLI   * Inv_W + PAHLI   * Inv_LW;
        pParam_B4SOIahlid  = B4SOIahlid  /* v4.0 */
                                         + LAHLID  * Inv_L + WAHLID  * Inv_W + PAHLID  * Inv_LW;
        /* v3.1 */
        pParam_B4SOIxj     = B4SOIxj     + LXJ     * Inv_L + WXJ     * Inv_W + PXJ     * Inv_LW;
        pParam_B4SOIalphaGB1 = B4SOIalphaGB1 + LALPHAGB1 * Inv_L + WALPHAGB1 * Inv_W + PALPHAGB1 * Inv_LW;
        pParam_B4SOIalphaGB2 = B4SOIalphaGB2 + LALPHAGB2 * Inv_L + WALPHAGB2 * Inv_W + PALPHAGB2 * Inv_LW;
        pParam_B4SOIbetaGB1 = B4SOIbetaGB1 + LBETAGB1 * Inv_L + WBETAGB1 * Inv_W + PBETAGB1 * Inv_LW;
        pParam_B4SOIbetaGB2 = B4SOIbetaGB2 + LBETAGB2 * Inv_L + WBETAGB2 * Inv_W + PBETAGB2 * Inv_LW;
        pParam_B4SOIndif   = B4SOIndif   + LNDIF   * Inv_L + WNDIF   * Inv_W + PNDIF   * Inv_LW;
        pParam_B4SOIntrecf = B4SOIntrecf + LNTRECF * Inv_L + WNTRECF * Inv_W + PNTRECF * Inv_LW;
        pParam_B4SOIntrecr = B4SOIntrecr + LNTRECR * Inv_L + WNTRECR * Inv_W + PNTRECR * Inv_LW;
        pParam_B4SOIxbjt   = B4SOIxbjt   + LXBJT   * Inv_L + WXBJT   * Inv_W + PXBJT   * Inv_LW;
        pParam_B4SOIxdif   = B4SOIxdif   + LXDIF   * Inv_L + WXDIF   * Inv_W + PXDIF   * Inv_LW;
        pParam_B4SOIxrec   = B4SOIxrec   + LXREC   * Inv_L + WXREC   * Inv_W + PXREC   * Inv_LW;
        pParam_B4SOIxtun   = B4SOIxtun   + LXTUN   * Inv_L + WXTUN   * Inv_W + PXTUN   * Inv_LW;
        pParam_B4SOIxdifd  = B4SOIxdifd  + LXDIFD  * Inv_L + WXDIFD  * Inv_W + PXDIFD  * Inv_LW;
        pParam_B4SOIxrecd  = B4SOIxrecd  + LXRECD  * Inv_L + WXRECD  * Inv_W + PXRECD  * Inv_LW;
        pParam_B4SOIxtund  = B4SOIxtund  + LXTUND  * Inv_L + WXTUND  * Inv_W + PXTUND  * Inv_LW;
        pParam_B4SOIcgdl   = B4SOIcgdl   + LCGDL   * Inv_L + WCGDL   * Inv_W + PCGDL   * Inv_LW;
        pParam_B4SOIcgsl   = B4SOIcgsl   + LCGSL   * Inv_L + WCGSL   * Inv_W + PCGSL   * Inv_LW;
        pParam_B4SOIckappa = B4SOIckappa + LCKAPPA * Inv_L + WCKAPPA * Inv_W + PCKAPPA * Inv_LW;
        pParam_B4SOIute    = B4SOIute    + LUTE    * Inv_L + WUTE    * Inv_W + PUTE    * Inv_LW;

        /*4.1 mobmod=4*/
        pParam_B4SOIud     = B4SOIud     + LUD     * Inv_L + WUD     * Inv_W + PUD     * Inv_LW;
        pParam_B4SOIud1    = B4SOIud1    + LUD1    * Inv_L + WUD1    * Inv_W + PUD1    * Inv_LW;
        pParam_B4SOIeu     = B4SOIeu     + LEU     * Inv_L + WEU     * Inv_W + PEU     * Inv_LW;
        pParam_B4SOIucs    = B4SOIucs    + LUCS    * Inv_L + WUCS    * Inv_W + PUCS    * Inv_LW;
        pParam_B4SOIucste  = B4SOIucste  + LUCSTE  * Inv_L + WUCSTE  * Inv_W + PUCSTE  * Inv_LW;

        pParam_B4SOIkt1    = B4SOIkt1    + LKT1    * Inv_L + WKT1    * Inv_W + PKT1    * Inv_LW;
        pParam_B4SOIkt2    = B4SOIkt2    + LKT2    * Inv_L + WKT2    * Inv_W + PKT2    * Inv_LW;
        pParam_B4SOIkt1l   = B4SOIkt1l   + LKT1L   * Inv_L + WKT1L   * Inv_W + PKT1L   * Inv_LW;
        pParam_B4SOIua1    = B4SOIua1    + LUA1    * Inv_L + WUA1    * Inv_W + PUA1    * Inv_LW;
        pParam_B4SOIub1    = B4SOIub1    + LUB1    * Inv_L + WUB1    * Inv_W + PUB1    * Inv_LW;
        pParam_B4SOIuc1    = B4SOIuc1    + LUC1    * Inv_L + WUC1    * Inv_W + PUC1    * Inv_LW;
        pParam_B4SOIat     = B4SOIat     + LAT     * Inv_L + WAT     * Inv_W + PAT     * Inv_LW;
        pParam_B4SOIprt    = B4SOIprt    + LPRT    * Inv_L + WPRT    * Inv_W + PPRT    * Inv_LW;
        /* v3.0 */
        pParam_B4SOInigc   = B4SOInigc   + LNIGC   * Inv_L + WNIGC   * Inv_W + PNIGC   * Inv_LW;
        pParam_B4SOIaigc   = B4SOIaigc   + LAIGC   * Inv_L + WAIGC   * Inv_W + PAIGC   * Inv_LW;
        pParam_B4SOIbigc   = B4SOIbigc   + LBIGC   * Inv_L + WBIGC   * Inv_W + PBIGC   * Inv_LW;
        pParam_B4SOIcigc   = B4SOIcigc   + LCIGC   * Inv_L + WCIGC   * Inv_W + PCIGC   * Inv_LW;
        pParam_B4SOIaigsd  = B4SOIaigsd  + LAIGSD  * Inv_L + WAIGSD  * Inv_W + PAIGSD  * Inv_LW;
        pParam_B4SOIbigsd  = B4SOIbigsd  + LBIGSD  * Inv_L + WBIGSD  * Inv_W + PBIGSD  * Inv_LW;
        pParam_B4SOIcigsd  = B4SOIcigsd  + LCIGSD  * Inv_L + WCIGSD  * Inv_W + PCIGSD  * Inv_LW;
        pParam_B4SOIpigcd  = B4SOIpigcd  + LPIGCD  * Inv_L + WPIGCD  * Inv_W + PPIGCD  * Inv_LW;
        pParam_B4SOIpoxedge = B4SOIpoxedge + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_LW;
        /* v3.0 */
        /* v3.1 added for RF */
        pParam_B4SOIxrcrg1 = B4SOIxrcrg1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_LW;
        pParam_B4SOIxrcrg2 = B4SOIxrcrg2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_LW;
        /* v3.1 added for RF end */
        /* CV model */
        pParam_B4SOIvsdfb  = B4SOIvsdfb  + LVSDFB  * Inv_L + WVSDFB  * Inv_W + PVSDFB  * Inv_LW;
        pParam_B4SOIvsdth  = B4SOIvsdth  + LVSDTH  * Inv_L + WVSDTH  * Inv_W + PVSDTH  * Inv_LW;
        pParam_B4SOIdelvt  = B4SOIdelvt  + LDELVT  * Inv_L + WDELVT  * Inv_W + PDELVT  * Inv_LW;
        pParam_B4SOIacde   = B4SOIacde   + LACDE   * Inv_L + WACDE   * Inv_W + PACDE   * Inv_LW;
        pParam_B4SOIacde   = pParam_B4SOIacde * pow((pParam_B4SOInpeak / 2.0e16), -0.25);
        /* v3.2 bug fix */
        pParam_B4SOImoin   = B4SOImoin   + LMOIN   * Inv_L + WMOIN   * Inv_W + PMOIN   * Inv_LW;
        pParam_B4SOInoff   = B4SOInoff   + LNOFF   * Inv_L + WNOFF   * Inv_W + PNOFF   * Inv_LW;  /* v3.2 */
        pParam_B4SOIdvtp0  = B4SOIdvtp0  + LDVTP0  * Inv_L + WDVTP0  * Inv_W + PDVTP0  * Inv_LW;  /* v4.0 */
        pParam_B4SOIdvtp1  = B4SOIdvtp1  + LDVTP1  * Inv_L + WDVTP1  * Inv_W + PDVTP1  * Inv_LW;  /* v4.0 */
        pParam_B4SOIdvtp2  = B4SOIdvtp2  + LDVTP2  * Inv_L + WDVTP2  * Inv_W + PDVTP2  * Inv_LW;  /* v4.1 */
        pParam_B4SOIdvtp3  = B4SOIdvtp3  + LDVTP3  * Inv_L + WDVTP3  * Inv_W + PDVTP3  * Inv_LW;  /* v4.1 */
        pParam_B4SOIdvtp4  = B4SOIdvtp4  + LDVTP4  * Inv_L + WDVTP4  * Inv_W + PDVTP4  * Inv_LW;  /* v4.1 */
        pParam_B4SOIminv   = B4SOIminv   + LMINV   * Inv_L + WMINV   * Inv_W + PMINV   * Inv_LW;  /* v4.0 */
        pParam_B4SOIminvcv = B4SOIminvcv + LMINVCV * Inv_L + WMINVCV * Inv_W + PMINVCV * Inv_LW;  /* v4.1 */
        pParam_B4SOIvoffcv = B4SOIvoffcv   /*Bug fix # 16 Jun09*/
                                         + LVOFFCV * Inv_L + WVOFFCV * Inv_W + PVOFFCV * Inv_LW;
        pParam_B4SOIfprout = B4SOIfprout + LFPROUT * Inv_L + WFPROUT * Inv_W + PFPROUT * Inv_LW;  /* v4.0 */
        pParam_B4SOIpdits  = B4SOIpdits  + LPDITS  * Inv_L + WPDITS  * Inv_W + PPDITS  * Inv_LW;  /* v4.0 */
        pParam_B4SOIpditsd = B4SOIpditsd + LPDITSD * Inv_L + WPDITSD * Inv_W + PPDITSD * Inv_LW;  /* v4.0 */
        pParam_B4SOIaigbcp2 = B4SOIaigbcp2 + LAIGBCP2 * Inv_L + WAIGBCP2 * Inv_W + PAIGBCP2 * Inv_LW;  /* v4.0 */
        pParam_B4SOIbigbcp2 = B4SOIbigbcp2 + LBIGBCP2 * Inv_L + WBIGBCP2 * Inv_W + PBIGBCP2 * Inv_LW;  /* v4.0 */
        pParam_B4SOIcigbcp2 = B4SOIcigbcp2 + LCIGBCP2 * Inv_L + WCIGBCP2 * Inv_W + PCIGBCP2 * Inv_LW;  /* v4.0 */
        /* Added for binning - END */

        /* v4.0 add mstar for Vgsteff */
        pParam_B4SOImstar = 0.5 + atan(pParam_B4SOIminv) / `M_PI;
        if (B4SOIvgstcvMod == 0 && VERSION >= 4.1)
            $strobe("vgstcvMod = 0, users are suggested to use vgstcvMod = 1 or 2.");
        /* v4.1 add mstarcv for Vgsteffcv */
        pParam_B4SOImstarcv = 0.5 + atan(pParam_B4SOIminvcv) / `M_PI;

        T0 = (TempRatio - 1.0);

        pParam_B4SOIuatemp = pParam_B4SOIua;  /*  save ua, ub, and uc for b4soild.c */
        pParam_B4SOIubtemp = pParam_B4SOIub;
        pParam_B4SOIuctemp = pParam_B4SOIuc;
        pParam_B4SOIrds0denom = pow(pParam_B4SOIweff * 1E6, pParam_B4SOIwr);

        /* v2.2 release */
        pParam_B4SOIrth = B4SOIrth0 / (B4SOInf * (pParam_B4SOIweff + B4SOIwth0)) * B4SOInseg;
        pParam_B4SOIcth = B4SOIcth0 * (B4SOInf * (pParam_B4SOIweff + B4SOIwth0)) / B4SOInseg;

        /* v2.2.2 adding layout-dependent Frbody multiplier */
        if (B4SOIrbody == 0)
            pParam_B4SOIrbody = 0.0;
        else
            pParam_B4SOIrbody = B4SOIfrbody * B4SOIrbody
                * B4SOIrhalo / (2 * B4SOIrbody + B4SOIrhalo * pParam_B4SOIleff)
                * pParam_B4SOIweff / B4SOInseg / B4SOInf;

        pParam_B4SOIoxideRatio = pow(B4SOItoxref/B4SOItoxqm, B4SOIntox)
                                                        /B4SOItoxqm/B4SOItoxqm;
        /* v2.2 release */

        pParam_B4SOIua = pParam_B4SOIua + pParam_B4SOIua1 * T0;
        pParam_B4SOIub = pParam_B4SOIub + pParam_B4SOIub1 * T0;
        pParam_B4SOIuc = pParam_B4SOIuc + pParam_B4SOIuc1 * T0;
        if (pParam_B4SOIu0 > 1.0)
            pParam_B4SOIu0 = pParam_B4SOIu0 / 1.0e4;

        pParam_B4SOIu0temp = pParam_B4SOIu0 * pow(TempRatio, pParam_B4SOIute);
        pParam_B4SOIvsattemp = pParam_B4SOIvsat - pParam_B4SOIat * T0;
        pParam_B4SOIrds0 = (pParam_B4SOIrdsw + pParam_B4SOIprt * T0)
                                  / pParam_B4SOIrds0denom;

        if (B4SOIrdsMod) begin /* v4.0 */ // {
            PowWeffWr = pParam_B4SOIrds0denom * B4SOInf;
            T10 = pParam_B4SOIprt * T0;

            /* External Rd(V) */
            T1 = pParam_B4SOIrdw + T10;
            T2 = B4SOIrdwmin + T10;
            if (T1 < 0.0) begin
                T1 = 0.0;
                $strobe("Warning: Rdw at current temperature is negative; set to 0.");
            end
            if (T2 < 0.0) begin
                T2 = 0.0;
                $strobe("Warning: Rdwmin at current temperature is negative; set to 0.");
            end
            pParam_B4SOIrd0 = T1 / PowWeffWr;
            pParam_B4SOIrdwmin = T2 / PowWeffWr;

            /* External Rs(V) */
            T3 = pParam_B4SOIrsw + T10;
            T4 = B4SOIrswmin + T10;
            if (T3 < 0.0) begin
                T3 = 0.0;
                $strobe("Warning: Rsw at current temperature is negative; set to 0.");
            end
            if (T4 < 0.0) begin
                T4 = 0.0;
                $strobe("Warning: Rswmin at current temperature is negative; set to 0.");
            end
            pParam_B4SOIrs0 = T3 / PowWeffWr;
            pParam_B4SOIrswmin = T4 / PowWeffWr;
        end else begin // }{
            pParam_B4SOIrd0 = 0;
            pParam_B4SOIrdwmin = 0;
            pParam_B4SOIrs0 = 0;
            pParam_B4SOIrswmin = 0;
        end // }

        if (B4SOIcgdo < 0.0) begin
            $strobe("Warning: cgdo = %g is negative. Set to zero.", B4SOIcgdo);
            B4SOIcgdo = 0.0;
        end
        if (B4SOIcgso < 0.0) begin
            $strobe("Warning: cgso = %g is negative. Set to zero.", B4SOIcgso);
            B4SOIcgso = 0.0;
        end
        if (B4SOIcgeo < 0.0) begin
            $strobe("Warning: cgeo = %g is negative. Set to zero.", B4SOIcgeo);
            B4SOIcgeo = 0.0;
        end

        pParam_B4SOIcgdo = (B4SOIcgdo + pParam_B4SOIcf) * pParam_B4SOIwdiodCV;
        pParam_B4SOIcgso = (B4SOIcgso + pParam_B4SOIcf) * pParam_B4SOIwdiosCV;
        pParam_B4SOIcgeo = B4SOIcgeo * pParam_B4SOIleffCV * B4SOInf;        /* v4.0 */

        if (!$param_given(NCH) && $param_given(GAMMA1)) begin
            T0 = pParam_B4SOIgamma1 * B4SOIcox;
            pParam_B4SOInpeak = 3.021E22 * T0 * T0;
        end

        T4 = `Eg300 / B4SOIvtm * (TempRatio - 1.0);
        /* source side */
        T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndiode;
        `DEXP(T7, T0)
        T7 = pParam_B4SOIxdif * T4 / pParam_B4SOIndiode;
        `DEXP(T7, T1)
        T7 = pParam_B4SOIxrec * T4 / pParam_B4SOInrecf0;
        `DEXP(T7, T2)

        pParam_B4SOIahli0s = pParam_B4SOIahli * T0;
        pParam_B4SOIjbjts = pParam_B4SOIisbjt * T0;
        pParam_B4SOIjdifs = pParam_B4SOIisdif * T1;
        pParam_B4SOIjrecs = pParam_B4SOIisrec * T2;
        T7 = pParam_B4SOIxtun * (TempRatio - 1);
        `DEXP(T7, T0)
        pParam_B4SOIjtuns = pParam_B4SOIistun * T0;

        /* drain side */
        T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndioded;
        `DEXP(T7, T0)
        T7 = pParam_B4SOIxdifd * T4 / pParam_B4SOIndioded;
        `DEXP(T7, T1)
        T7 = pParam_B4SOIxrecd * T4 / pParam_B4SOInrecf0d;
        `DEXP(T7, T2)

        pParam_B4SOIahli0d = pParam_B4SOIahlid * T0;
        pParam_B4SOIjbjtd = pParam_B4SOIidbjt * T0;
        pParam_B4SOIjdifd = pParam_B4SOIiddif * T1;
        pParam_B4SOIjrecd = pParam_B4SOIidrec * T2;
        T7 = pParam_B4SOIxtund * (TempRatio - 1);
        `DEXP(T7, T0)
        pParam_B4SOIjtund = pParam_B4SOIidtun * T0;

        if (pParam_B4SOInsub > 0)
            pParam_B4SOIvfbb = -B4SOItype * B4SOIvtm *
                                  ln(pParam_B4SOInpeak/ pParam_B4SOInsub);
        else
            pParam_B4SOIvfbb = -B4SOItype * B4SOIvtm *
                                  ln(-pParam_B4SOInpeak* pParam_B4SOInsub/ni/ni);

        if (!$param_given(VSDFB)) begin
            if (pParam_B4SOInsub > 0)
                    pParam_B4SOIvsdfb = -B4SOItype *
                                                (B4SOIvtm*ln(1e20 *
                                                pParam_B4SOInsub / ni /ni) - 0.3);
            else if (pParam_B4SOInsub < 0)
                    pParam_B4SOIvsdfb = -B4SOItype *
                                                (B4SOIvtm*ln(-1e20 /
                                                pParam_B4SOInsub) + 0.3);
        end

        /* Phi  & Gamma */
        SDphi = 2.0*B4SOIvtm*ln(abs(pParam_B4SOInsub) / ni);
        SDgamma = sqrt2qeps * sqrt(abs(pParam_B4SOInsub)) / B4SOIcbox;

        if (!$param_given(VSDTH)) begin
            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                 ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) )
                pParam_B4SOIvsdth = pParam_B4SOIvsdfb + SDphi +
                                        SDgamma * sqrt(SDphi);
            else
                pParam_B4SOIvsdth = pParam_B4SOIvsdfb - SDphi -
                                        SDgamma * sqrt(SDphi);
        end

        if (!$param_given(CSDMIN)) begin
                 /* Cdmin */
            tmp = sqrt(2.0 * epssub * SDphi / (`Charge_q *
                           abs(pParam_B4SOInsub) * 1.0e6));
            tmp1 = epssub / tmp;
            B4SOIcsdmin = tmp1 * B4SOIcbox / (tmp1 + B4SOIcbox);
        end

        pParam_B4SOIphi = 2.0 * B4SOIvtm * ln(pParam_B4SOInpeak / ni);

        pParam_B4SOIsqrtPhi = sqrt(pParam_B4SOIphi);

        pParam_B4SOIXdep0 = sqrt(2.0 * epssub / (`Charge_q
                                           * pParam_B4SOInpeak * 1.0e6))
                                           * pParam_B4SOIsqrtPhi;
        pParam_B4SOIsqrtXdep0 = sqrt(pParam_B4SOIXdep0);

        /*4.1*/
        if (B4SOImtrlMod == 0)
            pParam_B4SOIlitl = sqrt(3.0 *3.9/epsrox* pParam_B4SOIxj * B4SOItox);
        else
            /* pParam_B4SOIlitl = sqrt(epssub * pParam_B4SOIxj * B4SOItox/(epsrox*`EPS0)); */ /* Bug fix # 13 Jun 09 'not reported by vendors'*/
            pParam_B4SOIlitl = sqrt(epssub * pParam_B4SOIxj * toxe/(epsrox*`EPS0));
        pParam_B4SOIvbi = B4SOIvtm * ln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
        pParam_B4SOIcdep0 = sqrt(`Charge_q * epssub
                                   * pParam_B4SOInpeak * 1.0e6 / 2.0
                                   / pParam_B4SOIphi);

        /* v3.0 */
        /*4.1  */
        if (B4SOImtrlMod ==0) begin
            if (pParam_B4SOIngate > 0.0)
                pParam_B4SOIvfbsd = Vtm0 * ln(pParam_B4SOIngate / 1.0e20);
            else
                pParam_B4SOIvfbsd = 0.0;
        end else begin
            T0 = Vtm0 * ln(pParam_B4SOInsd/ni);
            T1 = 0.5 * Eg0;
            if (T0 > T1)
                T0 = T1;
            T2 = B4SOIeasub + T1 - B4SOItype * T0;
            pParam_B4SOIvfbsd = B4SOIphig - T2;
        end

        pParam_B4SOIToxRatio = exp(B4SOIntox * ln(B4SOItoxref /B4SOItoxqm))
                                  /B4SOItoxqm /B4SOItoxqm;
        pParam_B4SOIToxRatioEdge = exp(B4SOIntox * ln(B4SOItoxref
                                  / (B4SOItoxqm * pParam_B4SOIpoxedge)))
                                  / B4SOItoxqm / B4SOItoxqm
                                  / pParam_B4SOIpoxedge / pParam_B4SOIpoxedge;
        pParam_B4SOIAechvb = (B4SOItype == `NMOS) ? agbc2p : agbc2n;
        pParam_B4SOIBechvb = (B4SOItype == `NMOS) ? bgbc2p : bgbc2n;  /* v4.3.1 -Tanvir */
        pParam_B4SOIAechvbEdges = pParam_B4SOIAechvb
                                    * (pParam_B4SOIweff/B4SOInseg + B4SOIpsbcp)
                                    * pParam_B4SOIdlcig * pParam_B4SOIToxRatioEdge;
        pParam_B4SOIAechvbEdged = pParam_B4SOIAechvb
                                    * (pParam_B4SOIweff/B4SOInseg + B4SOIpdbcp)
                                    * pParam_B4SOIdlcig * pParam_B4SOIToxRatioEdge;
        pParam_B4SOIBechvbEdge = -pParam_B4SOIBechvb
                                    * B4SOItoxqm * pParam_B4SOIpoxedge;
        pParam_B4SOIAechvb = pParam_B4SOIAechvb * pParam_B4SOIToxRatio
                                    * (pParam_B4SOIweff/B4SOInseg
                                        * pParam_B4SOIleff + B4SOIagbcpd/B4SOInf);

        pParam_B4SOIBechvb = pParam_B4SOIBechvb * (  -B4SOItoxqm);
        /* v3.0 */

        if ($param_given(K1) || $param_given(K2)) begin // {
            if (!$param_given(K1)) begin
                $strobe( "Warning: k1 should be specified with k2.");
                pParam_B4SOIk1 = 0.53;
            end
            if (!$param_given(K2)) begin
                $strobe( "Warning: k2 should be specified with k1.");
                pParam_B4SOIk2 = -0.0186;
            end
            if ($param_given(XT))
                $strobe( "Warning: xt is ignored because k1 or k2 is given.");
            if ($param_given(VBX))
                $strobe( "Warning: vbx is ignored because k1 or k2 is given.");
            if ($param_given(VBM))
                $strobe( "Warning: vbm is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA1))
                $strobe( "Warning: gamma1 is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA2))
                $strobe( "Warning: gamma2 is ignored because k1 or k2 is given.");
        end else begin // }{
            if (!$param_given(VBX)) begin
                if (B4SOImtrlMod)
                    T0 = `Charge_q / (2.0 * epssub) * 1.0e6;
                else
                    T0 = 7.7348e-4; /* constant from v4.3.0 and earlier */
                pParam_B4SOIvbx = pParam_B4SOIphi - T0 * pParam_B4SOInpeak
                                             * pParam_B4SOIxt * pParam_B4SOIxt;
            end
            if (pParam_B4SOIvbx > 0.0)
                pParam_B4SOIvbx = -pParam_B4SOIvbx;
            if (pParam_B4SOIvbm > 0.0)
                pParam_B4SOIvbm = -pParam_B4SOIvbm;

            if (!$param_given(GAMMA1))
                pParam_B4SOIgamma1 = sqrt2qeps * sqrt(pParam_B4SOInpeak) / B4SOIcox;
            if (!$param_given(GAMMA2))
                pParam_B4SOIgamma2 = sqrt2qeps * sqrt(pParam_B4SOInsub) / B4SOIcox;

            T0 = pParam_B4SOIgamma1 - pParam_B4SOIgamma2;
            T1 = sqrt(pParam_B4SOIphi - pParam_B4SOIvbx) - pParam_B4SOIsqrtPhi;
            
            /*T2 = sqrt(pParam_B4SOIphi * (pParam_B4SOIphi - pParam_B4SOIvbm))
                - pParam_B4SOIphi;*/ //Bug fixed by Pankaj in May 2012
            T2 = pParam_B4SOIsqrtPhi * (sqrt(pParam_B4SOIphi - pParam_B4SOIvbm)- pParam_B4SOIsqrtPhi);
                
            
            pParam_B4SOIk2 = T0 * T1 / (2.0 * T2 + pParam_B4SOIvbm);
            pParam_B4SOIk1 = pParam_B4SOIgamma2 - 2.0
                                * pParam_B4SOIk2 * sqrt(pParam_B4SOIphi - pParam_B4SOIvbm);
        end // }

        T0 = pParam_B4SOIweff + pParam_B4SOIk1w2;
        if (T0 < 1e-8)
            T0 = 1e-8;
        pParam_B4SOIk1eff = pParam_B4SOIk1 * (1 + pParam_B4SOIk1w1/T0);

        /* v4.1 */
        if (!$param_given(VFB)) begin
            if ($param_given(VTH0) || $param_given(VTHO)) begin
                    pParam_B4SOIvfb = B4SOItype * pParam_B4SOIvth0
                                         - pParam_B4SOIphi - pParam_B4SOIk1eff
                                         * pParam_B4SOIsqrtPhi;
                end else begin
                    pParam_B4SOIvfb = -1.0;
                end
        end

        if (!$param_given(VTH0)) begin
            pParam_B4SOIvth0 = B4SOItype * (pParam_B4SOIvfb
                                        + pParam_B4SOIphi + pParam_B4SOIk1eff
                                        * pParam_B4SOIsqrtPhi);
        end

        /* v4.0 */
        pParam_B4SOIk1ox = pParam_B4SOIk1eff * B4SOItox / B4SOItoxm;
        T1 = B4SOIfactor1 * pParam_B4SOIsqrtXdep0;

        T0 = exp(-0.5 * pParam_B4SOIdsub * pParam_B4SOIleff / T1);
        pParam_B4SOItheta0vb0 = (T0 + 2.0 * T0 * T0);

        T0 = exp(-0.5 * pParam_B4SOIdrout * pParam_B4SOIleff / T1);
        T2 = (T0 + 2.0 * T0 * T0);
        pParam_B4SOIthetaRout = pParam_B4SOIpdibl1 * T2
                                   + pParam_B4SOIpdibl2;

        /* New DITS term (added in 4.1) */
        pParam_B4SOIdvtp2factor = pParam_B4SOIdvtp2 / exp(pParam_B4SOIdvtp3
                                     * ln(pParam_B4SOIleff));

        /* stress effect */
        if (B4SOIwlod < 0.0) begin
            $strobe( "Warning: WLOD = %g is less than 0. Set to 0.0",B4SOIwlod);
            B4SOIwlod = 0.0;
        end

        T0 = pow(Ldrn, B4SOIllodku0);
        W_tmp = Wdrn + B4SOIwlod;
        T1 = pow(W_tmp, B4SOIwlodku0);
        tmp1 = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);
        pParam_B4SOIku0 = 1.0 + tmp1;

        T0 = pow(Ldrn, B4SOIllodvth);
        T1 = pow(W_tmp, B4SOIwlodvth);
        tmp1 = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
        pParam_B4SOIkvth0 = 1.0 + tmp1;
        pParam_B4SOIkvth0 = sqrt( pParam_B4SOIkvth0
                                     * pParam_B4SOIkvth0 + `DELTA_);

        /*T0 = (TRatio - 1.0);*/
        T0 = (TempRatio - 1.0);  /* bug fix v4.1 */
        pParam_B4SOIku0temp = pParam_B4SOIku0 * (1.0 + B4SOItku0 * T0) + `DELTA_;

        Inv_saref = 1.0 / (B4SOIsaref + 0.5 * Ldrn);
        Inv_sbref = 1.0 / (B4SOIsbref + 0.5 * Ldrn);
        pParam_B4SOIinv_od_ref = Inv_saref + Inv_sbref;
        pParam_B4SOIrho_ref = B4SOIku0 / pParam_B4SOIku0temp
                                                 * pParam_B4SOIinv_od_ref;
        /* stress effect end */

        /*  v4.0 stress effect */    /* Bug Fix # 17 Jul09 Code 1484-1560 is moved up from lines 1884-1958 of old version*/
        if( (B4SOIsa > 0.0) && (B4SOIsb > 0.0) &&
            ( (B4SOInf == 1.0) ||
              ((B4SOInf > 1.0) && (B4SOIsd > 0.0))
            )
          ) begin // {
            Inv_sa = 0;
            Inv_sb = 0;

            if (B4SOIkvsat < -1.0 ) begin
                $strobe( "Warning: KVSAT = %g is too small; Reset to -1.0.",B4SOIkvsat);
                B4SOIkvsat = -1.0;
            end else if (B4SOIkvsat > 1.0) begin
                $strobe( "Warning: KVSAT = %g is too big; Reset to 1.0.",B4SOIkvsat);
                B4SOIkvsat = 1.0;
            end else begin
                B4SOIkvsat = B4SOIkvsat;
            end

            for (i = 0; i < B4SOInf; i = i+1) begin : forloop
                  real T0, T1;
                  T0 = 1.0 / B4SOInf / (B4SOIsa
                           + 0.5*Ldrn + i * (B4SOIsd +Ldrn));
                  T1 = 1.0 / B4SOInf / (B4SOIsb
                           + 0.5*Ldrn + i * (B4SOIsd +Ldrn));
                  Inv_sa = Inv_sa + T0;
                  Inv_sb = Inv_sb + T1;
            end

            Inv_ODeff = Inv_sa + Inv_sb;
            B4SOIInv_ODeff = Inv_ODeff;
            rho = B4SOIku0 / pParam_B4SOIku0temp * Inv_ODeff;
            T0 = (1.0 + rho)/(1.0 + pParam_B4SOIrho_ref);
            here_B4SOIu0temp = pParam_B4SOIu0temp * T0;

            T1 = (1.0 + B4SOIkvsat * rho)/(1.0 + B4SOIkvsat * pParam_B4SOIrho_ref);/*self-heating bug fix*/
            here_B4SOIvsattemp = pParam_B4SOIvsattemp * T1;

            OD_offset = Inv_ODeff - pParam_B4SOIinv_od_ref;
            dvth0_lod = B4SOIkvth0 / pParam_B4SOIkvth0 * OD_offset;
            dk2_lod = B4SOIstk2 / pow(pParam_B4SOIkvth0, B4SOIlodk2) * OD_offset;
            deta0_lod = B4SOIsteta0 / pow(pParam_B4SOIkvth0, B4SOIlodeta0) * OD_offset;
            deta0cv_lod = B4SOIsteta0cv / pow(pParam_B4SOIkvth0, B4SOIlodeta0cv) * OD_offset;

            here_B4SOIvth0 = pParam_B4SOIvth0 + dvth0_lod;
            here_B4SOIk2 = pParam_B4SOIk2 + dk2_lod;
            here_B4SOIeta0 = pParam_B4SOIeta0 + deta0_lod;
            here_B4SOIeta0cv = pParam_B4SOIeta0cv + deta0cv_lod; 
        end else begin // }{
            here_B4SOIu0temp = pParam_B4SOIu0temp;
            here_B4SOIvth0 = pParam_B4SOIvth0;
            here_B4SOIvsattemp = pParam_B4SOIvsattemp;
            here_B4SOIk2 = pParam_B4SOIk2;
            here_B4SOIeta0 = pParam_B4SOIeta0;
            here_B4SOIeta0cv = pParam_B4SOIeta0cv;
            B4SOIInv_ODeff = 0;
            pParam_B4SOIinv_od_ref = 0; /*Stress bug fix*/
            B4SOIkvsat = 0; /*Stress bug fix*/
        end // } /* v4.0 stress effect end */

        here_B4SOIk2ox = here_B4SOIk2 * B4SOItox / B4SOItoxm;        /* v4.0 */
        here_B4SOIvth0 = here_B4SOIvth0 + B4SOIdelvto; /* v4.0 */
        here_B4SOIvfb = pParam_B4SOIvfb + B4SOItype * B4SOIdelvto;
        /* Bug Fix # 17 Jul09 Code 1479-1545 is moved up from lines 1884-1950 of old version, 1954-2035 in this version*/

        B4SOIcsbox = B4SOIcbox*B4SOIsourceArea;
        B4SOIcsmin = B4SOIcsdmin*B4SOIsourceArea;
        B4SOIcdbox = B4SOIcbox*B4SOIdrainArea;
        B4SOIcdmin = B4SOIcsdmin*B4SOIdrainArea;

        if (B4SOIcsdmin > 0) begin
            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                 ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) ) begin

                T0 = pParam_B4SOIvsdth - pParam_B4SOIvsdfb;
                pParam_B4SOIsdt1 = pParam_B4SOIvsdfb + B4SOIasd * T0;
                T1 = B4SOIcsbox - B4SOIcsmin;
                T2 = T1 / T0 / T0;
                pParam_B4SOIst2 = T2 / B4SOIasd;
                pParam_B4SOIst3 = T2 /( 1 - B4SOIasd);
                B4SOIst4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcsmin * pParam_B4SOIvsdfb;

                T1 = B4SOIcdbox - B4SOIcdmin;
                T2 = T1 / T0 / T0;
                pParam_B4SOIdt2 = T2 / B4SOIasd;
                pParam_B4SOIdt3 = T2 /( 1 - B4SOIasd);
                B4SOIdt4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcdmin * pParam_B4SOIvsdfb;
            end else begin

                T0 = pParam_B4SOIvsdfb - pParam_B4SOIvsdth;
                pParam_B4SOIsdt1 = pParam_B4SOIvsdth + B4SOIasd * T0;
                T1 = B4SOIcsmin - B4SOIcsbox;
                T2 = T1 / T0 / T0;
                pParam_B4SOIst2 = T2 / B4SOIasd;
                pParam_B4SOIst3 = T2 /( 1 - B4SOIasd);
                B4SOIst4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcsbox * pParam_B4SOIvsdth;

                T1 = B4SOIcdmin - B4SOIcdbox;
                T2 = T1 / T0 / T0;
                pParam_B4SOIdt2 = T2 / B4SOIasd;
                pParam_B4SOIdt3 = T2 /( 1 - B4SOIasd);
                B4SOIdt4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcdbox * pParam_B4SOIvsdth;
            end
        end else begin
            pParam_B4SOIsdt1 = 0;
            pParam_B4SOIst2 = 0;
            pParam_B4SOIst3 = 0;
            B4SOIst4 = 0;
            pParam_B4SOIdt2 = 0;
            pParam_B4SOIdt3 = 0;
            B4SOIdt4 = 0;
        end

        /* v4.4 Sidewall Fringing Capacitance Enhancement */
        if (B4SOIcfrcoeff < 1.0 || B4SOIcfrcoeff > 2.0) begin
            $strobe("Warning: CfrCoeff = %g is outside valid range [1,2], set to 1. \n", B4SOIcfrcoeff);
            B4SOIcfrcoeff = 1.0;
        end 
        /* v2.2.2 bug fix */
        T0 = B4SOIcsdesw * ln(B4SOIcfrcoeff * (1 + B4SOItsi / B4SOItbox)); 
        T1 = B4SOIsourcePerimeter - B4SOIw;
        if (T1 > 0.0)
            B4SOIcsesw = T0 * T1;
        else
            B4SOIcsesw = 0.0;
        T1 = B4SOIdrainPerimeter - B4SOIw;
        if (T1 > 0.0)
            B4SOIcdesw = T0 * T1;
        else
            B4SOIcdesw = 0.0;

        /* process source/drain series resistance */
        B4SOIdrainResistance = B4SOIsheetResistance * B4SOIdrainSquares;
        if (B4SOIdrainResistance > 0.0)
            B4SOIdrainConductance = 1.0 / B4SOIdrainResistance;
        else
            B4SOIdrainConductance = 1.0e3;

        B4SOIsourceResistance = B4SOIsheetResistance * B4SOIsourceSquares;
        if (B4SOIsourceResistance > 0.0)
            B4SOIsourceConductance = 1.0 / B4SOIsourceResistance;
        else
            B4SOIsourceConductance = 1.0e3;

        /* v2.0 release */
        if (B4SOIln < 1e-15) B4SOIln = 1e-15;
        T0 = -0.5 * pParam_B4SOIleff * pParam_B4SOIleff / B4SOIln / B4SOIln;
        `DEXP(T0,T1)
        pParam_B4SOIarfabjt = T1;

        T0 = pParam_B4SOIlbjt0 * (1.0 / pParam_B4SOIleff + 1.0 / B4SOIln);
        pParam_B4SOIlratio = pow(T0,pParam_B4SOInbjt);
        pParam_B4SOIlratiodif = 1.0 + B4SOIldif0 * pow(T0,pParam_B4SOIndif);
        pParam_B4SOIvearly = pParam_B4SOIvabjt + pParam_B4SOIaely * pParam_B4SOIleff;
        if (pParam_B4SOIvearly < 1)
            pParam_B4SOIvearly = 1;

        /*4.1 toxp calculation*/
        if (B4SOImtrlMod == 0) begin
            B4SOItoxp = B4SOItox - B4SOIdtoxcv;
        end else begin // {
                 /* Calculate TOXP from EOT */
              /* Calculate Vgs_eff @ Vgs = VDD with Poly Depletion Effect */
            Vtm0eot = `KboQ * B4SOItempeot;
            Vtmeot  = Vtm0eot;
            vbieot = Vtm0eot * ln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
            phieot = 2.0 * Vtm0eot * ln(pParam_B4SOInpeak / ni);
            sqrtphieot = sqrt(phieot);
            tmp2 = here_B4SOIvfb + phieot;
            vddeot = B4SOItype * B4SOIvddeot;

            T0 = B4SOIepsrgate * `EPS0;
            if ((pParam_B4SOIngate > 1.0e18) && (pParam_B4SOIngate < 1.0e25)
                    && (vddeot > tmp2) && (T0!=0)) begin
                T1 = 1.0e6 * `Charge_q * epssub * pParam_B4SOIngate
                                         / (B4SOIcox * B4SOIcox);
                T4 = sqrt(1.0 + 2.0 * (vddeot - T0) / T1);
                T2 = T1 * (T4 - 1.0);
                T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
                T7 = eggdep - T3 - 0.05;
                T6 = sqrt(T7 * T7 + 0.224);
                T5 = eggdep - 0.5 * (T7 + T6);
                Vgs_eff = vddeot - T5;
            end else begin
                Vgs_eff = vddeot;
            end

            /* Calculate Vth @ Vds=Vbs=0 */

            V0 = vbieot - phieot;
            T3 = pParam_B4SOIsqrtXdep0;

            lt1 = B4SOIfactor1 * T3;
            ltw = B4SOIfactor1 * T3 ;

            T0 = -0.5 * pParam_B4SOIdvt1 * B4SOIleffeot / lt1;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end

            /* Calculate n */
            T2 = pParam_B4SOInfactor * epssub / pParam_B4SOIXdep0;
            T3 = pParam_B4SOIcdsc ;
            T4 = (T2 + T3 * Theta0 + pParam_B4SOIcit) / B4SOIcox;

            if (T4 >= -0.5) begin
                n = 1.0 + T4;
            end else begin
                /* avoid  discontinuity problems caused by T4 */
                T0 = 1.0 / (3.0 + 8.0 * T4);
                n = (1.0 + 3.0 * T4) * T0;
            end

            /* v4.0 DITS */
            if (pParam_B4SOIdvtp0 > 0.0) begin
                T3 = B4SOIleffeot + 2.0 * pParam_B4SOIdvtp0;
                T4 = Vtmeot * ln(B4SOIleffeot / T3);
                DITS_Sft = n * T4;
            end else begin
                DITS_Sft = 0.0;
            end

            B4SOIthetavth = pParam_B4SOIdvt0 * Theta0;
            Delt_vth = B4SOIthetavth * V0;

            T0 = -0.5 * pParam_B4SOIdvt1w * B4SOIweffeot * B4SOIleffeot / ltw;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                T2 = T1 * (1.0 + 2.0 * T1);
            end

            T0 = pParam_B4SOIdvt0w * T2;
            DeltVthw = T0 * V0;

            TempRatioMinus1 = B4SOItempeot / B4SOItnom - 1.0;

            T0 = sqrt(1.0 + pParam_B4SOIlpe0 / B4SOIleffeot);
            T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / B4SOIleffeot);
            DeltVthtemp = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtphieot
                                + T1 * TempRatioMinus1; /* v4.0 */

            tmp2 = toxe * phieot / (B4SOIweffeot + pParam_B4SOIw0);

            DIBL_Sft = 0.0;
            DITS_Sft2 = 0.0;

            Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / B4SOIleffeot);

            sqrtPhisExt = sqrtphieot;

            Vth = B4SOItype * here_B4SOIvth0
                              + (pParam_B4SOIk1ox * sqrtPhisExt
                              - pParam_B4SOIk1eff * sqrtphieot) * Lpe_Vb
                              - Delt_vth - DeltVthw
                              + pParam_B4SOIk3 * tmp2
                              + DeltVthtemp - DIBL_Sft -DITS_Sft - DITS_Sft2;

            Vgst = Vgs_eff - Vth;

            T10 = n * Vtmeot; /* v4.0 */
            VgstNVt = pParam_B4SOImstar * Vgst / T10; /* v4.0 */
            ExpArg = (pParam_B4SOIvoff - (1- pParam_B4SOImstar) * Vgst)
                                             / T10;                /* v4.0 */

            /* MCJ: Very small Vgst */
            if (VgstNVt > `EXPL_THRESHOLD) begin
                Vgsteff = Vgst;
            end else if (ExpArg > `EXPL_THRESHOLD) begin
                T0 = (Vgst - pParam_B4SOIvoff) / (n * Vtmeot);
                ExpVgst = exp(T0);
                Vgsteff = Vtmeot * pParam_B4SOIcdep0 / B4SOIcox * ExpVgst;
            end else begin
                ExpVgst = exp(VgstNVt);
                T1 = T10 * ln(1.0 + ExpVgst);
                T4 = -B4SOIcox / (Vtm0eot * pParam_B4SOIcdep0)
                        * exp(ExpArg) * (1 - pParam_B4SOImstar);
                T2 = pParam_B4SOImstar - T10 * T4
                        / (1.0 - pParam_B4SOImstar);
                Vgsteff = T1 / T2;
            end

            /* calculating Toxp */
            T3 = B4SOItype * here_B4SOIvth0 - here_B4SOIvfb - phieot;
            vtfbphi2eot = 4.0 * T3;
            if (vtfbphi2eot < 0.0)
                vtfbphi2eot = 0.0;

            niter = 0;
            toxpf = toxe;
            toxpi = 1e6; // force while loop
            while ((niter<=4)&&(abs(toxpf-toxpi)>1e-12)) begin : whileloop //
                real T0, T1;
                toxpi = toxpf;
                tmp2 = 2.0e8 * toxpf;
                T0 = (Vgsteff + vtfbphi2eot) / tmp2;
                T1 = 1.0 + exp(B4SOIbdos * 0.7 * ln(T0));
                Tcen = B4SOIados * 1.9e-9 / T1;
                toxpf = toxe - epsrox/B4SOIepsrsub * Tcen;
                niter = niter + 1;
            end // while
            B4SOItoxp = toxpf;
            /*B4SOIcoxp = epsrox * `EPS0 / B4SOItoxp;*/

        end // }/*End of Toxp*/

        /* vfbzb calculation for capMod 3 */
        tmp = pParam_B4SOIsqrtXdep0;
        tmp1 = pParam_B4SOIvbi - pParam_B4SOIphi;
        tmp2 = B4SOIfactor1 * tmp;

        T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * pParam_B4SOIleff / tmp2;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T2 = T1 * (1.0 + 2.0 * T1);
        end
        T0 = pParam_B4SOIdvt0w * T2;
        T2 = T0 * tmp1;

        T0 = -0.5 * pParam_B4SOIdvt1 * pParam_B4SOIleff / tmp2;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T3 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T3 = T1 * (1.0 + 2.0 * T1);
        end
        T3 = pParam_B4SOIdvt0 * T3 * tmp1;

        /* v2.2.3 */
        /*4.1*/
        /* T4 = (B4SOItox - B4SOIdtoxcv) * pParam_B4SOIphi
                / (pParam_B4SOIweff + pParam_B4SOIw0);
        */
        T4 = B4SOItoxp * pParam_B4SOIphi
                / (pParam_B4SOIweff + pParam_B4SOIw0);
        T0 = sqrt(1.0 + pParam_B4SOIlpe0 / pParam_B4SOIleff); /*v4.0*/
        T5 = pParam_B4SOIk1ox * (T0 - 1.0) * pParam_B4SOIsqrtPhi
                + (pParam_B4SOIkt1 + pParam_B4SOIkt1l / pParam_B4SOIleff)
                * (TempRatio - 1.0);        /* v4.0 */

        tmp3 = B4SOItype * pParam_B4SOIvth0
                - T2 - T3 + pParam_B4SOIk3 * T4 + T5;
        pParam_B4SOIvfbzb = tmp3 - pParam_B4SOIphi - pParam_B4SOIk1
                                         * pParam_B4SOIsqrtPhi;
        /* End of vfbzb */

        /* v3.2 */
        pParam_B4SOIqsi = `Charge_q * B4SOInpeak
                                 * (1.0 + pParam_B4SOIlpe0 / pParam_B4SOIleff)
                                 * 1e6 * B4SOItsi;


        /* v3.1 added for RF */
        B4SOIgrgeltd = B4SOIrshg * (B4SOIxgw
                               + pParam_B4SOIweff / B4SOInseg
                                    / 3.0 / B4SOIngcon) /
                              (B4SOIngcon * B4SOInf * (B4SOIl - B4SOIxgl));
        if (B4SOIgrgeltd > 0.0) begin
            B4SOIgrgeltd = 1.0 / B4SOIgrgeltd;
        end else begin
            B4SOIgrgeltd = 1.0e3; /* mho */
            if (B4SOIrgateMod !=0)
                $strobe("Warning: The gate conductance reset to 1.0e3 mho.");
        end
        /* v3.1 added for RF end */

        /* v4.0 rbodyMod */
        if (B4SOIrbodyMod) begin
            if (B4SOIrbdb < 1.0e-3)
                B4SOIgrbdb = 1.0e3; /* in mho */
            else
                B4SOIgrbdb = B4SOIgbmin + 1.0 / B4SOIrbdb;

            if (B4SOIrbsb < 1.0e-3)
                B4SOIgrbsb = 1.0e3;
            else
                B4SOIgrbsb = B4SOIgbmin + 1.0 / B4SOIrbsb;
        end else begin
            B4SOIgrbdb = 0;
            B4SOIgrbsb = 0;
        end
        /* v4.0 rbodyMod end */
        /* Bug Fix # 17 Jul09 Stress effect code (lines: 1954-2020) is moved up to lines 1479-1545*/

        B4SOIvfbzb = pParam_B4SOIvfbzb + B4SOItype * B4SOIdelvto;

        pParam_B4SOIldeb = sqrt(epssub * Vtm0 /
                               (`Charge_q * pParam_B4SOInpeak * 1.0e6)) / 3.0;

        /*For high k mobility*/
        T1 = B4SOItype * here_B4SOIvth0 - here_B4SOIvfb - pParam_B4SOIphi;
        T2 = T1 + T1;
        T3 = 2.5 * T1;
        B4SOIvtfbphi1 = (B4SOItype == `NMOS) ? T2 : T3;
        if (B4SOIvtfbphi1 < 0.0)
            B4SOIvtfbphi1 = 0.0;

        /*Calculate VgsteffVth for mobMod=4*/
        if (B4SOImobMod == 4) begin // {
            /*Calculate n @ Vbs=Vds=0*/
            lt1 = B4SOIfactor1* pParam_B4SOIsqrtXdep0;
            T0 = pParam_B4SOIdvt1 * pParam_B4SOIleff / lt1;
            if (T0 < `EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXPL;
                Theta0 = T1 / T4;
            end else begin
                Theta0 = 1.0 / (`MAX_EXPL - 2.0);
            end

            tmp1 = epssub / pParam_B4SOIXdep0;
            tmp2 = pParam_B4SOInfactor * tmp1;
            tmp3 = (tmp2 + pParam_B4SOIcdsc * Theta0 + pParam_B4SOIcit) / B4SOIcox;
            if (tmp3 >= -0.5) begin
                n0 = 1.0 + tmp3;
            end else begin
                T0 = 1.0 / (3.0 + 8.0 * tmp3);
                n0 = (1.0 + 3.0 * tmp3) * T0;
            end

            T0 = n0 * Vtm0;
            T1 = pParam_B4SOIvoff;
            T2 = T1/T0;
            if (T2 < -`EXPL_THRESHOLD) begin
                T3 = B4SOIcox * `MIN_EXPL / pParam_B4SOIcdep0;
                T4 = pParam_B4SOImstar + T3 * n0;
            end else if (T2 > `EXPL_THRESHOLD) begin
                T3 = B4SOIcox * `MAX_EXPL / pParam_B4SOIcdep0;
                T4 = pParam_B4SOImstar + T3 * n0;
            end else begin
                T3 = exp(T2)* B4SOIcox / pParam_B4SOIcdep0;
                T4 = pParam_B4SOImstar + T3 * n0;
            end

            B4SOIvgsteffvth = T0 * ln(2.0)/T4;

        end else begin
            B4SOIvgsteffvth = 0;
        end // }

    end // b4soi_temp // }
`ifdef __XYCE__
    end // initialize_instance
`endif

    begin : b4soi_check // {
        integer Fatal_Flag;

        Fatal_Flag = 0;

        if (pParam_B4SOIlpe0 < -pParam_B4SOIleff) begin
            $strobe("Fatal: Lpe0 = %g is less than -Leff.", pParam_B4SOIlpe0);
            Fatal_Flag = 1;
        end

        if((B4SOIsa > 0.0) && (B4SOIsb > 0.0) &&
            ((B4SOInf == 1.0) || ((B4SOInf > 1.0) && (B4SOIsd > 0.0))) ) begin
            if (B4SOIsaref <= 0.0) begin
                $strobe("Fatal: SAref = %g is not positive.", B4SOIsaref);
                Fatal_Flag = 1;
            end
            if (B4SOIsbref <= 0.0) begin
                $strobe("Fatal: SBref = %g is not positive.", B4SOIsbref);
                Fatal_Flag = 1;
            end
        end

        if (pParam_B4SOIlpeb < -pParam_B4SOIleff) begin
            $strobe("Fatal: Lpeb = %g is less than -Leff.", pParam_B4SOIlpeb);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIfprout < 0.0) begin
            $strobe("Fatal: fprout = %g is negative.", pParam_B4SOIfprout);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIpdits < 0.0) begin
            $strobe("Fatal: pdits = %g is negative.", pParam_B4SOIpdits);
            Fatal_Flag = 1;
        end
        if (B4SOIpditsl < 0.0) begin
            $strobe("Fatal: pditsl = %g is negative.", B4SOIpditsl);
            Fatal_Flag = 1;
        end

        if (B4SOItox <= 0.0) begin
            $strobe("Fatal: Tox = %g is not positive.", B4SOItox);
            Fatal_Flag = 1;
        end
        if (B4SOIleffeot <= 0.0) begin
            $strobe("Fatal: Leffeot = %g is not positive.", B4SOIleffeot);
            Fatal_Flag = 1;
        end
        if (B4SOIweffeot <= 0.0) begin
            $strobe("Fatal: Weffeot = %g is not positive.", B4SOIweffeot);
            Fatal_Flag = 1;
        end
        if (B4SOItoxp <= 0.0) begin
            $strobe("Fatal: Toxp = %g is not positive.", B4SOItoxp);
            Fatal_Flag = 1;
        end
        if (B4SOIepsrgate < 0.0) begin
            $strobe("Fatal: Epsrgate = %g is not positive.", B4SOIepsrgate);
            Fatal_Flag = 1;
        end

        if (B4SOItoxm <= 0.0) begin
            $strobe("Fatal: Toxm = %g is not positive.", B4SOItoxm);
            Fatal_Flag = 1;
        end

        if (B4SOInf < 1.0) begin
            $strobe("Fatal: Number of finger = %g is smaller than one.", B4SOInf);
            Fatal_Flag = 1;
        end

        if (B4SOItox - B4SOIdtoxcv <= 0.0) begin
            $strobe("Fatal: Tox - dtoxcv = %g is not positive.", B4SOItox - B4SOIdtoxcv);
            Fatal_Flag = 1;
        end

        if (B4SOItbox <= 0.0) begin
            $strobe("Fatal: Tbox = %g is not positive.", B4SOItbox);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOInpeak <= 0.0) begin
            $strobe("Fatal: Nch = %g is not positive.", pParam_B4SOInpeak);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIngate < 0.0) begin
            $strobe("Fatal: Ngate = %g Ngate is not positive.", pParam_B4SOIngate);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIngate > 1.0e25) begin
            $strobe("Fatal: Ngate = %g Ngate is too high", pParam_B4SOIngate);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdvt1 < 0.0) begin
            $strobe("Fatal: Dvt1 = %g is negative.", pParam_B4SOIdvt1);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdvt1w < 0.0) begin
            $strobe("Fatal: Dvt1w = %g is negative.", pParam_B4SOIdvt1w);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIw0 == -pParam_B4SOIweff) begin
            $strobe("Fatal: (W0 + Weff) = 0 causing divided-by-zero.");
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdsub < 0.0) begin
            $strobe("Fatal: Dsub = %g is negative.", pParam_B4SOIdsub);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIb1 == -pParam_B4SOIweff) begin
            $strobe("Fatal: (B1 + Weff) = 0 causing divided-by-zero.");
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIu0temp <= 0.0) begin
            $strobe("Fatal: u0 at current temperature = %g is not positive.",
                pParam_B4SOIu0temp);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdelta < 0.0) begin
            $strobe("Fatal: Delta = %g is less than zero.", pParam_B4SOIdelta);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIvsattemp <= 0.0) begin
            $strobe("Fatal: Vsat at current temperature = %g is not positive.",
                pParam_B4SOIvsattemp);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIpclm <= 0.0) begin
            $strobe("Fatal: Pclm = %g is not positive.", pParam_B4SOIpclm);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdrout < 0.0) begin
            $strobe("Fatal: Drout = %g is negative.", pParam_B4SOIdrout);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIclc < 0.0) begin
            $strobe("Fatal: Clc = %g is negative.", pParam_B4SOIclc);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOInoff < 0.1)
            $strobe("Warning: Noff = %g is too small.", pParam_B4SOInoff);
        else if (pParam_B4SOInoff > 4.0)
            $strobe("Warning: Noff = %g is too large.", pParam_B4SOInoff);

        if( (B4SOIsa > 0.0) && (B4SOIsb > 0.0) &&
            ((B4SOInf == 1.0) || ((B4SOInf > 1.0) && (B4SOIsd > 0.0))) ) begin

            if (B4SOIlodk2 <= 0.0)
                $strobe("Warning: LODK2 = %g is not positive.",B4SOIlodk2);
            if (B4SOIlodeta0 <= 0.0)
                $strobe("Warning: LODETA0 = %g is not positive.",B4SOIlodeta0);
            if (B4SOIlodeta0cv <= 0.0)
                $strobe("Warning: LODETA0CV = %g is not positive.",B4SOIlodeta0cv);
        
        end

        if (pParam_B4SOImoin < 5.0)
            $strobe("Warning: Moin = %g is too small.", pParam_B4SOImoin);
        if (pParam_B4SOImoin > 25.0)
            $strobe("Warning: Moin = %g is too large.", pParam_B4SOImoin);
        if (B4SOImoinFD < 5.0)
            $strobe("Warning: MoinFD = %g is too small.", B4SOImoinFD);

        if (B4SOIcapMod == 3) begin
            if (pParam_B4SOIacde < 0.1)
                $strobe("Warning: Acde = %g is too small.", pParam_B4SOIacde);
            else if (pParam_B4SOIacde > 1.6)
                $strobe("Warning: Acde = %g is too large.", pParam_B4SOIacde);
        end


        /* checks that set Fatal_Flag are moved out of PARAMCHK block in 4.4 */
        if (B4SOIcsdmin > 0 && (B4SOIasd <= 0.0 || B4SOIasd >= 1.0)) begin
            $strobe("Fatal: Asd = %g should be within (0, 1).", B4SOIasd);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOInigc <= 0.0) begin
            $strobe("Fatal: nigc = %g is non-positive.", pParam_B4SOInigc);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIpoxedge <= 0.0) begin
            $strobe("Fatal: poxedge = %g is non-positive.", pParam_B4SOIpoxedge);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIpigcd <= 0.0) begin
            $strobe("Fatal: pigcd = %g is non-positive.", pParam_B4SOIpigcd);
            Fatal_Flag = 1;
        end

        if (B4SOItoxref < 0.0) begin
            $strobe("Warning:  Toxref = %g is negative.", B4SOItoxref);
            Fatal_Flag = 1;
        end
        if (B4SOItoxqm <= 0.0) begin
            $strobe("Fatal: Toxqm = %g is not positive.", B4SOItoxqm);
            Fatal_Flag = 1;
        end

        if (VERSION >= 4.4 || PARAMCHK) begin
            if (pParam_B4SOIa2 < 0.01) begin
                $strobe("Warning: A2 = %g is too small. Set to 0.01.", pParam_B4SOIa2);
                pParam_B4SOIa2 = 0.01;
            end else if (pParam_B4SOIa2 > 1.0) begin
                $strobe("Warning: A2 = %g is larger than 1. A2 is set to 1 and A1 is set to 0.",
                    pParam_B4SOIa2);
                pParam_B4SOIa2 = 1.0;
                pParam_B4SOIa1 = 0.0;
            end
        end

        if (pParam_B4SOIrdsw < 0.0) begin
            $strobe("Warning: Rdsw = %g is negative. Set to zero.",
                pParam_B4SOIrdsw);
            pParam_B4SOIrdsw = 0.0;
            pParam_B4SOIrds0 = 0.0;
        end else if (pParam_B4SOIrds0 < 0.001 && pParam_B4SOIrds0 != 0.0) begin
            $strobe("Warning: Rds at current temperature = %g is less than 0.001 ohm. Set to zero.",
                pParam_B4SOIrds0);
            pParam_B4SOIrds0 = 0.0;
        end

        if (PARAMCHK) begin // {
            if (pParam_B4SOIleff <= 5.0e-8)
                $strobe("Warning: Leff = %g may be too small.", pParam_B4SOIleff);
            if (pParam_B4SOIleffCV <= 5.0e-8)
                $strobe("Warning: Leff for CV = %g may be too small.", pParam_B4SOIleffCV);

            if (pParam_B4SOIweff <= 1.0e-7)
                $strobe("Warning: Weff = %g may be too small.", pParam_B4SOIweff);

            if (pParam_B4SOIweffCV <= 1.0e-7)
                $strobe("Warning: Weff for CV = %g may be too small.",
                   pParam_B4SOIweffCV);

            if (pParam_B4SOIlpe0 < 0.0)
               $strobe("Warning: Lpe0 = %g is negative.", pParam_B4SOIlpe0);

            if (B4SOItox < 1.0e-9)
                $strobe("Warning: Tox = %g is less than 10A.", B4SOItox);

            if (pParam_B4SOInpeak <= 1.0e15)
                $strobe("Warning: Nch = %g may be too small.", pParam_B4SOInpeak);
            else if (pParam_B4SOInpeak >= 1.0e21)
                $strobe("Warning: Nch = %g may be too large.", pParam_B4SOInpeak);

            if (abs(pParam_B4SOInsub) >= 1.0e21)
                $strobe("Warning: Nsub = %g may be too large.", pParam_B4SOInsub);

            if ((pParam_B4SOIngate > 0.0) && (pParam_B4SOIngate <= 1.0e18))
                $strobe("Warning: Ngate = %g is less than 1.E18cm^-3.", pParam_B4SOIngate);

            if (pParam_B4SOIdvt0 < 0.0)
                $strobe("Warning: Dvt0 = %g is negative.", pParam_B4SOIdvt0);

            if (abs(1.0e-6 / (pParam_B4SOIw0 + pParam_B4SOIweff)) > 10.0)
                $strobe("Warning: (W0 + Weff) may be too small.");

            if (B4SOInsd > 1.0e23)
                $strobe("Warning: Nsd = %g is too large, should be specified in cm^-3.", B4SOInsd);
            if (B4SOIngate > 1.0e23)
                $strobe("Warning: Ngate = %g is too large, should be specified in cm^-3.", B4SOIngate);
            if (B4SOInpeak > 1.0e20)
                $strobe("Warning: Npeak = %g is too large, should be less than 1.0e20, specified in cm^-3.", B4SOInpeak);

            if (pParam_B4SOInfactor < 0.0)
                $strobe("Warning: Nfactor = %g is negative.", pParam_B4SOInfactor);
            if (pParam_B4SOIcdsc < 0.0)
                $strobe("Warning: Cdsc = %g is negative.", pParam_B4SOIcdsc);
            if (pParam_B4SOIcdscd < 0.0)
                $strobe("Warning: Cdscd = %g is negative.", pParam_B4SOIcdscd);

            if (pParam_B4SOIeta0 < 0.0)
                $strobe("Warning: Eta0 = %g is negative.", pParam_B4SOIeta0);
            
            if (pParam_B4SOIeta0cv < 0.0)
                $strobe("Warning: Eta0CV = %g is negative.", pParam_B4SOIeta0cv);

            if (abs(1.0e-6 / (pParam_B4SOIb1 + pParam_B4SOIweff)) > 10.0)
                $strobe("Warning: (B1 + Weff) may be too small.");

            if (pParam_B4SOIvsattemp < 1.0e3)
                $strobe("Warning: Vsat at current temperature = %g may be too small.", pParam_B4SOIvsattemp);

            if (pParam_B4SOIpdibl1 < 0.0)
                $strobe("Warning: Pdibl1 = %g is negative.", pParam_B4SOIpdibl1);
            if (pParam_B4SOIpdibl2 < 0.0)
                $strobe("Warning: Pdibl2 = %g is negative.", pParam_B4SOIpdibl2);

            if (B4SOIntun < 0.0)
                $strobe("Warning: Ntuns = %g is negative.", B4SOIntun);
            if (B4SOIntund < 0.0)
                $strobe("Warning: Ntund = %g is negative.", B4SOIntund);

            if (B4SOIndiode < 0.0)
                $strobe("Warning: Ndiode = %g is negative.", B4SOIndiode);
            if (B4SOIndioded < 0.0)
                $strobe("Warning: Ndioded = %g is negative.", B4SOIndioded);

            if (B4SOIisbjt < 0.0)
                $strobe("Warning: Isbjt = %g is negative.", B4SOIisbjt);
            if (B4SOIidbjt < 0.0)
                $strobe("Warning: Idbjt = %g is negative.", B4SOIidbjt);

            if (B4SOIisdif < 0.0)
                $strobe("Warning: Isdif = %g is negative.", B4SOIisdif);
            if (B4SOIiddif < 0.0)
                $strobe("Warning: Iddif = %g is negative.", B4SOIiddif);

            if (B4SOIisrec < 0.0)
                $strobe("Warning: Isrec = %g is negative.", B4SOIisrec);
            if (B4SOIidrec < 0.0)
                $strobe("Warning: Idrec = %g is negative.", B4SOIidrec);

            if (B4SOIistun < 0.0)
                $strobe("Warning: Istun = %g is negative.", B4SOIistun);
            if (B4SOIidtun < 0.0)
                $strobe("Warning: Idtun = %g is negative.", B4SOIidtun);

            if (B4SOItt < 0.0)
                $strobe("Warning: Tt = %g is negative.", B4SOItt);

            if (B4SOIcsdmin < 0.0)
                $strobe("Warning: Csdmin = %g is negative.", B4SOIcsdmin);

            if (B4SOIcsdesw < 0.0)
                $strobe("Warning: Csdesw = %g is negative.", B4SOIcsdesw);

            if (B4SOIrth0 < 0.0)
                $strobe("Warning: Rth0 = %g is negative.", B4SOIrth0);
            if (B4SOIcth0 < 0.0)
                $strobe("Warning: Cth0 = %g is negative.", B4SOIcth0);
            if (B4SOIwth0 < 0.0)
                $strobe("Warning:  Wth0 = %g is negative.", B4SOIwth0);

            if (B4SOIrbody < 0.0)
                $strobe("Warning: Rbody = %g is negative.", B4SOIrbody);
            if (B4SOIrbsh < 0.0)
                $strobe("Warning: Rbsh = %g is negative.", B4SOIrbsh);
            if (B4SOIrhalo < 0.0)
                $strobe("Warning:  Rhalo = %g is negative.", B4SOIrhalo);

            if (B4SOIntox < 0.0)
                $strobe("Warning:  Ntox = %g is negative.", B4SOIntox);

            if (B4SOIebg < 0.0)
                $strobe("Warning:  Ebg = %g is negative.", B4SOIebg);
            if (B4SOIvevb < 0.0)
                $strobe("Warning:  Vevb = %g is negative.", B4SOIvevb);
            if (pParam_B4SOIalphaGB1 < 0.0)
                $strobe("Warning:  AlphaGB1 = %g is negative.", pParam_B4SOIalphaGB1);
            if (pParam_B4SOIbetaGB1 < 0.0)
                $strobe("Warning:  BetaGB1 = %g is negative.", pParam_B4SOIbetaGB1);
            if (B4SOIvgb1 < 0.0)
                $strobe("Warning:  Vgb1 = %g is negative.", B4SOIvgb1);
            if (B4SOIvecb < 0.0)
                $strobe("Warning:  Vecb = %g is negative.", B4SOIvecb);
            if (pParam_B4SOIalphaGB2 < 0.0)
                $strobe("Warning:  AlphaGB2 = %g is negative.", pParam_B4SOIalphaGB2);
            if (pParam_B4SOIbetaGB2 < 0.0)
                $strobe("Warning:  BetaGB2 = %g is negative.", pParam_B4SOIbetaGB2);
            if (B4SOIvgb2 < 0.0)
                $strobe("Warning:  Vgb2 = %g is negative.", B4SOIvgb2);

            if (B4SOIvoxh < 0.0)
                $strobe("Warning:  Voxh = %g is negative.", B4SOIvoxh);
            if (B4SOIdeltavox <= 0.0)
                $strobe("Fatal: Deltavox = %g is not positive.", B4SOIdeltavox);

            if (B4SOIk1w1 < 0.0)
                $strobe("Warning:  K1w1 = %g is negative.", B4SOIk1w1);
            if (B4SOIk1w2 < 0.0)
                $strobe("Warning:  K1w2 = %g is negative.", B4SOIk1w2);
            if (B4SOIketas < 0.0)
                $strobe("Warning:  Ketas = %g is negative.", B4SOIketas);
            if (B4SOIdwbc < 0.0)
                $strobe("Warning:  Dwbc = %g is negative.", B4SOIdwbc);
            if (B4SOIbeta0 < 0.0)
                $strobe("Warning:  Beta0 = %g is negative.", B4SOIbeta0);
            if (B4SOIbeta1 < 0.0)
                $strobe("Warning:  Beta1 = %g is negative.", B4SOIbeta1);
            if (B4SOIbeta2 < 0.0)
                $strobe("Warning:  Beta2 = %g is negative.", B4SOIbeta2);
            if (B4SOIlii < 0.0)
                $strobe("Warning:  Lii = %g is negative.", B4SOIlii);
            if (B4SOIsii1 < 0.0)
                $strobe("Warning:  Sii1 = %g is negative.", B4SOIsii1);
            if (B4SOIsii2 < 0.0)
                $strobe("Warning:  Sii2 = %g is negative.", B4SOIsii2);
            if (B4SOIsiid < 0.0)
                $strobe("Warning:  Siid = %g is negative.", B4SOIsiid);
            if (B4SOIfbjtii < 0.0)
                $strobe("Warning:  fbjtii = %g is negative.", B4SOIfbjtii);
            if (B4SOIvrec0 < 0.0)
                $strobe("Warning:  Vrec0s = %g is negative.", B4SOIvrec0);
            if (B4SOIvrec0d < 0.0)
                $strobe("Warning:  Vrec0d = %g is negative.", B4SOIvrec0d);
            if (B4SOIvtun0 < 0.0)
                $strobe("Warning:  Vtun0s = %g is negative.", B4SOIvtun0);
            if (B4SOIvtun0d < 0.0)
                $strobe("Warning:  Vtun0d = %g is negative.", B4SOIvtun0d);
            if (B4SOInbjt < 0.0)
                $strobe("Warning:  Nbjt = %g is negative.", B4SOInbjt);
            if (B4SOIaely < 0.0)
                $strobe("Warning:  Aely = %g is negative.", B4SOIaely);
            if (B4SOIahli < 0.0)
                $strobe("Warning:  Ahlis = %g is negative.", B4SOIahli);
            if (B4SOIahlid < 0.0)
                $strobe("Warning:  Ahlid = %g is negative.", B4SOIahlid);

            if ((B4SOIacde < 0.1) || (B4SOIacde > 1.6))
                $strobe("Warning:  Acde = %g is out of range.", B4SOIacde);
            if ((B4SOImoin < 5.0)||(B4SOImoin > 25.0))
                $strobe("Warning:  Moin = %g is out of range.", B4SOImoin);
            if (B4SOIdlbg < 0.0)
                $strobe("Warning:  dlbg = %g is negative.", B4SOIdlbg);

            if (B4SOIagidl < 0.0)
                $strobe("Warning:  Agidl = %g is negative.", B4SOIagidl);
            if (B4SOIbgidl < 0.0)
                $strobe("Warning:  Bgidl = %g is negative.", B4SOIbgidl);
            if (abs(B4SOIcgidl) < 1e-9)
                $strobe("Warning:  Cgidl = %g is smaller than 1e-9.", B4SOIcgidl);
            if (B4SOIegidl < 0.0)
                $strobe("Warning:  Egidl = %g is negative.", B4SOIegidl);

            if (B4SOIagisl < 0.0)
                $strobe("Warning:  Agidl = %g is negative.", B4SOIagidl);
            if (B4SOIbgisl < 0.0)
                $strobe("Warning:  Bgisl = %g is negative.", B4SOIbgisl);
            if (abs(B4SOIcgisl) < 1e-9)
                $strobe("Warning:  Cgisl = %g is smaller than 1e-9.", B4SOIcgisl);
            if (B4SOIegisl < 0.0)
                $strobe("Warning:  Egisl = %g is negative.", B4SOIegisl);

            if (B4SOIesatii < 0.0)
                $strobe("Warning: Esatii = %g is negative.", B4SOIesatii);

            if (pParam_B4SOIxj > B4SOItsi)
                $strobe("Warning: Xj = %g is thicker than Tsi = %g.",
                    pParam_B4SOIxj, B4SOItsi);

        end // } PARAMCHK

        if (Fatal_Flag)
            $finish(0);

    end // b4soi_check // }


    /*  Calculate temperature dependent values for self-heating effect  */
   // For Xyce, we copy out what BSIM-SOI 4.6.1 does
`ifndef __XYCE__
    if ((SHMOD == 1) && (RTH0 != 0.0))
        delTemp = Temp(t);
    else
        delTemp = 0;
`else // __XYCE__
 `ifdef PORT_CONNECTED
   if ((SHMOD ==1) && (RTH0 !=0.0)) begin
      if (TNODEOUT && !$port_connected(t)) begin
         if ($port_connected(b)) begin       //last terminal is 'b'
            delTemp = V(b);
         end else if ($port_connected(p)) begin      //last terminal is 'p'
            delTemp = V(p);
         end else begin      // 4-terminal mode ('t' is internal)
            delTemp = Temp(t);
         end
      end else begin
         delTemp = Temp(t);
      end
   end else begin
      delTemp = 0;
   end
 `else
   if ((SHMOD == 1) && (RTH0 != 0.0))
     delTemp = Temp(t);
   else
     delTemp = 0;
 `endif // PORT_CONNECTED
`endif // __XYCE__

`ifdef __XYCE__
    DevTemp = $temperature + DTEMP;
`endif
    DevTemp = delTemp + DevTemp;
    TempRatio = DevTemp / B4SOItnom;
    /* TempRatio used for Vth and mobility */
    TempRatioMinus1 = DevTemp / B4SOItnom - 1.0;
    
    B4SOITempSH = DevTemp;          /*v4.2 added for portability of SH Temp */

    begin : load // {
        real VgstNVt, ExpVgst;
        real arg;
        real Vfbeff, V3, V4;
        real PhiBSWG, MJSWG;
        real vbd, vbs, vds, vgd, vgs;
        real Vds, Vgs, Vbs;
        real Vgs_eff, Vfb;
        real Phis, sqrtPhis, Vth;
        real Vgst;
        real n, Vtm;
        real ExpArg, V0;
        real ueff, Esat, Vdsat, EsatL;
        real Va, Vasat;
        real Vbseff;
        real CoxWL;
        real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
        real dT2_dVg, dT3_dVb;
        real tmp, Abulk, Abulk0;
        real VACLM, VADIBL;
        real Xdep, lt1, ltw;
        real Delt_vth;
        real Theta0;
        real tmp1, tmp2, tmp3, tmp4;
        real DIBL_Sft, Lambda;

        real Vgsteff, Vdseff, VdseffCV;
        real diffVds;
        real dAbulk_dVg;
        real beta, gche, fgche1, fgche2;
        real Idl, Ids;
        real CoxWovL;
        real Rds, WVCox, WVCoxRds;
        real Vgst2Vtm, VdsatCV;
        real Leff, Weff;
        real AbulkCV;
        real qgdo, qgso;

        real ves, ved, vbp;
        real Vbd, Ves, Vesfb, DeltVthtemp;
        real DeltVthw;
        real Igidl, Igisl;
        real Ibp, Iii;
        real qjd, qjs;
        real ni, Eg, Cbox, CboxWL;
        real qinv, qgate, qbody, qdrn, qsrc, qsub;
        real Vdsatii;
        real Ibd1, Ibd2, Ibd3, Ibd4;
        real Ibs1, Ibs2, Ibs3, Ibs4;
        real WTsi, NVtm1, NVtm2;
        real Ic, Ibs, Ibd;
        real Denomi;
        real Qsub0, Qac0, Qe1;

        /*  for self-heating  */
        real vbi, vfbb, phi, sqrtPhi, Xdep0, u0temp, vsattemp;
        real jdifs, jdifd;
        real jbjts, jbjtd;
        real jrecs, jrecd;
        real jtuns, jtund;
        real rds0, ua, ub, uc;
        real rho, rho_ref, ku0temp; /* v4.0 */

        /* v2.0 release */
        real Vbsh;
        real sqrtPhisExt;
        real T13, T14;
        real Vdsatii0;
        real VgsStep, Ratio;
        real Vdiff;
        real NVtmf, NVtmr;
        real Ahlis, Ahlid;
        real WsTsi, WdTsi;
        real cjsbs, cjdbs, dcjdbs_dT, dcjsbs_dT, dPhiBSWG_dT;
        real CoxWLb, CoxWLcenb;
        real ExpVbsNVtm, ExpVbdNVtm;
        real Ien, Iendif;
        real Ibsdif, Ibddif;
        real Ehlis, Ehlid;
        real EhlisFactor, EhlidFactor;
        real E2ndFactor;
        real DioMax;
        real wdios, wdiod;

        /* for capMod3 */
        real Cox, Tox, Tcen, LINK, Ccen, Coxeff;
        real CoxWLcen, DeltaPhi;
        real qinoi, qbulk;
        real T3zb, lt1zb, ltwzb, Theta0zb;
        real Delt_vthzb;
        real DeltVthwzb;
        real DeltVthtempzb;
        real Vthzb, Vfbzb;

        /* v3.2 */
        real noff;

        /* v3.1 added for RF */
        real vgms, vgmd;

        /* v3.0 */
        real Igc, Igs, Igd, Igcs, Igcd;
        real vgs_eff, vgd_eff;
        real VxNVt, ExpVxNVt;

        /* v3.0 */
        real Vbsitf, Vbs0, Vbs0mos, Vbsmos;
        real PhiON, PhiFD, Vbs0t, VthFD;
        real VtgsFD, ExpVtgsFD, VgstFD, ExpVgstFD;
        real VtgseffFD, VgsteffFD;
        
        /*New Variables due to introduction of ETA0CV and ETABCV by Pankaj in May 2012*/ 
        
        real Vbseff_CV;  
        real Vbsh_CV;
        real Vbsitf_CV, Vbs0_CV,Vbsmos_CV;
        real PhiON_CV, PhiFD_CV, Vbs0t_CV, VthFD_CV; 
        real Phis_CV, sqrtPhis_CV, Xdep_CV; 
        real lt1_CV, ltw_CV;
        real Theta0_CV, n_CV; 
        real VtgsFD_CV, ExpVtgsFD_CV, VgstFD_CV, ExpVgstFD_CV; 
        real VtgseffFD_CV, VgsteffFD_CV;
        real tmp2_CV; 
        real Delt_vth_CV, DeltVthw_CV, DeltVthtemp_CV, DIBL_Sft_CV, DITS_Sft_CV; 
        real sqrtPhisExt_CV;
        real Vth_CV, VTH_CV; 
        real Abulk0_CV;  


        /* v2.2 release */
        real Vgb, Vox;
        real OxideRatio, Vaux;
        real Igb;
        real Voxeff, Voxacc, Voxdepinv;
        real Igb1, Igb2;

        /* v4.0 */
        real IdlovVdseff, IdovVds;
        real vsbs, vdbd;
        real Lpe_Vb; /* v4.0 for Vth */
        real DITS_Sft, DITS_Sft2;
        real FP;
        real VADITS; /* for DITS */
        real PowWeffWr, rd0, rs0, rdwmin, rswmin, Rd, Rs;
        /*4.1*/
        real Tnom, Eg0, Vtm0;
        real Vbci, Idsmosfet, Iiibjt;
        real VgsteffVth;
        /* v4.1 */
        /* Jun 09 */
        real toxe_mob ;
        /* Jun 09 */

        real Vgd, Vgd_eff;
        real Ig_agbcp2;
        real vgp_eff, vgp;

        /* improved body contact charge model */
        real CoxWL2, CoxWLb2;
        real ExpVgst2, Vgsteff2, VgstNVt2, ExpArg2;
        real T02, T22;
        real Qac02, Qsub02;
        real Vgs_eff2;
        real Vfbzb2, Vfb2, Vfbeff2, VdsatCV2, VdseffCV2;
        real Tcen2, Ccen2, Coxeff2, CoxWLcen2, CoxWLcenb2;
        real DeltaPhi2;
        real qsrc2, qbulk2;
        real DELTA_3_SOI2;
        real cdep0, theta0vb0, thetaRout;
        real agidl, bgidl, cgidl, egidl, rgidl, kgidl, fgidl;
        real agisl, bgisl, cgisl, egisl, rgisl, kgisl, fgisl;
        real ucs, ud;

        // initialization to prevent hidden state warnings
        // variables used and set for B4SOIagbcp2 > 0
        Coxeff2 = 0; CoxWLcen2 = 0; CoxWLcenb2 = 0;
        DeltaPhi2 = 0;
        Tcen2 = 0;
        T02 = 0; T12 = 0; T22 = 0;
        VdseffCV2 = 0;
        Vfb2 = 0;
        Vfbeff2 = 0;
        Vfbzb2 = 0;
        Vgsteff2 = 0;

        // rdsmod
        rds0 = pParam_B4SOIrds0;
        rd0 = pParam_B4SOIrd0;
        rs0 = pParam_B4SOIrs0;
        rdwmin = pParam_B4SOIrdwmin;
        rswmin = pParam_B4SOIrswmin;
        
         
        if ((SHMOD == 1) && (RTH0 != 0.0)) begin // {
            if (B4SOImtrlMod == 0) begin // {
                Vtm = `KboQ * DevTemp;

                T0 = 1108.0 + DevTemp;
                T5 = DevTemp * DevTemp;
                Eg = 1.16 - 7.02e-4 * T5 / T0;

                T2 = 1.9230584e-4;  /*  T2 = 1 / 300.15^(3/2)  */
                T5 = sqrt(DevTemp);
                T3 = 1.45e10 * DevTemp * T5 * T2;
                
                /*T4 = exp(21.5565981 - Eg / (2.0 * Vtm)) is limited at extremely low temperature by Pankaj in May 2012*/

                T6=21.5565981 - Eg / (2.0 * Vtm);
                if (T6 >-`EXPL_THRESHOLD) 
                    T4 = exp(T6);    
                else
                    T4=exp(-`EXPL_THRESHOLD);  
                
 
                ni = T3 * T4;

                T0 = ln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
                vbi = Vtm * T0;
            end else begin // }{
                Tnom = B4SOItnom;
                Vtm  = `KboQ * DevTemp;
                Vtm0 = `KboQ * Tnom;

                Eg0 = B4SOIeg0;
                Eg = B4SOIbg0sub - B4SOItbgasub * DevTemp * DevTemp
                    / (DevTemp + B4SOItbgbsub);

                T2 = 1/sqrt(Tnom*Tnom*Tnom);
                T5 = sqrt(DevTemp);
                T3 = B4SOIni0sub * DevTemp * T5 * T2;
                T4 = exp(Eg0/(2.0*Vtm0) - Eg / (2.0 * Vtm));
                ni = T3 * T4;

                T0 = ln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
                vbi = Vtm * T0;
            end // }

            if (pParam_B4SOInsub > 0) begin
                T0 = ln(pParam_B4SOInpeak / pParam_B4SOInsub);
                vfbb = -B4SOItype * Vtm * T0;
            end else begin
                T0 = ln(-pParam_B4SOInpeak * pParam_B4SOInsub / ni / ni);
                vfbb = -B4SOItype * Vtm * T0;
            end

            /* V4.0 changed phi */
            phi = 2.0 * Vtm * ln(pParam_B4SOInpeak / ni);
            sqrtPhi = sqrt(phi);
            Xdep0 = sqrt(2.0 * epssub / (`Charge_q
                    * pParam_B4SOInpeak * 1.0e6))
                    * sqrtPhi;

            /* cdep0 = sqrt(`Charge_q * `EPSSI
                    * pParam_B4SOInpeak * 1.0e6 / 2.0) / sqrtPhi;    */   /* Bug fix #2 Jun 09 Body type is generalized for mtrlMod 1*/
            cdep0 = sqrt(`Charge_q * epssub                                    /* Fix */
                    * pParam_B4SOInpeak * 1.0e6 / 2.0) / sqrtPhi;

            /* T1 = sqrt(`EPSSI / (B4SOIepsrox * `EPSOX / 3.9)       */   /* Bug fix #3 Jun 09 Body type is generalized for mtrlMod 1*/
            /*  * B4SOItox * Xdep0); */

            T1 = sqrt(epssub / (epsrox * `EPS0)                                /* Fix */
                    * toxe * Xdep0);
            T0 = exp(-0.5 * pParam_B4SOIdsub * pParam_B4SOIleff / T1);
            theta0vb0 = (T0 + 2.0 * T0 * T0);
            T0 = exp(-0.5 * pParam_B4SOIdrout * pParam_B4SOIleff / T1);
            T2 = (T0 + 2.0 * T0 * T0);
            thetaRout = pParam_B4SOIpdibl1 * T2 + pParam_B4SOIpdibl2;

            /*  Save the values below for phi calculation in B4SOIaccept()  */
            B4SOIvtm = Vtm;

            T3 = TempRatio - 1.0;
            T4 = `Eg300 / Vtm * T3;

            T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndiode;
            `DEXP(T7, T0)

            if (pParam_B4SOIxbjt == pParam_B4SOIxdif) begin
                T1 = T0;
            end else begin
                T7 = pParam_B4SOIxdif * T4 / pParam_B4SOIndiode;
                `DEXP(T7, T1)
            end

            T7 = pParam_B4SOIxrec * T4 / pParam_B4SOInrecf0;
            `DEXP(T7, T2)

            Ahlis = pParam_B4SOIahli * T0; /* high level injection */
            jbjts = pParam_B4SOIisbjt * T0;
            jdifs = pParam_B4SOIisdif * T1;
            jrecs = pParam_B4SOIisrec * T2;

            T7 = pParam_B4SOIxtun * T3;
            `DEXP(T7, T0)
            jtuns = pParam_B4SOIistun * T0;

            /* drain side */
            T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndioded;
            `DEXP(T7, T0)

            if (pParam_B4SOIxbjt == pParam_B4SOIxdifd) begin
                T1 = T0;
            end else begin
                T7 = pParam_B4SOIxdifd * T4 / pParam_B4SOIndioded;
                `DEXP(T7, T1)
            end

            T7 = pParam_B4SOIxrecd * T4 / pParam_B4SOInrecf0d;
            `DEXP(T7, T2)

            Ahlid = pParam_B4SOIahlid * T0; /* high level injection */
            jbjtd = pParam_B4SOIidbjt * T0;
            jdifd = pParam_B4SOIiddif * T1;
            jrecd = pParam_B4SOIidrec * T2;

            T7 = pParam_B4SOIxtund * T3;
            `DEXP(T7, T0)
            jtund = pParam_B4SOIidtun * T0;

            u0temp = pParam_B4SOIu0 * pow(TempRatio, pParam_B4SOIute);
            if (VERSION < 4.2) // backwards compatibility
                ku0temp = pParam_B4SOIku0 * (1.0 + B4SOItku0 * TempRatio) + `DELTA_;
            else
                ku0temp = pParam_B4SOIku0 * (1.0 + B4SOItku0 * T3) + `DELTA_;
            T7 = B4SOIku0 * pParam_B4SOIinv_od_ref;
            rho_ref = T7 / ku0temp;
            T4 = B4SOIku0 * B4SOIInv_ODeff;
            rho = T4 / ku0temp;
            T2 = (1.0 + rho);
            T7 = (1.0 + rho_ref);
            T0 = T2 / T7;
            u0temp = u0temp * T0;

            vsattemp = pParam_B4SOIvsat - pParam_B4SOIat * T3;
            T2 = (1.0 + B4SOIkvsat * rho);
            T7 = (1.0 + B4SOIkvsat * rho_ref);
            T0 = T2 / T7;
            vsattemp = vsattemp * T0;

            if (!B4SOIrdsMod) begin
                rds0 = (pParam_B4SOIrdsw + pParam_B4SOIprt * T3)
                        / pParam_B4SOIrds0denom;
            end else begin /* v4.0 */
                PowWeffWr = pParam_B4SOIrds0denom * B4SOInf;
                T10 = pParam_B4SOIprt * T3;

                /* External Rd(V) */
                T1 = pParam_B4SOIrdw + T10;
                T2 = B4SOIrdwmin + T10;
                rd0 = T1 / PowWeffWr;
                rdwmin = T2 / PowWeffWr;

                /* External Rs(V) */
                T7 = pParam_B4SOIrsw + T10;
                T4 = B4SOIrswmin + T10;
                rs0 = T7 / PowWeffWr;
                rswmin = T4 / PowWeffWr;
            end

            ua = pParam_B4SOIuatemp + pParam_B4SOIua1 * T3;
            ub = pParam_B4SOIubtemp + pParam_B4SOIub1 * T3;
            uc = pParam_B4SOIuctemp + pParam_B4SOIuc1 * T3;

        end else begin // }{

            vbi = pParam_B4SOIvbi;
            vfbb = pParam_B4SOIvfbb;
            phi = pParam_B4SOIphi;
            sqrtPhi = pParam_B4SOIsqrtPhi;
            Xdep0 = pParam_B4SOIXdep0;
            /* Eg = B4SOIeg0; */                          /* Bug fix #11 Jun 09 'Eg is evaluated at DevTemp, not Tnom' */
            Eg = B4SOIeg;                                /* 'B4SOIeg' computed in b4soitemp.c */
            /* v4.1 */                                        /* Since selfheat=0, using Eg from b4soitemp.c*/
            cdep0 = pParam_B4SOIcdep0;
            theta0vb0 = pParam_B4SOItheta0vb0;
            thetaRout = pParam_B4SOIthetaRout;

            jbjts = pParam_B4SOIjbjts;    /* v4.0 */
            jbjtd = pParam_B4SOIjbjtd;
            jdifs = pParam_B4SOIjdifs;
            jdifd = pParam_B4SOIjdifd;
            jrecs = pParam_B4SOIjrecs;
            jrecd = pParam_B4SOIjrecd;
            jtuns = pParam_B4SOIjtuns;
            jtund = pParam_B4SOIjtund;

            /* v2.2.2 bug fix */
            Ahlis = pParam_B4SOIahli0s;
            Ahlid = pParam_B4SOIahli0d;

            u0temp = here_B4SOIu0temp;
            vsattemp = here_B4SOIvsattemp;
            ua = pParam_B4SOIua;
            ub = pParam_B4SOIub;
            uc = pParam_B4SOIuc;
        end // }
        
        if ($param_given(K1) || $param_given(K2)) begin // {
            if (!$param_given(K1)) begin
                $strobe( "Warning: k1 should be specified with k2.");
                pParam_B4SOIk1 = 0.53;
            end
            if (!$param_given(K2)) begin
                $strobe( "Warning: k2 should be specified with k1.");
                pParam_B4SOIk2 = -0.0186;
            end
            if ($param_given(XT))
                $strobe( "Warning: xt is ignored because k1 or k2 is given.");
            if ($param_given(VBX))
                $strobe( "Warning: vbx is ignored because k1 or k2 is given.");
            if ($param_given(VBM))
                $strobe( "Warning: vbm is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA1))
                $strobe( "Warning: gamma1 is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA2))
                $strobe( "Warning: gamma2 is ignored because k1 or k2 is given.");
        end else begin // }{
            if (!$param_given(VBX)) begin
                if (B4SOImtrlMod)
                    T0 = `Charge_q / (2.0 * epssub) * 1.0e6;
                else
                    T0 = 7.7348e-4; /* constant from v4.3.0 and earlier */
                pParam_B4SOIvbx = phi - T0 * pParam_B4SOInpeak
                                             * pParam_B4SOIxt * pParam_B4SOIxt;
            end
            if (pParam_B4SOIvbx > 0.0)
                pParam_B4SOIvbx = -pParam_B4SOIvbx;
            if (pParam_B4SOIvbm > 0.0)
                pParam_B4SOIvbm = -pParam_B4SOIvbm;

            if (!$param_given(GAMMA1))
                pParam_B4SOIgamma1 = sqrt2qeps * sqrt(pParam_B4SOInpeak) / B4SOIcox;

            if (!$param_given(GAMMA2))
                pParam_B4SOIgamma2 = sqrt2qeps * sqrt(pParam_B4SOInsub) / B4SOIcox;

            T0 = pParam_B4SOIgamma1 - pParam_B4SOIgamma2;
            T1 = sqrt(phi - pParam_B4SOIvbx) - sqrtPhi;
            T2 = sqrtPhi * (sqrt(phi - pParam_B4SOIvbm)- sqrtPhi);
            T3= T0 * T1 / (2.0 * T2 + pParam_B4SOIvbm);
            here_B4SOIk2=here_B4SOIk2-pParam_B4SOIk2 + T3;
            pParam_B4SOIk1 = pParam_B4SOIgamma2 - 2.0
                                * here_B4SOIk2 * sqrt(phi - pParam_B4SOIvbm);
        end // }

        T0 = pParam_B4SOIweff + pParam_B4SOIk1w2;
        if (T0 < 1e-8)
            T0 = 1e-8;
        pParam_B4SOIk1eff = pParam_B4SOIk1 * (1 + pParam_B4SOIk1w1/T0);

        /* v4.1 */
     
         if (!$param_given(VFB)) begin
            if ($param_given(VTH0) || $param_given(VTHO)) begin
                    here_B4SOIvfb = here_B4SOIvfb - pParam_B4SOIvfb + B4SOItype * here_B4SOIvth0 - phi - pParam_B4SOIk1eff* sqrtPhi;
                end else begin
                    here_B4SOIvfb = here_B4SOIvfb;  
                end
         end
       
    
        if (!$param_given(VTH0)) begin
            here_B4SOIvth0= B4SOItype * (here_B4SOIvfb + phi + pParam_B4SOIk1eff*sqrtPhi); 
         end
 
        if (VERSION < 4.2) begin
            // for backwards-compatibility: self-heating temperature-adjusted
            // parameters were not used in actual equations below
            rd0 = pParam_B4SOIrd0;
            rdwmin = pParam_B4SOIrdwmin;
            cdep0 = pParam_B4SOIcdep0;
            theta0vb0 = pParam_B4SOItheta0vb0;
            thetaRout = pParam_B4SOIthetaRout;
            if (B4SOImobMod == 4) begin
                ua = pParam_B4SOIua;
                uc = pParam_B4SOIuc;
            end
        end

        vds  = B4SOItype * V(di,si);
        vbs  = B4SOItype * V(b, si);
        vgs  = B4SOItype * V(gi,si);
        ves  = B4SOItype * V(e, si);
        vbp  = B4SOItype * V(b, p);
        vgp  = B4SOItype * V(gi,p);
        vsbs = B4SOItype * V(sb,si);
        vdbd = B4SOItype * V(db,di);
        vgms = B4SOItype * V(gm,si);

        /* determine DC current and derivatives */
        vbd = vbs - vds;
        vgd = vgs - vds;
        ved = ves - vds;

        /* v3.1 added for RF */
        vgmd = vgms - vds;
        /* v3.1 added for RF end */

        if (vds >= 0.0) begin   /* normal mode */
            B4SOImode = 1;
            Vds = vds;
            Vgs = vgs;
            Vbs = vbs;
            Vbd = vbd;
            Ves = ves;
            Vgd = vgd;

            wdios = pParam_B4SOIwdios;
            wdiod = pParam_B4SOIwdiod;

            agidl = pParam_B4SOIagidl;
            bgidl = pParam_B4SOIbgidl;
            cgidl = pParam_B4SOIcgidl;
            egidl = pParam_B4SOIegidl;
            rgidl = pParam_B4SOIrgidl;
            kgidl = pParam_B4SOIkgidl;
            fgidl = pParam_B4SOIfgidl;

            agisl = pParam_B4SOIagisl;
            bgisl = pParam_B4SOIbgisl;
            cgisl = pParam_B4SOIcgisl;
            egisl = pParam_B4SOIegisl;
            rgisl = pParam_B4SOIrgisl;
            kgisl = pParam_B4SOIkgisl;
            fgisl = pParam_B4SOIfgisl;

        end else begin   /* inverse mode */
            B4SOImode = -1;
            Vds = -vds;
            Vgs = vgd;
            Vbs = vbd;
            Vbd = vbs;
            Ves = ved;
            Vgd = vgs;

            wdios = pParam_B4SOIwdiod;
            wdiod = pParam_B4SOIwdios;

            agidl = pParam_B4SOIagisl;
            bgidl = pParam_B4SOIbgisl;
            cgidl = pParam_B4SOIcgisl;
            egidl = pParam_B4SOIegisl;
            rgidl = pParam_B4SOIrgisl;
            kgidl = pParam_B4SOIkgisl;
            fgidl = pParam_B4SOIfgisl;

            agisl = pParam_B4SOIagidl;
            bgisl = pParam_B4SOIbgidl;
            cgisl = pParam_B4SOIcgidl;
            egisl = pParam_B4SOIegidl;
            rgisl = pParam_B4SOIrgidl;
            kgisl = pParam_B4SOIkgidl;
            fgisl = pParam_B4SOIfgidl;
        end

        Vesfb = Ves - vfbb;
        Cbox = B4SOIcbox;

        /* Poly Gate Si Depletion Effect */
        T0 = here_B4SOIvfb + phi;
        if (B4SOImtrlMod == 0)
            epsgate = epssub;
        else
            epsgate = B4SOIepsrgate * `EPS0;

        if ((pParam_B4SOIngate > 1.0e18) && (pParam_B4SOIngate < 1.0e25)
                && (Vgs > T0)&& (epsgate!=0)) begin
            /* added to avoid the problem caused by ngate */
            T1 = 1.0e6 * `Charge_q * epsgate * pParam_B4SOIngate
                    / (B4SOIcox * B4SOIcox);
            T4 = sqrt(1.0 + 2.0 * (Vgs - T0) / T1);
            T2 = T1 * (T4 - 1.0);
            T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
            T7 = eggdep - T3 - 0.05;
            T6 = sqrt(T7 * T7 + 0.224);
            T5 = eggdep - 0.5 * (T7 + T6);
            Vgs_eff = Vgs - T5;
        end else begin
            Vgs_eff = Vgs;
        end

        if ((pParam_B4SOIngate > 1.0e18) && (pParam_B4SOIngate < 1.0e25)/* Bug fix # 25/26 Vgd_eff defined */
                && (Vgd > T0)&& (epsgate!=0)) begin
            /* added to avoid the problem caused by ngate */
            T1 = 1.0e6 * `Charge_q * epsgate * pParam_B4SOIngate
                    / (B4SOIcox * B4SOIcox);
            T4 = sqrt(1.0 + 2.0 * (Vgd - T0) / T1);
            T2 = T1 * (T4 - 1.0);
            T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
            T7 = eggdep - T3 - 0.05;
            T6 = sqrt(T7 * T7 + 0.224);
            T5 = eggdep - 0.5 * (T7 + T6);
            Vgd_eff = Vgd - T5;
        end else begin
            Vgd_eff = Vgd;
        end

        /* v4.1 for improved BT charge model, no poly depletion  */
        Vgs_eff2 = Vgs;
        /* end v4.1 for improved BT charge model */

        Leff = pParam_B4SOIleff;

        if ((SHMOD == 1) && (RTH0 != 0.0)) begin
            Vtm = `KboQ * DevTemp;
        end else begin
            Vtm = B4SOIvtm;
        end

        V0 = vbi - phi;

        /* begin of v3.0 block addition */
        /* B/S built-in potential lowering calculation */
        if (B4SOIsoiMod == 0) begin /* BSIMPD */ /* v3.2 */ // {
            Vbsmos = Vbs;
			Vbsmos_CV = Vbs;
        end else begin // }{
            /* soiMod = 1 or 2: adding FD module on top of BSIMPD */
            /* prepare Vbs0 & Vbs0mos for VthFD and VthFD_CV calculation */
            if (B4SOIfdMod == 0) begin /* v4.0 */
                T0 = -B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T1 = B4SOIdvbd0 * (exp(0.5*T0) + 2*exp(T0));
                T2 = T1 * (vbi - phi);
                T3 = 0.5 * pParam_B4SOIqsi / B4SOIcsi; /* v3.2 */
                Vbs0t = phi - T3 + B4SOIvbsa + T2;


                T0 = 1 + B4SOIcsi / Cbox;
                T3 = -B4SOIdk2b * pParam_B4SOIleff / pParam_B4SOIlitl;
                T5 = B4SOIk2b * (exp(0.5*T3) + 2*exp(T3));
                T1 = (B4SOIk1b - T5) / T0;
                T2 = T1 * Vesfb;
                T4 = 1.0/(1 + Cbox / B4SOIcsi);
                Vbs0 = T4 * Vbs0t + T2;
                
      
            end else begin
                T0 = 1.0/(B4SOIcsi + Cbox + B4SOIcdsbs);
                T1 = -B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T2 = B4SOIdvbd0 * (exp(0.5*T1) + 2*exp(T1));
                T3 = T2 * (Vds + B4SOIvsce);
                T4 = 0.5 * pParam_B4SOIqsi / B4SOIcsi;
                T5 = B4SOIcsi * T0 * (phi - T4 + B4SOIvbsa);
                T6 = B4SOIcdsbs * T0 * T3;
                Vbs0t = T5 + T6;

                T7 = Cbox * T0 * Vesfb;
                Vbs0 = Vbs0t + T7;
            end

            /* zero field body potential cal. */
            T1 = Vbs0t - Vbs0 - 0.005;
            T2 = sqrt(T1 * T1 + (2.5e-5));
            T3 = 0.5 * (T1 + T2);
            T4 = T3 * B4SOIcsi / pParam_B4SOIqsi; /* v3.2 */
            Vbs0mos = Vbs0 - 0.5 * T3 * T4;

            /* set the upper bound of Vbs0mos to be phi for square root calc. */
            T1 = phi - 0.02;
            T2 = T1 - Vbs0mos - 0.005;
            T3 = sqrt(T2 * T2 + 4.0 * 0.005);
            Vbs0mos = T1 - 0.5 * (T2 + T3);

            /* VthFD and VthFD_CV calculation */
            Phis = phi - Vbs0mos;
            sqrtPhis = sqrt(Phis);

            Xdep = Xdep0 * sqrtPhis / sqrtPhi;

            T3 = sqrt(Xdep);
            T0 = pParam_B4SOIdvt2 * Vbs0mos;
            if (T0 >= - 0.5) begin
                T1 = 1.0 + T0;
            end else begin
                /* Added to avoid any discontinuity problems caused by dvt2 */
                T4 = 1.0 / (3.0 + 8.0 * T0);
                T1 = (1.0 + 3.0 * T0) * T4;
            end
            lt1 = B4SOIfactor1 * T3 * T1;

            T0 = pParam_B4SOIdvt2w * Vbs0mos;
            if (T0 >= - 0.5) begin
                T1 = 1.0 + T0;
            end else begin
                /* Added to avoid any discontinuity problems caused by dvt2w */
                T4 = 1.0 / (3.0 + 8.0 * T0);
                T1 = (1.0 + 3.0 * T0) * T4;
            end
            ltw = B4SOIfactor1 * T3 * T1;

            T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end

            T2 = pParam_B4SOInfactor * epssub / Xdep;
            /* T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbseff
                    + pParam_B4SOIcdscd * Vds;*/
            /* v4.1 */
            T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbs0mos
                    + pParam_B4SOIcdscd * Vds;
            T4 = (T2 + T3 * Theta0 + pParam_B4SOIcit) / B4SOIcox;

            if (T4 >= -0.5) begin
                n = 1.0 + T4;
            end else begin /* avoid  discontinuity problems caused by T4 */
                T0 = 1.0 / (3.0 + 8.0 * T4);
                n = (1.0 + 3.0 * T4) * T0;
            end

            if (pParam_B4SOIdvtp0 > 0.0) begin /* v4.0 */
                T0 = -pParam_B4SOIdvtp1 * Vds;
                if (T0 < -`EXPL_THRESHOLD) begin
                    T2 = `MIN_EXPL;
                end else begin
                    T2 = exp(T0);
                end

                T3 = Leff + pParam_B4SOIdvtp0 * (1.0 + T2);
                T4 = Vtm * ln(Leff / T3);
                DITS_Sft = n * T4;
            end else begin
                DITS_Sft = 0.0;
            end

            B4SOIthetavth = pParam_B4SOIdvt0 * Theta0;
            Delt_vth = B4SOIthetavth * V0;

            T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltw;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                T2 = T1 * (1.0 + 2.0 * T1);
            end

            T0 = pParam_B4SOIdvt0w * T2;
            DeltVthw = T0 * V0;

            T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
            T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff
                    + pParam_B4SOIkt2 * Vbs0mos);

            /* v4.0 */
            /* DeltVthtemp = pParam_B4SOIk1eff * (T0 - 1.0) * sqrtPhi + T1 * TempRatioMinus1; */
            DeltVthtemp = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                            + T1 * TempRatioMinus1;
            /* v4.0 end */

            tmp2 = toxe * phi / (pParam_B4SOIweff + pParam_B4SOIw0);

            T3 = here_B4SOIeta0 + pParam_B4SOIetab * Vbs0mos;/*v4.0*/

            if (T3 < 1.0e-4) begin /* avoid  discontinuity problems caused by etab */
                T9 = 1.0 / (3.0 - 2.0e4 * T3);
                T3 = (2.0e-4 - T3) * T9;
            end
            DIBL_Sft = T3 * theta0vb0 * Vds;

            /* DIBL_Sft_CV due to introduction of ETA0CV and ETABCV */  
            T3 = here_B4SOIeta0cv + pParam_B4SOIetabcv * Vbs0mos;

            if (T3 < 1.0e-4) begin /* avoid  discontinuity problems caused by etabcv */
                T9 = 1.0 / (3.0 - 2.0e4 * T3);
                T3 = (2.0e-4 - T3) * T9;
            end
            DIBL_Sft_CV = T3 * theta0vb0 * Vds;
                
            Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / Leff);

            /* 4.1 */
            T0 = exp(2.0 * pParam_B4SOIdvtp4 * Vds);
            DITS_Sft2 = pParam_B4SOIdvtp2factor * (T0-1) / (T0+1);

            VthFD = B4SOItype * here_B4SOIvth0
                    + (pParam_B4SOIk1ox * sqrtPhis
                    - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                    - here_B4SOIk2ox * Vbs0mos- Delt_vth - DeltVthw
                    + (pParam_B4SOIk3 + pParam_B4SOIk3b * Vbs0mos)
                    * tmp2 + DeltVthtemp - DIBL_Sft - DITS_Sft - DITS_Sft2;
           
            VthFD_CV = B4SOItype * here_B4SOIvth0
                    + (pParam_B4SOIk1ox * sqrtPhis
                    - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                    - here_B4SOIk2ox * Vbs0mos- Delt_vth - DeltVthw
                    + (pParam_B4SOIk3 + pParam_B4SOIk3b * Vbs0mos)
                    * tmp2 + DeltVthtemp - DIBL_Sft_CV - DITS_Sft - DITS_Sft2;
               

            /*VthFD_CV =VthFD + DIBL_Sft -DIBL_Sft_CV;*/
 
            /* VtgseffFD calculation for PhiFD */
            VtgsFD = VthFD - Vgs_eff;
            T10 = B4SOInofffd * Vtm;
            `DEXP((VtgsFD - B4SOIvofffd)/ T10, ExpVtgsFD)
            VtgseffFD = T10 * ln(1.0 + ExpVtgsFD);
            
            /* surface potential modeling at strong inversion: PhiON */
            VgstFD = Vgs_eff - VthFD;
            `DEXP((VgstFD - B4SOIvofffd)/ T10, ExpVgstFD)
            VgsteffFD = T10 * ln(1.0 + ExpVgstFD);

            /* T1 = B4SOImoinFD*pParam_B4SOIk1eff*Vtm*Vtm;  */
            T1 = B4SOImoinFD*pParam_B4SOIk1ox*Vtm*Vtm;
            T2 = VgsteffFD + 2*pParam_B4SOIk1eff*sqrt(phi);
            T0 = 1 + VgsteffFD * T2 / T1;
            PhiON = phi + Vtm * ln(T0) ;
            
           /* surface potential from subthreshold to inversion: PhiFD */
            T0 = B4SOIcox / (B4SOIcox + 1.0/(1.0/B4SOIcsi + 1.0/Cbox));
            PhiFD = PhiON - T0 * VtgseffFD;
            
          /* built-in potential lowering: Vbs0 */
            if (B4SOIfdMod == 0) begin /* v4.0 */
                T0 = -B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T1 = B4SOIdvbd0 * (exp(0.5*T0) + 2*exp(T0));
                T2 = T1 * (vbi - phi);
                T3 = 0.5 * pParam_B4SOIqsi / B4SOIcsi; /* v3.2 */
                Vbs0t = PhiFD - T3 + B4SOIvbsa + T2;
                
                T0 = 1 + B4SOIcsi / Cbox;
                T3 = -B4SOIdk2b * pParam_B4SOIleff / pParam_B4SOIlitl;
                T5 = B4SOIk2b * (exp(0.5*T3) + 2*exp(T3));
                T1 = (B4SOIk1b - T5) / T0;
                T2 = T1 * Vesfb;
                T0 = 1.0/(1 + Cbox / B4SOIcsi);
                Vbs0 = T0 * Vbs0t + T2;
          end else begin
                 /* v4.1 */
                T0 = 1.0/(B4SOIcsi + Cbox + B4SOIcdsbs);
                T1 = -B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T2 = B4SOIdvbd0 * (exp(0.5*T1) + 2*exp(T1));
                T3 = T2 * (Vds + B4SOIvsce);
                T4 = 0.5 * pParam_B4SOIqsi / B4SOIcsi;
                T5 = B4SOIcsi * T0 * (PhiFD - T4 + B4SOIvbsa);
                T6 = B4SOIcdsbs * T0 * T3;
                Vbs0t = T5 + T6;
               
                T7 = Cbox * T0 * Vesfb;
                Vbs0 = Vbs0t + T7;
          end
          
          /* set lower bound of Vbs (from SPICE) to Vbs0: Vbsitf (Vbs at back interface) */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* v3.1 ideal FD: Vbsitf is pinned at Vbs0 */
                Vbsitf = Vbs0 + `OFF_Vbsitf;
                Vbs = Vbs0 + `OFF_Vbsitf;
            end else begin
                /* soiMod = 1 */
                T1 = Vbs - (Vbs0 + `OFF_Vbsitf) - 0.01;
                T2 = sqrt(T1*T1 + 0.0001);
                Vbsitf = (Vbs0 + `OFF_Vbsitf) + 0.5 * (T1 + T2);
            end
            
         /* Based on Vbsitf, calculate zero-field body potential for MOS: Vbsmos */
            T1 = Vbs0t - Vbsitf - 0.005;
            T2 = sqrt(T1 * T1 + (2.5e-5));
            T3 = 0.5 * (T1 + T2);
            T4 = T3 * B4SOIcsi / pParam_B4SOIqsi; /* v3.2 */
            Vbsmos = Vbsitf - 0.5 * T3 * T4;

         /* VtgseffFD_CV, PhiON_CV, PhiFD_CV, Vbs0_CV, Vbsitf_CV, and Vbsmos_CV calculation by Pankaj in May 2012 */       
         
          /* VtgseffFD_CV calculation for PhiFD_CV */
            VtgsFD_CV = VthFD_CV - Vgs_eff;
            T10 = B4SOInofffd * Vtm;
            `DEXP((VtgsFD_CV - B4SOIvofffd)/ T10, ExpVtgsFD_CV)
            VtgseffFD_CV = T10 * ln(1.0 + ExpVtgsFD_CV);
            
          /* surface potential modeling at strong inversion: PhiON_CV */
            VgstFD_CV = Vgs_eff - VthFD_CV;
            `DEXP((VgstFD_CV - B4SOIvofffd)/ T10, ExpVgstFD_CV)
            VgsteffFD_CV = T10 * ln(1.0 + ExpVgstFD_CV);

          /* T1 = B4SOImoinFD*pParam_B4SOIk1eff*Vtm*Vtm;*/ 
            T1 = B4SOImoinFD*pParam_B4SOIk1ox*Vtm*Vtm;
            T2 = VgsteffFD_CV + 2*pParam_B4SOIk1eff*sqrt(phi);
            T0 = 1 + VgsteffFD_CV * T2 / T1;
            PhiON_CV = phi + Vtm * ln(T0) ;
  
          /* surface potential from subthreshold to inversion: PhiFD_CV */
            T0 = B4SOIcox / (B4SOIcox + 1.0/(1.0/B4SOIcsi + 1.0/Cbox));
            PhiFD_CV = PhiON_CV - T0 * VtgseffFD_CV;
             
          /* built-in potential lowering: Vbs0_CV */       
            if (B4SOIfdMod == 0) begin
                T0 = -B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T1 = B4SOIdvbd0 * (exp(0.5*T0) + 2*exp(T0));
                T2 = T1 * (vbi - phi);
                T3 = 0.5 * pParam_B4SOIqsi / B4SOIcsi; /* v3.2 */
                Vbs0t_CV=PhiFD_CV - T3 + B4SOIvbsa + T2;

                T0 = 1 + B4SOIcsi / Cbox;
                T3 = -B4SOIdk2b * pParam_B4SOIleff / pParam_B4SOIlitl;
                T5 = B4SOIk2b * (exp(0.5*T3) + 2*exp(T3));
                T1 = (B4SOIk1b - T5) / T0;
                T2 = T1 * Vesfb;
                T0 = 1.0/(1 + Cbox / B4SOIcsi);
                Vbs0_CV = T0 * Vbs0t_CV + T2; 
            end else begin
                T0 = 1.0/(B4SOIcsi + Cbox + B4SOIcdsbs);
                T1 = -B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T2 = B4SOIdvbd0 * (exp(0.5*T1) + 2*exp(T1));
                T3 = T2 * (Vds + B4SOIvsce);
                T4 = 0.5 * pParam_B4SOIqsi / B4SOIcsi;
                T5 = B4SOIcsi * T0 * (PhiFD_CV - T4 + B4SOIvbsa);
                T6 = B4SOIcdsbs * T0 * T3;
                Vbs0t_CV = T5 + T6;
                T7 = Cbox * T0 * Vesfb;
                Vbs0_CV = Vbs0t_CV + T7;
            end

            
            /* set lower bound of Vbs (from SPICE) to Vbs0_CV: Vbsitf_CV (Vbs at back interface) */
            if (B4SOIsoiMod == 2) begin 
                Vbsitf_CV = Vbs0_CV + `OFF_Vbsitf;
                Vbs = Vbs0_CV + `OFF_Vbsitf;
            end else begin
                /* soiMod = 1 */
                T1 = Vbs - (Vbs0_CV + `OFF_Vbsitf) - 0.01;
                T2 = sqrt(T1*T1 + 0.0001);
                Vbsitf_CV = (Vbs0_CV + `OFF_Vbsitf) + 0.5 * (T1 + T2);
            end
 
            /* Based on Vbsitf_CV, calculate zero-field body potential for MOS: Vbsmos_CV */
            T1 = Vbs0t_CV - Vbsitf_CV - 0.005;
            T2 = sqrt(T1 * T1 + (2.5e-5));
            T3 = 0.5 * (T1 + T2);
            T4 = T3 * B4SOIcsi / pParam_B4SOIqsi; /* v3.2 */
            Vbsmos_CV = Vbsitf_CV - 0.5 * T3 * T4;
            
            /* Vbsmos/Vbsmos_CV should be used in MOS after some limiting (Vbseff) */

        end // }
        /* end of v3.0 block edition */

        /* v3.0 modification */

        /* T2 is Vbsmos limited above Vbsc=-5 */
        T0 = Vbsmos + 5 - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * (-5));
        T2 = (-5) + 0.5 * (T0 + T1);

        /* Vbsh is T2 limited below 1.5 */
        T0 = 1.5;
        T1 = T0 - T2 - 0.002;
        T3 = sqrt(T1 * T1 + 0.008 * T0);
        Vbsh = T0 - 0.5 * (T1 + T3);
        
        /* Vbseff is Vbsh limited to 0.95*phi */
        T0 = 0.95 * phi;
        T1 = T0 - Vbsh - 0.002;
        T2 = sqrt(T1 * T1 + 0.008 * T0);
        Vbseff = T0 - 0.5 * (T1 + T2);
        
        /* Vbsmos_CV, Vbsh_CV, and Vbseff_CV calculation by Pankaj in May 2012 */

        /* T2 is Vbsmos_CV limited above Vbsc=-5 */
        T0 = Vbsmos_CV + 5 - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * (-5));
        T2 = (-5) + 0.5 * (T0 + T1);

        /* Vbsh_CV is T2 limited below 1.5 */
        T0 = 1.5;
        T1 = T0 - T2 - 0.002;
        T3 = sqrt(T1 * T1 + 0.008 * T0);
        Vbsh_CV = T0 - 0.5 * (T1 + T3);

        /* Vbseff_CV is Vbsh_CV limited to 0.95*phi */
        T0 = 0.95 * phi;
        T1 = T0 - Vbsh_CV - 0.002;
        T2 = sqrt(T1 * T1 + 0.008 * T0);
        Vbseff_CV = T0 - 0.5 * (T1 + T2);
        
        /* end of v3.0 modification */

        /* Below all the variables refer to Vbseff */

        Phis = phi - Vbseff;
        sqrtPhis = sqrt(Phis);
        Xdep = Xdep0 * sqrtPhis / sqrtPhi;

        /* Calculate nstar v3.2 */
        B4SOInstar = B4SOIvtm / `Charge_q *
                (B4SOIcox + epssub / Xdep + pParam_B4SOIcit);

        /* Vth Calculation */
        T3 = sqrt(Xdep);

        T0 = pParam_B4SOIdvt2 * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2 */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        lt1 = B4SOIfactor1 * T3 * T1;

        T0 = pParam_B4SOIdvt2w * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2w */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        ltw = B4SOIfactor1 * T3 * T1;

        T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            Theta0 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            Theta0 = T1 * (1.0 + 2.0 * T1);
        end

        /* Calculate n */
        T2 = pParam_B4SOInfactor * epssub / Xdep;
        T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbseff
                + pParam_B4SOIcdscd * Vds;
        T4 = (T2 + T3 * Theta0 + pParam_B4SOIcit) / B4SOIcox;
        if (T4 >= -0.5) begin
            n = 1.0 + T4;
        end else begin
            /* avoid  discontinuity problems caused by T4 */
            T0 = 1.0 / (3.0 + 8.0 * T4);
            n = (1.0 + 3.0 * T4) * T0;
        end

        /* v4.0 DITS */
        if (pParam_B4SOIdvtp0 > 0.0) begin
            T0 = -pParam_B4SOIdvtp1 * Vds;
            if (T0 < -`EXPL_THRESHOLD) begin
                T2 = `MIN_EXPL;
            end else begin
                T2 = exp(T0);
            end

            T3 = Leff + pParam_B4SOIdvtp0 * (1.0 + T2);
            T4 = Vtm * ln(Leff / T3);
            DITS_Sft = n * T4;
        end else begin
            DITS_Sft = 0.0;
        end

        B4SOIthetavth = pParam_B4SOIdvt0 * Theta0;
        Delt_vth = B4SOIthetavth * V0;

        T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltw;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T2 = T1 * (1.0 + 2.0 * T1);
        end

        T0 = pParam_B4SOIdvt0w * T2;
        DeltVthw = T0 * V0;

        T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
        T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff
                + pParam_B4SOIkt2 * Vbseff);
        DeltVthtemp = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                + T1 * TempRatioMinus1; /* v4.0 */

        tmp2 = toxe * phi / (pParam_B4SOIweff + pParam_B4SOIw0);

        T3 = here_B4SOIeta0 + pParam_B4SOIetab * Vbseff;
        if (T3 < 1.0e-4) begin
            /* avoid  discontinuity problems caused by etab */
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end
        DIBL_Sft = T3 * theta0vb0 * Vds;

        Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / Leff);

        T9 =  2.2361 / sqrtPhi;
        sqrtPhisExt = sqrtPhis - T9 * (Vbsh - Vbseff);

        /* 4.1 */
        T0 = exp(2.0 * pParam_B4SOIdvtp4 * Vds);
        DITS_Sft2 = pParam_B4SOIdvtp2factor * (T0-1) / (T0+1);

        Vth = B4SOItype * here_B4SOIvth0
                + (pParam_B4SOIk1ox * sqrtPhisExt
                - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                - here_B4SOIk2ox * Vbseff- Delt_vth - DeltVthw
                +(pParam_B4SOIk3 + pParam_B4SOIk3b * Vbseff) * tmp2
                + DeltVthtemp - DIBL_Sft - DITS_Sft - DITS_Sft2;

        VTH = Vth;
       
       
       /* Calculation of Vth_CV for CV due to introduction of ETA0CV and ETABCV by Pankaj in May2012*/

        Phis_CV = phi - Vbseff_CV;
        sqrtPhis_CV = sqrt(Phis_CV);
        Xdep_CV = Xdep0 * sqrtPhis_CV / sqrtPhi;

        /* Calculate nstar v3.2 */
        B4SOInstar = B4SOIvtm / `Charge_q *
                (B4SOIcox + epssub / Xdep_CV + pParam_B4SOIcit);

        /* Vth_CV Calculation */
        
        T3 = sqrt(Xdep_CV);
        T0 = pParam_B4SOIdvt2 * Vbseff_CV;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2 */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        lt1_CV = B4SOIfactor1 * T3 * T1;

        T0 = pParam_B4SOIdvt2w * Vbseff_CV;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2w */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        ltw_CV = B4SOIfactor1 * T3 * T1;

        T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1_CV;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            Theta0_CV = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            Theta0_CV = T1 * (1.0 + 2.0 * T1);
        end

        /* Calculate n_CV */

        T2 = pParam_B4SOInfactor * epssub / Xdep_CV;
        T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbseff_CV
                + pParam_B4SOIcdscd * Vds;
        T4 = (T2 + T3 * Theta0_CV + pParam_B4SOIcit) / B4SOIcox;
        if (T4 >= -0.5) begin
            n_CV = 1.0 + T4;
        end else begin
            /* avoid  discontinuity problems caused by T4 */
            T0 = 1.0 / (3.0 + 8.0 * T4);
            n_CV = (1.0 + 3.0 * T4) * T0;
        end

        /* v4.0 DITS */
        if (pParam_B4SOIdvtp0 > 0.0) begin
            T0 = -pParam_B4SOIdvtp1 * Vds;
            if (T0 < -`EXPL_THRESHOLD) begin
                T2 = `MIN_EXPL;
            end else begin
                T2 = exp(T0);
            end

            T3 = Leff + pParam_B4SOIdvtp0 * (1.0 + T2);
            T4 = Vtm * ln(Leff / T3);
            DITS_Sft_CV = n_CV * T4;
        end else begin
            DITS_Sft_CV = 0.0;
        end

        B4SOIthetavth = pParam_B4SOIdvt0 * Theta0_CV;
        Delt_vth_CV = B4SOIthetavth * V0;

        T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltw_CV;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T2 = T1 * (1.0 + 2.0 * T1);
        end

        T0 = pParam_B4SOIdvt0w * T2;
        DeltVthw_CV = T0 * V0;

        T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
        T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff
                + pParam_B4SOIkt2 * Vbseff_CV);
        DeltVthtemp_CV = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                + T1 * TempRatioMinus1; /* v4.0 */

        tmp2_CV = toxe * phi / (pParam_B4SOIweff + pParam_B4SOIw0);

        /* Introduction of ETA0CV and ETABCV by Pankaj in May 2012*/  

        T3 = here_B4SOIeta0cv + pParam_B4SOIetabcv * Vbseff_CV;
        if (T3 < 1.0e-4) begin
            /* avoid  discontinuity problems caused by ETABCV */
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end
        DIBL_Sft_CV = T3 * theta0vb0 * Vds;

        Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / Leff);

        T9 =  2.2361 / sqrtPhi;
        sqrtPhisExt_CV = sqrtPhis_CV - T9 * (Vbsh_CV - Vbseff_CV);

        T0 = exp(2.0 * pParam_B4SOIdvtp4 * Vds);
        DITS_Sft2 = pParam_B4SOIdvtp2factor * (T0-1) / (T0+1);

        Vth_CV = B4SOItype * here_B4SOIvth0
                + (pParam_B4SOIk1ox * sqrtPhisExt_CV
                - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                - here_B4SOIk2ox * Vbseff_CV- Delt_vth_CV - DeltVthw_CV
                +(pParam_B4SOIk3 + pParam_B4SOIk3b * Vbseff_CV) * tmp2_CV
                + DeltVthtemp_CV - DIBL_Sft_CV - DITS_Sft_CV - DITS_Sft2;

        VTH_CV = Vth_CV;



        /* dVthzb_dT calculation */
        if ((B4SOIcapMod == 3) && (SHMOD == 1) && (RTH0 != 0.0)) begin
            T3zb = sqrt(Xdep0);
            lt1zb = B4SOIfactor1 * T3zb;
            ltwzb = B4SOIfactor1 * T3zb;

            T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1zb;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                Theta0zb = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                Theta0zb = T1 * (1.0 + 2.0 * T1);
            end
            Delt_vthzb = pParam_B4SOIdvt0 * Theta0zb * V0;

            T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltwzb;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                T2 = T1 * (1.0 + 2.0 * T1);
            end
            T0 = pParam_B4SOIdvt0w * T2;
            DeltVthwzb = T0 * V0;

            T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
            T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff);
            DeltVthtempzb = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                    + T1 * TempRatioMinus1;

            Vthzb = B4SOItype * here_B4SOIvth0
                    - Delt_vthzb - DeltVthwzb + pParam_B4SOIk3 * tmp2_CV
                    + DeltVthtempzb;
        end else
            Vthzb = 0;

        /* Effective Vgst (Vgsteff) Calculation */

        Vgst = Vgs_eff - Vth;

        T10 = n * Vtm; /* v4.0 */
        VgstNVt = pParam_B4SOImstar * Vgst / T10; /* v4.0 */
        ExpArg = (pParam_B4SOIvoff - (1- pParam_B4SOImstar) * Vgst)
                / T10;        /* v4.0 */

        /* MCJ: Very small Vgst */
        if (VgstNVt > `EXPL_THRESHOLD) begin
            Vgsteff = Vgst;
            ExpVgst = 0; // prevent hidden state
        end else if (ExpArg > `EXPL_THRESHOLD) begin
            T0 = (Vgst - pParam_B4SOIvoff) / (n * Vtm);
            ExpVgst = exp(T0);
            Vgsteff = Vtm * cdep0 / B4SOIcox * ExpVgst; /* v4.2 bug fix */
        end else begin
            ExpVgst = exp(VgstNVt);
            T1 = T10 * ln(1.0 + ExpVgst);
            dT2_dVg = -B4SOIcox / (Vtm * cdep0)
                    * exp(ExpArg) * (1 - pParam_B4SOImstar);
            T2 = pParam_B4SOImstar - T10 * dT2_dVg
                    / (1.0 - pParam_B4SOImstar);
            Vgsteff = T1 / T2;
        end
        Vgst2Vtm = Vgsteff + 2.0 * Vtm;
        B4SOIVgsteff = Vgsteff; /* v2.2.3 bug fix */

        /* v4.0 F-factor (degradation factor due to pocket implant) */
        if (pParam_B4SOIfprout <= 0.0) begin
            FP = 1.0;
        end else begin
            T9 = pParam_B4SOIfprout * sqrt(Leff) / Vgst2Vtm;
            FP = 1.0 / (1.0 + T9);
        end

        /* Calculate Effective Channel Geometry */
        T9 = sqrtPhis - sqrtPhi;
        Weff = pParam_B4SOIweff - (2.0 - B4SOInbc)
                * (pParam_B4SOIdwg * Vgsteff + pParam_B4SOIdwb * T9);

        if (Weff < 2.0e-8) begin /* to avoid the discontinuity problem due to Weff*/
            T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
            Weff = 2.0e-8 * (4.0e-8 - Weff) * T0;
        end

        if (B4SOIrdsMod == 1) begin   /* v4.0 */
            Rds = 0.0;
        end else begin
            T0 = pParam_B4SOIprwg * Vgsteff + pParam_B4SOIprwb * T9;
            if (T0 >= -0.9) begin
                Rds = rds0 * (1.0 + T0);
            end else begin
                /* to avoid the discontinuity problem due to prwg and prwb*/
                T1 = 1.0 / (17.0 + 20.0 * T0);
                Rds = rds0 * (0.8 + T0) * T1;
            end
        end
        B4SOIrds = Rds / B4SOInf; /* Fix v4.31 bug in Thermal noise for TNOIMOD=0 */

        /* Calculate Abulk */
        
        if (pParam_B4SOIa0 == 0.0) begin // {
            Abulk = 1.0;
            Abulk0 = 1.0;
        end else begin // }{

            T10 = pParam_B4SOIketa * Vbsh;
            
            /*Old Limting of 1.0/(1.0 + T10) */ 
            /*
             if (T10 >= -0.9) begin
                 T11 = 1.0 / (1.0 + T10);
             end else begin // added to avoid the problems caused by Keta
                 T12 = 1.0 / (0.8 + T10);
                 T11 = (17.0 + 20.0 * T10) * T12;
                
            end
            */   
            
           /*New Limting of 1.0/(1.0 + T10) on May 2012 by Pankaj*/

            if (T10 >=-0.5) begin
                T11 = 1.0 / (1.0 + T10);
            end else begin // added to avoid the problems caused by Keta
                
                T12=-1.0/((1.0 - 0.5)*(1.0 - 0.5));
                T13=1.0/((1.0 - 0.5))+T12*0.5;  
                T11=T12*T10+T13;   
            end
            
            
            /* v3.0 bug fix */
            T10 = phi + pParam_B4SOIketas;

            T13 = (Vbsh * T11) / T10;

          
            
  
            /* limit 1/sqrt(1-T13) to 6, starting at T13=0.96 */
            
            /* 
              if (T13 < 0.96) begin
                T14 = 1 / sqrt(1-T13);
               end else begin
                T11 = 1.0 / (1.0 - 1.0593220339 * T13);
                T14 = (6.0169491525 - 6.3559322034 * T13) * T11;
              end
            */ 
          
          /*New Limting of 1.0/sqrt(1.0 - T13) in May 2012 by Pankaj*/    
          /*Point around which limiting is done may be chnaged*/
           if (T13 < 0.50) begin 
                T14 = 1.0 / sqrt(1.0-T13);
           end else begin
                T11=1.0/(2*(1-0.50)*sqrt(1-0.50));
                T12=(1/sqrt(1.0 - 0.50))-T11*0.50;
                T14=T11*T13+T12; 
           end
       
            T10 = 0.5 * pParam_B4SOIk1ox * Lpe_Vb/ sqrt(phi + pParam_B4SOIketas);     /* v4.0 */
            T1 = T10 * T14;
            T9 = sqrt(pParam_B4SOIxj * Xdep);
            tmp1 = Leff + 2.0 * T9;
            T5 = Leff / tmp1;
            tmp2 = pParam_B4SOIa0 * T5;
            tmp3 = pParam_B4SOIweff + pParam_B4SOIb1;
            tmp4 = pParam_B4SOIb0 / tmp3;
            T2 = tmp2 + tmp4;
            T6 = T5 * T5;
            T7 = T5 * T6;

            Abulk0 = 1 + T1 * T2;
             

            T8 = pParam_B4SOIags * pParam_B4SOIa0 * T7;
            dAbulk_dVg = -T1 * T8;
            Abulk = Abulk0 + dAbulk_dVg * Vgsteff;
        end

        if (Abulk0 < 0.01) begin
            T9 = 1.0 / (3.0 - 200.0 * Abulk0);
            Abulk0 = (0.02 - Abulk0) * T9;
        end

        if (Abulk < 0.01) begin
            T9 = 1.0 / (3.0 - 200.0 * Abulk);
            Abulk = (0.02 - Abulk) * T9;
        end
 
        B4SOIAbulk = Abulk; /*v3.2 for noise */

        /* Calculation of Abulk0_CV by Pankaj in May 2012*/

        if (pParam_B4SOIa0 == 0.0) begin // {
            Abulk0_CV = 1.0;
        end else begin // }{

            T10 = pParam_B4SOIketa * Vbsh_CV;
          
            if (T10 >=-0.5) begin
                T11 = 1.0 / (1.0 + T10);
            end else begin /* added to avoid the problems caused by Keta */
                
                T12=-1.0/((1.0 - 0.5)*(1.0 - 0.5));
                T13=1.0/((1.0 - 0.5))+T12*0.5;  
                T11=T12*T10+T13;   
            end
            
            T10 = phi + pParam_B4SOIketas;
            T13 = (Vbsh_CV * T11) / T10;
    
           if (T13 < 0.50) begin 
                T14 = 1.0 / sqrt(1.0-T13);
           end else begin
                T11=1.0/(2*(1-0.50)*sqrt(1-0.50));
                T12=(1/sqrt(1.0 - 0.50))-T11*0.50;
                T14=T11*T13+T12; 
           end
                       
            T10 = 0.5 * pParam_B4SOIk1ox * Lpe_Vb/ sqrt(phi + pParam_B4SOIketas);     /* v4.0 */
            T1 = T10 * T14;
            T9 = sqrt(pParam_B4SOIxj * Xdep_CV);
            tmp1 = Leff + 2.0 * T9;
            T5 = Leff / tmp1;
            tmp2 = pParam_B4SOIa0 * T5;
            tmp3 = pParam_B4SOIweff + pParam_B4SOIb1;
            tmp4 = pParam_B4SOIb0 / tmp3;
            T2 = tmp2 + tmp4;
            T6 = T5 * T5;
            T7 = T5 * T6;
            Abulk0_CV = 1 + T1 * T2;
            
        end

        if (Abulk0_CV < 0.01) begin
            T9 = 1.0 / (3.0 - 200.0 * Abulk0_CV);
            Abulk0_CV = (0.02 - Abulk0_CV) * T9;
        end

        /* Mobility calculation */
        if (B4SOImtrlMod) begin
            T14 = 2.0 * B4SOItype *(B4SOIphig - B4SOIeasub - 0.5 * Eg + 0.45);
            toxe_mob = B4SOIeot * B4SOIepsrsub / 3.9;            /* Bug fix #4 Jun 09 implementing Eeff correctly*/
        end else begin
            T14 = 0.0;
            toxe_mob = B4SOItox;                                        /* Bug fix #4 Jun 09 implementing Eeff correctly*/
        end
        if (B4SOImobMod == 1) begin
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = ua + uc * Vbseff;
            T3 = T0 / toxe_mob;                                            /* Bug fix #4 Jun 09 implementing Eeff correctly*/
            T5 = T3 * (T2 + ub * T3);
        end else if (B4SOImobMod == 2) begin                                   /* Bug fix #5 Jun 09 implementing Eeff correctly*/
            T5 = (Vgsteff -T14)/ toxe * (ua                                /* MobMod=2 does not use Eeff */
                    + uc * Vbseff + ub * (Vgsteff -T14)                /* 'toxe' keeps code consistent with BSIMSOI4.1 Manual*/
                    / toxe);
        end else if (B4SOImobMod == 3) begin
            /*  mobMod == 3  */
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = 1.0 + uc * Vbseff;
            T3 = T0 / toxe_mob;                                            /* Bug fix #4 Jun 09 implementing Eeff correctly*/
            T4 = T3 * (ua + ub * T3);
            T5 = T4 * T2;
        end else begin
            /*  mobMod == 4  */
            /*universal mobility*/
            T0 = (Vgsteff + B4SOIvtfbphi1)* 1.0e-8 / toxe/6.0;
            T1 = exp(pParam_B4SOIeu * ln(T0));
            T2 = ua + uc * Vbseff;

            /*Coulombic*/
            /* pParam_B4SOIucs = pParam_B4SOIucs * pow(TempRatio, pParam_B4SOIucste);    Bug# 21 Jul09*/
            /* pParam_B4SOIud = pParam_B4SOIud * pow(TempRatio, pParam_B4SOIud1) ;         Bug# 21 Jul09 */
            ucs = pParam_B4SOIucs * pow(TempRatio, pParam_B4SOIucste);
            ud = pParam_B4SOIud * pow(TempRatio, pParam_B4SOIud1) ;
            VgsteffVth = B4SOIvgsteffvth;

            /*T10 = exp(pParam_B4SOIucs * ln(0.5 + 0.5 * Vgsteff/VgsteffVth));*/
            /* T10 = exp(pParam_B4SOIucs * ln(1.0 +  Vgsteff/VgsteffVth));                Bug# 21 Jul09 */
            /* T11 =  pParam_B4SOIud/T10;                                                    Bug# 21 Jul09 */
            T10 = exp(ucs * ln(1.0 +  Vgsteff/VgsteffVth));                    /* Bug Fix # 21 Jul09*/
            T11 = ud/T10;                                                        /* Bug Fix # 21 Jul09*/
            T5 = T1 * T2 + T11;
        end
        if (T5 >= -0.8) begin
            Denomi = 1.0 + T5;
        end else begin
            /* Added to avoid the discontinuity problem caused by ua and ub*/
            T9 = 1.0 / (7.0 + 10.0 * T5);
            Denomi = (0.6 + T5) * T9;
        end

        ueff = u0temp / Denomi;
        B4SOIueff = ueff;

        /* Saturation Drain Voltage  Vdsat */
        WVCox = Weff * vsattemp * B4SOIcox;
        WVCoxRds = WVCox * Rds;

        Esat = 2.0 * vsattemp / ueff;
        EsatL = Esat * Leff;

        /* Sqrt() */
        if (pParam_B4SOIa1 == 0.0) begin
            Lambda = pParam_B4SOIa2;
        end else if (pParam_B4SOIa1 > 0.0) begin
            /* Added to avoid the discontinuity problem caused by a1 and a2 (Lambda) */
            T0 = 1.0 - pParam_B4SOIa2;
            T1 = T0 - pParam_B4SOIa1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * T0);
            Lambda = pParam_B4SOIa2 + T0 - 0.5 * (T1 + T2);
        end else begin
            T1 = pParam_B4SOIa2 + pParam_B4SOIa1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * pParam_B4SOIa2);
            Lambda = 0.5 * (T1 + T2);
        end

        B4SOIAbovVgst2Vtm = Abulk /Vgst2Vtm; /* v2.2.3 bug fix */

        if ((Rds == 0.0) && (Lambda == 1.0)) begin
            T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
            T3 = EsatL * Vgst2Vtm;
            Vdsat = T3 * T0;
        end else begin
            T9 = Abulk * WVCoxRds;
            T7 = Vgst2Vtm * T9;
            T6 = Vgst2Vtm * WVCoxRds;
            T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda);
            T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
            T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
            T3 = sqrt(T1 * T1 - 2.0 * T0 * T2);
            Vdsat = (T1 - T3) / T0;
        end
        VDSAT = Vdsat;

        /* Effective Vds (Vdseff) Calculation */
        T1 = Vdsat - Vds - pParam_B4SOIdelta;
        T2 = sqrt(T1 * T1 + 4.0 * pParam_B4SOIdelta * Vdsat);
        Vdseff = Vdsat - 0.5 * (T1 + T2);

        if (Vdseff > Vds)
            Vdseff = Vds; /* This code is added to fixed the problem
                             caused by computer precision when
                             Vds is very close to Vdseff. */
        diffVds = Vds - Vdseff;
        B4SOIVdseff = Vdseff; /* v2.2.3 bug fix */

        /* Calculate VAsat */
        tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
        T9 = WVCoxRds * Vgsteff;
        T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
        T9 = WVCoxRds * Abulk;
        T1 = 2.0 / Lambda - 1.0 + T9;
        Vasat = T0 / T1;

        /* Calculate VACLM */
        if ((pParam_B4SOIpclm > 0.0) && (diffVds > 1.0e-10)) begin
            T0 = 1.0 / (pParam_B4SOIpclm * Abulk * pParam_B4SOIlitl);
            T2 = Vgsteff / EsatL;
            T1 = Leff * (Abulk + T2);
            T9 = T0 * T1;
            VACLM = T9 * diffVds;
        end else begin
            VACLM = `MAX_EXPL;
        end

        /* Calculate VADIBL */
        if (thetaRout > 0.0) begin
            T8 = Abulk * Vdsat;
            T0 = Vgst2Vtm * T8;
            T1 = Vgst2Vtm + T8;
            T2 = thetaRout;
            VADIBL = (Vgst2Vtm - T0 / T1) / T2;

            T7 = pParam_B4SOIpdiblb * Vbseff;
            if (T7 >= -0.9) begin
                T3 = 1.0 / (1.0 + T7);
                VADIBL = VADIBL * T3;
            end else begin
                /* Added to avoid the discontinuity problem caused by pdiblcb */
                T4 = 1.0 / (0.8 + T7);
                T3 = (17.0 + 20.0 * T7) * T4;
                VADIBL = VADIBL * T3;
            end
        end else begin
            VADIBL = `MAX_EXPL;
        end

        /* v4.0 DITS */
        T0 = pParam_B4SOIpditsd * Vds;
        if (T0 > `EXPL_THRESHOLD) begin
            T1 = `MAX_EXPL;
        end else begin
            T1 = exp(T0);
        end
        if (pParam_B4SOIpdits > `MIN_EXPL) begin
            T2 = 1.0 + B4SOIpditsl * Leff;
            VADITS = (1.0 + T2 * T1) / pParam_B4SOIpdits;
            VADITS = VADITS * FP;
        end else begin
            VADITS = `MAX_EXPL;
        end

        /* Calculate VA */

        T8 = pParam_B4SOIpvag / EsatL;
        T9 = T8 * Vgsteff;
        if (T9 > -0.9) begin
            T0 = 1.0 + T9;
        end else begin
            /* Added to avoid the discontinuity problems caused by pvag */
            T1 = 1.0 / (17.0 + 20.0 * T9);
            T0 = (0.8 + T9) * T1;
        end

        tmp3 = VACLM + VADIBL;
        T1 = VACLM * VADIBL / tmp3;

        /* v4.0 adding DITS */
        tmp3 = T1 + VADITS;
        T2 = T1 * VADITS / tmp3;
        /* v4.0 */
        Va = Vasat + T0 * T2;

        /* Calculate Ids */
        CoxWovL = B4SOIcox * Weff / Leff;
        beta = ueff * CoxWovL;

        T0 = 1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm;
        fgche1 = Vgsteff * T0;

        T9 = Vdseff / EsatL;
        fgche2 = 1.0 + T9;

        gche = beta * fgche1 / fgche2;

        T0 = 1.0 + gche * Rds;
        T9 = Vdseff / T0;
        Idl = gche * T9;
        IdlovVdseff = gche / T0;

        T9 =  diffVds / Va;
        T0 =  1.0 + T9;
        Ids = Idl * T0 / B4SOInseg;

        B4SOIidovVds = IdlovVdseff * T0 / B4SOInseg;
        if (B4SOIidovVds < 1e-9) B4SOIidovVds = 1e-9;
        /* v4.0 bug fix */
        IdovVds = IdlovVdseff * T0 / B4SOInseg; /* v4.0 */

        /* v3.1 */
        if (B4SOIsoiMod != 2) begin /* v3.2 */ // {
            /*  calculate GISL/GIDL current  */
            /*4.1*/
            if (B4SOImtrlMod == 0)
                T0 = 3.0 * 3.9 / epsrox * toxe;
            else
                T0 = B4SOIepsrsub * toxe / epsrox;

            if (B4SOIgidlMod == 0) begin // {
                if (B4SOImtrlMod == 0)
                   T1 = (- Vds - Vgd_eff - egisl) / T0;
                else
                   T1 = (- Vds - Vgd_eff - egisl+pParam_B4SOIvfbsd) / T0;

                /* GISL */
                
                if ((agisl <= 0.0) || (bgisl <= 0.0) ||
                     (cgisl < 0.0)) begin
                     Igisl = 0.0;
                end else begin
                           
                    T1 = hypsmooth(T1, 1.0E-2);    
                    T2 = bgisl / (T1+1.0E-3);
                    Igisl = wdios * agisl * T1 * exp(-T2);
                    
                    T4 = Vbs * Vbs;
                    T5 = -Vbs * T4;
                    T6 = cgisl + abs(T5) + 1.0E-9;
                    T7 = hypsmooth(T5 / T6, 1.0E-6) - 1.0E-6;
                    Igisl = Igisl * T7;
             
                end
                /* End of GISL */

                if (B4SOImtrlMod == 0)
                    T1 = (Vds - Vgs_eff - egidl) / T0;
                else
                    T1 = (Vds - Vgs_eff - egidl+pParam_B4SOIvfbsd) / T0;

                /* GIDL */
                
                if ((agidl <= 0.0) || (bgidl <= 0.0)||
                    (cgidl < 0.0)) begin
                    Igidl = 0.0;
                end else begin
 
                    T1 = hypsmooth(T1, 1.0E-2);    
                    T2 = bgidl / (T1+1.0E-3);
                    Igidl = wdios * agidl * T1 * exp(-T2);
                        
                    T4 = Vbd * Vbd;
                    T5 = -Vbd * T4;
                    T6 = cgidl + abs(T5) + 1.0E-9;
                    T7 = hypsmooth(T5 / T6, 1.0E-6) - 1.0E-6;
                    Igidl = Igidl * T7;
                    
                end
                /* End of GIDL*/

            end else begin // }{
                
                if (B4SOImtrlMod == 0)
                   T1 = (-Vds - rgisl*Vgd_eff - egisl) / T0;         /* Bug # 26 Jul09*/
                else
                   T1 = (-Vds - rgisl*Vgd_eff - egisl+pParam_B4SOIvfbsd) / T0;        /* Bug # 26 Jul09*/

                /* GISL */
                if ((agisl <= 0.0) || (bgisl <= 0.0)||
                    (cgisl < 0.0)  ) begin
                    Igisl = 0.0;
                end else begin
                    T1 = hypsmooth(T1, 1.0E-2);    
                    T2 = bgisl / (T1+1.0E-3);
                    Igisl = wdios * agisl * T1 * exp(-T2);
                    T4 = Vbs - fgisl;
					if (T4 >= -1.0/`EXPL_THRESHOLD)
        				T5 = -kgisl * `EXPL_THRESHOLD;
    				else
        				T5 = kgisl/T4;
    				T6 = exp(T5);                  
                    Igisl = Igisl * T6;

                end
                /* End of GISL */

                if (B4SOImtrlMod == 0)
                    T1 = (Vds - rgidl*Vgs_eff - egidl) / T0;
                else
                    T1 = (Vds - rgidl*Vgs_eff - egidl+pParam_B4SOIvfbsd) / T0;

                /* GIDL */
                if ((agidl <= 0.0) || (bgidl <= 0.0)||
                    (cgidl < 0.0)) begin
                    Igidl = 0.0;
                end else begin
                    T1 = hypsmooth(T1, 1.0E-2);    
                    T2 = bgidl / (T1+1.0E-3);
                    Igidl = wdios * agidl * T1 * exp(-T2);
                    T4 = Vbd - fgidl;
					if (T4 >= -1.0/`EXPL_THRESHOLD)
        				T5 = -kgidl * `EXPL_THRESHOLD;
    				else
        				T5 = kgidl/T4;
    				T6 = exp(T5); 
                    Igidl = Igidl * T6;
                end
                /* End of GIDL */

            end // }

            /* calculate diode and BJT current */
            WsTsi = pParam_B4SOIwdios * B4SOItsi;
            WdTsi = pParam_B4SOIwdiod * B4SOItsi;

            NVtm1 = Vtm * pParam_B4SOIndiode;
            T0 = vsbs / NVtm1; /* v4.0 */
            `DEXP(T0, ExpVbsNVtm)

            NVtm1 = Vtm * pParam_B4SOIndioded; /* v4.0 drain side */
            T0 = vdbd / NVtm1; /* v4.0 */
            `DEXP(T0, ExpVbdNVtm)

            /* Ibs1: diffusion current */
            if (jdifs == 0) begin
                Ibs1 = 0;
            end else begin
                T0 = WsTsi * jdifs;
                Ibs1 = T0 * (ExpVbsNVtm - 1);
            end

            /* Ibd1: diffusion current */
            if (jdifd == 0) begin
                Ibd1 = 0;
            end else begin
                T0 = WdTsi * jdifd;
                Ibd1 = T0 * (ExpVbdNVtm - 1);
            end

            /* Ibs2:recombination/trap-assisted tunneling current */

            if (jrecs == 0) begin
                Ibs2 = 0;
            end else begin
                /* forward bias */
                NVtmf = Vtm00 * pParam_B4SOInrecf0
                        * (1 + pParam_B4SOIntrecf * (TempRatio - 1));
                NVtmr = Vtm00 * pParam_B4SOInrecr0
                        * (1 + pParam_B4SOIntrecr * (TempRatio - 1));
                T0 = vsbs / NVtmf; /* v4.0 */
                `DEXP(T0,T10)

                /* reverse bias */
                if ((pParam_B4SOIvrec0 - vsbs) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vsbs / NVtmr * pParam_B4SOIvrec0 * T1;
                    //T11 = -exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/      
                    `DEXP(T0,T11)           
   		            T11=-T11;
                end else begin
                    T1 = 1 / (pParam_B4SOIvrec0 - vsbs);
                    T0 = -vsbs / NVtmr * pParam_B4SOIvrec0 * T1;
                    `DEXP(T0, T11)
                    T11 = -T11;
                end
                T3 = WsTsi * jrecs;
                Ibs2 = T3 * (T10 + T11);
            end

            if (jrecd == 0) begin
                Ibd2 = 0;
            end else begin
                NVtmf = Vtm00 * pParam_B4SOInrecf0d
                        * (1 + pParam_B4SOIntrecf * (TempRatio - 1));
                NVtmr = Vtm00 * pParam_B4SOInrecr0d
                        * (1 + pParam_B4SOIntrecr * (TempRatio - 1));
                T0 = vdbd / NVtmf;
                `DEXP(T0,T10)

                if ((pParam_B4SOIvrec0d - vdbd) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vdbd / NVtmr * pParam_B4SOIvrec0d * T1;
                    //T11 = -exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/      
                    `DEXP(T0,T11) 
		            T11=-T11;
                end else begin
                    T1 = 1 / (pParam_B4SOIvrec0d - vdbd);
                    T0 = -vdbd / NVtmr * pParam_B4SOIvrec0d * T1;
                    `DEXP(T0, T11)
                    T11 = - T11;
                end
                T3 = WdTsi * jrecd;
                Ibd2 = T3 * (T10 + T11);
            end

            /* Ibs3/Ibd3:  recombination current in neutral body */
            WTsi = pParam_B4SOIweff / B4SOInseg * B4SOItsi;
            if (jbjts == 0.0 && jbjtd == 0.0) begin // {
                Ibs3 = 0.0;
                Ibd3 = 0.0;
                Ibsdif = 0;
                Ibddif = 0;
                Ic = 0.0;
            end else begin // }{
                /* high level injection of source side */
                Ehlis = Ahlis * (ExpVbsNVtm - 1);
                if (Ehlis < 1e-5) begin
                    Ehlis = 0;
                    EhlisFactor = 1;
                end else begin
                    EhlisFactor = 1.0 / sqrt(1 + Ehlis);
                end

                /* high level injection of drain side */
                Ehlid = Ahlid * (ExpVbdNVtm - 1);
                if (Ehlid < 1e-5) begin
                    Ehlid = 0;
                    EhlidFactor = 1;
                end else begin
                    EhlidFactor = 1.0 / sqrt(1 + Ehlid);
                end

                /* v3.1.1 bug fix for Ibjt(L) discontinuity */
                T0 = 1 - pParam_B4SOIarfabjt;

                Ien = WTsi * jbjts * pParam_B4SOIlratio;
                T1 = T0 * Ien;
                Ibs3 = T1 * (ExpVbsNVtm - 1) * EhlisFactor;

                Ien = WTsi * jbjtd * pParam_B4SOIlratio;
                T1 = T0 * Ien;
                Ibd3 = T1 * (ExpVbdNVtm - 1) * EhlidFactor;

                /* effective diffusion current for capacitance calcu. */
                Iendif = WTsi * jbjts * pParam_B4SOIlratiodif;
                Ibsdif = Iendif * (ExpVbsNVtm - 1) * EhlisFactor;

                Iendif = WTsi * jbjtd * pParam_B4SOIlratiodif;
                Ibddif = Iendif * (ExpVbdNVtm - 1) * EhlidFactor;

                /* Ic: Bjt collector current */
                if (B4SOIbjtoff == 1) begin
                    Ic = 0.0;
                end else begin
                    /* second order effects */
                    T0 = 1 + (vsbs + vdbd) / pParam_B4SOIvearly;
                    T1 = Ehlis + Ehlid;
                    T3 = sqrt(T0 * T0 + 4 * T1);
                    T2 = (T0 + T3) / 2.0;
                    if (T2 < 0.1) begin
                        E2ndFactor = 10.0;
                    end else begin
                        E2ndFactor = 1.0 / T2;
                    end

                    T0 = pParam_B4SOIarfabjt * Ien;    /* here Ien refers to the drain side to simplify the code */
                    Ic = T0 * (ExpVbsNVtm - ExpVbdNVtm) * E2ndFactor;
                end
            end // }

            /* Ibs4/Ibd4 : tunneling */
            if (jtuns == 0 && jtund == 0) begin
                Ibd4 = 0;
                Ibs4 = 0;
            end else begin
                NVtm2 = Vtm00 * pParam_B4SOIntun;
                if ((pParam_B4SOIvtun0 - vsbs) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vsbs / NVtm2 * pParam_B4SOIvtun0 * T1;
                    //T1 = exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/      
                    `DEXP(T0,T1) 
                    T3 = WsTsi * jtuns;
                    Ibs4 = T3 * (1- T1);
                end else begin
                    T1 = 1 / (pParam_B4SOIvtun0 - vsbs);
                    T0 = -vsbs / NVtm2 * pParam_B4SOIvtun0 * T1;
                    `DEXP(T0, T1)
                    T3 = WsTsi * jtuns;
                    Ibs4 =  T3 * (1- T1);
                end

                NVtm2 = Vtm00 * pParam_B4SOIntund;
                if ((pParam_B4SOIvtun0d - vdbd) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vdbd / NVtm2 * pParam_B4SOIvtun0d * T1;
                    //T1 = exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/      
                    `DEXP(T0,T1)
                    T3 = WdTsi * jtund;
                    Ibd4 = T3 * (1- T1);
                end else begin
                    T1 = 1 / (pParam_B4SOIvtun0d - vdbd);
                    T0 = -vdbd / NVtm2 * pParam_B4SOIvtun0d * T1;
                    `DEXP(T0, T1)
                    T3 = WdTsi * jtund;
                    Ibd4 =  T3 * (1- T1);
                end
            end

            Ibs = Ibs1 + Ibs2 + Ibs3 + Ibs4;
            Ibd = Ibd1 + Ibd2 + Ibd3 + Ibd4;

        end else begin // }{
            /* v3.1 soiMod=2: ideal FD */
            Igidl = 0.0;
            Igisl = 0.0;
            Ibs = 0;
            Ibd = 0;
            Ibsdif = 0;
            Ibddif = 0;
            Ic = 0.0;

        end // }

        /* v3.0: gate-tunneling */
        if ((B4SOIigbMod != 0) || (B4SOIigcMod != 0)) begin // {
            Vgb = Vgs_eff - Vbs;

            /* Calculate Vox first */
            Vfb = B4SOItype * here_B4SOIvth0  /* v4.0 */
                    - phi - pParam_B4SOIk1eff * sqrtPhi;

            T3 = Vfb - Vgs_eff + Vbs - `DELTA_3;

            if (Vfb <= 0.0) begin
                T0 = sqrt(T3 * T3 - 4.0 * `DELTA_3 * Vfb);
            end else begin
                T0 = sqrt(T3 * T3 + 4.0 * `DELTA_3 * Vfb);
            end

            Vfbeff = Vfb - 0.5 * (T3 + T0);

            Voxacc = Vfb - Vfbeff;
            if (Voxacc < 0.0) begin
                Voxacc = 0.0;
            end

            if (pParam_B4SOIk1ox == 0.0) /* v4.0 */ begin
                Voxdepinv = 0.0;
            end else begin
                T0 = Vgs_eff - Vgsteff - Vfbeff - Vbseff;
                if (T0 < 0.0) begin
                    T1 = T0/pParam_B4SOIk1ox;
                end else begin
                    T1 = pParam_B4SOIk1ox/2*(-1 + sqrt(1 +
                            4*T0/pParam_B4SOIk1ox/pParam_B4SOIk1ox));
                end

                Voxdepinv = Vgs_eff - (T1*T1 + Vbs) - Vfb;
            end
        end else begin // }{
            Vfb = 0;
            Vgb = 0;
            Voxacc = 0;
            Voxdepinv = 0;
        end // }

        /* gate-channel tunneling component */
        if (B4SOIigcMod) begin // {
            T0 = Vtm * pParam_B4SOInigc;
            VxNVt = (Vgs_eff - B4SOItype * here_B4SOIvth0)
                    / T0; /* Vth instead of Vth0 may be used */
            if (VxNVt > `EXPL_THRESHOLD) begin
                Vaux = Vgs_eff - B4SOItype * here_B4SOIvth0;
            end else if (VxNVt < -`EXPL_THRESHOLD) begin
                Vaux = T0 * ln(1.0 + `MIN_EXPL);
            end else begin   ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end

            T2 = Vgs_eff * Vaux;

            T11 = pParam_B4SOIAechvb;
            T12 = pParam_B4SOIBechvb;
            T3 = pParam_B4SOIaigc * pParam_B4SOIcigc
                    - pParam_B4SOIbigc;
            T4 = pParam_B4SOIbigc * pParam_B4SOIcigc;
            T5 = T12 * (pParam_B4SOIaigc + T3 * Voxdepinv
                    - T4 * Voxdepinv * Voxdepinv);

            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end

            Igc = T11 * T2 * T6;

            T7 = -pParam_B4SOIpigcd * Vds;
            T8 = T7 * T7 + 2.0e-4;
            if (T7 > `EXPL_THRESHOLD) begin
                T9 = `MAX_EXPL;
            end else if (T7 < -`EXPL_THRESHOLD) begin
                T9 = `MIN_EXPL;
            end else begin
                T9 = exp(T7);
            end

            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;
            Igcs = Igc * T10;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            Igcd = Igc * T10;

            T0 = vgs - pParam_B4SOIvfbsd;
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgs * vgs_eff;
            T13 = pParam_B4SOIAechvbEdges;
            T14 = pParam_B4SOIAechvbEdged;
            T12 = pParam_B4SOIBechvbEdge;
            T3 = pParam_B4SOIaigsd * pParam_B4SOIcigsd
                    - pParam_B4SOIbigsd;
            T4 = pParam_B4SOIbigsd * pParam_B4SOIcigsd;
            T5 = T12 * (pParam_B4SOIaigsd + T3 * vgs_eff
                    - T4 * vgs_eff * vgs_eff);
            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end
            Igs = T13 * T2 * T6;

            T0 = vgd - pParam_B4SOIvfbsd;
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgd * vgd_eff;
            T5 = T12 * (pParam_B4SOIaigsd + T3 * vgd_eff
                    - T4 * vgd_eff * vgd_eff);
            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end
            Igd = T14 * T2 * T6;

        end else begin // }{
            Igd = 0.0;
            Igs = 0.0;
            Igcd = 0.0;
            Igcs = 0.0;
        end // }

        /* gate-body tunneling component */
        if ((B4SOIigbMod!= 0) && (B4SOIsoiMod != 2)) begin /* v3.2 */ // {
            /* v3.1: the Igb calculation is skipped for the ideal FD mode */
            OxideRatio = pParam_B4SOIoxideRatio;

            Vox = Voxdepinv;
            /* Voxeff is Vox limited below Voxh */
            T0 = B4SOIvoxh;
            T1 = T0 - Vox - B4SOIdeltavox;
            T3 = sqrt(T1 * T1 + 4*B4SOIdeltavox * T0);
            Voxeff = T0 - 0.5 * (T1 + T3);
            Vox = Voxeff;

            T0 = (Vox - B4SOIebg)/B4SOIvevb;

            `DEXP(T0, T1) /* T1=exp(T0), T2=dT1_dT0 */

            Vaux = B4SOIvevb * ln(1 + T1);

            if (B4SOIvgb1 != 0) begin
                T0 = 1 - Vox / B4SOIvgb1;
            end else begin
                T0 = 1;
            end

            if (T0 < 0.01) begin
                T0 = 0.01;
            end

            T1 = (Leff * Weff / B4SOInseg + B4SOIagbcpd/B4SOInf)
                    * agb1 * OxideRatio;

            T2 = bgb1 * B4SOItoxqm;
            T3 = pParam_B4SOIalphaGB1;
            T4 = pParam_B4SOIbetaGB1;

            T6 = T2*(T3 - T4 * Vox) / T0;

            `DEXP(T6, T5) /* T5=exp(T6), T7=dT5_dT6 */
            Igb1 = T1 * Vgb * Vaux * T5;

            Vox = Voxacc;
            /* Voxeff is Vox limited below Voxh */
            T0 = B4SOIvoxh;
            T1 = T0 - Vox - B4SOIdeltavox;
            T3 = sqrt(T1 * T1 + 4*B4SOIdeltavox * T0);
            Voxeff = T0 - 0.5 * (T1 + T3);
            Vox = Voxeff;

            T0 = (-Vgb+(Vfb))/B4SOIvecb;

            `DEXP(T0, T1) /* T1=exp(T0), T2=dT1_dT0 */

            Vaux = B4SOIvecb* ln(1 + T1);

            if (B4SOIvgb2 != 0) begin
                T0 = 1 - Vox / B4SOIvgb2;
            end else begin
                T0 = 1;
            end

            if (T0 < 0.01) begin
                T0 = 0.01;
            end

            T1 = (Leff * Weff / B4SOInseg + B4SOIagbcpd/B4SOInf)
                    * agb2 * OxideRatio;

            T2 = bgb2 * B4SOItoxqm;
            T3 = pParam_B4SOIalphaGB2;
            T4 = pParam_B4SOIbetaGB2;

            T6 = T2*(T3 - T4 * Vox) / T0;

            `DEXP(T6, T5) /* T5=exp(T6), T7=dT5_dT6 */
            Igb2 = T1 * Vgb * Vaux * T5;

            /* Igb1 dominates in inversion region, while Igb2 dominates in accumulation */
            /* v2.2.3 bug fix for residue at low Vgb */
            if (Vgb >= 0) begin
                Igb = Igb1;
            end else begin
                Igb = Igb2;
            end
            Vfb2 = Vfb + eggbcp2;
        end else begin // }{
            Igb = 0.0;
        end // }
        B4SOIig = B4SOItype * Igb;

        /* v4.1 */
        /* gate tunneling component in the AGBCP2 region */
        /* Vfb2 = Vfb + 1.12;   Bug fix #18 Jul09 Code moved to 4370 where Vfb definition is valid*/

        if ((B4SOIigbMod!= 0) && (B4SOIsoiMod != 2) &&
            (B4SOIbodyMod != 0) && (B4SOIagbcp2 > 0) &&
            (vgp < Vfb2)) begin
            /* v4.1: the Igb2_agbcp2 calculation is skipped for the ideal FD mode or if there is no "p" node */
            T0 = vgp - Vfb2;

            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgp_eff = 0.5 * (-T0 + T1 - 1.0e-2);

            /* T11=A*  T12=B* */
            T11 = (B4SOItype == `NMOS) ? agbc2n : agbc2p;
            T12 = (B4SOItype == `NMOS) ? bgbc2n : bgbc2p;  /* v4.3.1 -Tanvir */

            T2 = vgp * vgp_eff;
            T3 = pParam_B4SOIaigbcp2 * pParam_B4SOIcigbcp2
                    - pParam_B4SOIbigbcp2;
            T4 = pParam_B4SOIbigbcp2 * pParam_B4SOIcigbcp2;
            T5 = (-T12) * B4SOItoxqm * (pParam_B4SOIaigbcp2
                    + T3 * vgp_eff - T4 * vgp_eff * vgp_eff);
            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end
            /* T11 = T11 * B4SOIagbcp2 * pParam_B4SOIoxideRatio/B4SOInf */ /* B4SOInf removed by Pankaj in May 2012 */      
            T11 = T11 * B4SOIagbcp2 * pParam_B4SOIoxideRatio;
            Ig_agbcp2 = T11 * T2 * T6;
        end else begin
            Ig_agbcp2 = 0.0;
        end
        B4SOIigp = B4SOItype * Ig_agbcp2;

        /* end of gate-body tunneling */
        /* end of v3.0 gate-tunneling  */

        /* v3.1 */
        if (B4SOIsoiMod != 2) begin /* v3.2 */ // {
            if (B4SOIiiiMod == 0 ) begin // {
                /* calculate substrate current Iii */
                if (pParam_B4SOIalpha0 <= 0.0) begin
                    Iii = 0.0;
                end else begin
                    Vdsatii0 = pParam_B4SOIvdsatii0 * (1 + B4SOItii * (TempRatio-1.0))
                            - pParam_B4SOIlii / Leff;

                    /* Calculate VgsStep */
                    T0 = pParam_B4SOIesatii * Leff; /* v3.0 bug fix: T0 is dimensionless (i.e., scaled by 1V) */
                    T1 = pParam_B4SOIsii0 * T0 / (1.0 + T0);

                    T0 = 1 / (1 + pParam_B4SOIsii1 * Vgsteff);
                    T3 = T0 + pParam_B4SOIsii2;
                    T2 = Vgst * T3;
                    T3 = 1 / (1 + pParam_B4SOIsiid * Vds);
                    VgsStep = T1 * T2 * T3;
                    Vdsatii = Vdsatii0 + VgsStep;
                    Vdiff = Vds - Vdsatii;

                    T0 = pParam_B4SOIbeta2 + pParam_B4SOIbeta1 * Vdiff
                            + pParam_B4SOIbeta0 * Vdiff * Vdiff;
                    if (T0 < 1e-5) begin
                        T0 = 1e-5;
                    end

                    if ((T0 < Vdiff / `EXPL_THRESHOLD) && (Vdiff > 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MAX_EXPL;
                    end else if ((T0 < -Vdiff / `EXPL_THRESHOLD) && (Vdiff < 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MIN_EXPL;
                    end else begin
                        Ratio = pParam_B4SOIalpha0 * exp(Vdiff / T0);
                    end

                    /* Avoid too high ratio */
                    if (Ratio > 10.0) begin
                        Ratio = 10.0;
                    end

                    T0 = Ids + pParam_B4SOIfbjtii * B4SOImode * Ic;
                    Iii = Ratio * T0;

                end
            end else begin // }{
                 /*new Iii model*/
                /*Idsmosfet part*/
                if (pParam_B4SOIalpha0 <= 0.0) begin
                    Idsmosfet = 0.0;

                end else begin
                    Vdsatii0 = pParam_B4SOIvdsatii0 * (1 + B4SOItii * (TempRatio-1.0))
                            - pParam_B4SOIlii / Leff;

                    /* Calculate VgsStep */
                    T0 = pParam_B4SOIesatii * Leff; /* v3.0 bug fix: T0 is dimensionless (i.e., scaled by 1V) */
                    T1 = pParam_B4SOIsii0 * T0 / (1.0 + T0);

                    T0 = 1 / (1 + pParam_B4SOIsii1 * Vgsteff);
                    T3 = T0 + pParam_B4SOIsii2;
                    T2 = Vgst * T3;
                    T3 = 1 / (1 + pParam_B4SOIsiid * Vds);
                    VgsStep = T1 * T2 * T3;
                    Vdsatii = Vdsatii0 + VgsStep;
                    Vdiff = Vds - Vdsatii;

                    T0 = pParam_B4SOIbeta2 + pParam_B4SOIbeta1 * Vdiff
                            + pParam_B4SOIbeta0 * Vdiff * Vdiff;
                    if (T0 < 1e-5) begin
                        T0 = 1e-5;
                    end

                    if ((T0 < Vdiff / `EXPL_THRESHOLD) && (Vdiff > 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MAX_EXPL;
                    end else if ((T0 < -Vdiff / `EXPL_THRESHOLD) && (Vdiff < 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MIN_EXPL;
                    end else begin
                        Ratio = pParam_B4SOIalpha0 * exp(Vdiff / T0);
                    end

                    /* Avoid too high ratio */
                    if (Ratio > 10.0) begin
                        Ratio = 10.0;
                    end

                    T0 = Ids;
                    Idsmosfet = Ratio * T0;
                end
                /*New BJT part*/

                T0 = (pParam_B4SOIcbjtii + pParam_B4SOIebjtii * Leff)/Leff;

                Vbci = pParam_B4SOIvbci*(1.0+B4SOItvbci*(TempRatio-1.0));
                if (B4SOImode > 0)
                    T1 = Vbci - vdbd;
                else
                    T1 = Vbci - vsbs;

                T2 = pParam_B4SOImbjtii -1.0;

                if (T1 <= 0.0)
                    T3 = 0.0;
                else
                    T3 = -pParam_B4SOIabjtii * pow(T1,T2);

                if (T3> `EXPL_THRESHOLD)
                    T4 = `MAX_EXPL;
                else if (T3 < -`EXPL_THRESHOLD)
                    T4 = `MIN_EXPL;
                else
                    T4 = exp(T3);

                Iiibjt = T0 * B4SOImode * Ic * T1 * T4;

                /*Total Iii*/
                Iii = Idsmosfet + Iiibjt;

            end // }

            /* Current through body resistor */
            /* Current going out is +ve */
            if ((B4SOIbodyMod == 0) || (B4SOIbodyMod == 2)) begin
                Ibp = 0;
            end else begin /* B4SOIbodyMod == 1 */
                if (pParam_B4SOIrbody < 1e-3) begin
                    if (B4SOIrbodyext <= 1e-3)
                        T0 = 1.0 / 1e-3;
                    else
                        T0 = 1.0 / B4SOIrbodyext;
                    Ibp = vbp * T0;
                end else begin
                    Ibp = vbp / (pParam_B4SOIrbody + B4SOIrbodyext);
                end
            end

        end else begin // }{
             /* v3.1 soiMod=2: ideal FD */
            Iii = 0.0;
            Ibp = 0.0;
        end // }
        /* v3.1 */

        /* v3.1 for RF */
        /* Calculate Rg */
        if (B4SOIrgateMod >1) begin
            T9 = pParam_B4SOIxrcrg2 * B4SOIvtm;
            T0 = T9 * beta;
            B4SOIgcrg = pParam_B4SOIxrcrg1 * (T0 + IdovVds);

            if (B4SOInf != 1.0) begin
                B4SOIgcrg = B4SOIgcrg * B4SOInf;
            end

            if (B4SOIrgateMod == 2) begin
                T11 = B4SOIgrgeltd + B4SOIgcrg;
                B4SOIgcrg = B4SOIgrgeltd * B4SOIgcrg / T11;
            end

            /* v3.1 added Rg for RF end */
        end else begin
            B4SOIgcrg = 0;
        end

        /* v4.0 Calculate bias-dependent external S/D resistance */
        if (B4SOIrdsMod) begin  /* Rs(V) */
            T0 = vgs - pParam_B4SOIvfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgs_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + pParam_B4SOIprwg * vgs_eff;
            T1 = -pParam_B4SOIprwb * vbs;
            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = rs0 * 0.5;
            Rs = rswmin + T3 * T4;

            T0 = 1.0 + B4SOIsourceConductance * Rs;
            B4SOIgstot = B4SOIsourceConductance / T0;

            /* Rd(V) */
            T0 = vgd - pParam_B4SOIvfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgd_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + pParam_B4SOIprwg * vgd_eff;
            T1 = -pParam_B4SOIprwb * vbd;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);
            T4 = rd0 * 0.5;
            Rd = rdwmin + T3 * T4;

            T0 = 1.0 + B4SOIdrainConductance * Rd;
            B4SOIgdtot = B4SOIdrainConductance / T0;

        end else begin
            B4SOIgstot = B4SOIsourceConductance;
            B4SOIgdtot = B4SOIdrainConductance;
        end

        /* Calculate Qinv for Noise analysis */
        T1 = Vgsteff * (1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm);
        B4SOIqinv = -B4SOIcox * pParam_B4SOIweff
                * B4SOInf * Leff * T1; /* v4.0 */

        if (B4SOInf != 1) begin
            Ids = Ids * B4SOInf;
            Ic  = Ic  * B4SOInf;
            B4SOIidovVds = B4SOIidovVds * B4SOInf;

            Ibs = Ibs * B4SOInf;
            Ibd = Ibd * B4SOInf;

            Igcs = Igcs * B4SOInf;
            Igcd = Igcd * B4SOInf;

            Igs = Igs * B4SOInf;
            Igd = Igd * B4SOInf;

            Iii = Iii * B4SOInf;

            B4SOIig = B4SOIig * B4SOInf;

            Igidl = Igidl * B4SOInf;
            Igisl = Igisl * B4SOInf;
        end

        B4SOIgm = B4SOItype * ddx(Ids, V(gi));
        if (B4SOImode > 0)
            B4SOIgds = B4SOItype * ddx(Ids, V(di));
        else
            B4SOIgds = B4SOItype * ddx(Ids, V(si));
        B4SOIgmbs = B4SOItype * ddx(Ids, V(b));


        /*  Begin CV (charge) model  */
        CoxWL  = B4SOIcox * (pParam_B4SOIweffCV
                / B4SOInseg * B4SOInf /* v4.0 */
                * pParam_B4SOIleffCV + B4SOIagbcp);
        CoxWLb = B4SOIfbody * B4SOIcox
                * (pParam_B4SOIweffCV / B4SOInseg
                * B4SOInf    /* v4.0 */
                * pParam_B4SOIleffCVb + B4SOIagbcp);

        /* v4.1 for improved BT charge model */
        CoxWL2  = B4SOIcox * B4SOIagbcp2;
        CoxWLb2 = B4SOIfbody * B4SOIcox * B4SOIagbcp2;
        /* end v4.1 */

        /* v3.2 Separate VgsteffCV with noff */
        
        /* New Vgst(Vgs_eff -Vth_CV) and n_CV introduced by Pankaj in May 2012 */ 

         Vgst=Vgs_eff-Vth_CV;
                  
         T10 = n_CV*Vtm;
         VgstNVt = pParam_B4SOImstar * Vgst / T10;
    
         
         /*noff = n * pParam_B4SOInoff;*/ 
         noff = n_CV * pParam_B4SOInoff;
        
        if (B4SOIvgstcvMod == 0) begin
            if ((VgstNVt > -`EXPL_THRESHOLD) && (VgstNVt < `EXPL_THRESHOLD)) begin
                //ExpVgst = ExpVgst * ExpVgst;			  //------Navid, Cadence
				ExpVgst = exp(VgstNVt) * exp(VgstNVt);    //------Navid, Cadence
                ExpVgst = ExpVgst * exp( -(pParam_B4SOIdelvt / (noff * Vtm)));
                Vgsteff = noff * Vtm * ln(1.0 + ExpVgst);

                /* v4.1 */
                if (B4SOIagbcp2 > 0) begin
                    ExpVgst2 = ExpVgst * exp(-eggbcp2 / noff / Vtm);
                    Vgsteff2 = noff * Vtm * ln(1.0 + ExpVgst2);
                end
            end
        end else if (B4SOIvgstcvMod == 1) begin
                    /*VgstNvt is limited by Pankaj in May 2012*/ 
                    if ((VgstNVt > -`EXPL_THRESHOLD) && (VgstNVt < `EXPL_THRESHOLD)) begin
                        ExpVgst = exp(VgstNVt/(pParam_B4SOImstar * pParam_B4SOInoff));
                        ExpVgst = ExpVgst * exp( -(pParam_B4SOIdelvt / (noff * Vtm)));
                        Vgsteff = noff * Vtm * ln(1.0 + ExpVgst);

                        /* v4.1 */
                        if (B4SOIagbcp2 > 0) begin
                          ExpVgst2 = ExpVgst * exp(-eggbcp2 / noff / Vtm);
                          Vgsteff2 = noff * Vtm * ln(1.0 + ExpVgst2);
                        end
                    end    

        end else begin
            T10 = noff * Vtm;
            VgstNVt = pParam_B4SOImstarcv * (Vgst - pParam_B4SOIdelvt) / T10;
            ExpArg = (pParam_B4SOIvoffcv -
                    (1 - pParam_B4SOImstarcv) * (Vgst - pParam_B4SOIdelvt))/ T10;

            /* MCJ: Very small Vgst */
            if (VgstNVt > `EXPL_THRESHOLD) begin
                Vgsteff = Vgst - pParam_B4SOIdelvt;
            end else if (ExpArg > `EXPL_THRESHOLD) begin
                T0 = (Vgst - pParam_B4SOIdelvt - pParam_B4SOIvoffcv) / (noff * Vtm);
                ExpVgst = exp(T0);
                Vgsteff = Vtm * cdep0 / B4SOIcox * ExpVgst;
            end else begin
                ExpVgst = exp(VgstNVt);
                T1 = T10 * ln(1.0 + ExpVgst);
                dT2_dVg = -B4SOIcox / (Vtm * cdep0)
                        * exp(ExpArg) * (1 - pParam_B4SOImstarcv);
                T2 = pParam_B4SOImstarcv - T10 * dT2_dVg
                        / (1.0 - pParam_B4SOImstarcv);
                Vgsteff = T1 / T2;
            end

            if (B4SOIagbcp2 > 0) begin
                VgstNVt2 = pParam_B4SOImstarcv * (Vgst - pParam_B4SOIdelvt - eggbcp2) / T10;
                ExpArg2 = (pParam_B4SOIvoffcv -
                        (1 - pParam_B4SOImstarcv) * (Vgst - pParam_B4SOIdelvt - eggbcp2))/ T10;

                /* MCJ: Very small Vgst */
                if (VgstNVt2 > `EXPL_THRESHOLD) begin
                    Vgsteff2 = Vgst - pParam_B4SOIdelvt - eggbcp2;
                end else if (ExpArg2 > `EXPL_THRESHOLD) begin
                    T0 = (Vgst - pParam_B4SOIdelvt - pParam_B4SOIvoffcv - eggbcp2) / (noff * Vtm);
                    ExpVgst2 = exp(T0);
                    Vgsteff2 = Vtm * cdep0 / B4SOIcox * ExpVgst2;
                end else begin
                    ExpVgst2 = exp(VgstNVt2);
                    T1 = T10 * ln(1.0 + ExpVgst2);
                    dT2_dVg = -B4SOIcox / (Vtm * cdep0)
                            * exp(ExpArg2) * (1 - pParam_B4SOImstarcv);
                    T2 = pParam_B4SOImstarcv - T10 * dT2_dVg
                            / (1.0 - pParam_B4SOImstarcv);
                    Vgsteff2 = T1 / T2;
                end
            end
        end
        /* v3.2 */
        
        /* New Vth (Vth_CV), sqrtPhis (sqrtPhis_CV), Vbseff (Vbseff_CV) */
        Vth=Vth_CV;
        sqrtPhis=sqrtPhis_CV;     
        Vbseff=Vbseff_CV;


        if (B4SOIcapMod == 2) begin // {
            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qac0 = 0.0;
                Qsub0 = 0.0;
            end else begin
                /* soiMod = 0 or 1 */
                
                Vfb = Vth - phi - pParam_B4SOIk1eff * sqrtPhis + pParam_B4SOIdelvt;

                V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3_SOI;
                if (Vfb <= 0.0) begin
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3_SOI * Vfb);
                end else begin
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3_SOI * Vfb);
                end
                Vfbeff = Vfb - 0.5 * (V3 + T0);

                Qac0 = CoxWLb * (Vfbeff - Vfb);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                             /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' Jun 09 */
                    ( B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    Vfb2 = Vfb + eggbcp2;
                    DELTA_3_SOI2 = `DELTA_3_SOI;
                    V3 = Vfb2 - Vgs_eff2 + Vbseff - DELTA_3_SOI2;
                    if (Vfb2 <= 0.0) begin
                        T0 = sqrt(V3 * V3 - 100.0 * DELTA_3_SOI2 * Vfb2);
                    end else begin
                        T0 = sqrt(V3 * V3 + 100.0 * DELTA_3_SOI2 * Vfb2);
                    end
                    Vfbeff2 = Vfb2 - 0.5 * (V3 + T0);
                    Qac0 = Qac0 + CoxWLb2 * (Vfbeff2 - Vfb2);
                end
                /* end v4.1 */
                T0 = 0.5 * pParam_B4SOIk1ox;
                T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
                if (pParam_B4SOIk1ox == 0.0) begin
                    T1 = 0.0;
                end else if (T3 < 0.0) begin
                    T1 = T0 + T3 / pParam_B4SOIk1ox;
                end else begin
                    T1 = sqrt(T0 * T0 + T3);
                end

                Qsub0 = CoxWLb * pParam_B4SOIk1ox * (T1 - T0); /* 4.1 bug fix */
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                            /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T3 = Vgs_eff2- Vfbeff2 - Vbseff - Vgsteff2;
                    if (T3 < 0.0) begin
                        T1 = T0 + T3 / pParam_B4SOIk1ox;
                    end else begin
                        T1 = sqrt(T0 * T0 + T3);
                    end
                    Qsub0 = Qsub0 + CoxWLb2 * pParam_B4SOIk1ox * (T1 - T0);
                end
            end
            /* v3.1 */

            AbulkCV = Abulk0 * pParam_B4SOIabulkCVfactor;

            VdsatCV = Vgsteff / AbulkCV;

            V4 = VdsatCV - Vds - `DELTA_4;
            T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
            VdseffCV = VdsatCV - 0.5 * (V4 + T0);

            /* v4.1 */
            if (B4SOIagbcp2 > 0) begin
                VdsatCV2 = Vgsteff2 / AbulkCV;
                V4 = VdsatCV2 - Vds - `DELTA_4;
                T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV2);
                VdseffCV2 = VdsatCV2 - 0.5 * (V4 + T0);
            end
            /* end v4.1 */

            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                qbulk = 0;
            end else begin
                T0 = AbulkCV * VdseffCV;
                T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1e-20);
                T2 = VdseffCV / T1;
                T3 = T0 * T2;
                T7 = 1.0 - AbulkCV;
                qbulk = CoxWLb * T7 * (0.5 * VdseffCV - T3);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T0 = AbulkCV * VdseffCV2;
                    T1 = 12.0 * (Vgsteff2 - 0.5 * T0 + 1e-20);
                    T2 = VdseffCV2 / T1;
                    T3 = T0 * T2;
                    T7 = 1.0 - AbulkCV;
                    qbulk = qbulk + CoxWLb2 * T7 * (0.5 * VdseffCV2 - T3);
                end
                /* end  v4.1 */
            end
            /* v3.1 */

            /* Total inversion charge */
            T0 = AbulkCV * VdseffCV;
            T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1e-20);
            /* T2 = VdseffCV / T1;
            */
            T2 = T0 / T1;
            T3 = T0 * T2;

            /* qinv = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);
            */
            qinv = CoxWL * (Vgsteff - 0.5 * T0 + T3);

            B4SOIqinv = -qinv; /* for noise v3.2 */

            /* v4.1 */
            if ((B4SOIsoiMod != 2) &&                /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                T02 = AbulkCV * VdseffCV2;
                T12 = 12.0 * (Vgsteff2 - 0.5 * T02 + 1e-20);
                T2 = T02 / T12;
                T3 = T02 * T2;

                qinv = qinv + CoxWL2 * (Vgsteff2 - 0.5 * T02 + T3);
                B4SOIqinv = -qinv;
            end
            /* end v4.1 */
            /* Inversion charge partitioning into S / D */
            if (B4SOIxpart > 0.5) begin
                /* 0/100 Charge partition model */
                T1 = T1 + T1;
                qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0
                        - T0 * T0 / T1);

                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&             /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T12 = T12 + T12;
                    qsrc = qsrc -CoxWL2 * (0.5 * Vgsteff2 + 0.25 * T02- T02 * T02 / T12);
                end
                /* end v4.1 */

            end else if (B4SOIxpart < 0.5) begin
                /* 40/60 Charge partition model */
                T1 = T1 / 12.0;
                T2 = 0.5 * CoxWL / (T1 * T1);
                T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff
                        * (Vgsteff - 4.0 * T0 / 3.0))
                        - 2.0 * T0 * T0 * T0 / 15.0;
                qsrc = -T2 * T3;
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&         /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 >0) begin
                    T12 = T12 /12.0;
                    T2 = 0.5 * CoxWL2 / (T12 * T12);
                    T3 = Vgsteff2 * (2.0 * T02 * T02 / 3.0 + Vgsteff2
                            * (Vgsteff2 - 4.0 * T02 / 3.0))
                            - 2.0 * T02 * T02 * T02 / 15.0;
                    qsrc2 = -T2 * T3;
                    qsrc = qsrc + qsrc2;
                end

                /* end v4.1 */
            end else begin
                /* 50/50 Charge partition model */
                qsrc = - 0.5 * (qinv + qbulk);
            end

            /* Backgate charge */
            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qe1 = 0;
            end else begin
                /* soiMod = 0 or 1 */
                CboxWL = pParam_B4SOIkb1 * B4SOIfbody * Cbox
                        * (pParam_B4SOIweffCV / B4SOInseg * B4SOInf
                        * pParam_B4SOIleffCVbg + B4SOIaebcp);
                Qe1 = CboxWL * (Vesfb - Vbs);
            end
            /* v3.1 */

            qgate = qinv + Qac0 + Qsub0;
            qbody = (qbulk - Qac0 - Qsub0 - Qe1);
            qsub = Qe1;
            qdrn = -(qgate + qsrc + qbody + qsub);

            /* End of if capMod == 2 */
        end else if (B4SOIcapMod == 3) begin // }{

            if (B4SOImtrlMod == 0)
                Cox = 3.453133e-11 / B4SOItoxp;
            else
                Cox = epsrox * `EPS0 / B4SOItoxp;

            CoxWL = CoxWL * toxe / B4SOItoxp;
            CoxWLb = CoxWLb * B4SOItox/ B4SOItoxp;
            Tox = 1.0e8*B4SOItoxp;

            /* v4.1 */
            if (B4SOIagbcp2 > 0) begin
                CoxWL2 = CoxWL2 * B4SOItox / B4SOItoxp;
                CoxWLb2 = CoxWLb2 * B4SOItox / B4SOItoxp;
            end
            /* end v4.1 */

            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qac0 = 0.0;
                Qsub0 = 0.0;
                Vfbzb = 0;
            end else begin
                /* soiMod = 0 or 1 */
                if ((SHMOD == 1) && (RTH0 != 0.0)) begin
                    Vfbzb = Vthzb - phi - pParam_B4SOIk1eff * sqrtPhi
                            + pParam_B4SOIdelvt;
                end else begin
                    Vfbzb = B4SOIvfbzb + pParam_B4SOIdelvt;
                end

                V3 = Vfbzb - Vgs_eff + Vbseff - `DELTA_3;
                if (Vfbzb <= 0.0) begin
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfbzb);
                end else begin
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfbzb);
                end
                Vfbeff = Vfbzb - 0.5 * (V3 + T0);

                /* v4.1 */
                if (B4SOIagbcp2 >0) begin
                    Vfbzb2 = Vfbzb + eggbcp2;
                    V3 = Vfbzb2 - Vgs_eff2 + Vbseff - `DELTA_3;
                    if (Vfbzb2 <= 0.0) begin                                /* Bug fix #12 Jun 09 Vfbzb changed to Vfbzb2 */
                        T0 = sqrt(V3 * V3 - 100.0 * `DELTA_3 * Vfbzb2);    /* Value of 100 instead of 4 is used to make transition smooth*/
                    end else begin
                        T0 = sqrt(V3 * V3 + 100.0 * `DELTA_3 * Vfbzb2);
                    end
                    Vfbeff2 = Vfbzb2 - 0.5 * (V3 + T0);
                end
                /* end v4.1 */

                T0 = (Vgs_eff - Vbseff - Vfbzb) / Tox;

                tmp = T0 * pParam_B4SOIacde;
                if ((-`EXPL_THRESHOLD < tmp) && (tmp < `EXPL_THRESHOLD)) begin
                    Tcen = pParam_B4SOIldeb * exp(tmp);
                end else if (tmp <= -`EXPL_THRESHOLD) begin
                    Tcen = pParam_B4SOIldeb * `MIN_EXPL;
                end else begin
                    Tcen = pParam_B4SOIldeb * `MAX_EXPL;
                end

                /*LINK = 1.0e-3 * (toxe - B4SOIdtoxcv);  v2.2.3 */
                LINK = 1.0e-3 * B4SOItoxp;
                V3 = pParam_B4SOIldeb - Tcen - LINK;
                V4 = sqrt(V3 * V3 + 4.0 * LINK * pParam_B4SOIldeb);
                Tcen = pParam_B4SOIldeb - 0.5 * (V3 + V4);
                /* v4.1 small Tcen can introduce numerical issue  */
                if (Tcen < 1e-15) begin
                    Tcen = 1e-15;
                end  /* end */

                /* v4.1 */
                if (B4SOIagbcp2 > 0) begin
                    T0 = (Vgs_eff2 - Vbseff - Vfbzb2) / Tox;

                    tmp = T0 * pParam_B4SOIacde;
                    if ((-`EXPL_THRESHOLD < tmp) && (tmp < `EXPL_THRESHOLD)) begin
                        Tcen2 = pParam_B4SOIldeb * exp(tmp);
                    end else if (tmp <= -`EXPL_THRESHOLD) begin
                        Tcen2 = pParam_B4SOIldeb * `MIN_EXPL;
                    end else begin
                        Tcen2 = pParam_B4SOIldeb * `MAX_EXPL;
                    end

                    V3 = pParam_B4SOIldeb - Tcen2 - LINK;
                    V4 = sqrt(V3 * V3 + 4.0 * LINK * pParam_B4SOIldeb);
                    Tcen2 = pParam_B4SOIldeb - 0.5 * (V3 + V4);
                    if (Tcen2 < 1e-15) begin
                        Tcen2 = 1e-15;
                    end
                end
                /* end v4.1 */

                Ccen = epssub / Tcen;
                T2 = Cox / (Cox + Ccen);
                Coxeff = T2 * Ccen;
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    /* Ccen2 = `EPSSI / Tcen2; */                /* Bug Fix # 30 Jul09 `EPSSI changed to epssub */
                    Ccen2 = epssub / Tcen2;
                    T2 = Cox / (Cox + Ccen2);
                    Coxeff2 = T2 * Ccen2;
                end
                /* end v4.1 */
                CoxWLcenb = CoxWLb * Coxeff / Cox;
                /* v4.1 */
                if (B4SOIagbcp2 > 0) begin
                    CoxWLcenb2 = CoxWLb2 * Coxeff2 / Cox;
                end
                /* end v4.1 */
                Qac0 = CoxWLcenb * (Vfbeff - Vfbzb);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    Qac02 = CoxWLcenb2 * (Vfbeff2 - Vfbzb2);
                    Qac0 = Qac0 + Qac02;
                end
                /* end v4.1 */

                T0 = 0.5 * pParam_B4SOIk1ox;
                T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
                if (pParam_B4SOIk1ox == 0.0) begin
                    T1 = 0.0;
                end else if (T3 < 0.0) begin
                    T1 = T0 + T3 / pParam_B4SOIk1ox;
                end else begin
                    T1 = sqrt(T0 * T0 + T3);
                end

                Qsub0 = CoxWLcenb * pParam_B4SOIk1ox * (T1 - T0);

                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&             /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T3 = Vgs_eff2 - Vfbeff2 - Vbseff - Vgsteff2;
                    if (pParam_B4SOIk1ox == 0.0) begin
                        T1 = 0.0;
                    end else if (T3 < 0.0) begin
                        T1 = T0 + T3 / pParam_B4SOIk1ox;
                    end else begin
                        T1 = sqrt(T0 * T0 + T3);
                    end

                    Qsub02 = CoxWLcenb2 * pParam_B4SOIk1ox * (T1 - T0);
                    Qsub0 = Qsub0 + Qsub02;
                end
                /* end v4.1 */

            end
            /* v3.1 */

            /* Gate-bias dependent delta Phis begins */
            if (pParam_B4SOIk1ox <= 0.0) begin
                Denomi = 0.25 * pParam_B4SOImoin * Vtm;
                T0 = 0.5 * pParam_B4SOIsqrtPhi;
            end else begin
                Denomi = pParam_B4SOImoin * Vtm
                        * pParam_B4SOIk1ox * pParam_B4SOIk1ox;
                T0 = pParam_B4SOIk1ox * pParam_B4SOIsqrtPhi;
            end
            T1 = 2.0 * T0 + Vgsteff;

            DeltaPhi = Vtm * ln(1.0 + T1 * Vgsteff / Denomi);

            /* v4.1 */
            if (B4SOIagbcp2 > 0) begin
                T1 = 2.0 * T0 + Vgsteff2;
                DeltaPhi2 = Vtm * ln(1.0 + T1 * Vgsteff2 / Denomi);
            end
            /* end v4.1 */
            /* End of delta Phis */

            /* v3.1.1 bug fix for discontinuity */
            T3 = 4.0 * (Vth - Vfbzb - phi);
            T2 = sqrt(T3*T3 + 0.0001);
            T4 = 0.5 * (T3 + T2);

            Tox = Tox + Tox;
            T0 = (Vgsteff + T4) / Tox;
            //tmp = exp(0.7 * ln(T0)); /*BDOS added in May 2012 by Pankaj*/   
            tmp = exp(B4SOIbdos*0.7 * ln(T0));
            T1 = 1.0 + tmp;
            /*Tcen = 1.9e-9 / T1;*//*ADOS added in May 2012 by Pankaj*/ 
            Tcen = B4SOIados*1.9e-9 / T1; 
            Ccen = epssub / Tcen;
            T0 = Cox / (Cox + Ccen);
            Coxeff = T0 * Ccen;
            CoxWLcen = CoxWL * Coxeff / Cox;
            CoxWLcenb = CoxWLb * Coxeff / Cox;
            /* v4.1 */
            if ((B4SOIsoiMod != 2) &&              /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                T3 = 4.0 * (Vth + eggbcp2 - Vfbzb2 - phi);
                T2 = sqrt(T3*T3 + 0.0001);
                T4 = 0.5 * (T3 + T2);
                /* Tox = Tox + Tox; */
                T0 = (Vgsteff2 + T4) / Tox;
                /*tmp = exp(0.7 * ln(T0));*//*BDOS added on May 2012 by Pankaj*/ 
                tmp = exp(B4SOIbdos*0.7 * ln(T0));
                T1 = 1.0 + tmp;
                /*Tcen2 = 1.9e-9 / T1;*//*ADOS added on May 2012 by Pankaj*/ 
                Tcen2 = B4SOIados*1.9e-9 / T1; 
                /*Ccen2 = `EPSSI / Tcen2;*//*Bug Fix # 30 Jul09*/
                Ccen2 = epssub/ Tcen2;
                T0 = Cox / (Cox + Ccen2);
                Coxeff2 = T0 * Ccen2;
                CoxWLcen2 = CoxWL2 * Coxeff2 / Cox;
                CoxWLcenb2 = CoxWLb2 * Coxeff2 / Cox;
            end
            /* end v4.1 */

            T1 = Vgsteff - DeltaPhi;
            AbulkCV = Abulk0 * pParam_B4SOIabulkCVfactor;
            VdsatCV = T1 / AbulkCV;
            V4 = VdsatCV - Vds - `DELTA_4;
            T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
            VdseffCV = VdsatCV - 0.5 * (V4 + T0);

            T0 = AbulkCV * VdseffCV;
            T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
            T3 = T0 / T2;

            qinv = CoxWLcen * (T1 - T0 * (0.5 - T3));
            qinoi = qinv;
            qgate = qinv;

            /* v4.1 */
            if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                T12 = Vgsteff2 - DeltaPhi2;
                VdsatCV2 = T12 / AbulkCV;
                V4 = VdsatCV2 - Vds - `DELTA_4;
                T02 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV2);
                VdseffCV2 = VdsatCV2 - 0.5 * (V4 + T02);

                T02 = AbulkCV * VdseffCV2;
                T22 = 12.0 * (T12 - 0.5 * T02 + 1.0e-20);
                T3 = T02 / T22;
                T7 = CoxWLcen2 * (T12 - T02 * (0.5 - T3));
                qinv = qinv + T7;
                qinoi = qinv;
                qgate = qinv;
            end
            /* end v4.1 */

            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                qbulk = 0;
            end else begin
                /* soiMod = 0 or 1 */
                T7 = 1.0 - AbulkCV;
                qbulk = CoxWLcenb * T7 * (0.5 * VdseffCV - T0 * VdseffCV / T2);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                    /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin

                    qbulk2 = CoxWLcenb2 * T7 * (0.5 * VdseffCV2 - T02 * VdseffCV2 / T22);
                    qbulk = qbulk + qbulk2;
                end

                /* end v4.1 */

            end
            /* v3.1 */

            if (B4SOIxpart > 0.5) begin   /* 0/100 partition */
                qsrc = -CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 * T0 * T0 / T2);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    qsrc2 = -CoxWLcen2 * ( (Vgsteff2 - DeltaPhi2) / 2.0 + T02 / 4.0
                            - 0.5 * T02 * T02 / T22);
                    qsrc = qsrc + qsrc2;
                end
                /* end v4.1 */

            end else if (B4SOIxpart < 0.5) begin   /* 40/60 partition */
                T2 = T2 / 12.0;
                T3 = 0.5 * CoxWLcen / (T2 * T2);
                T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0
                        * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                qsrc = -T3 * T4;
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T22 = T22 / 12.0;
                    T3 = 0.5 * CoxWLcen2 / (T22 * T22);
                    T4 = T12 * (2.0 * T02 * T02 / 3.0 + T12 * (T12 - 4.0
                            * T02 / 3.0)) - 2.0 * T02 * T02 * T02 / 15.0;
                    qsrc2 = -T3 * T4;
                    qsrc = qsrc + qsrc2;
                end
                /* end v4.1 */
            end else begin   /* 50/50 partition */
                qsrc = -0.5 * qgate;
            end

            /* Backgate charge */
            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qe1 = 0;
            end else begin
                /* soiMod = 0 or 1 */
                CboxWL = pParam_B4SOIkb1 * B4SOIfbody * Cbox
                        * (pParam_B4SOIweffCV / B4SOInseg * B4SOInf
                        * pParam_B4SOIleffCVbg + B4SOIaebcp);
                Qe1 = CboxWL * (Vesfb - Vbs);
            end
            /* v3.1 */

            qgate = qgate + Qac0 + Qsub0 - qbulk;
            qbody = qbulk - Qac0 - Qsub0 - Qe1;
            qsub = Qe1;
            qdrn = -(qgate + qbody + qsub + qsrc);

            B4SOIqinv = -qinoi;

            /* End of if capMod ==3 */
        end else begin /* v4.0 */ // }{
            Qac0 = 0.0;
            Qsub0 = 0.0;
            qsub = 0.0;
            qbody = 0.0;
            qsrc = 0.0;
            qdrn = 0.0;
            qgate = 0.0;
        end // }

        /*
        *  COMPUTE EQUIVALENT DRAIN CURRENT SOURCE
        */
        /* Intrinsic S/D junction charge */

        if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */ // {
            qjd = 0.0;
            qjs = 0.0;
        end else begin /* soiMod = 0 or 1 */ // }{
            PhiBSWG = B4SOIGatesidewallJctSPotential;
            dPhiBSWG_dT = -B4SOItpbswg;
            PhiBSWG = PhiBSWG + dPhiBSWG_dT * (DevTemp - B4SOItnom);
            MJSWG = B4SOIbodyJctGateSideSGradingCoeff;

            cjsbs = B4SOIunitLengthGateSidewallJctCapS
                    * pParam_B4SOIwdiosCV * B4SOItsi * B4SOInf / 1e-7;
            dcjsbs_dT = cjsbs * B4SOItcjswg;
            cjsbs = cjsbs + dcjsbs_dT * (DevTemp - B4SOItnom);

            cjdbs = B4SOIunitLengthGateSidewallJctCapD
                    * pParam_B4SOIwdiodCV * B4SOItsi * B4SOInf / 1e-7;
            dcjdbs_dT = cjdbs * B4SOItcjswgd;
            cjdbs = cjdbs + dcjdbs_dT * (DevTemp - B4SOItnom);

            DioMax = 0.9 * (PhiBSWG);

            arg = 1.0 - (vsbs > DioMax ? DioMax : vsbs) / PhiBSWG;

            if (MJSWG == 0.5) begin
                dT3_dVb = 1.0 / sqrt(arg);
            end else begin
                dT3_dVb = exp(-MJSWG * ln(arg));
            end
            T3 = (1.0 - arg * dT3_dVb) * PhiBSWG / (1.0 - MJSWG);

            if (vsbs > DioMax)
                T3 = T3 + dT3_dVb * (vsbs - DioMax);

            qjs = cjsbs * T3 + B4SOItt * Ibsdif * B4SOInf;

            PhiBSWG = B4SOIGatesidewallJctDPotential;
            dPhiBSWG_dT = -B4SOItpbswgd;
            PhiBSWG = PhiBSWG + dPhiBSWG_dT * (DevTemp - B4SOItnom);
            MJSWG = B4SOIbodyJctGateSideDGradingCoeff;

            DioMax = 0.9 * (PhiBSWG);
            arg = 1.0 - (vdbd > DioMax ? DioMax : vdbd) / PhiBSWG;

            if (MJSWG == 0.5) begin
                dT3_dVb = 1.0 / sqrt(arg);
            end else begin
                dT3_dVb = exp(-MJSWG * ln(arg));
            end
            T3 = (1.0 - arg * dT3_dVb) * PhiBSWG / (1.0 - MJSWG);

            if (vdbd > DioMax)
                T3 = T3 + dT3_dVb * (vdbd - DioMax);

            qjd = cjdbs * T3 + B4SOItt * Ibddif * B4SOInf;
        end // }

        /* Extrinsic Bottom S/D to substrate charge */
        T10 = -B4SOItype * ves;
        /* T10 is vse without type conversion */
        T11 = B4SOItype * (vds - ves);
        /* T11 is vde without type conversion */

        if (B4SOIcsdmin != 0.0) begin // {
            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                    ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) ) begin
                if (T10 < pParam_B4SOIvsdfb) begin
                    B4SOIqse = B4SOIcsbox * (T10 - pParam_B4SOIvsdfb);
                end else if (T10 < pParam_B4SOIsdt1) begin
                    T0 = T10 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqse = T0 * (B4SOIcsbox - pParam_B4SOIst2 / 3 * T1) ;
                end else if (T10 < pParam_B4SOIvsdth) begin
                    T0 = T10 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqse = B4SOIcsmin * T10 + B4SOIst4 +
                            pParam_B4SOIst3 / 3 * T0 * T1;
                end else begin
                    B4SOIqse = B4SOIcsmin * T10 + B4SOIst4;
                end
            end else begin
                if (T10 < pParam_B4SOIvsdth) begin
                    B4SOIqse = B4SOIcsmin * (T10 - pParam_B4SOIvsdth);
                end else if (T10 < pParam_B4SOIsdt1) begin
                    T0 = T10 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqse = T0 * (B4SOIcsmin - pParam_B4SOIst2 / 3 * T1) ;
                end else if (T10 < pParam_B4SOIvsdfb) begin
                    T0 = T10 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqse = B4SOIcsbox * T10 + B4SOIst4 +
                            pParam_B4SOIst3 / 3 * T0 * T1;
                end else begin
                    B4SOIqse = B4SOIcsbox * T10 + B4SOIst4;
                end
            end

            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                    ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) ) begin
                if (T11 < pParam_B4SOIvsdfb) begin
                    B4SOIqde = B4SOIcdbox * (T11 - pParam_B4SOIvsdfb);
                end else if (T11 < pParam_B4SOIsdt1) begin
                    T0 = T11 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqde = T0 * (B4SOIcdbox - pParam_B4SOIdt2 / 3 * T1) ;
                end else if (T11 < pParam_B4SOIvsdth) begin
                    T0 = T11 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqde = B4SOIcdmin * T11 + B4SOIdt4 +
                            pParam_B4SOIdt3 / 3 * T0 * T1;
                end else begin
                    B4SOIqde = B4SOIcdmin * T11 + B4SOIdt4;
                end
            end else begin
                if (T11 < pParam_B4SOIvsdth) begin
                    B4SOIqde = B4SOIcdmin * (T11 - pParam_B4SOIvsdth);
                end else if (T11 < pParam_B4SOIsdt1) begin
                    T0 = T11 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqde = T0 * (B4SOIcdmin - pParam_B4SOIdt2 / 3 * T1) ;
                end else if (T11 < pParam_B4SOIvsdfb) begin
                    T0 = T11 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqde = B4SOIcdbox * T11 + B4SOIdt4 +
                            pParam_B4SOIdt3 / 3 * T0 * T1;
                end else begin
                    B4SOIqde = B4SOIcdbox * T11 + B4SOIdt4;
                end
            end
        end else begin // }{
            B4SOIqse = B4SOIcsbox * T10;
            B4SOIqde = B4SOIcdbox * T11;
        end // }

        /* Extrinsic : Sidewall fringing S/D charge */
        B4SOIqse = B4SOIqse + B4SOIcsesw * T10;
        B4SOIqde = B4SOIqde + B4SOIcdesw * T11;

        /* bulk and channel charge plus overlaps */

        if (B4SOIrgateMod == 3)
            T0 = vgmd + `DELTA_1; /* v3.2 bug fix */
        else
            T0 = vgd + `DELTA_1;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
        T2 = 0.5 * (T0 - T1);

        /* v2.2.3 bug fix */
        T3 = pParam_B4SOIwdiodCV * pParam_B4SOIcgdl; /* v3.1 bug fix */

        T4 = sqrt(1.0 - 4.0 * T2 / pParam_B4SOIckappa);
        if (B4SOIrgateMod == 3) begin /* v3.2 bug fix */
            qgdo = (pParam_B4SOIcgdo + T3) * vgmd - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end else begin
            qgdo = (pParam_B4SOIcgdo + T3) * vgd - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end

        if (B4SOIrgateMod == 3)
            T0 = vgms + `DELTA_1; /* v3.2 bug fix */
        else
            T0 = vgs + `DELTA_1;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
        T2 = 0.5 * (T0 - T1);

        /* v2.2.3 bug fix */
        T3 = pParam_B4SOIwdiosCV * pParam_B4SOIcgsl; /* v3.1 bug fix */

        T4 = sqrt(1.0 - 4.0 * T2 / pParam_B4SOIckappa);
        if (B4SOIrgateMod == 3) begin /* v3.2 bug fix */
            qgso = (pParam_B4SOIcgso + T3) * vgms - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end else begin
            qgso = (pParam_B4SOIcgso + T3) * vgs - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end

        if (B4SOInf != 1.0) begin
            qgdo = qgdo * B4SOInf;
            qgso = qgso * B4SOInf;
        end

        begin : noise // {
            real cd, cdmin, logcdmin, wefftot, leffBcox;
            real thermalNoiseContrib, flickerNoiseContrib;
            real esat, npart_beta, npart_theta, igsquare;

`ifdef  _TNOIMOD3_
	real npart_c;
    real eta, gamma, delta, epsilon;
    real Lvsat;    
    real sid, sf;
	real ctnoi, B4SOInoiGd0, GammaGd0, C0;
`endif

            if (B4SOImode > 0)
                cd = abs(Ids + Ic - Ibd + Iii + Igidl);
            else
                cd = abs(Ids - Ic - Ibs + Iii + Igidl);

            fourkt = 4.0 * `P_K * B4SOITempSH;
            gdnoise = B4SOIgdtot;
            gsnoise = B4SOIgstot;

         case(TNOIMOD)
         0 : begin
          thermalNoiseContrib = B4SOIntnoi * B4SOIueff*abs(B4SOIqinv/(pParam_B4SOIleff*pParam_B4SOIleff+B4SOIueff*abs(B4SOIqinv)         
          *B4SOIrds) );

          I(di,si) <+ white_noise(`MFACTOR_USE *abs(fourkt * thermalNoiseContrib), "id"); 

         end
         1: begin  
                T0 = B4SOIgm + B4SOIgds + B4SOIgmbs;
                T0 = T0 * T0;
                esat = 2.0 * vsattemp / B4SOIueff;
                T5 = B4SOIVgsteff / (esat * pParam_B4SOIleff);
                T5 = T5 * T5;
                npart_beta = B4SOIrnoia * (1.0 + T5 * B4SOItnoia
                                                    * pParam_B4SOIleff);
                npart_theta = B4SOIrnoib * (1.0 + T5 * B4SOItnoib
                                                     * pParam_B4SOIleff);
                if (npart_theta > 0.9)
                    npart_theta = 0.9;
                if (npart_theta > 0.9 * npart_beta)
                    npart_theta = 0.9 * npart_beta;

                igsquare = npart_theta * npart_theta * T0 / B4SOIidovVds;
                T1 = npart_beta * (B4SOIgm + B4SOIgmbs) + B4SOIgds;
                T2 = T1 * T1 / B4SOIidovVds;
                thermalNoiseContrib = T2 - igsquare;
                
                if (B4SOImode > 0)
                    gsnoise = gsnoise * (1.0 + npart_theta * npart_theta
                                                * gsnoise / B4SOIidovVds);
                else
                    gdnoise = gdnoise * (1.0 + npart_theta * npart_theta
                                                * gdnoise / B4SOIidovVds);

               I(di,si) <+ white_noise(`MFACTOR_USE *abs(fourkt * thermalNoiseContrib), "id");   
          end 
        
         3: begin

//Correlated Thermal Noise by Navid, July 2013
`ifdef _TNOIMOD3_
      
        eta   = 1.0 - B4SOIVdseff*B4SOIAbovVgst2Vtm ;
        T0    = 1.0 - eta;
        T1    = 1.0 + eta;
        T2    = T1 + 2.0*B4SOIAbulk*B4SOIvtm/(B4SOIVgsteff+1.0e-10);           
        Lvsat = Leff*(1.0 + B4SOIVdseff /EsatL) ;  
        T6    = Leff / Lvsat ; 
        gamma = T6*(0.5*T1 + T0*T0/(6.0*T2));             

		T3      = T2*T2;
        T4      = T0*T0;           
        T5      = T3*T3;
        delta   = ((T1/T3)-(5.0*T1 + T2)*T4/(15.0*T5) + T4*T4/(9.0*T5*T2))/(6.0*T6*T6*T6);
        T7      = T0/T2;
		epsilon = (T7 + T7*T7*T7/3.0)/(6.0*T6);

        T8      = B4SOIVgsteff / (EsatL);
        T8      = T8 * T8;
		npart_c = B4SOIrnoic * (1.0 + T8 * B4SOItnoic * Leff);  
        ctnoi   = epsilon / sqrt( gamma * delta) * (2.5316 * npart_c);
		
        if (ctnoi > 1) 
            ctnoi=1;
        if (ctnoi < 0)
            ctnoi=0;
		npart_beta  = B4SOIrnoia * (1.0 + T8 * B4SOItnoia * Leff);
        npart_theta = B4SOIrnoib * (1.0 + T8 * B4SOItnoib * Leff);
        gamma       = gamma * (3.0  * npart_beta  * npart_beta);
		delta       = delta * (3.75 * npart_theta * npart_theta);  
		
		B4SOInoiGd0 = B4SOInf * beta * B4SOIVgsteff / (1.0 + gche * Rds);
	    GammaGd0    = gamma * B4SOInoiGd0;  
		sid         = fourkt * GammaGd0;
		C0          = B4SOInf * B4SOIcox * pParam_B4SOIweffCV * pParam_B4SOIleffCV;
	    //sigrat      = C0 / B4SOInoiGd0 * sqrt(delta / gamma);
		sf = (B4SOInoiGd0+1e-15)/sqrt(delta/gamma);
		
        I(di,si) <+  white_noise(`MFACTOR_USE *sid*abs(1.0-ctnoi * ctnoi));
        I(N)     <+  `MFACTOR_USE *V(N) * sf * SCALEN; 
        I(N)     <+  white_noise(`MFACTOR_USE *sid/(sf*sf*SCALEN*SCALEN));

        I(di,si) <+ `MFACTOR_USE * ctnoi * V(N)*sf*SCALEN ;
        I(gi,si) <+ `MFACTOR_USE * ddt(0.5 * C0 * SCALEN * V(N));
        I(gi,di) <+ `MFACTOR_USE * ddt(0.5 * C0 * SCALEN * V(N));
`else
		$strobe("[BSIMSOI] Although the model selector TNOIMOD is set to 3, the new correlated thermal noise model is not activated in the Verilog-A code.  Please uncomment \"`define _TNOIMOD3_\" in the beginning of the Verilog-A code.");

`endif
        end 

        2: begin

         thermalNoiseContrib = 2.0/3.0 * B4SOIntnoi*abs(B4SOIgm + B4SOIgds + B4SOIgmbs);
         I(di,si) <+ white_noise(`MFACTOR_USE *abs(fourkt * thermalNoiseContrib), "id"); 
      end
      endcase
            
           
            wefftot = B4SOInf * pParam_B4SOIweff;
            if (B4SOIbf == 1)
                leffBcox =  pParam_B4SOIleff * B4SOIcox;
            else if (B4SOIbf == 2)
                leffBcox =  pParam_B4SOIleff * pParam_B4SOIleff * B4SOIcox;
            else
                leffBcox =  pow(pParam_B4SOIleff, B4SOIbf) * B4SOIcox;

            if (FNOIMOD == 0) begin // {
                if (B4SOIw0flk > 0) begin
                    cdmin = cd / wefftot * B4SOIw0flk;
                    if (cdmin < `N_MINLOG)
                        cdmin = `N_MINLOG;
                    logcdmin = ln(cdmin);
                    flickerNoiseContrib = wefftot/B4SOIw0flk * B4SOIkf
                                          * exp(B4SOIaf * logcdmin) / leffBcox;
                end else begin
                    if (cd < `N_MINLOG)
                        cdmin = `N_MINLOG;
                    else
                        cdmin = cd;
                    logcdmin = ln(cdmin);
                    flickerNoiseContrib = B4SOIkf * exp(B4SOIaf * logcdmin)
                                                                / leffBcox;
                end
            end else begin : Eval1ovFNoise // }{
                real esat, DelClm, N0, Nl, Nratio, logem38;
                real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
                real Ssi, Swi;
                logem38 = ln(1e-38);
                esat = 2.0 * vsattemp / B4SOIueff;

                /* v2.2.3 bug fix */
                if (B4SOIem <= 0.0)
                    DelClm = 0.0;
                else begin
                    T0 = ((((Vds - B4SOIVdseff) / pParam_B4SOIlitl)
                        + B4SOIem) / esat);
                    if (T0 < 1e-38)
                        DelClm = pParam_B4SOIlitl * logem38;
                    else
                        DelClm = pParam_B4SOIlitl * ln(T0);
                end

                T1 = `Charge_q * `Charge_q * `P_K * cd * B4SOITempSH * B4SOIueff;
                T2 = 1.0e10 * B4SOIAbulk * B4SOIcox
                   * pParam_B4SOIleff * pParam_B4SOIleff;

                /* v2.2.3 bug fix */
                N0 = B4SOIcox * B4SOIVgsteff / `Charge_q;
                Nl = B4SOIcox * B4SOIVgsteff
                     * (1.0 - B4SOIAbovVgst2Vtm * B4SOIVdseff) / `Charge_q;

                Nratio = (N0 + B4SOInstar) / (Nl + B4SOInstar);
                if (Nratio < 1e-38)
                    T3 = B4SOIoxideTrapDensityA * logem38;
                else
                    T3 = B4SOIoxideTrapDensityA * ln(Nratio);
                T4 = B4SOIoxideTrapDensityB * (N0 - Nl);
                T5 = B4SOIoxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl);

                T6 = `P_K * B4SOITempSH * cd * cd;
                T7 = 1.0e10 * pParam_B4SOIleff
                   * pParam_B4SOIleff * wefftot;
                T8 = B4SOIoxideTrapDensityA + B4SOIoxideTrapDensityB * Nl
                   + B4SOIoxideTrapDensityC * Nl * Nl;
                T9 = (Nl + B4SOInstar) * (Nl + B4SOInstar);

                Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
                T10 = B4SOIoxideTrapDensityA * `P_K * B4SOITempSH;
                T11 = wefftot * pParam_B4SOIleff
                        * 1.0e10 * B4SOInstar * B4SOInstar ;
                Swi = T10 / T11 * cd * cd;
                T1 = Swi + Ssi;
                if (T1 > 0.0 && Ssi > 0.0 && Swi > 0.0)
                    flickerNoiseContrib = (Ssi * Swi ) / T1;
                else
                    flickerNoiseContrib = 0;

            end // }

            I(di,si) <+ flicker_noise(`MFACTOR_USE *flickerNoiseContrib, B4SOIef, "flicker");

      end // noise // }


        // Load currents and charges:
       /* Absolute values of fourkt * gdnoise and fourkt * gsnoise used by Pankaj in May 2012*/   
        if (B4SOIdrainConductance) begin
            I(d, di) <+ `MFACTOR_USE *V(d,di) * B4SOIgdtot;
            I(d, di) <+ white_noise( `MFACTOR_USE *abs(fourkt * gdnoise), "rd");
        end else
            V(d, di) <+ 0.0;

        if (B4SOIsourceConductance) begin
            I(s, si) <+ `MFACTOR_USE *V(s,si) * B4SOIgstot;
            I(s, si) <+ white_noise( `MFACTOR_USE *abs(fourkt * gsnoise), "rs");
        end else
            V(s, si) <+ 0.0;

        if (B4SOImode > 0) begin
            I(di,si)  <+ `MFACTOR_USE *B4SOItype * (Ids + Ic);
            I(di,b)   <+ `MFACTOR_USE *B4SOItype * Iii;
            B4SOIigidl = B4SOItype * Igidl;
            B4SOIigisl = B4SOItype * Igisl;
            B4SOIIgcd  = B4SOItype * Igcd;
            B4SOIIgcs  = B4SOItype * Igcs;
            B4SOIqdrn  = B4SOItype * qdrn;
            B4SOIqsrc  = B4SOItype * qsrc;
        end else begin
            I(si,di)  <+ `MFACTOR_USE *B4SOItype * (Ids - Ic);
            I(si,b)   <+ `MFACTOR_USE *B4SOItype * Iii;
            B4SOIigisl = B4SOItype * Igidl;
            B4SOIigidl = B4SOItype * Igisl;
            B4SOIIgcs  = B4SOItype * Igcd;
            B4SOIIgcd  = B4SOItype * Igcs;
            B4SOIqsrc  = B4SOItype * qdrn;
            B4SOIqdrn  = B4SOItype * qsrc;
        end
        B4SOIIgd = B4SOItype * Igd;
        B4SOIIgs = B4SOItype * Igs;

        I(di,b)  <+ `MFACTOR_USE *B4SOIigidl;
        I(si,b)  <+ `MFACTOR_USE *B4SOIigisl;
        I(db,di) <+ `MFACTOR_USE *B4SOItype * Ibd;
        I(sb,si) <+ `MFACTOR_USE *B4SOItype * Ibs;
        I(gi,di) <+ `MFACTOR_USE *(B4SOIIgd + B4SOIIgcd);
        I(gi,si) <+ `MFACTOR_USE *(B4SOIIgs + B4SOIIgcs);
        I(gi,b)  <+ `MFACTOR_USE *B4SOIig;
        I(gi,p)  <+ `MFACTOR_USE *B4SOIigp;
        if ((B4SOIbodyMod == 0) || (B4SOIbodyMod == 2))
            V(b, p)  <+ 0;
        else
            begin
				I(b, p)  <+ `MFACTOR_USE *B4SOItype * Ibp;
				I(b, p)  <+ white_noise(`MFACTOR_USE *fourkt*abs(Ibp)/(abs(vbp)+1.0e-9));
			end
		
        /* Low frequency excess noise due to FBE */
        /* Absolute values of Ibd, Ibs, (B4SOIIgd + B4SOIIgcd), (B4SOIIgs + B4SOIIgcs), and B4SOIig used by Pankaj in May 2012 */

        I(db,di) <+ white_noise( `MFACTOR_USE *2 * `Charge_q * B4SOInoif * abs(Ibd), "ibd");
        I(sb,si) <+ white_noise( `MFACTOR_USE *2 * `Charge_q * B4SOInoif * abs(Ibs), "ibs");

        /* v3.2 for gate tunneling shot noise */
        I(gi,di) <+ white_noise( `MFACTOR_USE *2 * `Charge_q * abs(B4SOIIgd + B4SOIIgcd), "igd");
        I(gi,si) <+ white_noise( `MFACTOR_USE *2 * `Charge_q * abs(B4SOIIgs + B4SOIIgcs), "igs");
        I(gi,b)  <+ white_noise( `MFACTOR_USE *2 * `Charge_q * abs(B4SOIig), "igb");

        I(di,b)  <+ `MFACTOR_USE *ddt(B4SOIqdrn);
        I(si,b)  <+ `MFACTOR_USE *ddt(B4SOIqsrc);
        I(gi,b)  <+ `MFACTOR_USE *B4SOItype * ddt(qgate);
        I(e, b)  <+ `MFACTOR_USE *B4SOItype * ddt(qsub);
        //I(b, b)  <+ B4SOItype * ddt(qbody);

        I(db,di) <+ `MFACTOR_USE *B4SOItype * ddt(qjd);
        I(sb,si) <+ `MFACTOR_USE *B4SOItype * ddt(qjs);

        if (RGATEMOD == 3) begin
            I(gm,di) <+ `MFACTOR_USE *B4SOItype * ddt(qgdo);
            I(gm,si) <+ `MFACTOR_USE *B4SOItype * ddt(qgso);
            I(gm, e) <+ `MFACTOR_USE *ddt(V(gm,e) * pParam_B4SOIcgeo);
        end else begin
            I(gi,di) <+ `MFACTOR_USE *B4SOItype * ddt(qgdo);
            I(gi,si) <+ `MFACTOR_USE *B4SOItype * ddt(qgso);
            I(gi, e) <+ `MFACTOR_USE *ddt(V(gi,e) * pParam_B4SOIcgeo);
        end
        I(di,e)  <+ `MFACTOR_USE *ddt(B4SOIqde);
        I(si,e)  <+ `MFACTOR_USE *ddt(B4SOIqse);

        if (RGATEMOD == 0 || RGATEMOD == 2) begin
            V(g, gm) <+ 0;
        end else begin
            I(g, gm) <+ `MFACTOR_USE *V(g, gm) * B4SOIgrgeltd;
            /* Absolute value of fourkt * B4SOIgrgeltd used by Pankaj in May 2012 */  
            I(g, gm) <+ white_noise( `MFACTOR_USE *abs(fourkt * B4SOIgrgeltd), "rg");
        end

        if (RGATEMOD == 0 || RGATEMOD == 1) begin
            V(gm,gi) <+ 0;
        end else begin
            I(gm,gi) <+ `MFACTOR_USE *V(gm,gi) * B4SOIgcrg;

            if (RGATEMOD == 2) begin : rgate2
                real T0;
                T0 = 1.0 + B4SOIgrgeltd / B4SOIgcrg;
                /* Absolute value of fourkt * B4SOIgrgeltd / (T0 * T0) used by Pankaj in May 2012 */ 
                I(gm,gi) <+ white_noise( `MFACTOR_USE *abs(fourkt * B4SOIgrgeltd / (T0 * T0)), "rg");
            end
        end

        if (B4SOIrbodyMod) begin
            I(b, db) <+ `MFACTOR_USE *V(b, db) * B4SOIgrbdb;
            I(b, sb) <+ `MFACTOR_USE *V(b, sb) * B4SOIgrbsb;
            /* Absolute values of fourkt * B4SOIgrbdb and fourkt * B4SOIgrbsb used by Pankaj in May 2012 */ 
            I(b, db) <+ white_noise( `MFACTOR_USE *abs(fourkt * B4SOIgrbdb), "rbdb");
            I(b, sb) <+ white_noise( `MFACTOR_USE *abs(fourkt * B4SOIgrbsb), "rbsb");
        end else begin
            V(b, db) <+ 0;
            V(b, sb) <+ 0;
        end

        if (B4SOIsoiMod == 2)
            V(b, si) <+ 0;

        // self-heating network
       // XYCE:  Copied out what BSIM-SOI 4.6.1 does, because this won't
       // work with optional nodes
`ifndef __XYCE__
        if ((SHMOD == 1) && (RTH0 != 0.0))
          begin
            Pwr(t) <+ `MFACTOR_USE *(-Ids * Vds  + delTemp / pParam_B4SOIrth);
            Pwr(t) <+ `MFACTOR_USE *ddt(delTemp * pParam_B4SOIcth);
          end
        else
            Temp(t) <+ 0;
`else // __XYCE__
 `ifdef PORT_CONNECTED
         if ((SHMOD == 1) && (RTH0 != 0.0)) begin /* 2014bug2 */ /* v4.6 */
            if (TNODEOUT && !$port_connected(t)) begin
               if ($port_connected(b)) begin // last terminal is 'b'
                  I(b) <+ `MFACTOR_USE*(-Ids * Vds  + delTemp / pParam_B4SOIrth);
                  I(b) <+  `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
               end else if ($port_connected(p)) begin  // last terminal is 'p'
                  I(p) <+ `MFACTOR_USE*(-Ids * Vds + delTemp / pParam_B4SOIrth);
                  I(p) <+ `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
               end else begin  // 4-terminal mode ('t' is internal)
                  Pwr(t) <+ `MFACTOR_USE*(-Ids * Vds + delTemp / pParam_B4SOIrth);
                  Pwr(t) <+ `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
               end
            end else begin
               Pwr(t) <+ `MFACTOR_USE*(-Ids * Vds + delTemp / pParam_B4SOIrth);
               Pwr(t) <+ `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
            end
         end else begin
            if (TNODEOUT && !$port_connected(t)) begin
               if ($port_connected(b)) begin // last terminal is 'b'
                  $strobe("Error:  you have specified a temperature node as the 6th node with TNODEOUT=1 and self-heating disabled (either because SHMOD=0 or RTH0=0).  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 6th node.");
                  $finish(1);
                  // V(b) <+0;
               end else if ($port_connected(p)) begin // last terminal is 'p'
                  $strobe("Error:  you have specified a temperature node as the 5th node with TNODEOUT=1 and self-heating disabled (either because SHMOD=0 or RTH0=0).  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 5th node.");
                  $finish(1);
                  // V(p) <+ 0;
               end else begin // 4-terminal mode ('t' is internal)
                  $strobe("Error:  you have specified a temperature node as the 7th node with TNODEOUT=1 and self-heating disabled (either because SHMOD=0 or RTH0=0).  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 7th node.");
                  $finish(1);
                  // Temp(t) <+ 0;
               end
            end else begin
               Temp(t) <+ 0;
            end
         end
 `else
       if ((SHMOD == 1) && (RTH0 != 0.0)) begin
          Pwr(t) <+ `MFACTOR_USE * (-Ids * Vds + delTemp / pParam_B4SOIrth);
          Pwr(t) <+ `MFACTOR_USE * ddt(delTemp * pParam_B4SOIcth);
       end else
         Temp(t) <+ 0;
 `endif // PORT_CONNECTED
`endif // __XYCE__

        // operating-point information
        IDS   = B4SOItype * Ids;
        GM    = B4SOIgm;
        GDS   = B4SOIgds;
        GMBS  = B4SOIgmbs;
        IC    = B4SOItype * Ic;
        IBS   = B4SOItype * Ibs;
        IBD   = B4SOItype * Ibd;
        IGIDL = B4SOIigidl;
        IGISL = B4SOIigisl;
        IGS   = B4SOIIgs;
        IGD   = B4SOIIgd;
        IGB   = B4SOIig;
        IGCS  = B4SOIIgcs;
        IGCD  = B4SOIIgcd;
        QG    = B4SOItype * qgate;
        QB    = B4SOItype * qbody;
        QD    = B4SOIqdrn;
        QS    = B4SOIqsrc;
        CGG   =  ddx(QG, V(gi)); 
        CGS   = -ddx(QG, V(si));
        CGD   = -ddx(QG, V(di));
        CBG   = -ddx(QB, V(gi));
        CBD   = -ddx(QB, V(di));
        CBS   = -ddx(QB, V(si));
        CDG   = -ddx(QD, V(gi));
        CDD   =  ddx(QD, V(di));
        CDS   = -ddx(QD, V(si));
        QJD   = B4SOItype * qjd;
        QJS   = B4SOItype * qjs;
        CAPBD = ddx(QJD, V(db));
        CAPBS = ddx(QJS, V(sb));

    end // load // }

end // analog
endmodule
