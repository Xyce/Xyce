// ****************************************************************************
// *  BSIM-SOI 4.6.1 released by Chetan Kumar Dabhi on 11/14/2017             *
// *                                                                          *
// *  Project Director: Prof. Chenming Hu (UC Berkeley)                       *
// *                                                                          *
// *  Current developers: Chetan Kumar Dabhi (Ph.D. student, IIT Kanpur)      *
// *                      Prof. Yogesh Chauhan (IIT Kanpur)                   *
// *                      Dr. Huan-Lin Chang (Postdoc, UC Berkeley)           *
// *                      Dr. Harshit Agarwal (Postdoc, UC Berkeley)          *
// *                      Dr. Pragya Kushwaha (Postdoc, UC Berkeley)          *
// *                      Juan Duarte (Ph.D. student, UC Berkeley)            *
// *                      Yen-Kai Lin (Ph.D. student, UC Berkeley)            *
// ****************************************************************************

// ****************************************************************************
// *  Software is distributed as is, completely without warranty or service   *
// *  support. The University of California and its employees are not liable  *
// *  for the condition or performance of the software.                       *
// *                                                                          *
// *  The University of California owns the copyright and grants users a      *
// *  perpetual, irrevocable, worldwide, non-exclusive, royalty-free license  *
// *  with respect to the software as set forth below.                        *
// *                                                                          *
// *  The University of California hereby disclaims all implied warranties.   *
// *                                                                          *
// *  The University of California grants the users the right to modify,      *
// *  copy, and redistribute the software and documentation, both within      *
// *  the user's organization and externally, subject to the following        *
// *  restrictions:                                                           *
// *                                                                          *
// *  1. The users agree not to charge for the University of California code  *
// *     itself but may charge for additions, extensions, or support.         *
// *                                                                          *
// *  2. In any product based on the software, the users agree to             *
// *     acknowledge the University of California that developed the          *
// *     software. This acknowledgment shall appear in the product            *
// *     documentation.                                                       *
// *                                                                          *
// *  3. Redistributions to others of source code and documentation must      *
// *     retain the copyright notice, disclaimer, and list of conditions.     *
// *                                                                          *
// *  4. Redistributions to others in binary form must reproduce the          *
// *     copyright notice, disclaimer, and list of conditions in the          *
// *     documentation and/or other materials provided with the               *
// *     distribution.                                                        *
// *                                                                          *
// *  Agreed to on ________Nov 14, 2017____________                           *
// *                                                                          *
// *  By: ____University of California, Berkeley___                           *
// *      ____Chenming Hu__________________________                           *
// *      ____Professor in Graduate School ________                           *
// ****************************************************************************

// ****************************************************************************
// *  Copyright (C) 2010, Analog Devices, Inc. All rights reserved.           *
// *  The original Verilog-A implementation of BSIMSOI was developed by       *
// *  Analog Devices, Inc.                                                    *
// *  Members of the Compact Model Council of the TechAmerica organization    *
// *  and Tiburon Design Automation, Inc. are acknowledged for assistance.    *
// *                                                                          *
// *  The original C source code is                                           *
// *  Copyright (C) 2017, Regents of the University of California.            *
// *  All rights reserved.                                                    *
// *                                                                          *
// *  The terms under which this software is provided are:                    *
// *                                                                          *
// *  The Regents of the University of California and Analog Devices, Inc.    *
// *  ("Authors") own the copyright but shall not be liable for any           *
// *  infringement of copyright or other proprietary rights brought by third  *
// *  parties against the users of the software.                              *
// *                                                                          *
// *  The Authors jointly grant the users the right to modify, copy, and      *
// *  redistribute the software and documentation, both within the user's     *
// *  organization and externally, subject to the following conditions:       *
// *                                                                          *
// *  1. The users agree not to charge for the original source code itself    *
// *     but may charge for additions, extensions, or support.                *
// *                                                                          *
// *  2. In any product based on the software, the users agree to             *
// *     acknowledge the UC Berkeley BSIM Research Group that developed       *
// *     the software. This acknowledgment shall appear in the product        *
// *     documentation.                                                       *
// *                                                                          *
// *  3. The users agree to obey all U.S. Government restrictions governing   *
// *     redistribution or export of the software.                            *
// *                                                                          *
// *  4. Redistributions of source code must retain the above copyright       *
// *     notices, this list of conditions and the following disclaimer.       *
// *                                                                          *
// *  5. Redistributions in binary form must reproduce the above copyright    *
// *     notices, this list of conditions and the following disclaimer in     *
// *     the documentation and/or other materials provided with the           *
// *     distribution.                                                        *
// *                                                                          *
// *  6. Users may not claim authorship of the original software. Modified    *
// *     versions of the software must be plainly marked as such.             *
// *                                                                          *
// *  7. Users may not suggest any sponsorship or endorsement by the          *
// *     Authors of users' product.                                           *
// *                                                                          *
// *  THIS SOFTWARE IS PROVIDED BY AUTHORS AS IS AND ANY EXPRESS OR IMPLIED   *
// *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF    *
// *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND               *
// *  NONINFRINGEMENT OF THIRD PARTY RIGHTS ARE DISCLAIMED. IN NO EVENT       *
// *  SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,       *
// *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT        *
// *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   *
// *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   *
// *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     *
// *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   *
// *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    *
// ****************************************************************************

`include "disciplines.vams"
`include "constants.vams"

// DEFINE THIS IF IN XYCE!
`define __XYCE__

// These constants are part of the model
`define Kb 1.3806226e-23
`define KboQ 8.617087e-5  /* Kb / q  where q = 1.60219e-19 */
`define EPSOX 3.453133e-11
`define EPSSI 1.03594e-10
`define EPS0 8.85418e-12
`define Charge_q 1.60219e-19
`define Eg300 1.115   /*  energy gap at 300K  */
`define MAX_EXPL 2.688117142e+43
`define MIN_EXPL 3.720075976e-44
`define EXPL_THRESHOLD 100.0
`define DELTA_ 1.0E-9
`define DELTA_1 0.02
`define DELTA_2 0.02
`define DELTA_3 0.02
`define DELTA_3_SOI 0.08
`define DELTA_4 0.02
`define DELTA_VFB  0.02
`define OFF_Vbsitf 0.02

`define N_MINLOG 1.0e-38
`define ln_N_MINLOG -87.498233533773742465
`define NMOS 1

`define DEXP(A,B) \
    if (A > `EXPL_THRESHOLD) begin \
        B = `MAX_EXPL*(1.0+(A)-`EXPL_THRESHOLD); \
    end else if (A < -`EXPL_THRESHOLD) begin \
        B = `MIN_EXPL; \
    end else begin \
        B = exp(A); \
    end
//  Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     ||
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     cz    closed lower bound=0, open upper bound=inf
//     oz    open   lower bound=0, open upper bound=inf
//     nb    no bounds
//     ex    no bounds with exclude
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  IPM   instance parameter mFactor(multiplicity, implicit for LRM2.2)
//  OPP   operating point parameter, includes units and description for printing
//
`define OPP(nam,uni,des)               (*units=uni,                   desc=des*)            real    nam ;

`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def ;
`define MPRex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter real    nam=def exclude exc ;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr] ;
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr) ;
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr) ;
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr] ;
`define MPRcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from(  0:inf);

`define MPInb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def ;
`define MPIex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter integer nam=def exclude exc ;
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr] ;
`define MPIoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr) ;
`define MPIco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr) ;
`define MPIoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr] ;
`define MPIcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:inf);
`define MPIoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from(  0:inf);

`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1] ;
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0 ;

`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def ;
`define IPRex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def exclude exc ;
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr] ;
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr) ;
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr) ;
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr] ;
`define IPRcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[  0:inf);
`define IPRoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(  0:inf);

`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def ;
`define IPIex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def exclude exc ;
`define IPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr] ;
`define IPIoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr) ;
`define IPIco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr) ;
`define IPIoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr] ;
`define IPIcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[  0:inf);
`define IPIoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(  0:inf);

`define BPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr] ;

`ifdef __XYCE__
// These macros should be used where BSIM-SOI defines a parameter as instance,
// but the manual describes them as being both model and instance
`define IPRcc_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter real    nam=def from[lwr:upr] ;
`define IPRco_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter real    nam=def from[lwr:upr) ;
`define IPRcz_BOTH(nam,def,uni,        des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter real    nam=def from[  0:inf);
`define IPRoz_BOTH(nam,def,uni,        des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter real    nam=def from(  0:inf);
`define IPIco_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter integer nam=def from[lwr:upr) ;
`define IPIcc_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter integer nam=def from[lwr:upr] ;
`define IPRnb_BOTH(nam,def,uni,        des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter real    nam=def ;
`define BPIcc_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des xyceAlsoModel="yes"*) parameter integer nam=def from[lwr:upr] ;
`else
`define IPRcc_BOTH(nam,def,uni,lwr,upr,des) `IPRcc(nam,def,uni,lwr,upr,des)
`define IPRco_BOTH(nam,def,uni,lwr,upr,des) `IPRco(nam,def,uni,lwr,upr,des)
`define IPRcz_BOTH(nam,def,uni,        des) `IPRcz(nam,def,uni,        des)
`define IPRoz_BOTH(nam,def,uni,        des) `IPRoz(nam,def,uni,        des)
`define IPIco_BOTH(nam,def,uni,lwr,upr,des) `IPIco(nam,def,uni,lwr,upr,des)
`define IPIcc_BOTH(nam,def,uni,lwr,upr,des) `IPIcc(nam,def,uni,lwr,upr,des)
`define IPRnb_BOTH(nam,def,uni,        des) `IPRnb(nam,def,uni,        des)
`define BPIcc_BOTH(nam,def,uni,lwr,upr,des) `BPIcc(nam,def,uni,lwr,upr,des)
`endif

`ifdef __XYCE__
   `define IPM                         (*units="" , type="instance",  desc="multiplicity factor"*) parameter real m=1.0 from(0.0:inf) ;
   `define MFACTOR_USE m
`else
   `define IPM
   `define MFACTOR_USE 1.0
`endif

// Do not define PORT_CONNECTED for Xyce
`define PORT_CONNECTED

`ifdef PORT_CONNECTED

    module bsimsoi(d, g, s, e, p, b, t) (* xyceModelGroup="MOSFET" xyceLevelNumber="70" xyceDeviceName="BSIM-SOI 4.6.1" xyceTypeVariable="TYPE" *);
    inout      g, d, s, e, p, b, t;
`else

    module bsimsoi(d, g, s, e) (* xyceModelGroup="MOSFET" xyceLevelNumber="70" xyceDeviceName="BSIM-SOI 4.6.1" xyceTypeVariable="TYPE" *);
    inout      g, d, s, e;
`endif

electrical g, d, s, e, p, b;
thermal t;
electrical di, si, gi, gm, sb, db;

// Correlated Thermal Noise Switch
//`define _TNOIMOD3_

// Internal node controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
    electrical N;
`endif
// Clamped log function
analog function real lln;
    input x;
    real x;
    begin
        lln = (x>`N_MINLOG) ? ln(x) : `ln_N_MINLOG;
    end
endfunction

// Hypsmooth function
analog function real hypsmooth;

       input x,c;
       real x, c;
       begin
            hypsmooth = 0.5*(x +  sqrt(x*x+4.0*c*c ));
       end

endfunction
/***************************/
/*  Instance Parameters    */
/***************************/
`IPRnb( DTEMP          ,0.0            ,""                                 ,"device temperature offset from ambient" ) /* Changed to instance parameter in v4.6 */
`IPRoz_BOTH( L              ,5e-6           ,"m"                                ,"Length" )
`IPRoz_BOTH( W              ,5e-6           ,"m"                                ,"Width" )
`IPIco_BOTH( NF             ,1            ,""          ,1          ,inf       ,"Number of fingers" )
`IPRcz_BOTH( SA             ,0.0            ,"m"                                ,"distance between  OD edge to poly of one side" )
`IPRcz_BOTH( SB             ,0.0            ,"m"                                ,"distance between  OD edge to poly of the other side" )
`IPRcz_BOTH( SD             ,0.0            ,"m"                                ,"distance between neighbor fingers" )
`IPRcz_BOTH( AD             ,0.0            ,"m^2"                              ,"Drain area" )
`IPRcz_BOTH( AS             ,0.0            ,"m^2"                              ,"Source area" )
`IPRcz_BOTH( PD             ,0.0            ,"m"                                ,"Drain perimeter" )
`IPRcz_BOTH( PS             ,0.0            ,"m"                                ,"Source perimeter" )
`IPRcz_BOTH( NRD            ,1.0            ,""                                 ,"Number of squares in drain" )
`IPRcz_BOTH( NRS            ,1.0            ,""                                 ,"Number of squares in source" )
`IPIcc_BOTH( OFF            ,0              ,""          ,0          ,1         ,"Device is initially off" )
`IPIcc_BOTH( BJTOFF         ,0              ,""          ,0          ,1         ,"BJT on/off flag" )
`IPIcc( DEBUG          ,0              ,""          ,0          ,1         ,"DEBUG on/off flag" )
`IPRcz_BOTH( RTH0           ,0.0            ,"ohm"                              ,"Instance Thermal Resistance" )
`IPRcz_BOTH( CTH0           ,1e-5           ,"Ws/mK"                                                    ,"Instance Thermal Capacitance" )
`IPRcz_BOTH( NRB            ,1.0            ,""                                 ,"Number of squares in body" )
`IPRnb_BOTH( FRBODY         ,1.0            ,""                                 ,"layout dependent body-resistance coefficient" )
`IPRcz_BOTH( RBDB           ,50.0           ,"ohm"                              ,"Body resistance" )
`IPRcz_BOTH( RBSB           ,50.0           ,"ohm"                              ,"Body resistance" )
`IPRnb_BOTH( DELVTO         ,0.0            ,"V"                                ,"Zero bias threshold voltage variation" )
`IPIcc_BOTH( SOIMOD         ,0              ,""          ,0          ,3         ,"Instance model selector for PD/FD operation /* v3.2 " )
`IPRcz_BOTH( NBC            ,0.0            ,""                                 ,"Number of body contact isolation edge" )
`IPRco_BOTH( NSEG           ,1              ,""          ,1          ,inf       ,"Number segments for width partitioning" )
`IPRcz_BOTH( PDBCP          ,0.0            ,"m"                                ,"Perimeter length for bc parasitics at drain side" )
`IPRcz_BOTH( PSBCP          ,0.0            ,"m"                                ,"Perimeter length for bc parasitics at source side" )
`IPRcz_BOTH( AGBCP          ,0.0            ,"m^2"                              ,"Gate to body overlap area for bc parasitics" )
`IPRcz_BOTH( AGBCP2         ,0.0            ,"m^2"                              ,"Parasitic Gate to body overlap area for bc parasitics /* v4.1 improvement on BC " )
`IPRcz_BOTH( AGBCPD         ,AGBCP          ,"m^2"                              ,"Gate to body overlap area for bc parasitics in DC" )
`IPRcz_BOTH( AEBCP          ,0.0            ,"m^2"                              ,"Substrate to body overlap area for bc parasitics" )
`IPIcc( TNODEOUT       ,0              ,""          ,0          ,1         ,"Flag indicating external temp node" ) /* Changed to instance parameter in v4.6 */
`BPIcc_BOTH( SHMOD          ,0              ,""          ,0          ,1         ,"Self heating mode selector" )
/************************/
/*  Model Parameters    */
/************************/
`MPIty( TYPE           ,`NMOS          ,""                                 ,"+1 = NMOS, -1 = PMOS" )
`MPRco( VERSION        ,4.60           ,""          ,4.0        ,5.0       ,"parameter for model version" )
`MPRnb( VBSUSR         ,0.0            ,"V"                                ,"Vbs specified by user" )
`MPIcc( RGATEMOD       ,0              ,""          ,0          ,3         ,"Gate resistance model selector" )
`MPIcc( RBODYMOD       ,0              ,""          ,0          ,1         ,"Body R model selector /* v4.0 " )
`MPIcc( MTRLMOD        ,0              ,""          ,0          ,1         ,"parameter for non-silicon substrate or metal gate selector" )
`MPIcc( VGSTCVMOD      ,((VERSION>=4.2) ? 1 : 0),"" ,0          ,2         ,"Improved VgsteffCV selector" )
`MPIcc( GIDLMOD        ,0              ,""          ,0          ,1         ,"parameter for GIDL selector" )
`MPIcc( IIIMOD         ,0              ,""          ,0          ,1         ,"parameter for III selector" )
`MPRcz( EOT            ,100.0e-10      ,"m"                                ,"Effective SiO2 thickness" )
`MPRcz( EPSROX         ,3.9            ,""                                 ,"Dielectric constant of the gate oxide relative to vacuum" )
`MPRoz( EPSRSUB        ,11.7           ,""                                 ,"Dielectric constant of substrate relative to vacuum" )
`MPRcz( NI0SUB         ,1.45e10        ,"cm^-3"                            ,"Intrinsic carrier concentration of substrate at Tnom" )
`MPRcz( BG0SUB         ,1.16           ,"eV"                               ,"Band-gap of substrate at T=0K" )
`MPRcz( TBGASUB        ,7.02e-4        ,""                                 ,"First parameter of band-gap change due to temperature" )
`MPRnb( TBGBSUB        ,1108.0         ,""                                 ,"Second parameter of band-gap change due to temperature" )
`MPRnb( PHIG           ,4.05           ,"eV"                               ,"Work function of gate" )
`MPRnb( EASUB          ,4.05           ,"eV"                               ,"Electron affinity of substrate" )
`MPRoz( LEFFEOT        ,1.0            ,"um"                               ,"Effective length for extraction of EOT" )
`MPRnb( WEFFEOT        ,10.0           ,"um"                               ,"Effective width for extraction of EOT" )
`MPRnb( VDDEOT         ,((TYPE == `NMOS) ? 1.5 : -1.5),""                  ,"Voltage for extraction of EOT" )
`MPRnb( TEMPEOT        ,300.15         ,"K"                                ,"Temperature for extraction of EOT" )
`MPRnb( ADOS           ,1.0            ,""                                 ,"Charge centroid parameter" )
`MPRnb( BDOS           ,1.0            ,""                                 ,"Charge centroid parameter" )
`MPRoz( EPSRGATE       ,11.7           ,""                                 ,"Dielectric constant of gate relative to vacuum" )
`MPIcc( CAPMOD         ,2              ,""          ,2          ,3         ,"Capacitance model selector" )
`MPIcc( MOBMOD         ,1              ,""          ,1          ,4         ,"Mobility model selector" )
`MPInb( PARAMCHK       ,0              ,""                                 ,"Model parameter checking selector" )
`MPInb( NODECHK        ,1              ,""                                 ,"NODE checking flag" )     /* Added for Node Checking in v4.6 */

`MPInb( BINUNIT        ,1              ,""                                 ,"Bin  unit  selector" )
`MPRoz( TOX            ,100.0e-10      ,"m"                                ,"Gate oxide thickness in meters" )
`MPRoz( TOXP           ,TOX            ,"m"                                ,"Physical gate oxide thickness" )
`MPRoz( TOXM           ,TOX            ,"m"                                ,"Gate oxide thickness used in extraction /* v3.2 " )
`MPRnb( DTOXCV         ,0.0            ,"m"                                ,"Delta oxide thickness in meters in CapMod3 /* v2.2.3 " )
`MPRnb( CDSC           ,2.4e-4         ,"F/m^2"                            ,"Drain/Source and channel coupling capacitance" )
`MPRnb( CDSCB          ,0.0            ,"F/m^2"                            ,"Body-bias dependence of cdsc" )
`MPRnb( CDSCD          ,0.0            ,"F/m^2"                            ,"Drain-bias dependence of cdsc" )
`MPRnb( CIT            ,0.0            ,"F/m^2"                            ,"Interface state capacitance" )
`MPRnb( NFACTOR        ,1              ,""                                 ,"Subthreshold swing Coefficient" )
`MPRoz( VSAT           ,8.0e4          ,"m/s"                              ,"Saturation velocity at tnom" )
`MPRnb( AT             ,3.3e4          ,"m/s"                              ,"Temperature coefficient of vsat" )
`MPRnb( A0             ,1.0            ,""                                 ,"Non-uniform depletion width effect coefficient." )
`MPRnb( AGS            ,0.0            ,"1/V"                              ,"Gate bias  coefficient of Abulk." )
`MPRnb( A1             ,0.0            ,"1/V"                              ,"Non-saturation effect coefficient" )
`MPRnb( A2             ,1.0            ,"1/V"                              ,"Non-saturation effect coefficient" )
`MPRnb( KETA           ,-0.6           ,"1/V"                              ,"Body-bias coefficient of non-uniform depletion width effect." )
`MPRoz( NSUB           ,6.0e16         ,"cm^-3"                            ,"Substrate doping concentration with polarity" )
`MPRoz( NCH            ,1.7e17         ,"cm^-3"                            ,"Channel doping concentration" )
`MPRcz( NGATE          ,0.0            ,"cm^-3"                            ,"Poly-gate doping concentration" )
`MPRoz( NSD            ,1.0e20         ,"cm^-3"                            ,"S/D doping concentration" )
`MPRnb( GAMMA1         ,0.0            ,""                                 ,"Vth body coefficient" )
`MPRnb( GAMMA2         ,0.0            ,""                                 ,"Vth body coefficient" )
`MPRnb( VBX            ,0.0            ,""                                 ,"Vth transition body Voltage" )
`MPRnb( VBM            ,-3.0           ,"V"                                ,"Maximum body voltage" )
`MPRnb( XT             ,1.55e-7        ,"m"                                ,"Doping depth" )
`MPRnb( K1             ,0.53           ,"V^1/2"                            ,"Bulk effect coefficient 1" )
`MPRnb( KT1            ,-0.11          ,"V"                                ,"Temperature coefficient of Vth" )
`MPRnb( KT1L           ,0.0            ,""                                 ,"Temperature coefficient of Vth" )
`MPRnb( KT2            ,0.022          ,""                                 ,"Body-coefficient of kt1" )
`MPRnb( K2             ,-0.0186        ,""                                 ,"Bulk effect coefficient 2" )
`MPRnb( K3             ,0.0            ,""                                 ,"Narrow width effect coefficient" )
`MPRnb( K3B            ,0.0            ,"1/V"                              ,"Body effect coefficient of k3" )
`MPRnb( W0             ,2.5e-6         ,"m"                                ,"Narrow width effect parameter" )
`MPRnb( LPEB           ,0.0            ,"m"                                ,"Lateral non-uniform doping effect for body bias" )
`MPRnb( DVT0           ,2.2            ,""                                 ,"Short channel effect coeff. 0" )
`MPRnb( DVT1           ,0.53           ,""                                 ,"Short channel effect coeff. 1" )
`MPRnb( DVT2           ,-0.032         ,"1/V"                              ,"Short channel effect coeff. 2" )
`MPRnb( DVT0W          ,0.0            ,""                                 ,"Narrow Width coeff. 0" )
`MPRnb( DVT1W          ,5.3e6          ,""                                 ,"Narrow Width effect coeff. 1" )
`MPRnb( DVT2W          ,-0.032         ,""                                 ,"Narrow Width effect coeff. 2" )
`MPRnb( DROUT          ,0.56           ,""                                 ,"DIBL coefficient of output resistance" )
`MPRnb( DSUB           ,DROUT          ,""                                 ,"DIBL coefficient in the subthreshold region" )
`MPRnb( VTHO           ,((TYPE == `NMOS) ? 0.7 : -0.7),"V"                 ,"Threshold voltage" )
`MPRnb( VTH0           ,VTHO           ,"V"                                ,"Threshold voltage" )
`MPRnb( VFB            ,-1.0           ,"V"                                ,"Flat Band Voltage /* v4.1 " )
`MPRnb( UA             ,2.25e-9        ,""                                 ,"Linear gate dependence of mobility" )
`MPRnb( UA1            ,4.31e-9        ,"m/V"                              ,"Temperature coefficient of ua" )
`MPRnb( UB             ,5.87e-19       ,"(m/V)^2"                          ,"Quadratic gate dependence of mobility" )
`MPRnb( UB1            ,-7.61e-18      ,""                                 ,"Temperature coefficient of ub" )
`MPRnb( UC             ,((MOBMOD == 3) ? -0.0465 : -0.0465e-9),"1/V"       ,"Body-bias dependence of mobility" )
`MPRnb( UC1            ,((MOBMOD == 3) ? -0.056 : -0.056e-9),"1/V"         ,"Temperature coefficient of uc" )
`MPRnb( U0             ,((TYPE == `NMOS) ? 0.067 : 0.025),"m^2/Vs"         ,"Low-field mobility at Tnom" )
`MPRnb( EU             ,((TYPE == `NMOS) ? 1.67 : 1.0),""                  ,"Mobility exponent" )
`MPRnb( UTE            ,-1.5           ,""                                 ,"Temperature coefficient of mobility" )
`MPRnb( UCS            ,((TYPE == `NMOS) ? 1.67 : 1.0),""                  ,"Mobility exponent" )
`MPRnb( UCSTE          ,-4.775e-3      ,""                                 ,"Temperature coefficient of UCS" )
`MPRnb( UD             ,0.0            ,""                                 ,"Coulomb scattering factor of mobility" )
`MPRnb( UD1            ,0.0            ,""                                 ,"Temperature coefficient of ud" )
`MPRnb( VOFF           ,-0.08          ,"V"                                ,"Threshold voltage offset" )
`MPRnb( TNOM           ,27.0           ,"Degree Celsius"                   ,"Parameter measurement temperature" )
`MPRcz( CGSO           ,0.0            ,"F/m"                              ,"Gate-source overlap capacitance per width" )
`MPRcz( CGDO           ,0.0            ,"F/m"                              ,"Gate-drain overlap capacitance per width" )
`MPRnb( XPART          ,0.0            ,""                                 ,"Channel charge partitioning" )
`MPRnb( DELTA          ,0.01           ,""                                 ,"Effective Vds parameter" )
`MPRcz( RSH            ,0.0            ,"ohm"                              ,"Source-drain sheet resistance" )
`MPRcz( RDSW           ,100            ,""                                 ,"Source-drain resistance per width" )
`MPRcz( RSW            ,50             ,"ohm(um)^(WR)"                     ,"Source resistance per width /* v4.0 " )
`MPRcz( RDW            ,50             ,"ohm(um)^(WR)"                     ,"Drain resistance per width /* v4.0 " )
`MPRcz( RSWMIN         ,0.0            ,"ohm(um)^(WR)"                     ,"Source resistance per width at high Vg" )
`MPRcz( RDWMIN         ,0.0            ,"ohm(um)^(WR)"                     ,"Drain resistance per width at hight Vg" )
`MPRnb( PRWG           ,0.0            ,"V^(-1/2)"                         ,"Gate-bias effect on parasitic resistance" )
`MPRnb( PRWB           ,0.0            ,"1/V"                              ,"Body-effect on parasitic resistance" )
`MPRnb( PRT            ,0.0            ,"ohm-um"                           ,"Temperature coefficient of parasitic resistance" )
`MPRnb( ETA0           ,0.08           ,""                                 ,"Subthreshold region DIBL coefficient for I-V" )
`MPRnb( ETAB           ,-0.07          ,"1/V"                              ,"Subthreshold region DIBL coefficient for I-V" )
`MPRnb( ETA0CV         ,ETA0           ,""                                 ,"Subthreshold region DIBL coefficient for C-V" )
`MPRnb( ETABCV         ,ETAB           ,"1/V"                              ,"Subthreshold region DIBL coefficient for C-V" )
`MPRnb( PCLM           ,1.3            ,""                                 ,"Channel length modulation Coefficient" )
`MPRnb( PDIBLC1        ,0.39           ,""                                 ,"Drain-induced barrier lowering coefficient" )
`MPRnb( PDIBLC2        ,0.0086         ,""                                 ,"Drain-induced barrier lowering coefficient" )
`MPRnb( PDIBLCB        ,0.0            ,""                                 ,"Body-effect on drain-induced barrier lowering" )
`MPRnb( PVAG           ,0.0            ,""                                 ,"Gate dependence of output resistance parameter" )
`MPRoz( TBOX           ,3e-7           ,"m"                                ,"Back gate oxide thickness in meters" )
`MPRoz( TSI            ,1e-7           ,"m"                                ,"Silicon-on-insulator thickness in meters" )
`MPRoz( ETSI           ,1e-7           ,"m"                                ,"Effective Silicon-on-insulator thickness in meters" )
`MPRoz( XJ             ,TSI            ,"m"                                ,"Junction Depth" )
`MPRnb( AGIDL          ,0.0            ,"1/ohm"                            ,"GIDL second parameter" )
`MPRnb( BGIDL          ,2.3e9          ,"V/m"                              ,"GIDL third parameter" )
`MPRnb( CGIDL          ,0.5            ,"V^3"                              ,"GIDL vb parameter" )
`MPRnb( RGIDL          ,1.0            ,""                                 ,"GIDL vg parameter" )
`MPRnb( KGIDL          ,0.0            ,"V"                                ,"GIDL vb parameter" )
`MPRnb( FGIDL          ,0.0            ,""                                 ,"GIDL vb parameter" )
`MPRnb( AGISL          ,AGIDL          ,"1/ohm"                            ,"GISL second parameter" )
`MPRnb( BGISL          ,BGIDL          ,"V/m"                              ,"GISL third parameter" )
`MPRnb( CGISL          ,CGIDL          ,"V^3"                              ,"GISL vb parameter" )
`MPRnb( RGISL          ,RGIDL          ,""                                 ,"GISL vg parameter" )
`MPRnb( KGISL          ,KGIDL          ,"V"                                ,"GISL vb parameter" )
`MPRnb( FGISL          ,FGIDL          ,"V"                                ,"GISL vb parameter" )
`MPRnb( NDIODE         ,1.0            ,""                                 ,"Diode non-ideality factor /*v4.0" )
`MPRnb( NDIODED        ,NDIODE         ,""                                 ,"Diode non-ideality factor /*v4.0" )
`MPRnb( XBJT           ,1.0            ,""                                 ,"Temperature coefficient for Isbjt" )
`MPRnb( XDIF           ,XBJT           ,""                                 ,"Temperature coefficient for Isdif" )
`MPRnb( XREC           ,1.0            ,""                                 ,"Temperature coefficient for Isrec" )
`MPRnb( XTUN           ,0.0            ,""                                 ,"Temperature coefficient for Istun" )
`MPRnb( XDIFD          ,XDIF           ,""                                 ,"Temperature coefficient for Iddif" )
`MPRnb( XRECD          ,XREC           ,""                                 ,"Temperature coefficient for Idrec" )
`MPRnb( XTUND          ,XTUN           ,""                                 ,"Temperature coefficient for Idtun" )
`MPRnb( PBSWG          ,0.7            ,"V"                                ,"Source(gate side) sidewall junction capacitance built in potential /* v4.0 " )
`MPRnb( PBSWGD         ,PBSWG          ,"V"                                ,"Drain(gate side) sidewall junction capacitance built in potential /* v4.0 " )
`MPRnb( MJSWG          ,0.5            ,"V"                                ,"Source (gate side) sidewall junction capacitance grading coefficient /* v4.0 " )
`MPRnb( MJSWGD         ,MJSWG          ,"V"                                ,"Drain (gate side) sidewall junction capacitance grading coefficient /* v4.0 " )
`MPRoz( CJSWG          ,1e-10          ,"F/m^2"                            ,"Source(gate side) sidewall junction capacitance per unit width /* v4.0 " )
`MPRoz( CJSWGD         ,CJSWG          ,"F/m^2"                            ,"Drain (gate side) sidewall junction capacitance per unit width /* v4.0 " )
`MPRnb( LINT           ,0.0            ,"m"                                ,"Length reduction parameter" )
`MPRnb( LL             ,0.0            ,"m"                                ,"Length reduction parameter" )
`MPRnb( LLC            ,0.0            ,""                                 ,"Length reduction parameter /* v2.2.3 " )
`MPRnb( LLN            ,1.0            ,""                                 ,"Length reduction parameter" )
`MPRnb( LW             ,0.0            ,"m"                                ,"Length reduction parameter" )
`MPRnb( LWC            ,0.0            ,""                                 ,"Length reduction parameter /* v2.2.3 " )
`MPRnb( LWN            ,1.0            ,""                                 ,"Length reduction parameter" )
`MPRnb( LWL            ,0.0            ,""                                 ,"Length reduction parameter" )
`MPRnb( LWLC           ,0.0            ,""                                 ,"Length reduction parameter /* v2.2.3 " )
`MPRnb( WR             ,1.0            ,""                                 ,"Width dependence of rds" )
`MPRnb( WINT           ,0.0            ,"m"                                ,"Width reduction parameter" )
`MPRnb( DWG            ,0.0            ,"m/V"                              ,"Width reduction parameter" )
`MPRnb( DWB            ,0.0            ,"m/V^1/2"                          ,"Width reduction parameter" )
`MPRnb( WL             ,0.0            ,"m"                                ,"Width reduction parameter" )
`MPRnb( WLC            ,0.0            ,""                                 ,"Width reduction parameter /* v2.2.3 " )
`MPRnb( WLN            ,1.0            ,""                                 ,"Width reduction parameter" )
`MPRnb( WW             ,0.0            ,"m"                                ,"Width reduction parameter" )
`MPRnb( WWC            ,0.0            ,""                                 ,"Width reduction parameter /* v2.2.3 " )
`MPRnb( WWN            ,1.0            ,""                                 ,"Width reduction parameter" )
`MPRnb( WWL            ,0.0            ,"m"                                ,"Width reduction parameter" )
`MPRnb( WWLC           ,0.0            ,""                                 ,"Width reduction parameter /* v2.2.3 " )
`MPRnb( B0             ,0.0            ,"m"                                ,"Abulk narrow width parameter" )
`MPRnb( B1             ,0.0            ,"m"                                ,"Abulk narrow width parameter" )
`MPRnb( CGSL           ,0.0            ,"F/m"                              ,"New C-V model parameter" )
`MPRnb( CGDL           ,0.0            ,"F/m"                              ,"New C-V model parameter" )
`MPRoz( CKAPPA         ,0.6            ,"F/m"                              ,"New C-V model parameter" )
`MPRnb( CF             ,0.0            ,"F/m"                              ,"Fringe capacitance parameter" )
`MPRnb( CLC            ,0.1e-7         ,"m"                                ,"Vdsat parameter for C-V model" )
`MPRnb( CLE            ,0.0            ,""                                 ,"Vdsat parameter for C-V model" )
`MPRnb( DWC            ,WINT           ,"m"                                ,"Delta W for C-V model" )
`MPRnb( DLC            ,LINT           ,"m"                                ,"Delta L for C-V model" )
`MPRnb( ALPHA0         ,0.0            ,"m/V"                              ,"substrate current model parameter" )
`MPRnb( NOIA           ,((TYPE == `NMOS) ? 6.25e41 : 6.188e40),""          ,"Flicker noise parameter" )
`MPRnb( NOIB           ,((TYPE == `NMOS) ? 3.125e26 : 1.5e25),""           ,"Flicker noise parameter" )
`MPRnb( NOIC           ,8.75e9         ,""                                 ,"Flicker noise parameter" )
`MPIcc( FNOIMOD        ,1              ,""          ,0          ,1         ,"Flicker noise model selector" )
`MPIcc( TNOIMOD        ,0              ,""          ,0          ,3         ,"Thermal noise model selector" )

//Parameters controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
`MPRnb( TNOIC          ,3.5            ,""                                 ,"Thermal noise parameter for TNOIMOD=3" )
`MPRnb( RNOIC          ,0.395          ,""                                 ,"Thermal noise coefficient for TNOIMOD=3" )

`MPRnb( SCALEN         ,1e5            ,""                                 ,"" )
`endif

//parameter integer NOIMOD   = 1 from [1:4]; // carry-over from v. 3.x
`MPRnb( TNOIA          ,1.5            ,""                                 ,"Thermal noise parameter" )
`MPRnb( TNOIB          ,3.5            ,""                                 ,"Thermal noise parameter" )
`MPRnb( RNOIA          ,0.577          ,""                                 ,"Thermal noise coefficient" )
`MPRnb( RNOIB          ,0.37           ,""                                 ,"Thermal noise coefficient" )
`MPRcz( NTNOI          ,1.0            ,""                                 ,"Thermal noise parameter" )
`MPRoz( SAREF          ,1e-6           ,"m"                                ,"Reference distance between OD edge to poly of one side" )
`MPRoz( SBREF          ,1e-6           ,"m"                                ,"Reference distance between OD edge to poly of the other side" )
`MPRnb( WLOD           ,0.0            ,"m"                                ,"Width parameter for stress effect" )
`MPRnb( KU0            ,0.0            ,"m"                                ,"Mobility degradation/enhancement coefficient for LOD" )
`MPRnb( KVSAT          ,0.0            ,"m"                                ,"Saturation velocity degradation/enhancement parameter for LOD" )
`MPRnb( KVTH0          ,0.0            ,"Vm"                               ,"Threshold degradation/enhancement parameter for LOD" )
`MPRnb( TKU0           ,0.0            ,""                                 ,"Temperature coefficient of KU0" )
`MPRnb( LLODKU0        ,0.0            ,""                                 ,"Length parameter for u0 LOD effect" )
`MPRnb( WLODKU0        ,0.0            ,""                                 ,"Width parameter for u0 LOD effect" )
`MPRnb( LLODVTH        ,0.0            ,""                                 ,"Length parameter for vth LOD effect" )
`MPRnb( WLODVTH        ,0.0            ,""                                 ,"Width parameter for vth LOD effect" )
`MPRnb( LKU0           ,0.0            ,""                                 ,"Length dependence of ku0" )
`MPRnb( WKU0           ,0.0            ,""                                 ,"Width dependence of ku0" )
`MPRnb( PKU0           ,0.0            ,""                                 ,"Cross-term dependence of ku0" )
`MPRnb( LKVTH0         ,0.0            ,""                                 ,"Length dependence of kvth0" )
`MPRnb( WKVTH0         ,0.0            ,""                                 ,"Width dependence of kvth0" )
`MPRnb( PKVTH0         ,0.0            ,""                                 ,"Cross-term dependence of kvth0" )
`MPRnb( STK2           ,0.0            ,"m"                                ,"K2 shift factor related to stress effect on vth" )
`MPRnb( LODK2          ,1.0            ,""                                 ,"K2 shift modification factor for stress effect" )
`MPRnb( STETA0         ,0.0            ,"m"                                ,"eta0 shift factor related to stress effect on vth" )
`MPRnb( LODETA0        ,1.0            ,""                                 ,"eta0 shift modification factor for stress effect" )
`MPRnb( STETA0CV       ,STETA0         ,""                                 ,"eta0cv shift factor related to stress effect on vth" )
`MPRnb( LODETA0CV      ,LODETA0        ,""                                 ,"eta0cv shift modification factor for stress effect" )
`MPRnb( GBMIN          ,1.0e-12        ,"1/ohm"                            ,"Minimum body conductance" )
`MPRnb( BF             ,2.0            ,""                                 ,"Flicker noise length dependence exponent" )
`MPRnb( W0FLK          ,10.0e-6        ,""                                 ,"Flicker noise width dependence" )
`MPRnb( DVTP0          ,0.0            ,"m"                                ,"First parameter for Vth shift due to pocket" )
`MPRnb( LDVTP0         ,0.0            ,""                                 ,"Length dependence of dvtp0" )
`MPRnb( WDVTP0         ,0.0            ,""                                 ,"Width dependence of dvtp0" )
`MPRnb( PDVTP0         ,0.0            ,""                                 ,"Cross-term dependence of dvtp0" )
`MPRnb( DVTP1          ,0.0            ,"1/V"                              ,"Second parameter for Vth shift due to pocket" )
`MPRnb( LDVTP1         ,0.0            ,""                                 ,"Length dependence of dvtp1" )
`MPRnb( WDVTP1         ,0.0            ,""                                 ,"Width dependence of dvtp1" )
`MPRnb( PDVTP1         ,0.0            ,""                                 ,"Cross-term dependence of dvtp1" )
`MPRnb( DVTP2          ,0.0            ,""                                 ,"Third parameter for Vth shift due to pocket" )
`MPRnb( LDVTP2         ,0.0            ,""                                 ,"Length dependence of dvtp2" )
`MPRnb( WDVTP2         ,0.0            ,""                                 ,"Width dependence of dvtp2" )
`MPRnb( PDVTP2         ,0.0            ,""                                 ,"Cross-term dependence of dvtp2" )
`MPRnb( DVTP3          ,0.0            ,"1/V"                              ,"Third parameter for Vth shift due to pocket" )
`MPRnb( LDVTP3         ,0.0            ,""                                 ,"Length dependence of dvtp3" )
`MPRnb( WDVTP3         ,0.0            ,""                                 ,"Width dependence of dvtp3" )
`MPRnb( PDVTP3         ,0.0            ,""                                 ,"Cross-term dependence of dvtp3" )
`MPRnb( DVTP4          ,0.0            ,"1/V"                              ,"Forth parameter for Vth shift due to pocket" )
`MPRnb( LDVTP4         ,0.0            ,""                                 ,"Length dependence of dvtp4" )
`MPRnb( WDVTP4         ,0.0            ,""                                 ,"Width dependence of dvtp4" )
`MPRnb( PDVTP4         ,0.0            ,""                                 ,"Cross-term dependence of dvtp4" )
`MPRnb( MINV           ,0.0            ,""                                 ,"For moderate inversion in Vgsteff" )
`MPRnb( LMINV          ,0.0            ,""                                 ,"Length dependence of minv" )
`MPRnb( WMINV          ,0.0            ,""                                 ,"width dependence of minv" )
`MPRnb( PMINV          ,0.0            ,""                                 ,"Cross-term dependence of minv" )
`MPRnb( PDITS          ,1e-20          ,"1/V"                              ,"Coefficient for drain-induced Vth shifts" )
`MPRnb( PDITSL         ,0.0            ,"1/m"                              ,"Length dependence of drain-induced Vth shifts" )
`MPRnb( PDITSD         ,0.0            ,"1/V"                              ,"Vds dependence of drain-induced Vth shifts" )
`MPRnb( FPROUT         ,0.0            ,"Vm^1/2"                           ,"Rout degradation coefficient for pocket devices" )
`MPRnb( LFPROUT        ,0.0            ,""                                 ,"Length dependence of pdiblcb" )
`MPRnb( LPDITS         ,0.0            ,""                                 ,"Length dependence of pdits" )
`MPRnb( LPDITSD        ,0.0            ,""                                 ,"Length dependence of pditsd" )
`MPRnb( WFPROUT        ,0.0            ,""                                 ,"Width dependence of pdiblcb" )
`MPRnb( WPDITS         ,0.0            ,""                                 ,"Width dependence of pdits" )
`MPRnb( WPDITSD        ,0.0            ,""                                 ,"Width dependence of pditsd" )
`MPRnb( PFPROUT        ,0.0            ,""                                 ,"Cross-term dependence of pdiblcb" )
`MPRnb( PPDITS         ,0.0            ,""                                 ,"Cross-term dependence of pdits" )
`MPRnb( PPDITSD        ,0.0            ,""                                 ,"Cross-term dependence of pditsd" )
`MPRnb( EM             ,4.1e7          ,"V/m"                              ,"Flicker noise parameter" )
`MPRnb( EF             ,1.0            ,""                                 ,"Flicker noise frequency exponent" )
`MPRnb( AF             ,1.0            ,""                                 ,"Flicker noise exponent" )
`MPRnb( KF             ,0.0            ,""                                 ,"Flicker noise coefficient" )
`MPRco( NOIF           ,1.0            ,""          ,0          ,inf       ,"Floating body excess noise ideality factor" )
`MPRnb( K1W1           ,0.0            ,"m"                                ,"First Body effect width dependent parameter" )
`MPRnb( K1W2           ,0.0            ,"m"                                ,"Second Body effect width dependent parameter" )
`MPRnb( KETAS          ,0.0            ,"V"                                ,"Surface potential adjustment for bulk charge effect" )
`MPRnb( DWBC           ,0.0            ,"m"                                ,"Width offset for body contact isolation edge" )
`MPRnb( BETA0          ,0.0            ,"1/V"                              ,"First Vds dependent parameter of impact ionization current" )
`MPRnb( BETA1          ,0.0            ,""                                 ,"Second Vds dependent parameter of impact ionization current" )
`MPRnb( BETA2          ,0.1            ,"V"                                ,"Third Vds dependent parameter of impact ionization current" )
`MPRnb( VDSATII0       ,0.9            ,""                                 ,"Nominal drain saturation voltage at threshold for impact ionization current" )
`MPRnb( TII            ,0.0            ,""                                 ,"Temperature dependent parameter for impact ionization" )
`MPRnb( LII            ,0.0            ,""                                 ,"Channel length dependent parameter at threshold for impact ionization current" )
`MPRnb( SII0           ,0.5            ,""                                 ,"First Vgs dependent parameter for impact ionization current" )
`MPRnb( SII1           ,0.1            ,""                                 ,"Second Vgs dependent parameter for impact ionization current" )
`MPRnb( SII2           ,0.0            ,""                                 ,"Third Vgs dependent parameter for impact ionization current" )
`MPRnb( SIID           ,0.0            ,""                                 ,"Vds dependent parameter of drain saturation voltage for impact ionization current" )
`MPRnb( FBJTII         ,0.0            ,""                                 ,"Fraction of bipolar current affecting the impact ionization" )
`MPRnb( EBJTII         ,0.0            ,""                                 ,"Impact ionization parameter for BJT part" )
`MPRnb( CBJTII         ,0.0            ,"m"                                ,"Length scaling parameter for II BJT part" )
`MPRnb( VBCI           ,0.0            ,"V"                                ,"Internal B-C built-in potential" )
`MPRnb( ABJTII         ,0.0            ,"1/V"                              ,"Exponent factor for avalanche current" )
`MPRnb( MBJTII         ,0.4            ,""                                 ,"Internal B-C grading coefficient" )
`MPRnb( TVBCI          ,0.0            ,""                                 ,"Temperature coefficient for VBCI" )
`MPRnb( ESATII         ,1e7            ,"V/m"                              ,"Saturation electric field for impact ionization" )
`MPRcz( NTUN           ,10.0           ,""                                 ,"Reverse tunneling non-ideality factor" )
`MPRcz( NTUND          ,NTUN           ,""                                 ,"Reverse tunneling non-ideality factor" )
`MPRcz( NRECF0         ,2.0            ,""                                 ,"Recombination non-ideality factor at forward bias" )
`MPRcz( NRECF0D        ,NRECF0         ,""                                 ,"Recombination non-ideality factor at forward bias" )
`MPRcz( NRECR0         ,10.0           ,""                                 ,"Recombination non-ideality factor at reversed bias" )
`MPRcz( NRECR0D        ,NRECR0         ,""                                 ,"Recombination non-ideality factor at reversed bias" )
`MPRcz( ISBJT          ,1e-6           ,"A/m^2"                            ,"BJT injection saturation current" )
`MPRcz( IDBJT          ,ISBJT          ,"A/m^2"                            ,"BJT injection saturation current" )
`MPRcz( ISDIF          ,0.0            ,"A/m^2"                            ,"Body to source/drain injection saturation current" )
`MPRcz( IDDIF          ,ISDIF          ,"A/m^2"                            ,"Body to source/drain injection saturation current /* v4.0 " )
`MPRcz( ISREC          ,1e-5           ,"A/m^2"                            ,"Recombination in depletion saturation current" )
`MPRcz( IDREC          ,ISREC          ,"A/m^2"                            ,"Recombination in depletion saturation current" )
`MPRcz( ISTUN          ,0.0            ,"A/m^2"                            ,"Reverse tunneling saturation current" )
`MPRcz( IDTUN          ,ISTUN          ,"A/m^2"                            ,"Reverse tunneling saturation current" )
`MPRcz( LN             ,2e-6           ,"m"                                ,"Electron/hole diffusion length" )
`MPRnb( VREC0          ,0.0            ,"V"                                ,"Voltage dependent parameter for recombination current" )
`MPRnb( VREC0D         ,VREC0          ,"V"                                ,"Voltage dependent parameter for recombination current" )
`MPRnb( VTUN0          ,0.0            ,"V"                                ,"Voltage dependent parameter for tunneling current" )
`MPRnb( VTUN0D         ,VTUN0          ,"V"                                ,"Voltage dependent parameter for tunneling current" )
`MPRnb( NBJT           ,1.0            ,""                                 ,"Power coefficient of channel length dependency for bipolar current" )
`MPRnb( LBJT0          ,0.20e-6        ,"m"                                ,"Reference channel length for bipolar current" )
`MPRnb( LDIF0          ,1.0            ,""                                 ,"Channel-length dependency coefficient of diffusion cap" )
`MPRnb( VABJT          ,10.0           ,"V"                                ,"Early voltage for bipolar current" )
`MPRnb( AELY           ,0.0            ,"V/m"                              ,"Channel length dependency of early voltage for bipolar current" )
`MPRnb( AHLI           ,0.0            ,""                                 ,"High level injection parameter for bipolar current /* v4.0 " )
`MPRnb( AHLID          ,AHLI           ,""                                 ,"High level injection parameter for bipolar current /* v4.0 " )
`MPRnb( RBODY          ,0.0            ,"ohm/square"                       ,"Intrinsic body contact sheet resistance" )
`MPRnb( RBSH           ,0.0            ,"ohm/square"                       ,"Extrinsic body contact sheet resistance" )
`MPRnb( CGEO           ,0.0            ,"F/m"                              ,"Gate substrate overlap capacitance per unit channel length" )
`MPRcz( TT             ,1e-12          ,"s"                                ,"Diffusion capacitance transit time coefficient" )
`MPRnb( NDIF           ,-1.0           ,""                                 ,"Power coefficient of channel length dependency for diffusion capacitance" )
`MPRnb( VSDFB          ,0.0            ,"V"                                ,"Source/drain bottom diffusion capacitance flatband voltage" )
`MPRnb( VSDTH          ,0.0            ,"V"                                ,"Source/drain bottom diffusion capacitance threshold voltage" )
`MPRnb( CSDMIN         ,0.0            ,"V"                                ,"Source/drain bottom diffusion minimum capacitance" )
`MPRoz( ASD            ,0.3            ,""                                 ,"Source/drain bottom diffusion smoothing parameter" )
`MPRnb( CSDESW         ,0.0            ,"F/m"                              ,"Source/drain sidewall fringing capacitance per unit length" )
`MPRnb( NTRECF         ,0.0            ,""                                 ,"Temperature coefficient for Nrecf" )
`MPRnb( NTRECR         ,0.0            ,""                                 ,"Temperature coefficient for Nrecr" )
`MPRnb( DLCB           ,0.0            ,"m"                                ,"Length offset fitting parameter for body charge" )
`MPRnb( FBODY          ,1.0            ,""                                 ,"Scaling factor for body charge" )
`MPRnb( TCJSWG         ,0.0            ,"1/K"                              ,"Temperature coefficient of Cjswgs" )
`MPRnb( TPBSWG         ,0.0            ,"V/K"                              ,"Temperature coefficient of Pbswgs" )
`MPRnb( TCJSWGD        ,TCJSWG         ,"1/K"                              ,"Temperature coefficient of Cjswgd" )
`MPRnb( TPBSWGD        ,TPBSWG         ,"V/K"                              ,"Temperature coefficient of Pbswgd" )
`MPRnb( ACDE           ,1.0            ,"m/V"                              ,"Exponential coefficient for charge thickness in capMod=3 for accumulation and depletion regions" )
`MPRnb( MOIN           ,15.0           ,"V^1/2"                            ,"Coefficient for the gate-bias dependent surface potential" )
`MPRoz( NOFF           ,1.0            ,""                                 ,"C-V turn-on/off parameter /* v3.2 " )
`MPRoz( NOFF2          ,NOFF           ,""                                 ,"C-V turn-on/off parameter /* v4.6 " ) /* 2015enh2 */
`MPRnb( DELVT          ,0.0            ,"V"                                ,"Threshold voltage adjust for CV" )
`MPRnb( KB1            ,1.0            ,""                                 ,"Scaling factor for backgate charge" )
`MPRnb( DLBG           ,0.0            ,"m"                                ,"Length offset fitting parameter for backgate charge" )
`MPRnb( CFRCOEFF       ,1.0            ,""                                 ,"Fringe Cap parameter /* v4.4 " )
`MPInb( IGBMOD         ,0              ,""                                 ,"gate-body tunneling current model selector /* v3.0 " )
`MPInb( IGMOD          ,IGBMOD         ,""                                 ,"gate-body tunneling current model selector /* v3.1.1 " )
`MPInb( IGCMOD         ,0              ,""                                 ,"gate-channel tunneling current model selector /* v3.0 " )
`MPRnb( TOXQM          ,TOX            ,"m"                                ,"effective oxide thickness considering quantum effect" )
`MPRnb( WTH0           ,0.0            ,"m"                                ,"Minimum width for thermal resistance calculation" )
`MPRnb( RHALO          ,1e15           ,"ohm/m"                            ,"body halo sheet resistance" )
`MPRnb( NTOX           ,1              ,""                                 ,"power term of gate current" )
`MPRcz( TOXREF         ,2.5e-9         ,"m"                                ,"target oxide thickness" )
`MPRnb( EBG            ,1.2            ,"eV"                               ,"effective bandgap in gate current calculation" )
`MPRoz( VEVB           ,0.075          ,""                                 ,"Vaux parameter for valence-band electron tunneling" )
`MPRnb( ALPHAGB1       ,0.35           ,"1/V"                              ,"First Vox dependent parameter for gate current in inversion" )
`MPRnb( BETAGB1        ,0.03           ,"1/V^2"                            ,"Second Vox dependent parameter for gate current in inversion" )
`MPRnb( VGB1           ,300            ,"V"                                ,"Third Vox dependent parameter for gate current in inversion" )
`MPRoz( VECB           ,0.026          ,""                                 ,"Vaux parameter for conduction-band electron tunneling" )
`MPRnb( ALPHAGB2       ,0.43           ,"1/V"                              ,"First Vox dependent parameter for gate current in accumulation" )
`MPRnb( BETAGB2        ,0.05           ,"1/V^2"                            ,"Second Vox dependent parameter for gate current in accumulation" )
`MPRnb( VGB2           ,17             ,"V"                                ,"Third Vox dependent parameter for gate current in accumulation" )
`MPRnb( AIGBCP2        ,0.043          ,"1/V^2"                            ,"First Vgp dependent parameter for gate current in accumulation in AGBCP2 region" )
`MPRnb( BIGBCP2        ,0.0054         ,"1/V^2"                            ,"Second Vgp dependent parameter for gate current in accumulation in AGBCP2 region" )
`MPRnb( CIGBCP2        ,0.0075         ,"1/V^2"                            ,"Third Vgp dependent parameter for gate current in accumulation in AGBCP2 region" )
`MPRnb( VOXH           ,5.0            ,"V"                                ,"the limit of Vox in gate current calculation" )
`MPRnb( DELTAVOX       ,0.005          ,""                                 ,"the smoothing parameter in the Vox smoothing function" )
`MPRnb( AIGC           ,((TYPE == `NMOS) ? 0.43 : 0.31)      ,""           ,"Parameter for Igc" )
`MPRnb( BIGC           ,((TYPE == `NMOS) ? 0.054 : 0.024)    ,""           ,"Parameter for Igc" )
`MPRnb( CIGC           ,((TYPE == `NMOS) ? 0.075 : 0.03)     ,""           ,"Parameter for Igc" )
`MPRnb( AIGSD          ,((TYPE == `NMOS) ? 0.43 : 0.31)      ,""           ,"Parameter for Igs,d" )
`MPRnb( BIGSD          ,((TYPE == `NMOS) ? 0.054 : 0.024)    ,""           ,"Parameter for Igs,d" )
`MPRnb( CIGSD          ,((TYPE == `NMOS) ? 0.075 : 0.03)     ,""           ,"Parameter for Igs,d" )
`MPRnb( NIGC           ,1.0            ,""                                 ,"Parameter for Igc slope" )
`MPRnb( PIGCD          ,1.0            ,""                                 ,"Parameter for Igc partition" )
`MPRnb( POXEDGE        ,1.0            ,""                                 ,"Factor for the gate edge Tox" )
`MPRnb( DLCIG          ,LINT           ,"m"                                ,"Delta L for Ig model" )
`MPRnb( VBS0PD         ,0.0            ,"V"                                ,"Upper bound of built-in potential lowering for PD operation /* v3.2 " )
`MPRnb( VBS0FD         ,0.5            ,"V"                                ,"Lower bound of built-in potential lowering for FD operation /* v3.2 " )
`MPRnb( VBSA           ,0.0            ,"V"                                ,"vbsa offset voltage" )
`MPRnb( NOFFFD         ,1.0            ,""                                 ,"smoothing parameter in FD module" )
`MPRnb( VOFFFD         ,0.0            ,"V"                                ,"smoothing parameter in FD module" )
`MPRnb( K1B            ,1.0            ,""                                 ,"first backgate body effect parameter" )
`MPRnb( K2B            ,0.0            ,""                                 ,"second backgate body effect parameter for short channel effect" )
`MPRnb( DK2B           ,0.0            ,""                                 ,"third backgate body effect parameter for short channel effect" )
`MPRnb( DVBD0          ,0.0            ,""                                 ,"first short-channel effect parameter in FD module" )
`MPRnb( DVBD1          ,0.0            ,""                                 ,"second short-channel effect parameter in FD module" )
`MPRnb( MOINFD         ,1e3            ,""                                 ,"Coefficient for the gate-bias dependent surface potential in FD" )
`MPRnb( XRCRG1         ,12.0           ,""                                 ,"First fitting parameter the bias-dependent Rg" )
`MPRnb( XRCRG2         ,1.0            ,""                                 ,"Second fitting parameter the bias-dependent Rg" )
`MPRnb( RSHG           ,0.1            ,"ohm/square"                       ,"Gate sheet resistance" )
`MPRco( NGCON          ,1.0            ,""         ,1           ,inf       ,"Number of gate contacts" )
`MPRnb( XGW            ,0.0            ,"m"                                ,"Distance from gate contact center to device edge" )
`MPRnb( XGL            ,0.0            ,"m"                                ,"Variation in Ldrawn" )
`MPInb( RDSMOD         ,0              ,""                                 ,"Bias-dependent S/D resistance model selector /* v4.0 " )
`MPInb( FDMOD          ,0              ,""                                 ,"Improved dVbi model selector" )
`MPRnb( VSCE           ,0.0            ,""                                 ,"SCE parameter for improved dVbi model" )
`MPRnb( CDSBS          ,0.0            ,""                                 ,"coupling from Vd to Vbs for improved dVbi model" )
`MPRnb( MINVCV         ,0.0            ,""                                 ,"For moderate inversion in VgsteffCV" )
`MPRnb( LMINVCV        ,0.0            ,""                                 ,"Length dependence of minvcv" )
`MPRnb( WMINVCV        ,0.0            ,""                                 ,"width dependence of minvcv" )
`MPRnb( PMINVCV        ,0.0            ,""                                 ,"Cross-term dependence of minvcv" )
`MPRnb( VOFFCV         ,0.0            ,"V"                                ,"CV Threshold voltage offset // NOT -0.08 for backwards-compatibility" )
`MPRnb( LVOFFCV        ,0.0            ,""                                 ,"Length dependence of voffcv" )
`MPRnb( WVOFFCV        ,0.0            ,""                                 ,"Width dependence of voffcv" )
`MPRnb( PVOFFCV        ,0.0            ,""                                 ,"Cross-term dependence of voffcv" )
`MPRnb( LXJ            ,0.0            ,""                                 ,"Length dependence of xj" )
`MPRnb( LALPHAGB1      ,0.0            ,""                                 ,"Length dependence of alphagb1" )
`MPRnb( LBETAGB1       ,0.0            ,""                                 ,"Length dependence of betagb1" )
`MPRnb( LALPHAGB2      ,0.0            ,""                                 ,"Length dependence of alphagb2" )
`MPRnb( LBETAGB2       ,0.0            ,""                                 ,"Length dependence of betagb2" )
`MPRnb( LAIGBCP2       ,0.0            ,""                                 ,"Length dependence of aigbcp2" )
`MPRnb( LBIGBCP2       ,0.0            ,""                                 ,"Length dependence of bigbcp2" )
`MPRnb( LCIGBCP2       ,0.0            ,""                                 ,"Length dependence of cigbcp2" )
`MPRnb( LCGSL          ,0.0            ,""                                 ,"Length dependence of cgsl" )
`MPRnb( LCGDL          ,0.0            ,""                                 ,"Length dependence of cgdl" )
`MPRnb( LCKAPPA        ,0.0            ,""                                 ,"Length dependence of ckappa" )
`MPRnb( LNDIF          ,0.0            ,""                                 ,"Length dependence of ndif" )
`MPRnb( LUTE           ,0.0            ,""                                 ,"Length dependence of ute" )
`MPRnb( LKT1           ,0.0            ,""                                 ,"Length dependence of kt1" )
`MPRnb( LKT1L          ,0.0            ,""                                 ,"Length dependence of kt1l" )
`MPRnb( LKT2           ,0.0            ,""                                 ,"Length dependence of kt2" )
`MPRnb( LUA1           ,0.0            ,""                                 ,"Length dependence of ua1" )
`MPRnb( LUB1           ,0.0            ,""                                 ,"Length dependence of ub1" )
`MPRnb( LUC1           ,0.0            ,""                                 ,"Length dependence of uc1" )
`MPRnb( LAT            ,0.0            ,""                                 ,"Length dependence of at" )
`MPRnb( LPRT           ,0.0            ,""                                 ,"Length dependence of prt" )
`MPRnb( LNTRECF        ,0.0            ,""                                 ,"Length dependence of ntrecf" )
`MPRnb( LNTRECR        ,0.0            ,""                                 ,"Length dependence of ntrecr" )
`MPRnb( LXBJT          ,0.0            ,""                                 ,"Length dependence of xbjt" )
`MPRnb( LXDIF          ,0.0            ,""                                 ,"Length dependence of xdif" )
`MPRnb( LXREC          ,0.0            ,""                                 ,"Length dependence of xrec" )
`MPRnb( LXTUN          ,0.0            ,""                                 ,"Length dependence of xtun" )
`MPRnb( LXDIFD         ,LXDIF          ,""                                 ,"Length dependence of xdifd" )
`MPRnb( LXRECD         ,LXREC          ,""                                 ,"Length dependence of xrecd" )
`MPRnb( LXTUND         ,LXTUN          ,""                                 ,"Length dependence of xtund" )
`MPRnb( LAIGC          ,0.0            ,""                                 ,"Length dependence of aigc" )
`MPRnb( LBIGC          ,0.0            ,""                                 ,"Length dependence of bigc" )
`MPRnb( LCIGC          ,0.0            ,""                                 ,"Length dependence of cigc" )
`MPRnb( LAIGSD         ,0.0            ,""                                 ,"Length dependence of aigsd" )
`MPRnb( LBIGSD         ,0.0            ,""                                 ,"Length dependence of bigsd" )
`MPRnb( LCIGSD         ,0.0            ,""                                 ,"Length dependence of cigsd" )
`MPRnb( LNIGC          ,0.0            ,""                                 ,"Length dependence of nigc" )
`MPRnb( LPIGCD         ,0.0            ,""                                 ,"Length dependence for pigcd" )
`MPRnb( LPOXEDGE       ,0.0            ,""                                 ,"Length dependence for poxedge" )
`MPRnb( LNCH           ,0.0            ,""                                 ,"Length dependence of nch" )
`MPRnb( LNSUB          ,0.0            ,""                                 ,"Length dependence of nsub" )
`MPRnb( LNGATE         ,0.0            ,""                                 ,"Length dependence of ngate" )
`MPRnb( LNSD           ,0.0            ,""                                 ,"Length dependence of nsd" )
`MPRnb( LVTH0          ,0.0            ,""                                 ,"Length dependence of vto" )
`MPRnb( LVFB           ,0.0            ,""                                 ,"Length dependence of vfb /* v4.1 " )
`MPRnb( LK1            ,0.0            ,""                                 ,"Length dependence of k1" )
`MPRnb( LK1W1          ,0.0            ,""                                 ,"Length dependence of k1w1" )
`MPRnb( LK1W2          ,0.0            ,""                                 ,"Length dependence of k1w2" )
`MPRnb( LK2            ,0.0            ,""                                 ,"Length dependence of k2" )
`MPRnb( LK3            ,0.0            ,""                                 ,"Length dependence of k3" )
`MPRnb( LK3B           ,0.0            ,""                                 ,"Length dependence of k3b" )
`MPRnb( LKB1           ,0.0            ,""                                 ,"Length dependence of kb1" )
`MPRnb( LW0            ,0.0            ,""                                 ,"Length dependence of w0" )
`MPRnb( LLPEB          ,0.0            ,""                                 ,"Length dependence of lpeb" )
`MPRnb( LDVT0          ,0.0            ,""                                 ,"Length dependence of dvt0" )
`MPRnb( LDVT1          ,0.0            ,""                                 ,"Length dependence of dvt1" )
`MPRnb( LDVT2          ,0.0            ,""                                 ,"Length dependence of dvt2" )
`MPRnb( LDVT0W         ,0.0            ,""                                 ,"Length dependence of dvt0w" )
`MPRnb( LDVT1W         ,0.0            ,""                                 ,"Length dependence of dvt1w" )
`MPRnb( LDVT2W         ,0.0            ,""                                 ,"Length dependence of dvt2w" )
`MPRnb( LU0            ,0.0            ,""                                 ,"Length dependence of u0" )
`MPRnb( LEU            ,0.0            ,""                                 ,"Length dependence of eu" )
`MPRnb( LUA            ,0.0            ,""                                 ,"Length dependence of ua" )
`MPRnb( LUB            ,0.0            ,""                                 ,"Length dependence of ub" )
`MPRnb( LUC            ,0.0            ,""                                 ,"Length dependence of uc" )
`MPRnb( LUD            ,0.0            ,""                                 ,"Length dependence of ud" )
`MPRnb( LUD1           ,0.0            ,""                                 ,"Length dependence of ud1" )
`MPRnb( LUCSTE         ,0.0            ,""                                 ,"Length dependence of ucste" )
`MPRnb( LUCS           ,0.0            ,""                                 ,"Length dependence of lucs" )
`MPRnb( LVSAT          ,0.0            ,""                                 ,"Length dependence of vsat" )
`MPRnb( LA0            ,0.0            ,""                                 ,"Length dependence of a0" )
`MPRnb( LAGS           ,0.0            ,""                                 ,"Length dependence of ags" )
`MPRnb( LB0            ,0.0            ,""                                 ,"Length dependence of b0" )
`MPRnb( LB1            ,0.0            ,""                                 ,"Length dependence of b1" )
`MPRnb( LKETA          ,0.0            ,""                                 ,"Length dependence of keta" )
`MPRnb( LKETAS         ,0.0            ,""                                 ,"Length dependence of ketas" )
`MPRnb( LA1            ,0.0            ,""                                 ,"Length dependence of a1" )
`MPRnb( LA2            ,0.0            ,""                                 ,"Length dependence of a2" )
`MPRnb( LRDSW          ,0.0            ,""                                 ,"Length dependence of rdsw" )
`MPRnb( LRSW           ,0.0            ,""                                 ,"Length dependence of rsw /* v4.0 " )
`MPRnb( LRDW           ,0.0            ,""                                 ,"Length dependence of rdw /* v4.0 " )
`MPRnb( LPRWB          ,0.0            ,""                                 ,"Length dependence of prwb" )
`MPRnb( LPRWG          ,0.0            ,""                                 ,"Length dependence of prwg" )
`MPRnb( LWR            ,0.0            ,""                                 ,"Length dependence of wr" )
`MPRnb( LNFACTOR       ,0.0            ,""                                 ,"Length dependence of nfactor" )
`MPRnb( LDWG           ,0.0            ,""                                 ,"Length dependence of dwg" )
`MPRnb( LDWB           ,0.0            ,""                                 ,"Length dependence of dwb" )
`MPRnb( LVOFF          ,0.0            ,""                                 ,"Length dependence of voff" )
`MPRnb( LETA0          ,0.0            ,""                                 ,"Length dependence of eta0" )
`MPRnb( LETAB          ,0.0            ,""                                 ,"Length dependence of etab" )
`MPRnb( LETA0CV        ,LETA0          ,""                                 ,"Length dependence of eta0cv" )
`MPRnb( LETABCV        ,LETAB          ,""                                 ,"Length dependence of etabcv" )
`MPRnb( LDSUB          ,0.0            ,""                                 ,"Length dependence of dsub" )
`MPRnb( LCIT           ,0.0            ,""                                 ,"Length dependence of cit" )
`MPRnb( LCDSC          ,0.0            ,""                                 ,"Length dependence of cdsc" )
`MPRnb( LCDSCB         ,0.0            ,""                                 ,"Length dependence of cdscb" )
`MPRnb( LCDSCD         ,0.0            ,""                                 ,"Length dependence of cdscd" )
`MPRnb( LPCLM          ,0.0            ,""                                 ,"Length dependence of pclm" )
`MPRnb( LPDIBLC1       ,0.0            ,""                                 ,"Length dependence of pdiblc1" )
`MPRnb( LPDIBLC2       ,0.0            ,""                                 ,"Length dependence of pdiblc2" )
`MPRnb( LPDIBLCB       ,0.0            ,""                                 ,"Length dependence of pdiblcb" )
`MPRnb( LDROUT         ,0.0            ,""                                 ,"Length dependence of drout" )
`MPRnb( LPVAG          ,0.0            ,""                                 ,"Length dependence of pvag" )
`MPRnb( LDELTA         ,0.0            ,""                                 ,"Length dependence of delta" )
`MPRnb( LALPHA0        ,0.0            ,""                                 ,"Length dependence of alpha0" )
`MPRnb( LFBJTII        ,0.0            ,""                                 ,"Length dependence of fbjtii" )
`MPRnb( LABJTII        ,0.0            ,""                                 ,"Length dependence of abjtii" )
`MPRnb( LCBJTII        ,0.0            ,""                                 ,"Length dependence of cbjtii" )
`MPRnb( LEBJTII        ,0.0            ,""                                 ,"Length dependence of ebjtii" )
`MPRnb( LMBJTII        ,0.0            ,""                                 ,"Length dependence of mbjtii" )
`MPRnb( LVBCI          ,0.0            ,""                                 ,"Length dependence of vbci" )
`MPRnb( LBETA0         ,0.0            ,""                                 ,"Length dependence of beta0" )
`MPRnb( LBETA1         ,0.0            ,""                                 ,"Length dependence of beta1" )
`MPRnb( LBETA2         ,0.0            ,""                                 ,"Length dependence of beta2" )
`MPRnb( LVDSATII0      ,0.0            ,""                                 ,"Length dependence of vdsatii0" )
`MPRnb( LLII           ,0.0            ,""                                 ,"Length dependence of lii" )
`MPRnb( LESATII        ,0.0            ,""                                 ,"Length dependence of esatii" )
`MPRnb( LSII0          ,0.0            ,""                                 ,"Length dependence of sii0" )
`MPRnb( LSII1          ,0.0            ,""                                 ,"Length dependence of sii1" )
`MPRnb( LSII2          ,0.0            ,""                                 ,"Length dependence of sii2" )
`MPRnb( LSIID          ,0.0            ,""                                 ,"Length dependence of siid" )
`MPRnb( LAGIDL         ,0.0            ,""                                 ,"Length dependence of agidl" )
`MPRnb( LBGIDL         ,0.0            ,""                                 ,"Length dependence of bgidl" )
`MPRnb( LCGIDL         ,0.0            ,""                                 ,"Length dependence of cgidl" )
`MPRnb( LRGIDL         ,0.0            ,""                                 ,"Length dependence of rgidl" )
`MPRnb( LKGIDL         ,0.0            ,""                                 ,"Length dependence of kgidl" )
`MPRnb( LFGIDL         ,0.0            ,""                                 ,"Length dependence of fgidl" )
`MPRnb( LAGISL         ,LAGIDL         ,""                                 ,"Length dependence of agisl" )
`MPRnb( LBGISL         ,LBGIDL         ,""                                 ,"Length dependence of bgisl" )
`MPRnb( LCGISL         ,LCGIDL         ,""                                 ,"Length dependence of cgisl" )
`MPRnb( LRGISL         ,LRGIDL         ,""                                 ,"Length dependence of rgisl" )
`MPRnb( LKGISL         ,LKGIDL         ,""                                 ,"Length dependence of kgisl" )
`MPRnb( LFGISL         ,LFGIDL         ,""                                 ,"Length dependence of fgisl" )
`MPRnb( LNTUN          ,0.0            ,""                                 ,"Length dependence of ntun" )
`MPRnb( LNTUND         ,LNTUN          ,""                                 ,"Length dependence of ntund" )
`MPRnb( LNDIODE        ,0.0            ,""                                 ,"Length dependence of ndiode" )
`MPRnb( LNDIODED       ,LNDIODE        ,""                                 ,"Length dependence of ndioded" )
`MPRnb( LNRECF0        ,0.0            ,""                                 ,"Length dependence of nrecf0" )
`MPRnb( LNRECF0D       ,LNRECF0        ,""                                 ,"Length dependence of nrecf0d" )
`MPRnb( LNRECR0        ,0.0            ,""                                 ,"Length dependence of nrecr0" )
`MPRnb( LNRECR0D       ,LNRECR0        ,""                                 ,"Length dependence of nrecr0d" )
`MPRnb( LISBJT         ,0.0            ,""                                 ,"Length dependence of isbjt" )
`MPRnb( LIDBJT         ,LISBJT         ,""                                 ,"Length dependence of idbjt" )
`MPRnb( LISDIF         ,0.0            ,""                                 ,"Length dependence of isdif" )
`MPRnb( LIDDIF         ,LISDIF         ,""                                 ,"Length dependence of iddif" )
`MPRnb( LISREC         ,0.0            ,""                                 ,"Length dependence of isrec" )
`MPRnb( LIDREC         ,LISREC         ,""                                 ,"Length dependence of idrec" )
`MPRnb( LISTUN         ,0.0            ,""                                 ,"Length dependence of istun" )
`MPRnb( LIDTUN         ,LISTUN         ,""                                 ,"Length dependence of idtun" )
`MPRnb( LVREC0         ,0.0            ,""                                 ,"Length dependence of vrec0" )
`MPRnb( LVREC0D        ,LVREC0         ,""                                 ,"Length dependence of vrec0d" )
`MPRnb( LVTUN0         ,0.0            ,""                                 ,"Length dependence of vtun0" )
`MPRnb( LVTUN0D        ,LVTUN0         ,""                                 ,"Length dependence of vtun0d" )
`MPRnb( LNBJT          ,0.0            ,""                                 ,"Length dependence of nbjt" )
`MPRnb( LLBJT0         ,0.0            ,""                                 ,"Length dependence of lbjt0" )
`MPRnb( LVABJT         ,0.0            ,""                                 ,"Length dependence of vabjt" )
`MPRnb( LAELY          ,0.0            ,""                                 ,"Length dependence of aely" )
`MPRnb( LAHLI          ,0.0            ,""                                 ,"Length dependence of ahli /*v4.0" )
`MPRnb( LAHLID         ,LAHLI          ,""                                 ,"Length dependence of ahlid /*v4.0" )
`MPRnb( LVSDFB         ,0.0            ,""                                 ,"Length dependence of vsdfb" )
`MPRnb( LVSDTH         ,0.0            ,""                                 ,"Length dependence of vsdth" )
`MPRnb( LDELVT         ,0.0            ,""                                 ,"Length dependence of delvt" )
`MPRnb( LACDE          ,0.0            ,""                                 ,"Length dependence of acde" )
`MPRnb( LMOIN          ,0.0            ,""                                 ,"Length dependence of moin" )
`MPRnb( LNOFF          ,0.0            ,""                                 ,"Length dependence of noff /* v3.2 " )
`MPRnb( LNOFF2         ,LNOFF          ,""                                 ,"Length dependence of noff2 /* v4.6 " ) /* 2015enh2 */
`MPRnb( LXRCRG1        ,0.0            ,""                                 ,"Length dependence of xrcrg1" )
`MPRnb( LXRCRG2        ,0.0            ,""                                 ,"Length dependence of xrcrg2" )
`MPRnb( LVBSA          ,0.0            ,""                                 ,"Length dependence of vbsa" )
`MPRnb( LVSCE          ,0.0            ,""                                 ,"Length dependence of vsce" )
`MPRnb( LCDSBS         ,0.0            ,""                                 ,"Length dependence of cdsbs" )
`MPRnb( LNOFFFD        ,0.0            ,""                                 ,"Length dependence of nofffd" )
`MPRnb( LVOFFFD        ,0.0            ,""                                 ,"Length dependence of vofffd" )
`MPRnb( LK1B           ,0.0            ,""                                 ,"Length dependence of k1b" )
`MPRnb( LK2B           ,0.0            ,""                                 ,"Length dependence of k2b" )
`MPRnb( LDK2B          ,0.0            ,""                                 ,"Length dependence of dk2b" )
`MPRnb( LDVBD0         ,0.0            ,""                                 ,"Length dependence of dvbd0" )
`MPRnb( LDVBD1         ,0.0            ,""                                 ,"Length dependence of dvbd1" )
`MPRnb( LMOINFD        ,0.0            ,""                                 ,"Length dependence of moinfd" )
`MPRnb( LVBS0PD        ,0.0            ,""                                 ,"Length dependence of vbs0pd" )
`MPRnb( LVBS0FD        ,0.0            ,""                                 ,"Length dependence of vbs0fd" )
`MPRnb( WXJ            ,0.0            ,""                                 ,"Width dependence of xj" )
`MPRnb( WALPHAGB1      ,0.0            ,""                                 ,"Width dependence of alphagb1" )
`MPRnb( WBETAGB1       ,0.0            ,""                                 ,"Width dependence of betagb1" )
`MPRnb( WALPHAGB2      ,0.0            ,""                                 ,"Width dependence of alphagb2" )
`MPRnb( WBETAGB2       ,0.0            ,""                                 ,"Width dependence of betagb2" )
`MPRnb( WAIGBCP2       ,0.0            ,""                                 ,"Width dependence of aigbcp2" )
`MPRnb( WBIGBCP2       ,0.0            ,""                                 ,"Width dependence of bigbcp2" )
`MPRnb( WCIGBCP2       ,0.0            ,""                                 ,"Width dependence of cigbcp2" )
`MPRnb( WCGSL          ,0.0            ,""                                 ,"Width dependence of cgsl" )
`MPRnb( WCGDL          ,0.0            ,""                                 ,"Width dependence of cgdl" )
`MPRnb( WCKAPPA        ,0.0            ,""                                 ,"Width dependence of ckappa" )
`MPRnb( WNDIF          ,0.0            ,""                                 ,"Width dependence of ndif" )
`MPRnb( WUTE           ,0.0            ,""                                 ,"Width dependence of ute" )
`MPRnb( WKT1           ,0.0            ,""                                 ,"Width dependence of kt1" )
`MPRnb( WKT1L          ,0.0            ,""                                 ,"Width dependence of kt1l" )
`MPRnb( WKT2           ,0.0            ,""                                 ,"Width dependence of kt2" )
`MPRnb( WUA1           ,0.0            ,""                                 ,"Width dependence of ua1" )
`MPRnb( WUB1           ,0.0            ,""                                 ,"Width dependence of ub1" )
`MPRnb( WUC1           ,0.0            ,""                                 ,"Width dependence of uc1" )
`MPRnb( WAT            ,0.0            ,""                                 ,"Width dependence of at" )
`MPRnb( WPRT           ,0.0            ,""                                 ,"Width dependence of prt" )
`MPRnb( WNTRECF        ,0.0            ,""                                 ,"Width dependence of ntrecf" )
`MPRnb( WNTRECR        ,0.0            ,""                                 ,"Width dependence of ntrecr" )
`MPRnb( WXBJT          ,0.0            ,""                                 ,"Width dependence of xbjt" )
`MPRnb( WXDIF          ,0.0            ,""                                 ,"Width dependence of xdif" )
`MPRnb( WXREC          ,0.0            ,""                                 ,"Width dependence of xrec" )
`MPRnb( WXTUN          ,0.0            ,""                                 ,"Width dependence of xtun" )
`MPRnb( WXDIFD         ,WXDIF          ,""                                 ,"Width dependence of xdifd" )
`MPRnb( WXRECD         ,WXREC          ,""                                 ,"Width dependence of xrecd" )
`MPRnb( WXTUND         ,WXTUN          ,""                                 ,"Width dependence of xtund" )
`MPRnb( WAIGC          ,0.0            ,""                                 ,"Width dependence of aigc" )
`MPRnb( WBIGC          ,0.0            ,""                                 ,"Width dependence of bigc" )
`MPRnb( WCIGC          ,0.0            ,""                                 ,"Width dependence of cigc" )
`MPRnb( WAIGSD         ,0.0            ,""                                 ,"Width dependence of aigsd" )
`MPRnb( WBIGSD         ,0.0            ,""                                 ,"Width dependence of bigsd" )
`MPRnb( WCIGSD         ,0.0            ,""                                 ,"Width dependence of cigsd" )
`MPRnb( WNIGC          ,0.0            ,""                                 ,"Width dependence of nigc" )
`MPRnb( WPIGCD         ,0.0            ,""                                 ,"Width dependence for pigcd" )
`MPRnb( WPOXEDGE       ,0.0            ,""                                 ,"Width dependence for poxedge" )
`MPRnb( WNCH           ,0.0            ,""                                 ,"Width dependence of nch" )
`MPRnb( WNSUB          ,0.0            ,""                                 ,"Width dependence of nsub" )
`MPRnb( WNGATE         ,0.0            ,""                                 ,"Width dependence of ngate" )
`MPRnb( WNSD           ,0.0            ,""                                 ,"Width dependence of nsd" )
`MPRnb( WVTH0          ,0.0            ,""                                 ,"Width dependence of vto" )
`MPRnb( WVFB           ,0.0            ,""                                 ,"Width dependence of vfb /* v4.1 " )
`MPRnb( WK1            ,0.0            ,""                                 ,"Width dependence of k1" )
`MPRnb( WK1W1          ,0.0            ,""                                 ,"Width dependence of k1w1" )
`MPRnb( WK1W2          ,0.0            ,""                                 ,"Width dependence of k1w2" )
`MPRnb( WK2            ,0.0            ,""                                 ,"Width dependence of k2" )
`MPRnb( WK3            ,0.0            ,""                                 ,"Width dependence of k3" )
`MPRnb( WK3B           ,0.0            ,""                                 ,"Width dependence of k3b" )
`MPRnb( WKB1           ,0.0            ,""                                 ,"Width dependence of kb1" )
`MPRnb( WW0            ,0.0            ,""                                 ,"Width dependence of w0" )
`MPRnb( WLPEB          ,0.0            ,""                                 ,"Width dependence of lpeb" )
`MPRnb( WDVT0          ,0.0            ,""                                 ,"Width dependence of dvt0" )
`MPRnb( WDVT1          ,0.0            ,""                                 ,"Width dependence of dvt1" )
`MPRnb( WDVT2          ,0.0            ,""                                 ,"Width dependence of dvt2" )
`MPRnb( WDVT0W         ,0.0            ,""                                 ,"Width dependence of dvt0w" )
`MPRnb( WDVT1W         ,0.0            ,""                                 ,"Width dependence of dvt1w" )
`MPRnb( WDVT2W         ,0.0            ,""                                 ,"Width dependence of dvt2w" )
`MPRnb( WU0            ,0.0            ,""                                 ,"Width dependence of u0" )
`MPRnb( WEU            ,0.0            ,""                                 ,"Width dependence of eu" )
`MPRnb( WUA            ,0.0            ,""                                 ,"Width dependence of ua" )
`MPRnb( WUB            ,0.0            ,""                                 ,"Width dependence of ub" )
`MPRnb( WUC            ,0.0            ,""                                 ,"Width dependence of uc" )
`MPRnb( WUD            ,0.0            ,""                                 ,"Width dependence of ud" )
`MPRnb( WUD1           ,0.0            ,""                                 ,"Width dependence of ud1" )
`MPRnb( WUCSTE         ,0.0            ,""                                 ,"Width dependence of ucste" )
`MPRnb( WUCS           ,0.0            ,""                                 ,"Width dependence of ucs" )
`MPRnb( WVSAT          ,0.0            ,""                                 ,"Width dependence of vsat" )
`MPRnb( WA0            ,0.0            ,""                                 ,"Width dependence of a0" )
`MPRnb( WAGS           ,0.0            ,""                                 ,"Width dependence of ags" )
`MPRnb( WB0            ,0.0            ,""                                 ,"Width dependence of b0" )
`MPRnb( WB1            ,0.0            ,""                                 ,"Width dependence of b1" )
`MPRnb( WKETA          ,0.0            ,""                                 ,"Width dependence of keta" )
`MPRnb( WKETAS         ,0.0            ,""                                 ,"Width dependence of ketas" )
`MPRnb( WA1            ,0.0            ,""                                 ,"Width dependence of a1" )
`MPRnb( WA2            ,0.0            ,""                                 ,"Width dependence of a2" )
`MPRnb( WRDSW          ,0.0            ,""                                 ,"Width dependence of rdsw" )
`MPRnb( WRSW           ,0.0            ,""                                 ,"Width dependence of rsw /* v4.0 " )
`MPRnb( WRDW           ,0.0            ,""                                 ,"Width dependence of rdw /* v4.0 " )
`MPRnb( WPRWB          ,0.0            ,""                                 ,"Width dependence of prwb" )
`MPRnb( WPRWG          ,0.0            ,""                                 ,"Width dependence of prwg" )
`MPRnb( WWR            ,0.0            ,""                                 ,"Width dependence of wr" )
`MPRnb( WNFACTOR       ,0.0            ,""                                 ,"Width dependence of nfactor" )
`MPRnb( WDWG           ,0.0            ,""                                 ,"Width dependence of dwg" )
`MPRnb( WDWB           ,0.0            ,""                                 ,"Width dependence of dwb" )
`MPRnb( WVOFF          ,0.0            ,""                                 ,"Width dependence of voff" )
`MPRnb( WETA0          ,0.0            ,""                                 ,"Width dependence of eta0" )
`MPRnb( WETAB          ,0.0            ,""                                 ,"Width dependence of etab" )
`MPRnb( WETA0CV        ,WETA0          ,""                                 ,"Width dependence of eta0cv" )
`MPRnb( WETABCV        ,WETAB          ,""                                 ,"Width dependence of etabcv" )
`MPRnb( WDSUB          ,0.0            ,""                                 ,"Width dependence of dsub" )
`MPRnb( WCIT           ,0.0            ,""                                 ,"Width dependence of cit" )
`MPRnb( WCDSC          ,0.0            ,""                                 ,"Width dependence of cdsc" )
`MPRnb( WCDSCB         ,0.0            ,""                                 ,"Width dependence of cdscb" )
`MPRnb( WCDSCD         ,0.0            ,""                                 ,"Width dependence of cdscd" )
`MPRnb( WPCLM          ,0.0            ,""                                 ,"Width dependence of pclm" )
`MPRnb( WPDIBLC1       ,0.0            ,""                                 ,"Width dependence of pdiblc1" )
`MPRnb( WPDIBLC2       ,0.0            ,""                                 ,"Width dependence of pdiblc2" )
`MPRnb( WPDIBLCB       ,0.0            ,""                                 ,"Width dependence of pdiblcb" )
`MPRnb( WDROUT         ,0.0            ,""                                 ,"Width dependence of drout" )
`MPRnb( WPVAG          ,0.0            ,""                                 ,"Width dependence of pvag" )
`MPRnb( WDELTA         ,0.0            ,""                                 ,"Width dependence of delta" )
`MPRnb( WALPHA0        ,0.0            ,""                                 ,"Width dependence of alpha0" )
`MPRnb( WFBJTII        ,0.0            ,""                                 ,"Width dependence of fbjtii" )
`MPRnb( WABJTII        ,0.0            ,""                                 ,"Width dependence of abjtii" )
`MPRnb( WCBJTII        ,0.0            ,""                                 ,"Width dependence of cbjtii" )
`MPRnb( WEBJTII        ,0.0            ,""                                 ,"Width dependence of ebjtii" )
`MPRnb( WMBJTII        ,0.0            ,""                                 ,"Width dependence of mbjtii" )
`MPRnb( WVBCI          ,0.0            ,""                                 ,"Width dependence of vbci" )
`MPRnb( WBETA0         ,0.0            ,""                                 ,"Width dependence of beta0" )
`MPRnb( WBETA1         ,0.0            ,""                                 ,"Width dependence of beta1" )
`MPRnb( WBETA2         ,0.0            ,""                                 ,"Width dependence of beta2" )
`MPRnb( WVDSATII0      ,0.0            ,""                                 ,"Width dependence of vdsatii0" )
`MPRnb( WLII           ,0.0            ,""                                 ,"Width dependence of lii" )
`MPRnb( WESATII        ,0.0            ,""                                 ,"Width dependence of esatii" )
`MPRnb( WSII0          ,0.0            ,""                                 ,"Width dependence of sii0" )
`MPRnb( WSII1          ,0.0            ,""                                 ,"Width dependence of sii1" )
`MPRnb( WSII2          ,0.0            ,""                                 ,"Width dependence of sii2" )
`MPRnb( WSIID          ,0.0            ,""                                 ,"Width dependence of siid" )
`MPRnb( WAGIDL         ,0.0            ,""                                 ,"Width dependence of agidl" )
`MPRnb( WBGIDL         ,0.0            ,""                                 ,"Width dependence of bgidl" )
`MPRnb( WCGIDL         ,0.0            ,""                                 ,"Width dependence of cgidl" )
`MPRnb( WRGIDL         ,0.0            ,""                                 ,"Width dependence of rgidl" )
`MPRnb( WKGIDL         ,0.0            ,""                                 ,"Width dependence of kgidl" )
`MPRnb( WFGIDL         ,0.0            ,""                                 ,"Width dependence of fgidl" )
`MPRnb( WAGISL         ,WAGIDL         ,""                                 ,"Width dependence of agisl" )
`MPRnb( WBGISL         ,WBGIDL         ,""                                 ,"Width dependence of bgisl" )
`MPRnb( WCGISL         ,WCGIDL         ,""                                 ,"Width dependence of cgisl" )
`MPRnb( WRGISL         ,WRGIDL         ,""                                 ,"Width dependence of rgisl" )
`MPRnb( WKGISL         ,WKGIDL         ,""                                 ,"Width dependence of kgisl" )
`MPRnb( WFGISL         ,WFGIDL         ,""                                 ,"Width dependence of fgisl" )
`MPRnb( WNTUN          ,0.0            ,""                                 ,"Width dependence of ntun" )
`MPRnb( WNTUND         ,WNTUN          ,""                                 ,"Width dependence of ntund" )
`MPRnb( WNDIODE        ,0.0            ,""                                 ,"Width dependence of ndiode" )
`MPRnb( WNDIODED       ,WNDIODE        ,""                                 ,"Width dependence of ndioded" )
`MPRnb( WNRECF0        ,0.0            ,""                                 ,"Width dependence of nrecf0" )
`MPRnb( WNRECF0D       ,WNRECF0        ,""                                 ,"Width dependence of nrecf0d" )
`MPRnb( WNRECR0        ,0.0            ,""                                 ,"Width dependence of nrecr0" )
`MPRnb( WNRECR0D       ,WNRECR0        ,""                                 ,"Width dependence of nrecr0d" )
`MPRnb( WISBJT         ,0.0            ,""                                 ,"Width dependence of isbjt" )
`MPRnb( WIDBJT         ,WISBJT         ,""                                 ,"Width dependence of idbjt" )
`MPRnb( WISDIF         ,0.0            ,""                                 ,"Width dependence of isdif" )
`MPRnb( WIDDIF         ,WISDIF         ,""                                 ,"Width dependence of iddif" )
`MPRnb( WISREC         ,0.0            ,""                                 ,"Width dependence of isrec" )
`MPRnb( WIDREC         ,WISREC         ,""                                 ,"Width dependence of idrec" )
`MPRnb( WISTUN         ,0.0            ,""                                 ,"Width dependence of istun" )
`MPRnb( WIDTUN         ,WISTUN         ,""                                 ,"Width dependence of idtun" )
`MPRnb( WVREC0         ,0.0            ,""                                 ,"Width dependence of vrec0" )
`MPRnb( WVREC0D        ,WVREC0         ,""                                 ,"Width dependence of vrec0d" )
`MPRnb( WVTUN0         ,0.0            ,""                                 ,"Width dependence of vtun0" )
`MPRnb( WVTUN0D        ,WVTUN0         ,""                                 ,"Width dependence of vtun0d" )
`MPRnb( WNBJT          ,0.0            ,""                                 ,"Width dependence of nbjt" )
`MPRnb( WLBJT0         ,0.0            ,""                                 ,"Width dependence of lbjt0" )
`MPRnb( WVABJT         ,0.0            ,""                                 ,"Width dependence of vabjt" )
`MPRnb( WAELY          ,0.0            ,""                                 ,"Width dependence of aely" )
`MPRnb( WAHLI          ,0.0            ,""                                 ,"Width dependence of ahli /* v4.0 " )
`MPRnb( WAHLID         ,WAHLI          ,""                                 ,"Width dependence of ahlid /* v4.0 " )
`MPRnb( WVSDFB         ,0.0            ,""                                 ,"Width dependence of vsdfb" )
`MPRnb( WVSDTH         ,0.0            ,""                                 ,"Width dependence of vsdth" )
`MPRnb( WDELVT         ,0.0            ,""                                 ,"Width dependence of delvt" )
`MPRnb( WACDE          ,0.0            ,""                                 ,"Width dependence of acde" )
`MPRnb( WMOIN          ,0.0            ,""                                 ,"Width dependence of moin" )
`MPRnb( WNOFF          ,0.0            ,""                                 ,"Width dependence of noff /* v3.2 " )
`MPRnb( WNOFF2         ,WNOFF          ,""                                 ,"Width dependence of noff2 /* v4.6 " ) /* 2015enh2 */
`MPRnb( WXRCRG1        ,0.0            ,""                                 ,"Width dependence of xrcrg1" )
`MPRnb( WXRCRG2        ,0.0            ,""                                 ,"Width dependence of xrcrg2" )
`MPRnb( WVBSA          ,0.0            ,""                                 ,"Width dependence of vbsa" )
`MPRnb( WVSCE          ,0.0            ,""                                 ,"Width dependence of vsce" )
`MPRnb( WCDSBS         ,0.0            ,""                                 ,"Width dependence of cdsbs" )
`MPRnb( WNOFFFD        ,0.0            ,""                                 ,"Width dependence of nofffd" )
`MPRnb( WVOFFFD        ,0.0            ,""                                 ,"Width dependence of vofffd" )
`MPRnb( WK1B           ,0.0            ,""                                 ,"Width dependence of k1b" )
`MPRnb( WK2B           ,0.0            ,""                                 ,"Width dependence of k2b" )
`MPRnb( WDK2B          ,0.0            ,""                                 ,"Width dependence of dk2b" )
`MPRnb( WDVBD0         ,0.0            ,""                                 ,"Width dependence of dvbd0" )
`MPRnb( WDVBD1         ,0.0            ,""                                 ,"Width dependence of dvbd1" )
`MPRnb( WMOINFD        ,0.0            ,""                                 ,"Width dependence of moinfd" )
`MPRnb( WVBS0PD        ,0.0            ,""                                 ,"Width dependence of vbs0pd" )
`MPRnb( WVBS0FD        ,0.0            ,""                                 ,"Width dependence of vbs0fd" )
`MPRnb( PXJ            ,0.0            ,""                                 ,"Cross-term dependence of xj" )
`MPRnb( PALPHAGB1      ,0.0            ,""                                 ,"Cross-term dependence of alphagb1" )
`MPRnb( PBETAGB1       ,0.0            ,""                                 ,"Cross-term dependence of betagb1" )
`MPRnb( PALPHAGB2      ,0.0            ,""                                 ,"Cross-term dependence of alphagb2" )
`MPRnb( PBETAGB2       ,0.0            ,""                                 ,"Cross-term dependence of betagb2" )
`MPRnb( PAIGBCP2       ,0.0            ,""                                 ,"Cross-term dependence of aigbcp2" )
`MPRnb( PBIGBCP2       ,0.0            ,""                                 ,"Cross-term dependence of bigbcp2" )
`MPRnb( PCIGBCP2       ,0.0            ,""                                 ,"Cross-term dependence of cigbcp2" )
`MPRnb( PCGSL          ,0.0            ,""                                 ,"Cross-term dependence of cgsl" )
`MPRnb( PCGDL          ,0.0            ,""                                 ,"Cross-term dependence of cgdl" )
`MPRnb( PCKAPPA        ,0.0            ,""                                 ,"Cross-term dependence of ckappa" )
`MPRnb( PNDIF          ,0.0            ,""                                 ,"Cross-term dependence of ndif" )
`MPRnb( PUTE           ,0.0            ,""                                 ,"Cross-term dependence of ute" )
`MPRnb( PKT1           ,0.0            ,""                                 ,"Cross-term dependence of kt1" )
`MPRnb( PKT1L          ,0.0            ,""                                 ,"Cross-term dependence of kt1l" )
`MPRnb( PKT2           ,0.0            ,""                                 ,"Cross-term dependence of kt2" )
`MPRnb( PUA1           ,0.0            ,""                                 ,"Cross-term dependence of ua1" )
`MPRnb( PUB1           ,0.0            ,""                                 ,"Cross-term dependence of ub1" )
`MPRnb( PUC1           ,0.0            ,""                                 ,"Cross-term dependence of uc1" )
`MPRnb( PAT            ,0.0            ,""                                 ,"Cross-term dependence of at" )
`MPRnb( PPRT           ,0.0            ,""                                 ,"Cross-term dependence of prt" )
`MPRnb( PNTRECF        ,0.0            ,""                                 ,"Cross-term dependence of ntrecf" )
`MPRnb( PNTRECR        ,0.0            ,""                                 ,"Cross-term dependence of ntrecr" )
`MPRnb( PXBJT          ,0.0            ,""                                 ,"Cross-term dependence of xbjt" )
`MPRnb( PXDIF          ,0.0            ,""                                 ,"Cross-term dependence of xdif" )
`MPRnb( PXREC          ,0.0            ,""                                 ,"Cross-term dependence of xrec" )
`MPRnb( PXTUN          ,0.0            ,""                                 ,"Cross-term dependence of xtun" )
`MPRnb( PXDIFD         ,PXDIF          ,""                                 ,"Cross-term dependence of xdifd" )
`MPRnb( PXRECD         ,PXREC          ,""                                 ,"Cross-term dependence of xrecd" )
`MPRnb( PXTUND         ,PXTUN          ,""                                 ,"Cross-term dependence of xtund" )
`MPRnb( PAIGC          ,0.0            ,""                                 ,"Cross-term dependence of aigc" )
`MPRnb( PBIGC          ,0.0            ,""                                 ,"Cross-term dependence of bigc" )
`MPRnb( PCIGC          ,0.0            ,""                                 ,"Cross-term dependence of cigc" )
`MPRnb( PAIGSD         ,0.0            ,""                                 ,"Cross-term dependence of aigsd" )
`MPRnb( PBIGSD         ,0.0            ,""                                 ,"Cross-term dependence of bigsd" )
`MPRnb( PCIGSD         ,0.0            ,""                                 ,"Cross-term dependence of cigsd" )
`MPRnb( PNIGC          ,0.0            ,""                                 ,"Cross-term dependence of nigc" )
`MPRnb( PPIGCD         ,0.0            ,""                                 ,"Cross-term dependence for pigcd" )
`MPRnb( PPOXEDGE       ,0.0            ,""                                 ,"Cross-term dependence for poxedge" )
`MPRnb( PNCH           ,0.0            ,""                                 ,"Cross-term dependence of nch" )
`MPRnb( PNSUB          ,0.0            ,""                                 ,"Cross-term dependence of nsub" )
`MPRnb( PNSD           ,0.0            ,""                                 ,"Cross-term dependence of nsd" )
`MPRnb( PNGATE         ,0.0            ,""                                 ,"Cross-term dependence of ngate" )
`MPRnb( PVTH0          ,0.0            ,""                                 ,"Cross-term dependence of vto" )
`MPRnb( PVFB           ,0.0            ,""                                 ,"Cross-term dependence of vfb /* v4.1 " )
`MPRnb( PK1            ,0.0            ,""                                 ,"Cross-term dependence of k1" )
`MPRnb( PK1W1          ,0.0            ,""                                 ,"Cross-term dependence of k1w1" )
`MPRnb( PK1W2          ,0.0            ,""                                 ,"Cross-term dependence of k1w2" )
`MPRnb( PK2            ,0.0            ,""                                 ,"Cross-term dependence of k2" )
`MPRnb( PK3            ,0.0            ,""                                 ,"Cross-term dependence of k3" )
`MPRnb( PK3B           ,0.0            ,""                                 ,"Cross-term dependence of k3b" )
`MPRnb( PKB1           ,0.0            ,""                                 ,"Cross-term dependence of kb1" )
`MPRnb( PW0            ,0.0            ,""                                 ,"Cross-term dependence of w0" )
`MPRnb( PLPEB          ,0.0            ,""                                 ,"Cross-term dependence of lpeb" )
`MPRnb( PDVT0          ,0.0            ,""                                 ,"Cross-term dependence of dvt0" )
`MPRnb( PDVT1          ,0.0            ,""                                 ,"Cross-term dependence of dvt1" )
`MPRnb( PDVT2          ,0.0            ,""                                 ,"Cross-term dependence of dvt2" )
`MPRnb( PDVT0W         ,0.0            ,""                                 ,"Cross-term dependence of dvt0w" )
`MPRnb( PDVT1W         ,0.0            ,""                                 ,"Cross-term dependence of dvt1w" )
`MPRnb( PDVT2W         ,0.0            ,""                                 ,"Cross-term dependence of dvt2w" )
`MPRnb( PU0            ,0.0            ,""                                 ,"Cross-term dependence of u0" )
`MPRnb( PEU            ,0.0            ,""                                 ,"Cross-term dependence of eu" )
`MPRnb( PUA            ,0.0            ,""                                 ,"Cross-term dependence of ua" )
`MPRnb( PUB            ,0.0            ,""                                 ,"Cross-term dependence of ub" )
`MPRnb( PUC            ,0.0            ,""                                 ,"Cross-term dependence of uc" )
`MPRnb( PUD            ,0.0            ,""                                 ,"Cross-term dependence of ud" )
`MPRnb( PUD1           ,0.0            ,""                                 ,"Cross-term dependence of ud1" )
`MPRnb( PUCSTE         ,0.0            ,""                                 ,"Cross-term dependence of ucste" )
`MPRnb( PUCS           ,0.0            ,""                                 ,"Cross-term dependence of ucs" )
`MPRnb( PVSAT          ,0.0            ,""                                 ,"Cross-term dependence of vsat" )
`MPRnb( PA0            ,0.0            ,""                                 ,"Cross-term dependence of a0" )
`MPRnb( PAGS           ,0.0            ,""                                 ,"Cross-term dependence of ags" )
`MPRnb( PB0            ,0.0            ,""                                 ,"Cross-term dependence of b0" )
`MPRnb( PB1            ,0.0            ,""                                 ,"Cross-term dependence of b1" )
`MPRnb( PKETA          ,0.0            ,""                                 ,"Cross-term dependence of keta" )
`MPRnb( PKETAS         ,0.0            ,""                                 ,"Cross-term dependence of ketas" )
`MPRnb( PA1            ,0.0            ,""                                 ,"Cross-term dependence of a1" )
`MPRnb( PA2            ,0.0            ,""                                 ,"Cross-term dependence of a2" )
`MPRnb( PRDSW          ,0.0            ,""                                 ,"Cross-term dependence of rdsw" )
`MPRnb( PRSW           ,0.0            ,""                                 ,"Cross-term dependence of rsw /*v4.0" )
`MPRnb( PRDW           ,0.0            ,""                                 ,"Cross-term dependence of rdw /*v4.0" )
`MPRnb( PPRWB          ,0.0            ,""                                 ,"Cross-term dependence of prwb" )
`MPRnb( PPRWG          ,0.0            ,""                                 ,"Cross-term dependence of prwg" )
`MPRnb( PWR            ,0.0            ,""                                 ,"Cross-term dependence of wr" )
`MPRnb( PNFACTOR       ,0.0            ,""                                 ,"Cross-term dependence of nfactor" )
`MPRnb( PDWG           ,0.0            ,""                                 ,"Cross-term dependence of dwg" )
`MPRnb( PDWB           ,0.0            ,""                                 ,"Cross-term dependence of dwb" )
`MPRnb( PVOFF          ,0.0            ,""                                 ,"Cross-term dependence of voff" )
`MPRnb( PETA0          ,0.0            ,""                                 ,"Cross-term dependence of eta0" )
`MPRnb( PETAB          ,0.0            ,""                                 ,"Cross-term dependence of etab" )
`MPRnb( PETA0CV        ,PETA0          ,""                                 ,"Cross-term dependence of eta0cv" )
`MPRnb( PETABCV        ,PETAB          ,""                                 ,"Cross-term dependence of etabcv" )
`MPRnb( PDSUB          ,0.0            ,""                                 ,"Cross-term dependence of dsub" )
`MPRnb( PCIT           ,0.0            ,""                                 ,"Cross-term dependence of cit" )
`MPRnb( PCDSC          ,0.0            ,""                                 ,"Cross-term dependence of cdsc" )
`MPRnb( PCDSCB         ,0.0            ,""                                 ,"Cross-term dependence of cdscb" )
`MPRnb( PCDSCD         ,0.0            ,""                                 ,"Cross-term dependence of cdscd" )
`MPRnb( PPCLM          ,0.0            ,""                                 ,"Cross-term dependence of pclm" )
`MPRnb( PPDIBLC1       ,0.0            ,""                                 ,"Cross-term dependence of pdiblc1" )
`MPRnb( PPDIBLC2       ,0.0            ,""                                 ,"Cross-term dependence of pdiblc2" )
`MPRnb( PPDIBLCB       ,0.0            ,""                                 ,"Cross-term dependence of pdiblcb" )
`MPRnb( PDROUT         ,0.0            ,""                                 ,"Cross-term dependence of drout" )
`MPRnb( PPVAG          ,0.0            ,""                                 ,"Cross-term dependence of pvag" )
`MPRnb( PDELTA         ,0.0            ,""                                 ,"Cross-term dependence of delta" )
`MPRnb( PALPHA0        ,0.0            ,""                                 ,"Cross-term dependence of alpha0" )
`MPRnb( PFBJTII        ,0.0            ,""                                 ,"Cross-term dependence of fbjtii" )
`MPRnb( PABJTII        ,0.0            ,""                                 ,"Cross-term dependence of abjtii" )
`MPRnb( PCBJTII        ,0.0            ,""                                 ,"Cross-term dependence of cbjtii" )
`MPRnb( PEBJTII        ,0.0            ,""                                 ,"Cross-term dependence of ebjtii" )
`MPRnb( PMBJTII        ,0.0            ,""                                 ,"Cross-term dependence of mbjtii" )
`MPRnb( PVBCI          ,0.0            ,""                                 ,"Cross-term dependence of vbci" )
`MPRnb( PBETA0         ,0.0            ,""                                 ,"Cross-term dependence of beta0" )
`MPRnb( PBETA1         ,0.0            ,""                                 ,"Cross-term dependence of beta1" )
`MPRnb( PBETA2         ,0.0            ,""                                 ,"Cross-term dependence of beta2" )
`MPRnb( PVDSATII0      ,0.0            ,""                                 ,"Cross-term dependence of vdsatii0" )
`MPRnb( PLII           ,0.0            ,""                                 ,"Cross-term dependence of lii" )
`MPRnb( PESATII        ,0.0            ,""                                 ,"Cross-term dependence of esatii" )
`MPRnb( PSII0          ,0.0            ,""                                 ,"Cross-term dependence of sii0" )
`MPRnb( PSII1          ,0.0            ,""                                 ,"Cross-term dependence of sii1" )
`MPRnb( PSII2          ,0.0            ,""                                 ,"Cross-term dependence of sii2" )
`MPRnb( PSIID          ,0.0            ,""                                 ,"Cross-term dependence of siid" )
`MPRnb( PAGIDL         ,0.0            ,""                                 ,"Cross-term dependence of agidl" )
`MPRnb( PBGIDL         ,0.0            ,""                                 ,"Cross-term dependence of bgidl" )
`MPRnb( PCGIDL         ,0.0            ,""                                 ,"Cross-term dependence of cgidl" )
`MPRnb( PRGIDL         ,0.0            ,""                                 ,"Cross-term dependence of rgidl" )
`MPRnb( PKGIDL         ,0.0            ,""                                 ,"Cross-term dependence of kgidl" )
`MPRnb( PFGIDL         ,0.0            ,""                                 ,"Cross-term dependence of fgidl" )
`MPRnb( PAGISL         ,PAGIDL         ,""                                 ,"Cross-term dependence of agisl" )
`MPRnb( PBGISL         ,PBGIDL         ,""                                 ,"Cross-term dependence of bgisl" )
`MPRnb( PCGISL         ,PCGIDL         ,""                                 ,"Cross-term dependence of cgisl" )
`MPRnb( PRGISL         ,PRGIDL         ,""                                 ,"Cross-term dependence of rgisl" )
`MPRnb( PKGISL         ,PKGIDL         ,""                                 ,"Cross-term dependence of kgisl" )
`MPRnb( PFGISL         ,PFGIDL         ,""                                 ,"Cross-term dependence of fgisl" )
`MPRnb( PNTUN          ,0.0            ,""                                 ,"Cross-term dependence of ntun" )
`MPRnb( PNTUND         ,PNTUN          ,""                                 ,"Cross-term dependence of ntund" )
`MPRnb( PNDIODE        ,0.0            ,""                                 ,"Cross-term dependence of ndiode" )
`MPRnb( PNDIODED       ,PNDIODE        ,""                                 ,"Cross-term dependence of ndiode" )
`MPRnb( PNRECF0        ,0.0            ,""                                 ,"Cross-term dependence of nrecf0" )
`MPRnb( PNRECF0D       ,PNRECF0        ,""                                 ,"Cross-term dependence of nrecf0" )
`MPRnb( PNRECR0        ,0.0            ,""                                 ,"Cross-term dependence of nrecr0" )
`MPRnb( PNRECR0D       ,PNRECR0        ,""                                 ,"Cross-term dependence of nrecr0" )
`MPRnb( PISBJT         ,0.0            ,""                                 ,"Cross-term dependence of isbjt" )
`MPRnb( PIDBJT         ,PISBJT         ,""                                 ,"Cross-term dependence of idbjt" )
`MPRnb( PISDIF         ,0.0            ,""                                 ,"Cross-term dependence of isdif" )
`MPRnb( PIDDIF         ,PISDIF         ,""                                 ,"Cross-term dependence of iddif" )
`MPRnb( PISREC         ,0.0            ,""                                 ,"Cross-term dependence of isrec" )
`MPRnb( PIDREC         ,PISREC         ,""                                 ,"Cross-term dependence of idrec" )
`MPRnb( PISTUN         ,0.0            ,""                                 ,"Cross-term dependence of istun" )
`MPRnb( PIDTUN         ,PISTUN         ,""                                 ,"Cross-term dependence of idtun" )
`MPRnb( PVREC0         ,0.0            ,""                                 ,"Cross-term dependence of vrec0" )
`MPRnb( PVREC0D        ,PVREC0         ,""                                 ,"Cross-term dependence of vrec0d" )
`MPRnb( PVTUN0         ,0.0            ,""                                 ,"Cross-term dependence of vtun0" )
`MPRnb( PVTUN0D        ,PVTUN0         ,""                                 ,"Cross-term dependence of vtun0d" )
`MPRnb( PNBJT          ,0.0            ,""                                 ,"Cross-term dependence of nbjt" )
`MPRnb( PLBJT0         ,0.0            ,""                                 ,"Cross-term dependence of lbjt0" )
`MPRnb( PVABJT         ,0.0            ,""                                 ,"Cross-term dependence of vabjt" )
`MPRnb( PAELY          ,0.0            ,""                                 ,"Cross-term dependence of aely" )
`MPRnb( PAHLI          ,0.0            ,""                                 ,"X-term dependence of ahli /* v4.0 " )
`MPRnb( PAHLID         ,PAHLI          ,""                                 ,"X-term dependence of ahlid /* v4.0 " )
`MPRnb( PVSDFB         ,0.0            ,""                                 ,"Cross-term dependence of vsdfb" )
`MPRnb( PVSDTH         ,0.0            ,""                                 ,"Cross-term dependence of vsdth" )
`MPRnb( PDELVT         ,0.0            ,""                                 ,"Cross-term dependence of delvt" )
`MPRnb( PACDE          ,0.0            ,""                                 ,"Cross-term dependence of acde" )
`MPRnb( PMOIN          ,0.0            ,""                                 ,"Cross-term dependence of moin" )
`MPRnb( PNOFF          ,0.0            ,""                                 ,"Cross-term dependence of noff /* v3.2 " )
`MPRnb( PNOFF2         ,PNOFF          ,""                                 ,"Cross-term dependence of noff2 /* v4.6 " ) /* 2015enh2 */
`MPRnb( PXRCRG1        ,0.0            ,""                                 ,"Cross-term dependence of xrcrg1" )
`MPRnb( PXRCRG2        ,0.0            ,""                                 ,"Cross-term dependence of xrcrg2" )
`MPRnb( PVBSA          ,0.0            ,""                                 ,"Cross-term dependence of vbsa" )
`MPRnb( PVSCE          ,0.0            ,""                                 ,"Cross-term dependence of vsce" )
`MPRnb( PCDSBS         ,0.0            ,""                                 ,"Cross-term dependence of cdsbs" )
`MPRnb( PNOFFFD        ,0.0            ,""                                 ,"Cross-term dependence of nofffd" )
`MPRnb( PVOFFFD        ,0.0            ,""                                 ,"Cross-term dependence of vofffd" )
`MPRnb( PK1B           ,0.0            ,""                                 ,"Cross-term dependence of k1b" )
`MPRnb( PK2B           ,0.0            ,""                                 ,"Cross-term dependence of k2b" )
`MPRnb( PDK2B          ,0.0            ,""                                 ,"Cross-term dependence of dk2b" )
`MPRnb( PDVBD0         ,0.0            ,""                                 ,"Cross-term dependence of dvbd0" )
`MPRnb( PDVBD1         ,0.0            ,""                                 ,"Cross-term dependence of dvbd1" )
`MPRnb( PMOINFD        ,0.0            ,""                                 ,"Cross-term dependence of moinfd" )
`MPRnb( PVBS0PD        ,0.0            ,""                                 ,"Cross-term dependence of vbs0pd" )
`MPRnb( PVBS0FD        ,0.0            ,""                                 ,"Cross-term dependence of vbs0fd" )
`MPRnb( NLX            ,1.74e-7        ,"m"                                ,"Lateral non-uniform doping effect" )
`MPRnb( LNLX           ,0.0            ,""                                 ,"Length dependence of nlx" )
`MPRnb( WNLX           ,0.0            ,""                                 ,"Width dependence of nlx" )
`MPRnb( PNLX           ,0.0            ,""                                 ,"Cross-term dependence of nlx" )

`MPRnb( NGIDL          ,1.2            ,""                                 ,"GIDL first parameter" )
`MPRnb( LNGIDL         ,0.0            ,""                                 ,"Length dependence of ngidl" )
`MPRnb( WNGIDL         ,0.0            ,""                                 ,"Width dependence of ngidl" )
`MPRnb( PNGIDL         ,0.0            ,""                                 ,"Cross-term dependence of ngidl" )
`MPRnb( LPE0           ,NLX            ,"m"                                ,"Lateral non-uniform doping effect" )
`MPRnb( EGIDL          ,NGIDL          ,"V"                                ,"GIDL first parameter" )
`MPRnb( EGISL          ,EGIDL          ,"V"                                ,"GISL first parameter" )
`MPRnb( LLPE0          ,LNLX           ,""                                 ,"Length dependence of lpe0" )
`MPRnb( LEGIDL         ,LNGIDL         ,""                                 ,"Length dependence of egidl" )
`MPRnb( LEGISL         ,LEGIDL         ,""                                 ,"Length dependence of egisl" )
`MPRnb( WLPE0          ,WNLX           ,""                                 ,"Width dependence of lpe0" )
`MPRnb( WEGIDL         ,WNGIDL         ,""                                 ,"Width dependence of egidl" )
`MPRnb( WEGISL         ,WEGIDL         ,""                                 ,"Width dependence of egisl" )
`MPRnb( PLPE0          ,PNLX           ,""                                 ,"Cross-term dependence of lpe0" )
`MPRnb( PEGIDL         ,PNGIDL         ,""                                 ,"Cross-term dependence of egidl" )
`MPRnb( PEGISL         ,PEGIDL         ,""                                 ,"Cross-term dependence of egisl" )

/* New parameters added corresponding to the various material properties for mtrlMod=1 by Pankaj in May 2012*/
`MPRnb( EGGBCP2        ,1.12           ,"eV"                                ,"Bandgap in Agbcp2 region" )
`MPRnb( EGGDEP         ,1.12           ,"eV"                                ,"Bandgap for gate depletion effect" )
`MPRnb( AGB1           ,3.7622e-7      ,""                                  ,"'A' for Igb1 Tunneling current model" )
`MPRnb( BGB1           ,-3.1051e10     ,""                                  ,"'B' for Igb1 Tunneling current model" )
`MPRnb( AGB2           ,4.9758e-7      ,""                                  ,"'A' for Igb2 Tunneling current model" )
`MPRnb( BGB2           ,-2.357e10      ,""                                  ,"'B' for Igb2 Tunneling current model" )
`MPRnb( AGBC2N         ,3.4254e-7      ,""                                  ,"NMOS 'A' for tunneling current model" )
`MPRnb( AGBC2P         ,4.9723e-7      ,""                                  ,"PMOS 'A' for tunneling current model" )
`MPRnb( BGBC2N         ,1.1665e12      ,""                                  ,"NMOS 'B' for tunneling current model" )
`MPRnb( BGBC2P         ,7.4567e11      ,""                                  ,"PMOS 'B' for tunneling current model" )
`MPRnb( VTM00          ,0.026          ,"V"                                 ,"Hard coded 25 degC thermal voltage" )

// XYCE MOD:  Add multiplicity factor declaration
// It is not OK to assume implicit mfactor
// NOTE:  Every contribution has also been modified to use the multiplicity factor!
`IPM

// Output variables
`OPP( VDSAT             , "V"           , "")
`OPP( VTH               , "V"           , "Threshold Voltage")
`OPP( IDS               , "A"           , "Drain-Source current")
`OPP( GM                , "mho"         , "")
`OPP( GDS               , "mho"         , "")
`OPP( GMBS              , "mho"         , "")
`OPP( IC                , "A"           , "  Collector Current")
`OPP( IBD               , "A"           , "")
`OPP( IBS               , "A"           , "")
`OPP( IGIDL             , "A"           , "")
`OPP( IGISL             , "A"           , "")
`OPP( IGS               , "A"           , "")
`OPP( IGD               , "A"           , "")
`OPP( IGB               , "A"           , "")
`OPP( IGCS              , "A"           , "")
`OPP( IGCD              , "A"           , "")
`OPP( CGG               , "F"           , "  g-g MOSFET capacitance")
`OPP( CGS               , "F"           , "  g-s MOSFET capacitance")
`OPP( CGD               , "F"           , "  g-d MOSFET capacitance")
`OPP( CBG               , "F"           , "  b-g MOSFET capacitance")
`OPP( CBS               , "F"           , "  b-s MOSFET capacitance")
`OPP( CBD               , "F"           , "  b-d MOSFET capacitance")
`OPP( CDG               , "F"           , "  d-g MOSFET capacitance")
`OPP( CDD               , "F"           , "  d-d MOSFET capacitance")
`OPP( CDS               , "F"           , "  d-s MOSFET capacitance")
`OPP( CAPBD             , "F"           , "  MOSFET capacitance")
`OPP( CAPBS             , "F"           , "  MOSFET capacitance")
`OPP( QG                , "C"           , " Gate Charge")
`OPP( QB                , "C"           , " Body Charge")
`OPP( QD                , "C"           , " Drain Charge")
`OPP( QS                , "C"           , " Source Charge")
`OPP( QJD               , "C"           , " Drain Junction Charge")
`OPP( QJS               , "C"           , " Source Junction Charge")
`OPP( T_TOTAL_K         , "K"           , "")
`OPP( T_TOTAL_C         , "K"           , "")
`OPP( T_DELTA_SH        , "K"           , "")

`ifndef __XYCE__
analog begin : the_module
`endif
    integer B4SOItype;
    real B4SOIl;
    real B4SOIw;
    real B4SOInf;
    real B4SOIsa;
    real B4SOIsb;
    real B4SOIsd;
    real B4SOIdrainArea;
    real B4SOIsourceArea;
    real B4SOIdrainPerimeter;
    real B4SOIsourcePerimeter;
    real B4SOIdrainSquares;
    real B4SOIsourceSquares;
    integer B4SOIbjtoff;
    real B4SOIrth0;
    real B4SOIcth0;
    real B4SOIbodySquares;
    real B4SOIfrbody;
    real B4SOIrbdb;
    real B4SOIrbsb;
    real B4SOIdelvto;
    integer B4SOIsoiMod;
    real B4SOInbc;
    real B4SOInseg;
    real B4SOIpdbcp;
    real B4SOIpsbcp;
    real B4SOIagbcp;
    real B4SOIagbcp2;
    real B4SOIagbcpd;
    real B4SOIaebcp;
    integer B4SOIrgateMod;
    integer B4SOIrbodyMod;
    integer B4SOImtrlMod;
    integer B4SOIvgstcvMod;
    integer B4SOIgidlMod;
    integer B4SOIiiiMod;
    real B4SOIeot;
    real B4SOIepsrox;
    real B4SOIepsrsub;
    real B4SOIni0sub;
    real B4SOIbg0sub;
    real B4SOItbgasub;
    real B4SOItbgbsub;
    real B4SOIphig;
    real B4SOIeasub;
    real B4SOIleffeot;
    real B4SOIweffeot;
    real B4SOIvddeot;
    real B4SOItempeot;
    real B4SOIados;
    real B4SOIbdos;
    real B4SOIepsrgate;
    integer B4SOIcapMod;
    integer B4SOImobMod;
    integer B4SOIbinUnit;
    real B4SOItox;
    real B4SOItoxp;
    real B4SOItoxm;
    real B4SOIdtoxcv;
    real B4SOIcdsc;
    real B4SOIcdscb;
    real B4SOIcdscd;
    real B4SOIcit;
    real B4SOInfactor;
    real B4SOIvsat;
    real B4SOIat;
    real B4SOIa0;
    real B4SOIags;
    real B4SOIa1;
    real B4SOIa2;
    real B4SOIketa;
    real B4SOInsub;
    real B4SOInpeak;
    real B4SOIngate;
    real B4SOInsd;
    real B4SOIgamma1;
    real B4SOIgamma2;
    real B4SOIvbx;
    real B4SOIvbm;
    real B4SOIxt;
    real B4SOIk1;
    real B4SOIkt1;
    real B4SOIkt1l;
    real B4SOIkt2;
    real B4SOIk2;
    real B4SOIk3;
    real B4SOIk3b;
    real B4SOIw0;
    real B4SOIlpe0;
    real B4SOIlpeb;
    real B4SOIdvt0;
    real B4SOIdvt1;
    real B4SOIdvt2;
    real B4SOIdvt0w;
    real B4SOIdvt1w;
    real B4SOIdvt2w;
    real B4SOIdrout;
    real B4SOIdsub;
    real B4SOIvth0;
    real B4SOIvfb;
    real B4SOIua;
    real B4SOIua1;
    real B4SOIub;
    real B4SOIub1;
    real B4SOIuc;
    real B4SOIuc1;
    real B4SOIu0;
    real B4SOIeu;
    real B4SOIute;
    real B4SOIucs;
    real B4SOIucste;
    real B4SOIud;
    real B4SOIud1;
    real B4SOIvoff;
    real B4SOItnom;
    real B4SOIcgso;
    real B4SOIcgdo;
    real B4SOIxpart;
    real B4SOIdelta;
    real B4SOIsheetResistance;
    real B4SOIrdsw;
    real B4SOIrsw;
    real B4SOIrdw;
    real B4SOIrswmin;
    real B4SOIrdwmin;
    real B4SOIprwg;
    real B4SOIprwb;
    real B4SOIprt;
    real B4SOIeta0;
    real B4SOIetab;
    real B4SOIeta0cv;
    real B4SOIetabcv;
    real B4SOIpclm;
    real B4SOIpdibl1;
    real B4SOIpdibl2;
    real B4SOIpdiblb;
    real B4SOIpvag;
    real B4SOItbox;
    real B4SOItsi;
    real B4SOIetsi;
    real B4SOIxj;
    real B4SOIegidl;
    real B4SOIagidl;
    real B4SOIbgidl;
    real B4SOIcgidl;
    real B4SOIrgidl;
    real B4SOIkgidl;
    real B4SOIfgidl;
    real B4SOIegisl;
    real B4SOIagisl;
    real B4SOIbgisl;
    real B4SOIcgisl;
    real B4SOIrgisl;
    real B4SOIkgisl;
    real B4SOIfgisl;
    real B4SOIndiode;
    real B4SOIndioded;
    real B4SOIxbjt;
    real B4SOIxdif;
    real B4SOIxrec;
    real B4SOIxtun;
    real B4SOIxdifd;
    real B4SOIxrecd;
    real B4SOIxtund;
    real B4SOIGatesidewallJctSPotential;
    real B4SOIGatesidewallJctDPotential;
    real B4SOIbodyJctGateSideSGradingCoeff;
    real B4SOIbodyJctGateSideDGradingCoeff;
    real B4SOIunitLengthGateSidewallJctCapS;
    real B4SOIunitLengthGateSidewallJctCapD;
    real B4SOILint;
    real B4SOILl;
    real B4SOILlc;
    real B4SOILln;
    real B4SOILw;
    real B4SOILwc;
    real B4SOILwn;
    real B4SOILwl;
    real B4SOILwlc;
    real B4SOIwr;
    real B4SOIWint;
    real B4SOIdwg;
    real B4SOIdwb;
    real B4SOIWl;
    real B4SOIWlc;
    real B4SOIWln;
    real B4SOIWw;
    real B4SOIWwc;
    real B4SOIWwn;
    real B4SOIWwl;
    real B4SOIWwlc;
    real B4SOIb0;
    real B4SOIb1;
    real B4SOIcgsl;
    real B4SOIcgdl;
    real B4SOIckappa;
    real B4SOIcf;
    real B4SOIclc;
    real B4SOIcle;
    real B4SOIdwc;
    real B4SOIdlc;
    real B4SOIalpha0;
    real B4SOIoxideTrapDensityA;
    real B4SOIoxideTrapDensityB;
    real B4SOIoxideTrapDensityC;
    real B4SOItnoia;
    real B4SOItnoib;

//Variables controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
    real B4SOItnoic; // for TNOIMOD=3
    real B4SOIrnoic; // for TNOIMOD=3
`endif

    real B4SOIrnoia;
    real B4SOIrnoib;
    real B4SOIntnoi;
    real B4SOIsaref;
    real B4SOIsbref;
    real B4SOIwlod;
    real B4SOIku0;
    real B4SOIkvsat;
    real B4SOIkvth0;
    real B4SOItku0;
    real B4SOIllodku0;
    real B4SOIwlodku0;
    real B4SOIllodvth;
    real B4SOIwlodvth;
    real B4SOIstk2;
    real B4SOIlodk2;
    real B4SOIsteta0;
    real B4SOIlodeta0;
    real B4SOIsteta0cv;
    real B4SOIlodeta0cv;
    real B4SOIgbmin;
    real B4SOIbf;
    real B4SOIw0flk;
    real B4SOIdvtp0;
    real B4SOIdvtp1;
    real B4SOIdvtp2;
    real B4SOIdvtp3;
    real B4SOIdvtp4;
    real B4SOIminv;
    real B4SOIpdits;
    real B4SOIpditsl;
    real B4SOIpditsd;
    real B4SOIfprout;
    real B4SOIem;
    real B4SOIef;
    real B4SOIaf;
    real B4SOIkf;
    real B4SOInoif;
    real B4SOIk1w1;
    real B4SOIk1w2;
    real B4SOIketas;
    real B4SOIdwbc;
    real B4SOIbeta0;
    real B4SOIbeta1;
    real B4SOIbeta2;
    real B4SOIvdsatii0;
    real B4SOItii;
    real B4SOIlii;
    real B4SOIsii0;
    real B4SOIsii1;
    real B4SOIsii2;
    real B4SOIsiid;
    real B4SOIfbjtii;
    real B4SOIebjtii;
    real B4SOIcbjtii;
    real B4SOIvbci;
    real B4SOIabjtii;
    real B4SOImbjtii;
    real B4SOItvbci;
    real B4SOIesatii;
    real B4SOIntun;
    real B4SOIntund;
    real B4SOInrecf0;
    real B4SOInrecf0d;
    real B4SOInrecr0;
    real B4SOInrecr0d;
    real B4SOIisbjt;
    real B4SOIidbjt;
    real B4SOIisdif;
    real B4SOIiddif;
    real B4SOIisrec;
    real B4SOIidrec;
    real B4SOIistun;
    real B4SOIidtun;
    real B4SOIln;
    real B4SOIvrec0;
    real B4SOIvrec0d;
    real B4SOIvtun0;
    real B4SOIvtun0d;
    real B4SOInbjt;
    real B4SOIlbjt0;
    real B4SOIldif0;
    real B4SOIvabjt;
    real B4SOIaely;
    real B4SOIahli;
    real B4SOIahlid;
    real B4SOIrbody;
    real B4SOIrbsh;
    real B4SOIcgeo;
    real B4SOItt;
    real B4SOIndif;
    real B4SOIvsdfb;
    real B4SOIvsdth;
    real B4SOIcsdmin;
    real B4SOIasd;
    real B4SOIcsdesw;
    real B4SOIntrecf;
    real B4SOIntrecr;
    real B4SOIdlcb;
    real B4SOIfbody;
    real B4SOItcjswg;
    real B4SOItpbswg;
    real B4SOItcjswgd;
    real B4SOItpbswgd;
    real B4SOIacde;
    real B4SOImoin;
    real B4SOInoff;
    real B4SOInoff2; /* 2015enh2 */
    real B4SOIdelvt;
    real B4SOIkb1;
    real B4SOIdlbg;
    real B4SOIcfrcoeff;
    integer B4SOIigbMod;
    integer B4SOIigcMod;
    real B4SOItoxqm;
    real B4SOIwth0;
    real B4SOIrhalo;
    real B4SOIntox;
    real B4SOItoxref;
    real B4SOIebg;
    real B4SOIvevb;
    real B4SOIalphaGB1;
    real B4SOIbetaGB1;
    real B4SOIvgb1;
    real B4SOIvecb;
    real B4SOIalphaGB2;
    real B4SOIbetaGB2;
    real B4SOIvgb2;
    real B4SOIaigbcp2;
    real B4SOIbigbcp2;
    real B4SOIcigbcp2;
    real B4SOIvoxh;
    real B4SOIdeltavox;
    real B4SOIaigc;
    real B4SOIbigc;
    real B4SOIcigc;
    real B4SOIaigsd;
    real B4SOIbigsd;
    real B4SOIcigsd;
    real B4SOInigc;
    real B4SOIpigcd;
    real B4SOIpoxedge;
    real B4SOIdlcig;
    real B4SOIvbs0pd;
    real B4SOIvbs0fd;
    real B4SOIvbsa;
    real B4SOInofffd;
    real B4SOIvofffd;
    real B4SOIk1b;
    real B4SOIk2b;
    real B4SOIdk2b;
    real B4SOIdvbd0;
    real B4SOIdvbd1;
    real B4SOImoinFD;
    real B4SOIxrcrg1;
    real B4SOIxrcrg2;
    real B4SOIrshg;
    real B4SOIngcon;
    real B4SOIxgw;
    real B4SOIxgl;
    integer B4SOIrdsMod;
    integer B4SOIfdMod;
    real B4SOIvsce;
    real B4SOIcdsbs;
    real B4SOIminvcv;
    real B4SOIvoffcv;
    real B4SOIvtm;
    real B4SOIueff;
    real B4SOIthetavth;
    real B4SOIig;
    real B4SOIgcrg;
    real B4SOIInv_ODeff;
    real B4SOIgrbsb;
    real B4SOIgrbdb;
    real B4SOIigp;
    real B4SOITempSH;
    real B4SOIigidl;
    real B4SOIigisl;
    real B4SOIgrgeltd;
    real B4SOIsourceResistance;
    real B4SOIdrainResistance;
    real B4SOIvfbzb;
    real B4SOIvtfbphi1;
    real B4SOIvgsteffvth;
    real B4SOIrbodyext;
    real B4SOIcsesw;
    real B4SOIcdesw;
    real B4SOIcsbox;
    real B4SOIcdbox;
    real B4SOIcsmin;
    real B4SOIcdmin;
    real B4SOIst4;
    real B4SOIdt4;
    real B4SOInstar;
    real B4SOIAbulk;
    real B4SOIqinv;
    real B4SOIgm;
    real B4SOIgds;
    real B4SOIgmbs;
    real B4SOIIgcs;
    real B4SOIIgcd;
    real B4SOIIgs;
    real B4SOIIgd;
    real B4SOIqdrn;
    real B4SOIqsrc;
    real B4SOIqse;
    real B4SOIqde;
    real B4SOIrds;
    real B4SOIVgsteff;
    real B4SOIVdseff;
    real B4SOIAbovVgst2Vtm;
    real B4SOIidovVds;

    /* New variables added corresponding to the various material properties for mtrlMod=1 by Pankaj in May 2012*/
    real B4SOIEGGBCP2;
    real B4SOIEGGDEP;
    real B4SOIAGB1;
    real B4SOIBGB1;
    real B4SOIAGB2;
    real B4SOIBGB2;
    real B4SOIAGBC2N;
    real B4SOIAGBC2P;
    real B4SOIBGBC2N;
    real B4SOIBGBC2P;
    real B4SOIVTM00;

    /* Binnig parameter */
    real pParam_B4SOIcdsc;
    real pParam_B4SOIcdscb;
    real pParam_B4SOIcdscd;
    real pParam_B4SOIcit;
    real pParam_B4SOInfactor;
    real pParam_B4SOIvsat;
    real pParam_B4SOIat;
    real pParam_B4SOIa0;
    real pParam_B4SOIags;
    real pParam_B4SOIa1;
    real pParam_B4SOIa2;
    real pParam_B4SOIketa;
    real pParam_B4SOInpeak;
    real pParam_B4SOInsub;
    real pParam_B4SOIngate;
    real pParam_B4SOInsd;
    real pParam_B4SOIgamma1;
    real pParam_B4SOIgamma2;
    real pParam_B4SOIvbx;
    real pParam_B4SOIvbi;
    real pParam_B4SOIvbm;
    real pParam_B4SOIxt;
    real pParam_B4SOIphi;
    real pParam_B4SOIlitl;
    real pParam_B4SOIk1;
    real pParam_B4SOIkt1;
    real pParam_B4SOIkt1l;
    real pParam_B4SOIkt2;
    real pParam_B4SOIk2;
    real pParam_B4SOIk3;
    real pParam_B4SOIk3b;
    real pParam_B4SOIw0;
    real pParam_B4SOIlpe0;
    real pParam_B4SOIdvt0;
    real pParam_B4SOIdvt1;
    real pParam_B4SOIdvt2;
    real pParam_B4SOIdvt0w;
    real pParam_B4SOIdvt1w;
    real pParam_B4SOIdvt2w;
    real pParam_B4SOIdrout;
    real pParam_B4SOIdsub;
    real pParam_B4SOIvth0;
    real pParam_B4SOIua;
    real pParam_B4SOIua1;
    real pParam_B4SOIub;
    real pParam_B4SOIub1;
    real pParam_B4SOIuc;
    real pParam_B4SOIuc1;
    real pParam_B4SOIu0;
    real pParam_B4SOIute;
    real pParam_B4SOIud;
    real pParam_B4SOIud1;
    real pParam_B4SOIeu;
    real pParam_B4SOIucs;
    real pParam_B4SOIucste;
    real pParam_B4SOIvoff;
    real pParam_B4SOIvfb;
    real pParam_B4SOIuatemp;
    real pParam_B4SOIubtemp;
    real pParam_B4SOIuctemp;
    real pParam_B4SOIrbody;
    real pParam_B4SOIrth;
    real pParam_B4SOIcth;
    real pParam_B4SOIrds0denom;
    real pParam_B4SOIvfbb;
    real pParam_B4SOIjbjts;
    real pParam_B4SOIjbjtd;
    real pParam_B4SOIjdifs;
    real pParam_B4SOIjdifd;
    real pParam_B4SOIjrecs;
    real pParam_B4SOIjrecd;
    real pParam_B4SOIjtuns;
    real pParam_B4SOIjtund;
    real pParam_B4SOIrdw;
    real pParam_B4SOIrsw;
    real pParam_B4SOIrdwmin;
    real pParam_B4SOIrswmin;
    real pParam_B4SOIrd0;
    real pParam_B4SOIrs0;
    real pParam_B4SOIsdt1;
    real pParam_B4SOIst2;
    real pParam_B4SOIst3;
    real pParam_B4SOIdt2;
    real pParam_B4SOIdt3;
    real pParam_B4SOIdelta;
    real pParam_B4SOIrdsw;
    real pParam_B4SOIrds0;
    real pParam_B4SOIprwg;
    real pParam_B4SOIprwb;
    real pParam_B4SOIprt;
    real pParam_B4SOIeta0;
    real pParam_B4SOIetab;
    real pParam_B4SOIeta0cv;
    real pParam_B4SOIetabcv;
    real pParam_B4SOIpclm;
    real pParam_B4SOIpdibl1;
    real pParam_B4SOIpdibl2;
    real pParam_B4SOIpdiblb;
    real pParam_B4SOIpvag;
    real pParam_B4SOIwr;
    real pParam_B4SOIdwg;
    real pParam_B4SOIdwb;
    real pParam_B4SOIb0;
    real pParam_B4SOIb1;
    real pParam_B4SOIalpha0;
    real pParam_B4SOIbeta0;
    real pParam_B4SOIaigc;
    real pParam_B4SOIbigc;
    real pParam_B4SOIcigc;
    real pParam_B4SOIaigsd;
    real pParam_B4SOIbigsd;
    real pParam_B4SOIcigsd;
    real pParam_B4SOInigc;
    real pParam_B4SOIpigcd;
    real pParam_B4SOIpoxedge;
    real pParam_B4SOIdlcig;
    real pParam_B4SOIvbsa;
    real pParam_B4SOIvsce;
    real pParam_B4SOIcdsbs;
    real pParam_B4SOInofffd;
    real pParam_B4SOIvofffd;
    real pParam_B4SOIk1b;
    real pParam_B4SOIk2b;
    real pParam_B4SOIdk2b;
    real pParam_B4SOIdvbd0;
    real pParam_B4SOIdvbd1;
    real pParam_B4SOImoinfd;
    real pParam_B4SOIvbs0pd;
    real pParam_B4SOIvbs0fd;
    real pParam_B4SOIxrcrg1;
    real pParam_B4SOIxrcrg2;
    real pParam_B4SOIku0;
    real pParam_B4SOIkvth0;
    real pParam_B4SOIku0temp;
    real pParam_B4SOIrho_ref;
    real pParam_B4SOIinv_od_ref;
    real pParam_B4SOIcgsl;
    real pParam_B4SOIcgdl;
    real pParam_B4SOIckappa;
    real pParam_B4SOIcf;
    real pParam_B4SOIclc;
    real pParam_B4SOIcle;
    real pParam_B4SOIxj;
    real pParam_B4SOIalphaGB1;
    real pParam_B4SOIbetaGB1;
    real pParam_B4SOIalphaGB2;
    real pParam_B4SOIbetaGB2;
    real pParam_B4SOIaigbcp2;
    real pParam_B4SOIbigbcp2;
    real pParam_B4SOIcigbcp2;
    real pParam_B4SOIndif;
    real pParam_B4SOIntrecf;
    real pParam_B4SOIntrecr;
    real pParam_B4SOIxbjt;
    real pParam_B4SOIxdif;
    real pParam_B4SOIxrec;
    real pParam_B4SOIxtun;
    real pParam_B4SOIxdifd;
    real pParam_B4SOIxrecd;
    real pParam_B4SOIxtund;
    real pParam_B4SOIkb1;
    real pParam_B4SOIk1w1;
    real pParam_B4SOIk1w2;
    real pParam_B4SOIketas;
    real pParam_B4SOIfbjtii;
    real pParam_B4SOIebjtii;
    real pParam_B4SOIcbjtii;
    real pParam_B4SOIvbci;
    real pParam_B4SOIabjtii;
    real pParam_B4SOImbjtii;
    real pParam_B4SOIbeta1;
    real pParam_B4SOIbeta2;
    real pParam_B4SOIvdsatii0;
    real pParam_B4SOIlii;
    real pParam_B4SOIesatii;
    real pParam_B4SOIsii0;
    real pParam_B4SOIsii1;
    real pParam_B4SOIsii2;
    real pParam_B4SOIsiid;
    real pParam_B4SOIagidl;
    real pParam_B4SOIbgidl;
    real pParam_B4SOIcgidl;
    real pParam_B4SOIegidl;
    real pParam_B4SOIrgidl;
    real pParam_B4SOIkgidl;
    real pParam_B4SOIfgidl;
    real pParam_B4SOIagisl;
    real pParam_B4SOIbgisl;
    real pParam_B4SOIcgisl;
    real pParam_B4SOIegisl;
    real pParam_B4SOIrgisl;
    real pParam_B4SOIkgisl;
    real pParam_B4SOIfgisl;
    real pParam_B4SOIntun;
    real pParam_B4SOIntund;
    real pParam_B4SOIndiode;
    real pParam_B4SOIndioded;
    real pParam_B4SOInrecf0;
    real pParam_B4SOInrecf0d;
    real pParam_B4SOInrecr0;
    real pParam_B4SOInrecr0d;
    real pParam_B4SOIisbjt;
    real pParam_B4SOIidbjt;
    real pParam_B4SOIisdif;
    real pParam_B4SOIiddif;
    real pParam_B4SOIisrec;
    real pParam_B4SOIidrec;
    real pParam_B4SOIistun;
    real pParam_B4SOIidtun;
    real pParam_B4SOIvrec0;
    real pParam_B4SOIvrec0d;
    real pParam_B4SOIvtun0;
    real pParam_B4SOIvtun0d;
    real pParam_B4SOInbjt;
    real pParam_B4SOIlbjt0;
    real pParam_B4SOIvabjt;
    real pParam_B4SOIaely;
    real pParam_B4SOIvsdfb;
    real pParam_B4SOIvsdth;
    real pParam_B4SOIdelvt;
    real pParam_B4SOIdw;
    real pParam_B4SOIdl;
    real pParam_B4SOIleff;
    real pParam_B4SOIweff;
    real pParam_B4SOIdwc;
    real pParam_B4SOIdlc;
    real pParam_B4SOIleffCV;
    real pParam_B4SOIweffCV;
    real pParam_B4SOIabulkCVfactor;
    real pParam_B4SOIcgso;
    real pParam_B4SOIcgdo;
    real pParam_B4SOIcgeo;
    real pParam_B4SOIu0temp;
    real pParam_B4SOIvsattemp;
    real pParam_B4SOIsqrtPhi;
    real pParam_B4SOIXdep0;
    real pParam_B4SOIsqrtXdep0;
    real pParam_B4SOItheta0vb0;
    real pParam_B4SOIthetaRout;
    real pParam_B4SOIqsi;
    real pParam_B4SOIoxideRatio;
    real pParam_B4SOIk1eff;
    real pParam_B4SOIwdios;
    real pParam_B4SOIwdiod;
    real pParam_B4SOIwdiodCV;
    real pParam_B4SOIwdiosCV;
    real pParam_B4SOIarfabjt;
    real pParam_B4SOIlratio;
    real pParam_B4SOIlratiodif;
    real pParam_B4SOIvearly;
    real pParam_B4SOIahli;
    real pParam_B4SOIahlid;
    real pParam_B4SOIahli0s;
    real pParam_B4SOIahli0d;
    real pParam_B4SOIvfbzb;
    real pParam_B4SOIldeb;
    real pParam_B4SOIacde;
    real pParam_B4SOImoin;
    real pParam_B4SOInoff;
    real pParam_B4SOInoff2;  /* 2015enh2 */
    real pParam_B4SOIleffCVb;
    real pParam_B4SOIleffCVbg;
    real pParam_B4SOIcdep0;
    real pParam_B4SOIToxRatio;
    real pParam_B4SOIAechvb;
    real pParam_B4SOIBechvb;
    real pParam_B4SOIToxRatioEdge;
    real pParam_B4SOIAechvbEdges;
    real pParam_B4SOIAechvbEdged;
    real pParam_B4SOIBechvbEdge;
    real pParam_B4SOIvfbsd;
    real pParam_B4SOIk1ox;
    real pParam_B4SOIlpeb;
    real pParam_B4SOIdvtp0;
    real pParam_B4SOIdvtp1;
    real pParam_B4SOIdvtp2;
    real pParam_B4SOIdvtp3;
    real pParam_B4SOIdvtp4;
    real pParam_B4SOIminv;
    real pParam_B4SOImstar;
    real pParam_B4SOIfprout;
    real pParam_B4SOIpdits;
    real pParam_B4SOIpditsd;
    real pParam_B4SOImstarcv;
    real pParam_B4SOIminvcv;
    real pParam_B4SOIvoffcv;
    real pParam_B4SOIdvtp2factor;
    real B4SOIcbox;
    real B4SOIcsi;
    real B4SOIeg0;
    real B4SOIeg;
    real B4SOIcox;
    real B4SOIfactor1;
    integer B4SOImode;
    integer B4SOIbodyMod; // >0 when b and/or p terminals are connected


    // instance values for sti stress effect
    real here_B4SOIeta0, here_B4SOIeta0cv, here_B4SOIk2, here_B4SOIk2ox, here_B4SOIu0temp;
    real here_B4SOIvfb, here_B4SOIvsattemp, here_B4SOIvth0;

    real DevTemp, delTemp, TempRatio, TempRatioMinus1;
    real fourkt, gdnoise, gsnoise;
    real toxe, epsrox, epssub, epsgate, sqrt2qeps;

    real eggbcp2, eggdep, Vtm00;
    real agb1, bgb1, agb2, bgb2, agbc2n, agbc2p, bgbc2n, bgbc2p;

    real Qsi, Vbs0t;
    real NchMax;

    real QOV, QGI, qov, qgi; // overlap and intrinsic gate charges

`ifdef __XYCE__
analog begin : the_module
`endif

`ifdef __XYCE__
@(initial_instance)
    begin: initialize_instance
`endif
    DevTemp = $temperature + DTEMP;

    B4SOItype = TYPE;
    B4SOIl = L;
    B4SOIw = W;
    B4SOInf = NF;
    B4SOIsa = SA;
    B4SOIsb = SB;
    B4SOIsd = SD;
    B4SOIdrainArea = AD;
    B4SOIsourceArea = AS;
    B4SOIdrainPerimeter = PD;
    B4SOIsourcePerimeter = PS;
    B4SOIdrainSquares = NRD;
    B4SOIsourceSquares = NRS;
    B4SOIbjtoff = BJTOFF;
    B4SOIrth0 = RTH0;
    B4SOIcth0 = CTH0;
    B4SOIbodySquares = NRB;
    B4SOIfrbody = FRBODY;
    B4SOIrbdb = RBDB;
    B4SOIrbsb = RBSB;
    B4SOIdelvto = DELVTO;
    B4SOIsoiMod = SOIMOD;
    B4SOInbc = NBC;
    B4SOInseg = NSEG;
    B4SOIpdbcp = PDBCP;
    B4SOIpsbcp = PSBCP;
    B4SOIagbcp = AGBCP;
    B4SOIagbcp2 = AGBCP2;
    B4SOIagbcpd = AGBCPD;
    B4SOIaebcp = AEBCP;
    B4SOIrgateMod = RGATEMOD;
    B4SOIrbodyMod = RBODYMOD;
    B4SOImtrlMod = MTRLMOD;
    B4SOIvgstcvMod = VGSTCVMOD;
    B4SOIgidlMod = GIDLMOD;
    B4SOIiiiMod = IIIMOD;
    B4SOIeot = EOT;
    B4SOIepsrox = EPSROX;
    B4SOIepsrsub = EPSRSUB;
    B4SOIni0sub = NI0SUB;
    B4SOIbg0sub = BG0SUB;
    B4SOItbgasub = TBGASUB;
    B4SOItbgbsub = TBGBSUB;
    B4SOIphig = PHIG;
    B4SOIeasub = EASUB;
    B4SOIleffeot = LEFFEOT;
    B4SOIweffeot = WEFFEOT;
    B4SOIvddeot = VDDEOT;
    B4SOItempeot = TEMPEOT;
    B4SOIados = ADOS;
    B4SOIbdos = BDOS;
    B4SOIepsrgate = EPSRGATE;
    B4SOIcapMod = CAPMOD;
    B4SOImobMod = MOBMOD;
    B4SOIbinUnit = BINUNIT;
    B4SOItox = TOX;
    B4SOItoxm = TOXM;
    B4SOIdtoxcv = DTOXCV;
    B4SOIcdsc = CDSC;
    B4SOIcdscb = CDSCB;
    B4SOIcdscd = CDSCD;
    B4SOIcit = CIT;
    B4SOInfactor = NFACTOR;
    B4SOIvsat = VSAT;
    B4SOIat = AT;
    B4SOIa0 = A0;
    B4SOIags = AGS;
    B4SOIa1 = A1;
    B4SOIa2 = A2;
    B4SOIketa = KETA;
    B4SOInsub = NSUB;
    B4SOInpeak = NCH;
    B4SOIngate = NGATE;
    B4SOInsd = NSD;
    B4SOIgamma1 = GAMMA1;
    B4SOIgamma2 = GAMMA2;
    B4SOIvbx = VBX;
    B4SOIvbm = VBM;
    B4SOIxt = XT;
    B4SOIk1 = K1;
    B4SOIkt1 = KT1;
    B4SOIkt1l = KT1L;
    B4SOIkt2 = KT2;
    B4SOIk2 = K2;
    B4SOIk3 = K3;
    B4SOIk3b = K3B;
    B4SOIw0 = W0;
    B4SOIlpe0 = LPE0;
    B4SOIlpeb = LPEB;
    B4SOIdvt0 = DVT0;
    B4SOIdvt1 = DVT1;
    B4SOIdvt2 = DVT2;
    B4SOIdvt0w = DVT0W;
    B4SOIdvt1w = DVT1W;
    B4SOIdvt2w = DVT2W;
    B4SOIdrout = DROUT;
    B4SOIdsub = DSUB;
    B4SOIvth0 = VTH0;
    B4SOIvfb = VFB;
    B4SOIua = UA;
    B4SOIua1 = UA1;
    B4SOIub = UB;
    B4SOIub1 = UB1;
    B4SOIuc = UC;
    B4SOIuc1 = UC1;
    B4SOIu0 = U0;
    B4SOIeu = EU;
    B4SOIute = UTE;
    B4SOIucs = UCS;
    B4SOIucste = UCSTE;
    B4SOIud = UD;
    B4SOIud1 = UD1;
    B4SOIvoff = VOFF;
    B4SOItnom = TNOM + `P_CELSIUS0;
    B4SOIxpart = XPART;
    B4SOIdelta = DELTA;
    B4SOIsheetResistance = RSH;
    B4SOIrdsw = RDSW;
    B4SOIrsw = RSW;
    B4SOIrdw = RDW;
    B4SOIrswmin = RSWMIN;
    B4SOIrdwmin = RDWMIN;
    B4SOIprwg = PRWG;
    B4SOIprwb = PRWB;
    B4SOIprt = PRT;
    B4SOIeta0 = ETA0;
    B4SOIetab = ETAB;
    B4SOIeta0cv = ETA0CV;
    B4SOIetabcv = ETABCV;
    B4SOIpclm = PCLM;
    B4SOIpdibl1 = PDIBLC1;
    B4SOIpdibl2 = PDIBLC2;
    B4SOIpdiblb = PDIBLCB;
    B4SOIpvag = PVAG;
    B4SOItbox = TBOX;
    B4SOItsi = TSI;
    B4SOIetsi = ETSI;
    B4SOIxj = XJ;
    B4SOIegidl = EGIDL;
    B4SOIagidl = AGIDL;
    B4SOIbgidl = BGIDL;
    B4SOIcgidl = CGIDL;
    B4SOIrgidl = RGIDL;
    B4SOIkgidl = KGIDL;
    B4SOIfgidl = FGIDL;
    B4SOIegisl = EGISL;
    B4SOIagisl = AGISL;
    B4SOIbgisl = BGISL;
    B4SOIcgisl = CGISL;
    B4SOIrgisl = RGISL;
    B4SOIkgisl = KGISL;
    B4SOIfgisl = FGISL;
    B4SOIndiode = NDIODE;
    B4SOIndioded = NDIODED;
    B4SOIxbjt = XBJT;
    B4SOIxdif = XDIF;
    B4SOIxrec = XREC;
    B4SOIxtun = XTUN;
    B4SOIxdifd = XDIFD;
    B4SOIxrecd = XRECD;
    B4SOIxtund = XTUND;
    B4SOIGatesidewallJctSPotential = PBSWG;
    B4SOIGatesidewallJctDPotential = PBSWGD;
    B4SOIbodyJctGateSideSGradingCoeff = MJSWG;
    B4SOIbodyJctGateSideDGradingCoeff = MJSWGD;
    B4SOIunitLengthGateSidewallJctCapS = CJSWG;
    B4SOIunitLengthGateSidewallJctCapD = CJSWGD;
    B4SOILint = LINT;
    B4SOILl = LL;
    B4SOILlc = LLC;
    B4SOILln = LLN;
    B4SOILw = LW;
    B4SOILwc = LWC;
    B4SOILwn = LWN;
    B4SOILwl = LWL;
    B4SOILwlc = LWLC;
    B4SOIwr = WR;
    B4SOIWint = WINT;
    B4SOIdwg = DWG;
    B4SOIdwb = DWB;
    B4SOIWl = WL;
    B4SOIWlc = WLC;
    B4SOIWln = WLN;
    B4SOIWw = WW;
    B4SOIWwc = WWC;
    B4SOIWwn = WWN;
    B4SOIWwl = WWL;
    B4SOIWwlc = WWLC;
    B4SOIb0 = B0;
    B4SOIb1 = B1;
    B4SOIcgsl = CGSL;
    B4SOIcgdl = CGDL;
    B4SOIckappa = CKAPPA;
    B4SOIclc = CLC;
    B4SOIcle = CLE;
    B4SOIdwc = DWC;
    B4SOIdlc = DLC;
    B4SOIalpha0 = ALPHA0;
    B4SOIoxideTrapDensityA = NOIA;
    B4SOIoxideTrapDensityB = NOIB;
    B4SOIoxideTrapDensityC = NOIC;
    B4SOItnoia = TNOIA;
    B4SOItnoib = TNOIB;

//Assignments controlled by Correlated Thermal Noise Switch
`ifdef  _TNOIMOD3_
    B4SOItnoic = TNOIC;
    B4SOIrnoic = RNOIC;
`endif

    B4SOIrnoia = RNOIA;
    B4SOIrnoib = RNOIB;
    B4SOIntnoi = NTNOI;
    B4SOIsaref = SAREF;
    B4SOIsbref = SBREF;
    B4SOIwlod = WLOD;
    B4SOIku0 = KU0;
    B4SOIkvsat = KVSAT;
    B4SOIkvth0 = KVTH0;
    B4SOItku0 = TKU0;
    B4SOIllodku0 = LLODKU0;
    B4SOIwlodku0 = WLODKU0;
    B4SOIllodvth = LLODVTH;
    B4SOIwlodvth = WLODVTH;
    B4SOIstk2 = STK2;
    B4SOIlodk2 = LODK2;
    B4SOIsteta0 = STETA0;
    B4SOIlodeta0 = LODETA0;
    B4SOIsteta0cv = STETA0CV;
    B4SOIlodeta0cv = LODETA0CV;
    B4SOIgbmin = GBMIN;
    B4SOIbf = BF;
    B4SOIw0flk = W0FLK;
    B4SOIdvtp0 = DVTP0;
    B4SOIdvtp1 = DVTP1;
    B4SOIdvtp2 = DVTP2;
    B4SOIdvtp3 = DVTP3;
    B4SOIdvtp4 = DVTP4;
    B4SOIminv = MINV;
    B4SOIpdits = PDITS;
    B4SOIpditsl = PDITSL;
    B4SOIpditsd = PDITSD;
    B4SOIfprout = FPROUT;
    B4SOIem = EM;
    B4SOIef = EF;
    B4SOIaf = AF;
    B4SOIkf = KF;
    B4SOInoif = NOIF;
    B4SOIk1w1 = K1W1;
    B4SOIk1w2 = K1W2;
    B4SOIketas = KETAS;
    B4SOIdwbc = DWBC;
    B4SOIbeta0 = BETA0;
    B4SOIbeta1 = BETA1;
    B4SOIbeta2 = BETA2;
    B4SOIvdsatii0 = VDSATII0;
    B4SOItii = TII;
    B4SOIlii = LII;
    B4SOIsii0 = SII0;
    B4SOIsii1 = SII1;
    B4SOIsii2 = SII2;
    B4SOIsiid = SIID;
    B4SOIfbjtii = FBJTII;
    B4SOIebjtii = EBJTII;
    B4SOIcbjtii = CBJTII;
    B4SOIvbci = VBCI;
    B4SOIabjtii = ABJTII;
    B4SOImbjtii = MBJTII;
    B4SOItvbci = TVBCI;
    B4SOIesatii = ESATII;
    B4SOIntun = NTUN;
    B4SOIntund = NTUND;
    B4SOInrecf0 = NRECF0;
    B4SOInrecf0d = NRECF0D;
    B4SOInrecr0 = NRECR0;
    B4SOInrecr0d = NRECR0D;
    B4SOIisbjt = ISBJT;
    B4SOIidbjt = IDBJT;
    B4SOIisdif = ISDIF;
    B4SOIiddif = IDDIF;
    B4SOIisrec = ISREC;
    B4SOIidrec = IDREC;
    B4SOIistun = ISTUN;
    B4SOIidtun = IDTUN;
    B4SOIln = LN;
    B4SOIvrec0 = VREC0;
    B4SOIvrec0d = VREC0D;
    B4SOIvtun0 = VTUN0;
    B4SOIvtun0d = VTUN0D;
    B4SOInbjt = NBJT;
    B4SOIlbjt0 = LBJT0;
    B4SOIldif0 = LDIF0;
    B4SOIvabjt = VABJT;
    B4SOIaely = AELY;
    B4SOIahli = AHLI;
    B4SOIahlid = AHLID;
    B4SOIrbody = RBODY;
    B4SOIrbsh = RBSH;
    B4SOIcgeo = CGEO;
    B4SOItt = TT;
    B4SOIndif = NDIF;
    B4SOIvsdfb = VSDFB;
    B4SOIvsdth = VSDTH;
    B4SOIcsdmin = CSDMIN;
    B4SOIasd = ASD;
    B4SOIcsdesw = CSDESW;
    B4SOIntrecf = NTRECF;
    B4SOIntrecr = NTRECR;
    B4SOIdlcb = DLCB;
    B4SOIfbody = FBODY;
    B4SOItcjswg = TCJSWG;
    B4SOItpbswg = TPBSWG;
    B4SOItcjswgd = TCJSWGD;
    B4SOItpbswgd = TPBSWGD;
    B4SOIacde = ACDE;
    B4SOImoin = MOIN;
    B4SOInoff = NOFF;
    B4SOInoff2 = NOFF2;  /* 2015enh2 */
    B4SOIdelvt = DELVT;
    B4SOIkb1 = KB1;
    B4SOIdlbg = DLBG;
    B4SOIcfrcoeff = CFRCOEFF;
    B4SOIigbMod = IGMOD;
    B4SOIigcMod = IGCMOD;
    B4SOItoxqm = TOXQM;
    B4SOIwth0 = WTH0;
    B4SOIrhalo = RHALO;
    B4SOIntox = NTOX;
    B4SOItoxref = TOXREF;
    B4SOIebg = EBG;
    B4SOIvevb = VEVB;
    B4SOIalphaGB1 = ALPHAGB1;
    B4SOIbetaGB1 = BETAGB1;
    B4SOIvgb1 = VGB1;
    B4SOIvecb = VECB;
    B4SOIalphaGB2 = ALPHAGB2;
    B4SOIbetaGB2 = BETAGB2;
    B4SOIvgb2 = VGB2;
    B4SOIaigbcp2 = AIGBCP2;
    B4SOIbigbcp2 = BIGBCP2;
    B4SOIcigbcp2 = CIGBCP2;
    B4SOIvoxh = VOXH;
    B4SOIdeltavox = DELTAVOX;
    B4SOIaigc = AIGC;
    B4SOIbigc = BIGC;
    B4SOIcigc = CIGC;
    B4SOIaigsd = AIGSD;
    B4SOIbigsd = BIGSD;
    B4SOIcigsd = CIGSD;
    B4SOInigc = NIGC;
    B4SOIpigcd = PIGCD;
    B4SOIpoxedge = POXEDGE;
    B4SOIdlcig = DLCIG;
    B4SOIvbsa = VBSA;
    B4SOInofffd = NOFFFD;
    B4SOIvofffd = VOFFFD;
    B4SOIk1b = K1B;
    B4SOIk2b = K2B;
    B4SOIdk2b = DK2B;
    B4SOIdvbd0 = DVBD0;
    B4SOIdvbd1 = DVBD1;
    B4SOImoinFD = MOINFD;
    B4SOIvbs0pd = VBS0PD;
    B4SOIvbs0fd = VBS0FD;
    B4SOIxrcrg1 = XRCRG1;
    B4SOIxrcrg2 = XRCRG2;
    B4SOIrshg = RSHG;
    B4SOIngcon = NGCON;
    B4SOIxgw = XGW;
    B4SOIxgl = XGL;
    B4SOIrdsMod = RDSMOD;
    B4SOIfdMod = FDMOD;
    B4SOIvsce = VSCE;
    B4SOIcdsbs = CDSBS;
    B4SOIminvcv = MINVCV;
    B4SOIvoffcv = VOFFCV;

    /* New varaibles added corresponding to the various material properties for mtrlMod=1 by Pankaj in May 2012*/
    B4SOIEGGBCP2=EGGBCP2;
    B4SOIEGGDEP=EGGDEP;
    B4SOIAGB1=AGB1;
    B4SOIBGB1=BGB1;
    B4SOIAGB2=AGB2;
    B4SOIBGB2=BGB2;
    B4SOIAGBC2N=AGBC2N;
    B4SOIAGBC2P=AGBC2P;
    B4SOIBGBC2N=BGBC2N;
    B4SOIBGBC2P=BGBC2P;
    B4SOIVTM00=VTM00;


    if ($param_given(LPE0) && $param_given(NLX))
        $strobe("Warning: parameter LPE0 overrides NLX.");
    if ($param_given(LLPE0) && $param_given(LNLX))
        $strobe("Warning: parameter LLPE0 overrides LNLX.");
    if ($param_given(WLPE0) && $param_given(WNLX))
        $strobe("Warning: parameter WLPE0 overrides WNLX.");
    if ($param_given(PLPE0) && $param_given(PNLX))
        $strobe("Warning: parameter PLPE0 overrides PNLX.");
    if ($param_given(EGIDL) && $param_given(NGIDL))
        $strobe("Warning: parameter EGIDL overrides NGIDL.");
    if ($param_given(LEGIDL) && $param_given(LNGIDL))
        $strobe("Warning: parameter LEGIDL overrides LNGIDL.");
    if ($param_given(WEGIDL) && $param_given(WNGIDL))
        $strobe("Warning: parameter WEGIDL overrides WNGIDL.");
    if ($param_given(PEGIDL) && $param_given(PNGIDL))
        $strobe("Warning: parameter PEGIDL overrides PNGIDL.");

    /*B4SOIcox = 3.453133e-11 / B4SOItox;*/
    if (B4SOImtrlMod) begin
        epsrox = 3.9;
        toxe = B4SOIeot;
        epssub = `EPS0 * B4SOIepsrsub;
        sqrt2qeps = sqrt(2.0e6 * `Charge_q * epssub);
        //B4SOIcox = 3.453133e-11 / B4SOItox;
        B4SOIcox = epsrox * `EPS0 / toxe;

        /*These constants are replaced with model parameters by Pankaj in May 2012*/
        eggbcp2 = B4SOIEGGBCP2;
        eggdep = B4SOIEGGDEP;
        agb1 = B4SOIAGB1;
        bgb1 = B4SOIBGB1;
        agb2 = B4SOIAGB2;
        bgb2 = B4SOIBGB2;
        agbc2n = B4SOIAGBC2N;
        agbc2p = B4SOIAGBC2P;
        bgbc2n = B4SOIBGBC2N;
        bgbc2p = B4SOIBGBC2P;

    end else begin
        epsrox = B4SOIepsrox;
        toxe = B4SOItox;
        epssub = `EPSSI;
        sqrt2qeps = 5.753e-12; /* constant from v4.3.0 and earlier */
        //B4SOIcox = epsrox * `EPS0 / toxe;
        B4SOIcox = 3.453133e-11 / B4SOItox;

    /*These constants are replaced with model parameters for mtrlMod=0 on request made by TSMC in v4.6*/ /* 2015enh2 */
        eggbcp2 = B4SOIEGGBCP2;
        eggdep = B4SOIEGGDEP;
        agb1 = B4SOIAGB1;
        bgb1 = B4SOIBGB1;
        agb2 = B4SOIAGB2;
        bgb2 = B4SOIBGB2;
        agbc2n = B4SOIAGBC2N;
        agbc2p = B4SOIAGBC2P;
        bgbc2n = B4SOIBGBC2N;
        bgbc2p = B4SOIBGBC2P;

    end


`ifdef PORT_CONNECTED
    if (B4SOIsoiMod == 2) begin /* v3.2 */
        if (SHMOD == 0) begin
            if (TNODEOUT == 0) begin //TNODEOUT = 0 starts here.
                if ($port_connected(p) && $port_connected(b)) begin
                    //V(b) <+ 0;
                   $strobe("Error:  you have specified a P and B node (5th and 6th node) when soimod=2 and TNODEOUT=0.  The P and B nodes are not used in this mode and Xyce cannot deal with them being externally specified.  Please remove the 5th and 6th nodes from the instance line.");
                   $finish(1);
                end else begin
                    if ($port_connected(p)) begin
                       $strobe("Error:  you have specified a P node (5th node) when soimod=2 and TNODEOUT=0.  P node is not used in this mode and Xyce cannot deal with it as an externally specified node.  Please remove the 5th node.");
                       $finish(1);
                       //V(p) <+ 0;
                    end
                end
            end else begin //TNODEOUT = 0 for SHMOD = 0 ends here.
                if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                   $strobe("Error:  you have specified a P and B node (5th and 6th node) when soimod=2 and TNODEOUT=1, and a seventh node for temperature. The P and B nodes are not used in this mode and Xyce cannot deal with them being externally specified.  Please remove the P and B nodes. With TNODEOUT=1, the fifth node should be the last one and will be used for temperature.");
                   $finish(1);
                    // V(b) <+ 0; //Case 8
                end
            end            //TNODEOUT = 1 for SHMOD = 0 ends here.
        end else begin     //SHMOD = 0 ends here.
            if (TNODEOUT == 0) begin
                if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                   $strobe("Error:  you have specified a P and B node (fifth and 6th nodes) when soimod=2, and a temperature node (7th) with TNODEOUT=0.  None of these nodes are used in this mode and Xyce cannot deal with them being externally specified.  Please remove the 6th node.");
                   $finish(1);
                   //V(b) <+ 0;
                end else begin
                    if ($port_connected(p) && $port_connected(b)) begin
                       $strobe("Error:  you have specified P and B nodes (5th and 6th node) when soimod=2 and TNODEOUT=0.  These nodes are not used in this mode and Xyce cannot deal with them being externally specified.  Please remove the 5th and 6th nodes.");
                       $finish(1);
                       //V(b) <+ 0;
                    end else begin
                        if ($port_connected(p)) begin
                           $strobe("Error:  you have specified P node (5th node) when soimod=2 and TNODEOUT=0.  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 5th node.");
                           $finish(1);
                           //V(p) <+ 0;
                        end
                    end
                end
            end else begin //TNODEOUT = 0 for SHMOD = 1 ends here.
                if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                   $strobe("Error:  you have specified a B node (6th node) when soimod=2 and TNODEOUT=1, and a seventh node for temperature. The B node is not used in this mode and Xyce cannot deal with it as an externally specified node.  Please remove the B node. With TNODEOUT=1, the 6th node should be the last one and will be used for temperature.");
                   $finish(1);
                   // V(b) <+ 0;
                end
            end //TNODEOUT = 1 for SHMOD = 1 ends here.
        end //SHMOD = 1 ends here.
        // Following block is for issuing warnings for NODECHK
        if (NODECHK) begin      /* 2014bug2 */
            if (SHMOD == 0) begin
                if (TNODEOUT == 0) begin //TNODEOUT = 0 starts here.
                    if ($port_connected(p) && $port_connected(b)) begin
                        $strobe("Warning: 'P' and 'B' nodes were specified, however 'SOIMOD = 2' does not support 'P' or 'B' nodes. Internally these nodes are tied to global ground.");
                    end else begin
                        if ($port_connected(p)) begin
                            $strobe ("Warning: A 'P' node was specified, however 'SOIMOD = 2' does not support a 'P' node. Internally this node is tied to global ground.");
                        end
                    end
                end else begin //TNODEOUT = 0 for SHMOD = 0 ends here.
                    if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                        $strobe("Warning: 'P' and 'B' nodes were specified, however 'SOIMOD = 2' does not support 'P' or 'B' nodes. Internally these nodes are tied to global ground.");
                    end else begin
                        if ($port_connected(p) && $port_connected(b)) begin
                            $strobe ("Warning: A 'P' node was specified, however 'SOIMOD = 2' does not support a 'P' node. Internally this node is tied to global ground.");
                        end
                    end
                end  //TNODEOUT = 1 for SHMOD = 0 ends here.
            end else begin  //SHMOD = 0 ends here.
                if (TNODEOUT == 0) begin
                    if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                        $strobe("Warning: 'P' and 'B' nodes were specified, however 'SOIMOD = 2' does not support 'P' or 'B' nodes. Internally these nodes are tied to global ground.");
                    end else begin
                        if ($port_connected(p) && $port_connected(b)) begin
                            $strobe("Warning: 'P' and 'B' nodes were specified, however 'SOIMOD = 2' does not support 'P' or 'B' nodes. Internally these nodes are tied to global ground.");
                        end else begin
                            if ($port_connected(p)) begin
                                $strobe ("Warning: A 'P' node was specified however 'SOIMOD = 2' does not support a 'P' node. Internally this node is tied to global ground.");
                            end
                        end
                    end
                end else begin //TNODEOUT = 0 for SHMOD = 1 ends here.
                    if ($port_connected(p) && $port_connected(b) && $port_connected(t)) begin
                        $strobe("Warning: 'P' and 'B' nodes were specified, however 'SOIMOD = 2' does not support 'P' or 'B' nodes. Internally these nodes are tied to global ground.");
                    end else begin
                        if ($port_connected(p) && $port_connected(b)) begin
                            $strobe("Warning: Fifth and sixth nodes were specified when TNODEOUT = 1. The fifth node will be treated as the temperature node 'T', and internally the sixth node will be tied to global ground.");
                        end else begin
                            if ($port_connected(p)) begin
                                $strobe ("Warning: A fifth node has been specified with TNODEOUT = 1. The fifth node will be treated as the temperature node 'T'.");
                            end else begin
                                if (!($port_connected(p) && $port_connected(b) && $port_connected(t))) begin
                                    $strobe("Warning: TNODEOUT = 1 requesting an external temperature node, but a fifth node for temperature is not supplied.");
                                end
                            end
                        end
                    end
                end //TNODEOUT = 1 for SHMOD = 1 ends here.
            end //SHMOD = 1 ends here.
        end //NODECHK ends here.
        // here->B4SOIbNode = here->B4SOIpNode = 0;
        B4SOIbodyMod = 0;
        /* For ideal FD, body contact is disabled and no body node */
    end else begin
        if ($port_connected(p) == 0) begin /* floating body case -- 4-node */
            // here->B4SOIbNode = tmp->number;
            // here->B4SOIpNode = 0;
            B4SOIbodyMod = 0;
            if ($port_connected(b)) begin
                $strobe("Warning: cannot connect to 'b' terminal without connecting 'p' terminal.");
            end
        end else begin
            if ($port_connected(t) == 0 && TNODEOUT==1) begin
               $strobe("Xyce does not implement the BSIM-SOI 4 model with TNODEOUT and fewer than 7 nodes.  Ignore any subsequent messages regarding node collapse, they are meaningless.");
               $finish(1);
            end
            if ($port_connected(b) == 0) begin
                /* 5-node body tie, bNode has not been assigned */
                if ((B4SOIrbody == 0.0) && (B4SOIrbsh == 0.0)) begin
                    /* ideal body tie, pNode is not used */
                    // here->B4SOIbNode = here->B4SOIpNode;
                    B4SOIbodyMod = 2;
                end else begin
                    /* nonideal body tie */
                    // here->B4SOIbNode = tmp->number;
                    B4SOIbodyMod = 1;
                end
            end else begin
                /* 6-node body tie, bNode has been assigned */
                if ((B4SOIrbody == 0.0) && (B4SOIrbsh == 0.0)) begin
                    $strobe("Warning: model parameter rbody=0!");
                    B4SOIrbody = 1e0;
                    B4SOIbodyMod = 1;
                end else begin
                    /* nonideal body tie */
                    B4SOIbodyMod = 1;
                end
            end
        end
    end
`else
    // assume only d,g,s,e terminals connected
    B4SOIbodyMod = 0;
`endif

    if ($param_given(CF))
        B4SOIcf = CF;
    else
        B4SOIcf = 2.0 * `EPSOX / `M_PI * ln(1.0 + 0.4e-6 / B4SOItox);

    if ($param_given(CGDO))
        B4SOIcgdo = CGDO;
    else begin
        if ($param_given(DLC) && (B4SOIdlc > 0.0))
            B4SOIcgdo = B4SOIdlc * B4SOIcox - B4SOIcgdl;
        else
            B4SOIcgdo = 0.6 * B4SOIxj * B4SOIcox;
    end

    if ($param_given(CGSO))
        B4SOIcgso = CGSO;
    else begin
        if ($param_given(DLC) && (B4SOIdlc > 0.0))
            B4SOIcgso = B4SOIdlc * B4SOIcox - B4SOIcgsl;
        else
            B4SOIcgso = 0.6 * B4SOIxj * B4SOIcox;
    end

    begin : b4soi_temp // {
        real tmp, tmp1, tmp2, Eg, Eg0, ni, T0, T1, T2, T3, T4, T5, T6;
        real Ldrn, Wdrn;
        real TempRatio, Inv_L, Inv_W, Inv_LW, Vtm0, Tnom;
        real SDphi, SDgamma;
        real Inv_saref, Inv_sbref, Inv_sa, Inv_sb, rho, dvth0_lod;
        real W_tmp, Inv_ODeff, OD_offset, dk2_lod, deta0_lod, deta0cv_lod;
        integer i;
        real PowWeffWr, T10; /*v4.0 */
        real Vtm0eot, Vtmeot, vbieot, phieot, sqrtphieot, vddeot;
        real Vgs_eff, Vgsteff, V0, Vth, Vgst;
        real lt1, ltw;
        real TempRatioMinus1;
        real n, VgstNVt, ExpArg, sqrtPhisExt, ExpVgst, vtfbphi2eot;
        real DIBL_Sft, Lpe_Vb, DITS_Sft, DeltVthtemp, DITS_Sft2;
        real Theta0, Delt_vth, DeltVthw;
        real niter, toxpf, toxpi, Tcen;
        real n0;

        /* v2.0 release */
        real tmp3, T7;

        if (B4SOIGatesidewallJctSPotential < 0.1)   /* v4.0 */
            B4SOIGatesidewallJctSPotential = 0.1;
        if (B4SOIGatesidewallJctDPotential < 0.1)   /* v4.0 */
            B4SOIGatesidewallJctDPotential = 0.1;
        Tnom = B4SOItnom;
        TempRatio = DevTemp / Tnom;

        if (B4SOImtrlMod) begin
            B4SOIfactor1 = sqrt(epssub / (epsrox*`EPS0) * toxe);/*4.1*/
        end else begin
            B4SOIfactor1 = sqrt(`EPSSI / `EPSOX * B4SOItox);
        end

        /*Vtm00 replaced with model parameter B4SOIVTM00 by Pankaj in May 2012*/
        //Vtm00 = 0.026;
        Vtm00=B4SOIVTM00;
        if (B4SOImtrlMod == 0) begin
             Vtm0 = `KboQ * Tnom;
             Eg0 = 1.16 - 7.02e-4 * Tnom * Tnom / (Tnom + 1108.0);
             B4SOIeg0 = Eg0;
             B4SOIvtm = `KboQ * DevTemp;
             Eg = 1.16 - 7.02e-4 * DevTemp * DevTemp / (DevTemp + 1108.0);
             B4SOIeg = Eg;                /* Bug fix #11 Jun 09 Eg is evaluated at Temp, not Tnom. To be used if no selfheat */
             /* ni is in cm^-3 */
             ni = 1.45e10 * (DevTemp / 300.15) * sqrt(DevTemp / 300.15)
                    * exp(21.5565981 - Eg / (2.0 * B4SOIvtm));
        end else begin
            Vtm0 = `KboQ * Tnom;
            Eg0 = B4SOIbg0sub - B4SOItbgasub * Tnom * Tnom
                    / (Tnom + B4SOItbgbsub);
            B4SOIeg0 = Eg0;
            B4SOIvtm = `KboQ * DevTemp;
            Eg = B4SOIbg0sub - B4SOItbgasub * DevTemp * DevTemp
                    / (DevTemp + B4SOItbgbsub);
            B4SOIeg = Eg;        /* Bug fix #11 Jun 09 Eg is evaluated at Temp, not Tnom. To be used if no selfheat */
            ni = B4SOIni0sub * (DevTemp / Tnom) * sqrt(DevTemp / Tnom)
                    * exp(Eg0/(2.0*Vtm0) - Eg / (2.0 * B4SOIvtm));
        end

        B4SOIrbodyext = B4SOIbodySquares * B4SOIrbsh;

        Ldrn = B4SOIl;
        Wdrn = B4SOIw / B4SOInf; /* v4.0 */

        T0 = pow(Ldrn, B4SOILln);
        T1 = pow(Wdrn, B4SOILwn);
        tmp1 = B4SOILl / T0 + B4SOILw / T1 + B4SOILwl / (T0 * T1);
        pParam_B4SOIdl = B4SOILint + tmp1;

        /* v2.2.3 */
        tmp1 = B4SOILlc / T0 + B4SOILwc / T1 + B4SOILwlc / (T0 * T1);
        pParam_B4SOIdlc = B4SOIdlc + tmp1;

        /* v3.0 */
        pParam_B4SOIdlcig = B4SOIdlcig + tmp1;

        if (pParam_B4SOIdlcig < 0.0) begin
            $strobe("Warning: pParam_B4SOIdlcig = %g is negative. Set to zero.", pParam_B4SOIdlcig);
            pParam_B4SOIdlcig = 0;
        end

        T2 = pow(Ldrn, B4SOIWln);
        T3 = pow(Wdrn, B4SOIWwn);
        tmp2 = B4SOIWl / T2 + B4SOIWw / T3 + B4SOIWwl / (T2 * T3);
        pParam_B4SOIdw = B4SOIWint + tmp2;

        /* v2.2.3 */
        tmp2 = B4SOIWlc / T2 + B4SOIWwc / T3 + B4SOIWwlc / (T2 * T3);
        pParam_B4SOIdwc = B4SOIdwc + tmp2;

        pParam_B4SOIleff = B4SOIl - 2.0 * pParam_B4SOIdl;
        if (pParam_B4SOIleff <= 0.0) begin
            $strobe("Effective channel length <= 0");
            $finish(0);
        end

        pParam_B4SOIweff = B4SOIw / B4SOInf  /* v4.0 */
                                  - B4SOInbc * B4SOIdwbc
                                  - (2.0 - B4SOInbc) * pParam_B4SOIdw;
        if (pParam_B4SOIweff <= 0.0) begin
            $strobe("Effective channel width <= 0");
            $finish(0);
        end

        pParam_B4SOIwdiod = pParam_B4SOIweff / B4SOInseg + B4SOIpdbcp;
        pParam_B4SOIwdios = pParam_B4SOIweff / B4SOInseg + B4SOIpsbcp;

        pParam_B4SOIleffCV = B4SOIl - 2.0 * pParam_B4SOIdlc;
        if (pParam_B4SOIleffCV <= 0.0) begin
            $strobe("Effective channel length for C-V <= 0");
            $finish(0);
        end

        pParam_B4SOIweffCV = B4SOIw / B4SOInf /* v4.0 */
                                    - B4SOInbc * B4SOIdwbc
                                    - (2.0 - B4SOInbc) * pParam_B4SOIdwc;
        if (pParam_B4SOIweffCV <= 0.0) begin
            $strobe("Effective channel width for C-V <= 0");
            $finish(0);
        end

        pParam_B4SOIwdiodCV = pParam_B4SOIweffCV / B4SOInseg + B4SOIpdbcp;
        pParam_B4SOIwdiosCV = pParam_B4SOIweffCV / B4SOInseg + B4SOIpsbcp;

        pParam_B4SOIleffCVb = B4SOIl - 2.0 * pParam_B4SOIdlc - B4SOIdlcb;
        if (pParam_B4SOIleffCVb <= 0.0) begin
            $strobe("Effective channel length for C-V (body) <= 0");
            $finish(0);
        end

        pParam_B4SOIleffCVbg = pParam_B4SOIleffCVb + 2 * B4SOIdlbg;
        if (pParam_B4SOIleffCVbg <= 0.0) begin
            $strobe("Effective channel length for C-V (backgate) <= 0");
            $finish(0);
        end

        /* Not binned - START */
        pParam_B4SOIgamma1 = B4SOIgamma1;
        pParam_B4SOIgamma2 = B4SOIgamma2;
        pParam_B4SOIvbx = B4SOIvbx;
        pParam_B4SOIvbm = B4SOIvbm;
        pParam_B4SOIxt = B4SOIxt;
        /* Not binned - END */

        /* CV model */
        pParam_B4SOIcf = B4SOIcf;
        pParam_B4SOIclc = B4SOIclc;
        pParam_B4SOIcle = B4SOIcle;
        pParam_B4SOIabulkCVfactor = 1.0 + pow((pParam_B4SOIclc / pParam_B4SOIleff),
                                            pParam_B4SOIcle);

        /* Added for binning - START */
        if (B4SOIbinUnit == 1) begin
            Inv_L = 1.0e-6 / pParam_B4SOIleff;
            Inv_W = 1.0e-6 / pParam_B4SOIweff;
            Inv_LW = 1.0e-12 / (pParam_B4SOIleff * pParam_B4SOIweff);
        end else begin
            Inv_L = 1.0 / pParam_B4SOIleff;
            Inv_W = 1.0 / pParam_B4SOIweff;
            Inv_LW = 1.0 / (pParam_B4SOIleff * pParam_B4SOIweff);
        end

        pParam_B4SOInpeak  = B4SOInpeak  + LNCH    * Inv_L + WNCH    * Inv_W + PNCH    * Inv_LW;
        pParam_B4SOInsub   = B4SOInsub   + LNSUB   * Inv_L + WNSUB   * Inv_W + PNSUB   * Inv_LW;
        pParam_B4SOIngate  = B4SOIngate  + LNGATE  * Inv_L + WNGATE  * Inv_W + PNGATE  * Inv_LW;
        /*4.1*/
        pParam_B4SOInsd    = B4SOInsd    + LNSD    * Inv_L + WNSD    * Inv_W + PNSD    * Inv_LW;

        pParam_B4SOIvth0   = B4SOIvth0   + LVTH0   * Inv_L + WVTH0   * Inv_W + PVTH0   * Inv_LW;
        pParam_B4SOIvfb    = B4SOIvfb    + LVFB    * Inv_L + WVFB    * Inv_W + PVFB    * Inv_LW;    /* v4.1 */
        pParam_B4SOIk1     = B4SOIk1     + LK1     * Inv_L + WK1     * Inv_W + PK1     * Inv_LW;
        pParam_B4SOIk2     = B4SOIk2     + LK2     * Inv_L + WK2     * Inv_W + PK2     * Inv_LW;
        pParam_B4SOIk1w1   = B4SOIk1w1   + LK1W1   * Inv_L + WK1W1   * Inv_W + PK1W1   * Inv_LW;
        pParam_B4SOIk1w2   = B4SOIk1w2   + LK1W2   * Inv_L + WK1W2   * Inv_W + PK1W2   * Inv_LW;
        pParam_B4SOIk3     = B4SOIk3     + LK3     * Inv_L + WK3     * Inv_W + PK3     * Inv_LW;
        pParam_B4SOIk3b    = B4SOIk3b    + LK3B    * Inv_L + WK3B    * Inv_W + PK3B    * Inv_LW;
        pParam_B4SOIkb1    = B4SOIkb1    + LKB1    * Inv_L + WKB1    * Inv_W + PKB1    * Inv_LW;
        pParam_B4SOIw0     = B4SOIw0     + LW0     * Inv_L + WW0     * Inv_W + PW0     * Inv_LW;
        pParam_B4SOIlpe0   = B4SOIlpe0   + LLPE0   * Inv_L + WLPE0   * Inv_W + PLPE0   * Inv_LW;
        pParam_B4SOIlpeb   = B4SOIlpeb   + LLPEB   * Inv_L + WLPEB   * Inv_W + PLPEB   * Inv_LW;  /* v4.0 */
        pParam_B4SOIdvt0   = B4SOIdvt0   + LDVT0   * Inv_L + WDVT0   * Inv_W + PDVT0   * Inv_LW;
        pParam_B4SOIdvt1   = B4SOIdvt1   + LDVT1   * Inv_L + WDVT1   * Inv_W + PDVT1   * Inv_LW;
        pParam_B4SOIdvt2   = B4SOIdvt2   + LDVT2   * Inv_L + WDVT2   * Inv_W + PDVT2   * Inv_LW;
        pParam_B4SOIdvt0w  = B4SOIdvt0w  + LDVT0W  * Inv_L + WDVT0W  * Inv_W + PDVT0W  * Inv_LW;
        pParam_B4SOIdvt1w  = B4SOIdvt1w  + LDVT1W  * Inv_L + WDVT1W  * Inv_W + PDVT1W  * Inv_LW;
        pParam_B4SOIdvt2w  = B4SOIdvt2w  + LDVT2W  * Inv_L + WDVT2W  * Inv_W + PDVT2W  * Inv_LW;
        pParam_B4SOIu0     = B4SOIu0     + LU0     * Inv_L + WU0     * Inv_W + PU0     * Inv_LW;
        pParam_B4SOIua     = B4SOIua     + LUA     * Inv_L + WUA     * Inv_W + PUA     * Inv_LW;
        pParam_B4SOIub     = B4SOIub     + LUB     * Inv_L + WUB     * Inv_W + PUB     * Inv_LW;
        pParam_B4SOIuc     = B4SOIuc     + LUC     * Inv_L + WUC     * Inv_W + PUC     * Inv_LW;
        pParam_B4SOIvsat   = B4SOIvsat   + LVSAT   * Inv_L + WVSAT   * Inv_W + PVSAT   * Inv_LW;
        pParam_B4SOIa0     = B4SOIa0     + LA0     * Inv_L + WA0     * Inv_W + PA0     * Inv_LW;
        pParam_B4SOIags    = B4SOIags    + LAGS    * Inv_L + WAGS    * Inv_W + PAGS    * Inv_LW;
        pParam_B4SOIb0     = B4SOIb0     + LB0     * Inv_L + WB0     * Inv_W + PB0     * Inv_LW;
        pParam_B4SOIb1     = B4SOIb1     + LB1     * Inv_L + WB1     * Inv_W + PB1     * Inv_LW;
        pParam_B4SOIketa   = B4SOIketa   + LKETA   * Inv_L + WKETA   * Inv_W + PKETA   * Inv_LW;
        pParam_B4SOIketas  = B4SOIketas  + LKETAS  * Inv_L + WKETAS  * Inv_W + PKETAS  * Inv_LW;
        pParam_B4SOIa1     = B4SOIa1     + LA1     * Inv_L + WA1     * Inv_W + PA1     * Inv_LW;
        pParam_B4SOIa2     = B4SOIa2     + LA2     * Inv_L + WA2     * Inv_W + PA2     * Inv_LW;
        pParam_B4SOIrdsw   = B4SOIrdsw   + LRDSW   * Inv_L + WRDSW   * Inv_W + PRDSW   * Inv_LW;
        pParam_B4SOIrsw    = B4SOIrsw    /* v4.0 */
                                         + LRSW    * Inv_L + WRSW    * Inv_W + PRSW    * Inv_LW;
        pParam_B4SOIrdw    = B4SOIrdw    /* v4.0 */
                                         + LRDW    * Inv_L + WRDW    * Inv_W + PRDW    * Inv_LW;
        pParam_B4SOIprwb   = B4SOIprwb   + LPRWB   * Inv_L + WPRWB   * Inv_W + PPRWB   * Inv_LW;
        pParam_B4SOIprwg   = B4SOIprwg   + LPRWG   * Inv_L + WPRWG   * Inv_W + PPRWG   * Inv_LW;
        pParam_B4SOIwr     = B4SOIwr     + LWR     * Inv_L + WWR     * Inv_W + PWR     * Inv_LW;
        pParam_B4SOInfactor= B4SOInfactor+ LNFACTOR* Inv_L + WNFACTOR* Inv_W + PNFACTOR* Inv_LW;
        pParam_B4SOIdwg    = B4SOIdwg    + LDWG    * Inv_L + WDWG    * Inv_W + PDWG    * Inv_LW;
        pParam_B4SOIdwb    = B4SOIdwb    + LDWB    * Inv_L + WDWB    * Inv_W + PDWB    * Inv_LW;
        pParam_B4SOIvoff   = B4SOIvoff   + LVOFF   * Inv_L + WVOFF   * Inv_W + PVOFF   * Inv_LW;
        pParam_B4SOIeta0   = B4SOIeta0   + LETA0   * Inv_L + WETA0   * Inv_W + PETA0   * Inv_LW;
        pParam_B4SOIetab   = B4SOIetab   + LETAB   * Inv_L + WETAB   * Inv_W + PETAB   * Inv_LW;
        pParam_B4SOIeta0cv = B4SOIeta0cv + LETA0CV * Inv_L + WETA0CV * Inv_W + PETA0CV * Inv_LW;
        pParam_B4SOIetabcv = B4SOIetabcv + LETABCV * Inv_L + WETABCV * Inv_W + PETABCV * Inv_LW;

        pParam_B4SOIdsub   = B4SOIdsub   + LDSUB   * Inv_L + WDSUB   * Inv_W + PDSUB   * Inv_LW;
        pParam_B4SOIcit    = B4SOIcit    + LCIT    * Inv_L + WCIT    * Inv_W + PCIT    * Inv_LW;
        pParam_B4SOIcdsc   = B4SOIcdsc   + LCDSC   * Inv_L + WCDSC   * Inv_W + PCDSC   * Inv_LW;
        pParam_B4SOIcdscb  = B4SOIcdscb  + LCDSCB  * Inv_L + WCDSCB  * Inv_W + PCDSCB  * Inv_LW;
        pParam_B4SOIcdscd  = B4SOIcdscd  + LCDSCD  * Inv_L + WCDSCD  * Inv_W + PCDSCD  * Inv_LW;
        pParam_B4SOIpclm   = B4SOIpclm   + LPCLM   * Inv_L + WPCLM   * Inv_W + PPCLM   * Inv_LW;
        pParam_B4SOIpdibl1 = B4SOIpdibl1 + LPDIBLC1* Inv_L + WPDIBLC1* Inv_W + PPDIBLC1* Inv_LW;
        pParam_B4SOIpdibl2 = B4SOIpdibl2 + LPDIBLC2* Inv_L + WPDIBLC2* Inv_W + PPDIBLC2* Inv_LW;
        pParam_B4SOIpdiblb = B4SOIpdiblb + LPDIBLCB* Inv_L + WPDIBLCB* Inv_W + PPDIBLCB* Inv_LW;
        pParam_B4SOIdrout  = B4SOIdrout  + LDROUT  * Inv_L + WDROUT  * Inv_W + PDROUT  * Inv_LW;
        pParam_B4SOIpvag   = B4SOIpvag   + LPVAG   * Inv_L + WPVAG   * Inv_W + PPVAG   * Inv_LW;
        pParam_B4SOIdelta  = B4SOIdelta  + LDELTA  * Inv_L + WDELTA  * Inv_W + PDELTA  * Inv_LW;
        pParam_B4SOIalpha0 = B4SOIalpha0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_LW;
        pParam_B4SOIfbjtii = B4SOIfbjtii + LFBJTII * Inv_L + WFBJTII * Inv_W + PFBJTII * Inv_LW;
        /*4.1 Iii model*/
        pParam_B4SOIebjtii = B4SOIebjtii + LEBJTII * Inv_L + WEBJTII * Inv_W + PEBJTII * Inv_LW;
        pParam_B4SOIcbjtii = B4SOIcbjtii + LCBJTII * Inv_L + WCBJTII * Inv_W + PCBJTII * Inv_LW;
        pParam_B4SOIvbci   = B4SOIvbci   + LVBCI   * Inv_L + WVBCI   * Inv_W + PVBCI   * Inv_LW;
        pParam_B4SOIabjtii = B4SOIabjtii + LABJTII * Inv_L + WABJTII * Inv_W + PABJTII * Inv_LW;
        pParam_B4SOImbjtii = B4SOImbjtii + LMBJTII * Inv_L + WMBJTII * Inv_W + PMBJTII * Inv_LW;

        pParam_B4SOIbeta0  = B4SOIbeta0  + LBETA0  * Inv_L + WBETA0  * Inv_W + PBETA0  * Inv_LW;
        pParam_B4SOIbeta1  = B4SOIbeta1  + LBETA1  * Inv_L + WBETA1  * Inv_W + PBETA1  * Inv_LW;
        pParam_B4SOIbeta2  = B4SOIbeta2  + LBETA2  * Inv_L + WBETA2  * Inv_W + PBETA2  * Inv_LW;
        pParam_B4SOIvdsatii0 = B4SOIvdsatii0 + LVDSATII0 * Inv_L + WVDSATII0 * Inv_W + PVDSATII0 * Inv_LW;
        pParam_B4SOIlii    = B4SOIlii    + LLII    * Inv_L + WLII    * Inv_W + PLII    * Inv_LW;
        pParam_B4SOIesatii = B4SOIesatii + LESATII * Inv_L + WESATII * Inv_W + PESATII * Inv_LW;
        pParam_B4SOIsii0   = B4SOIsii0   + LSII0   * Inv_L + WSII0   * Inv_W + PSII0   * Inv_LW;
        pParam_B4SOIsii1   = B4SOIsii1   + LSII1   * Inv_L + WSII1   * Inv_W + PSII1   * Inv_LW;
        pParam_B4SOIsii2   = B4SOIsii2   + LSII2   * Inv_L + WSII2   * Inv_W + PSII2   * Inv_LW;
        pParam_B4SOIsiid   = B4SOIsiid   + LSIID   * Inv_L + WSIID   * Inv_W + PSIID   * Inv_LW;
        pParam_B4SOIagidl  = B4SOIagidl  + LAGIDL  * Inv_L + WAGIDL  * Inv_W + PAGIDL  * Inv_LW;
        pParam_B4SOIbgidl  = B4SOIbgidl  + LBGIDL  * Inv_L + WBGIDL  * Inv_W + PBGIDL  * Inv_LW;
        pParam_B4SOIcgidl  = B4SOIcgidl  + LCGIDL  * Inv_L + WCGIDL  * Inv_W + PCGIDL  * Inv_LW;
        pParam_B4SOIegidl  = B4SOIegidl  + LEGIDL  * Inv_L + WEGIDL  * Inv_W + PEGIDL  * Inv_LW;
        pParam_B4SOIrgidl  = B4SOIrgidl  + LRGIDL  * Inv_L + WRGIDL  * Inv_W + PRGIDL  * Inv_LW;
        pParam_B4SOIkgidl  = B4SOIkgidl  + LKGIDL  * Inv_L + WKGIDL  * Inv_W + PKGIDL  * Inv_LW;
        pParam_B4SOIfgidl  = B4SOIfgidl  + LFGIDL  * Inv_L + WFGIDL  * Inv_W + PFGIDL  * Inv_LW;
        pParam_B4SOIagisl  = B4SOIagisl  + LAGISL  * Inv_L + WAGISL  * Inv_W + PAGISL  * Inv_LW;
        pParam_B4SOIbgisl  = B4SOIbgisl  + LBGISL  * Inv_L + WBGISL  * Inv_W + PBGISL  * Inv_LW;
        pParam_B4SOIcgisl  = B4SOIcgisl  + LCGISL  * Inv_L + WCGISL  * Inv_W + PCGISL  * Inv_LW;
        pParam_B4SOIegisl  = B4SOIegisl  + LEGISL  * Inv_L + WEGISL  * Inv_W + PEGISL  * Inv_LW;
        pParam_B4SOIrgisl  = B4SOIrgisl  + LRGISL  * Inv_L + WRGISL  * Inv_W + PRGISL  * Inv_LW;
        pParam_B4SOIkgisl  = B4SOIkgisl  + LKGISL  * Inv_L + WKGISL  * Inv_W + PKGISL  * Inv_LW;
        pParam_B4SOIfgisl  = B4SOIfgisl  + LFGISL  * Inv_L + WFGISL  * Inv_W + PFGISL  * Inv_LW;

        pParam_B4SOIntun   = B4SOIntun   /* v4.0 */
                                         + LNTUN   * Inv_L + WNTUN   * Inv_W + PNTUN   * Inv_LW;
        pParam_B4SOIntund  = B4SOIntund  /* v4.0 */
                                         + LNTUND  * Inv_L + WNTUND  * Inv_W + PNTUND  * Inv_LW;
        pParam_B4SOIndiode = B4SOIndiode /* v4.0 */
                                         + LNDIODE * Inv_L + WNDIODE * Inv_W + PNDIODE * Inv_LW;
        pParam_B4SOIndioded= B4SOIndioded /* v4.0 */
                                         + LNDIODED * Inv_L + WNDIODED * Inv_W + PNDIODED * Inv_LW;
        pParam_B4SOInrecf0 = B4SOInrecf0 /* v4.0 */
                                         + LNRECF0 * Inv_L + WNRECF0 * Inv_W + PNRECF0 * Inv_LW;
        pParam_B4SOInrecf0d= B4SOInrecf0d /* v4.0 */
                                         + LNRECF0D * Inv_L + WNRECF0D * Inv_W + PNRECF0D * Inv_LW;
        pParam_B4SOInrecr0 = B4SOInrecr0 /* v4.0 */
                                         + LNRECR0 * Inv_L + WNRECR0 * Inv_W + PNRECR0 * Inv_LW;
        pParam_B4SOInrecr0d= B4SOInrecr0d /* v4.0 */
                                         + LNRECR0D * Inv_L + WNRECR0D * Inv_W + PNRECR0D * Inv_LW;
        pParam_B4SOIisbjt  = B4SOIisbjt  + LISBJT  * Inv_L + WISBJT  * Inv_W + PISBJT  * Inv_LW;
        pParam_B4SOIidbjt  = B4SOIidbjt  + LIDBJT  * Inv_L + WIDBJT  * Inv_W + PIDBJT  * Inv_LW;
        pParam_B4SOIisdif  = B4SOIisdif  + LISDIF  * Inv_L + WISDIF  * Inv_W + PISDIF  * Inv_LW;
        pParam_B4SOIiddif  = B4SOIiddif  + LIDDIF  * Inv_L + WIDDIF  * Inv_W + PIDDIF  * Inv_LW;
        pParam_B4SOIisrec  = B4SOIisrec  + LISREC  * Inv_L + WISREC  * Inv_W + PISREC  * Inv_LW;
        pParam_B4SOIistun  = B4SOIistun  + LISTUN  * Inv_L + WISTUN  * Inv_W + PISTUN  * Inv_LW;
        pParam_B4SOIidrec  = B4SOIidrec  + LIDREC  * Inv_L + WIDREC  * Inv_W + PIDREC  * Inv_LW;
        pParam_B4SOIidtun  = B4SOIidtun  + LIDTUN  * Inv_L + WIDTUN  * Inv_W + PIDTUN  * Inv_LW;
        pParam_B4SOIvrec0  = B4SOIvrec0  /* v4.0 */
                                         + LVREC0  * Inv_L + WVREC0  * Inv_W + PVREC0  * Inv_LW;
        pParam_B4SOIvrec0d = B4SOIvrec0d /* v4.0 */
                                         + LVREC0D * Inv_L + WVREC0D * Inv_W + PVREC0D * Inv_LW;
        pParam_B4SOIvtun0  = B4SOIvtun0  /* v4.0 */
                                         + LVTUN0  * Inv_L + WVTUN0  * Inv_W + PVTUN0  * Inv_LW;
        pParam_B4SOIvtun0d = B4SOIvtun0d /* v4.0 */
                                         + LVTUN0D * Inv_L + WVTUN0D * Inv_W + PVTUN0D * Inv_LW;
        pParam_B4SOInbjt   = B4SOInbjt   + LNBJT   * Inv_L + WNBJT   * Inv_W + PNBJT   * Inv_LW;
        pParam_B4SOIlbjt0  = B4SOIlbjt0  + LLBJT0  * Inv_L + WLBJT0  * Inv_W + PLBJT0  * Inv_LW;
        pParam_B4SOIvabjt  = B4SOIvabjt  + LVABJT  * Inv_L + WVABJT  * Inv_W + PVABJT  * Inv_LW;
        pParam_B4SOIaely   = B4SOIaely   + LAELY   * Inv_L + WAELY   * Inv_W + PAELY   * Inv_LW;
        pParam_B4SOIahli   = B4SOIahli   /* v4.0 */
                                         + LAHLI   * Inv_L + WAHLI   * Inv_W + PAHLI   * Inv_LW;
        pParam_B4SOIahlid  = B4SOIahlid  /* v4.0 */
                                         + LAHLID  * Inv_L + WAHLID  * Inv_W + PAHLID  * Inv_LW;
        /* v3.1 */
        pParam_B4SOIxj     = B4SOIxj     + LXJ     * Inv_L + WXJ     * Inv_W + PXJ     * Inv_LW;
        pParam_B4SOIalphaGB1 = B4SOIalphaGB1 + LALPHAGB1 * Inv_L + WALPHAGB1 * Inv_W + PALPHAGB1 * Inv_LW;
        pParam_B4SOIalphaGB2 = B4SOIalphaGB2 + LALPHAGB2 * Inv_L + WALPHAGB2 * Inv_W + PALPHAGB2 * Inv_LW;
        pParam_B4SOIbetaGB1 = B4SOIbetaGB1 + LBETAGB1 * Inv_L + WBETAGB1 * Inv_W + PBETAGB1 * Inv_LW;
        pParam_B4SOIbetaGB2 = B4SOIbetaGB2 + LBETAGB2 * Inv_L + WBETAGB2 * Inv_W + PBETAGB2 * Inv_LW;
        pParam_B4SOIndif   = B4SOIndif   + LNDIF   * Inv_L + WNDIF   * Inv_W + PNDIF   * Inv_LW;
        pParam_B4SOIntrecf = B4SOIntrecf + LNTRECF * Inv_L + WNTRECF * Inv_W + PNTRECF * Inv_LW;
        pParam_B4SOIntrecr = B4SOIntrecr + LNTRECR * Inv_L + WNTRECR * Inv_W + PNTRECR * Inv_LW;
        pParam_B4SOIxbjt   = B4SOIxbjt   + LXBJT   * Inv_L + WXBJT   * Inv_W + PXBJT   * Inv_LW;
        pParam_B4SOIxdif   = B4SOIxdif   + LXDIF   * Inv_L + WXDIF   * Inv_W + PXDIF   * Inv_LW;
        pParam_B4SOIxrec   = B4SOIxrec   + LXREC   * Inv_L + WXREC   * Inv_W + PXREC   * Inv_LW;
        pParam_B4SOIxtun   = B4SOIxtun   + LXTUN   * Inv_L + WXTUN   * Inv_W + PXTUN   * Inv_LW;
        pParam_B4SOIxdifd  = B4SOIxdifd  + LXDIFD  * Inv_L + WXDIFD  * Inv_W + PXDIFD  * Inv_LW;
        pParam_B4SOIxrecd  = B4SOIxrecd  + LXRECD  * Inv_L + WXRECD  * Inv_W + PXRECD  * Inv_LW;
        pParam_B4SOIxtund  = B4SOIxtund  + LXTUND  * Inv_L + WXTUND  * Inv_W + PXTUND  * Inv_LW;
        pParam_B4SOIcgdl   = B4SOIcgdl   + LCGDL   * Inv_L + WCGDL   * Inv_W + PCGDL   * Inv_LW;
        pParam_B4SOIcgsl   = B4SOIcgsl   + LCGSL   * Inv_L + WCGSL   * Inv_W + PCGSL   * Inv_LW;
        pParam_B4SOIckappa = B4SOIckappa + LCKAPPA * Inv_L + WCKAPPA * Inv_W + PCKAPPA * Inv_LW;
        pParam_B4SOIute    = B4SOIute    + LUTE    * Inv_L + WUTE    * Inv_W + PUTE    * Inv_LW;

        /*4.1 mobmod=4*/
        pParam_B4SOIud     = B4SOIud     + LUD     * Inv_L + WUD     * Inv_W + PUD     * Inv_LW;
        pParam_B4SOIud1    = B4SOIud1    + LUD1    * Inv_L + WUD1    * Inv_W + PUD1    * Inv_LW;
        pParam_B4SOIeu     = B4SOIeu     + LEU     * Inv_L + WEU     * Inv_W + PEU     * Inv_LW;
        pParam_B4SOIucs    = B4SOIucs    + LUCS    * Inv_L + WUCS    * Inv_W + PUCS    * Inv_LW;
        pParam_B4SOIucste  = B4SOIucste  + LUCSTE  * Inv_L + WUCSTE  * Inv_W + PUCSTE  * Inv_LW;

        pParam_B4SOIkt1    = B4SOIkt1    + LKT1    * Inv_L + WKT1    * Inv_W + PKT1    * Inv_LW;
        pParam_B4SOIkt2    = B4SOIkt2    + LKT2    * Inv_L + WKT2    * Inv_W + PKT2    * Inv_LW;
        pParam_B4SOIkt1l   = B4SOIkt1l   + LKT1L   * Inv_L + WKT1L   * Inv_W + PKT1L   * Inv_LW;
        pParam_B4SOIua1    = B4SOIua1    + LUA1    * Inv_L + WUA1    * Inv_W + PUA1    * Inv_LW;
        pParam_B4SOIub1    = B4SOIub1    + LUB1    * Inv_L + WUB1    * Inv_W + PUB1    * Inv_LW;
        pParam_B4SOIuc1    = B4SOIuc1    + LUC1    * Inv_L + WUC1    * Inv_W + PUC1    * Inv_LW;
        pParam_B4SOIat     = B4SOIat     + LAT     * Inv_L + WAT     * Inv_W + PAT     * Inv_LW;
        pParam_B4SOIprt    = B4SOIprt    + LPRT    * Inv_L + WPRT    * Inv_W + PPRT    * Inv_LW;
        /* v3.0 */
        pParam_B4SOInigc   = B4SOInigc   + LNIGC   * Inv_L + WNIGC   * Inv_W + PNIGC   * Inv_LW;
        pParam_B4SOIaigc   = B4SOIaigc   + LAIGC   * Inv_L + WAIGC   * Inv_W + PAIGC   * Inv_LW;
        pParam_B4SOIbigc   = B4SOIbigc   + LBIGC   * Inv_L + WBIGC   * Inv_W + PBIGC   * Inv_LW;
        pParam_B4SOIcigc   = B4SOIcigc   + LCIGC   * Inv_L + WCIGC   * Inv_W + PCIGC   * Inv_LW;
        pParam_B4SOIaigsd  = B4SOIaigsd  + LAIGSD  * Inv_L + WAIGSD  * Inv_W + PAIGSD  * Inv_LW;
        pParam_B4SOIbigsd  = B4SOIbigsd  + LBIGSD  * Inv_L + WBIGSD  * Inv_W + PBIGSD  * Inv_LW;
        pParam_B4SOIcigsd  = B4SOIcigsd  + LCIGSD  * Inv_L + WCIGSD  * Inv_W + PCIGSD  * Inv_LW;
        pParam_B4SOIpigcd  = B4SOIpigcd  + LPIGCD  * Inv_L + WPIGCD  * Inv_W + PPIGCD  * Inv_LW;
        pParam_B4SOIpoxedge = B4SOIpoxedge + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_LW;
        /* v3.0 */
        /* v3.1 added for RF */
        pParam_B4SOIxrcrg1 = B4SOIxrcrg1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_LW;
        pParam_B4SOIxrcrg2 = B4SOIxrcrg2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_LW;
        /*Built-In Potential Lowering (ΔVbi) Model Parameters*/
        pParam_B4SOIvbsa   = B4SOIvbsa   + LVBSA   * Inv_L +  WVBSA   * Inv_W + PVBSA  * Inv_LW;
        pParam_B4SOIvsce   = B4SOIvsce   + LVSCE   * Inv_L +  WVSCE   * Inv_W + PVSCE  * Inv_LW;
        pParam_B4SOIcdsbs  = B4SOIcdsbs  + LCDSBS  * Inv_L +  WCDSBS  * Inv_W + PCDSBS * Inv_LW;
        pParam_B4SOInofffd = B4SOInofffd + LNOFFFD * Inv_L +WNOFFFD   * Inv_W + PNOFFFD * Inv_LW;
        pParam_B4SOIvofffd = B4SOIvofffd + LVOFFFD * Inv_L +WVOFFFD   * Inv_W + PVOFFFD * Inv_LW;
        pParam_B4SOIk1b    = B4SOIk1b    + LK1B    * Inv_L +  WK1B    * Inv_W + PK1B    * Inv_LW;
        pParam_B4SOIk2b    = B4SOIk2b    + LK2B    * Inv_L +  WK2B    * Inv_W + PK2B    * Inv_LW;
        pParam_B4SOIdk2b   = B4SOIdk2b   + LDK2B   * Inv_L +  WDK2B   * Inv_W + PDK2B   * Inv_LW;
        pParam_B4SOIdvbd0  = B4SOIdvbd0  + LDVBD0  * Inv_L +  WDVBD0  * Inv_W + PDVBD0  * Inv_LW;
        pParam_B4SOIdvbd1  = B4SOIdvbd1  + LDVBD1  * Inv_L +  WDVBD1  * Inv_W + PDVBD1  * Inv_LW;
        pParam_B4SOImoinfd = B4SOImoinFD + LMOINFD * Inv_L +  WMOINFD * Inv_W + PMOINFD * Inv_LW;
        pParam_B4SOIvbs0pd = B4SOIvbs0pd + LVBS0PD * Inv_L +  WVBS0PD * Inv_W + PVBS0PD * Inv_LW;
        pParam_B4SOIvbs0fd = B4SOIvbs0fd + LVBS0FD * Inv_L +  WVBS0FD * Inv_W + PVBS0FD * Inv_LW;

        /* v3.1 added for RF end */
        /* CV model */
        pParam_B4SOIvsdfb  = B4SOIvsdfb  + LVSDFB  * Inv_L + WVSDFB  * Inv_W + PVSDFB  * Inv_LW;
        pParam_B4SOIvsdth  = B4SOIvsdth  + LVSDTH  * Inv_L + WVSDTH  * Inv_W + PVSDTH  * Inv_LW;
        pParam_B4SOIdelvt  = B4SOIdelvt  + LDELVT  * Inv_L + WDELVT  * Inv_W + PDELVT  * Inv_LW;
        pParam_B4SOIacde   = B4SOIacde   + LACDE   * Inv_L + WACDE   * Inv_W + PACDE   * Inv_LW;
        pParam_B4SOIacde   = pParam_B4SOIacde * pow((pParam_B4SOInpeak / 2.0e16), -0.25);
        /* v3.2 bug fix */
        pParam_B4SOImoin   = B4SOImoin   + LMOIN   * Inv_L + WMOIN   * Inv_W + PMOIN   * Inv_LW;
        pParam_B4SOInoff   = B4SOInoff   + LNOFF   * Inv_L + WNOFF   * Inv_W + PNOFF   * Inv_LW;  /* v3.2 */
        pParam_B4SOInoff2  = B4SOInoff2  + LNOFF2  * Inv_L + WNOFF2  * Inv_W + PNOFF2  * Inv_LW;  /* v4.6 */
        pParam_B4SOIdvtp0  = B4SOIdvtp0  + LDVTP0  * Inv_L + WDVTP0  * Inv_W + PDVTP0  * Inv_LW;  /* v4.0 */
        pParam_B4SOIdvtp1  = B4SOIdvtp1  + LDVTP1  * Inv_L + WDVTP1  * Inv_W + PDVTP1  * Inv_LW;  /* v4.0 */
        pParam_B4SOIdvtp2  = B4SOIdvtp2  + LDVTP2  * Inv_L + WDVTP2  * Inv_W + PDVTP2  * Inv_LW;  /* v4.1 */
        pParam_B4SOIdvtp3  = B4SOIdvtp3  + LDVTP3  * Inv_L + WDVTP3  * Inv_W + PDVTP3  * Inv_LW;  /* v4.1 */
        pParam_B4SOIdvtp4  = B4SOIdvtp4  + LDVTP4  * Inv_L + WDVTP4  * Inv_W + PDVTP4  * Inv_LW;  /* v4.1 */
        pParam_B4SOIminv   = B4SOIminv   + LMINV   * Inv_L + WMINV   * Inv_W + PMINV   * Inv_LW;  /* v4.0 */
        pParam_B4SOIminvcv = B4SOIminvcv + LMINVCV * Inv_L + WMINVCV * Inv_W + PMINVCV * Inv_LW;  /* v4.1 */
        pParam_B4SOIvoffcv = B4SOIvoffcv   /*Bug fix # 16 Jun09*/
                                         + LVOFFCV * Inv_L + WVOFFCV * Inv_W + PVOFFCV * Inv_LW;
        pParam_B4SOIfprout = B4SOIfprout + LFPROUT * Inv_L + WFPROUT * Inv_W + PFPROUT * Inv_LW;  /* v4.0 */
        pParam_B4SOIpdits  = B4SOIpdits  + LPDITS  * Inv_L + WPDITS  * Inv_W + PPDITS  * Inv_LW;  /* v4.0 */
        pParam_B4SOIpditsd = B4SOIpditsd + LPDITSD * Inv_L + WPDITSD * Inv_W + PPDITSD * Inv_LW;  /* v4.0 */
        pParam_B4SOIaigbcp2 = B4SOIaigbcp2 + LAIGBCP2 * Inv_L + WAIGBCP2 * Inv_W + PAIGBCP2 * Inv_LW;  /* v4.0 */
        pParam_B4SOIbigbcp2 = B4SOIbigbcp2 + LBIGBCP2 * Inv_L + WBIGBCP2 * Inv_W + PBIGBCP2 * Inv_LW;  /* v4.0 */
        pParam_B4SOIcigbcp2 = B4SOIcigbcp2 + LCIGBCP2 * Inv_L + WCIGBCP2 * Inv_W + PCIGBCP2 * Inv_LW;  /* v4.0 */
        /* Added for binning - END */

        /* v4.0 add mstar for Vgsteff */
        pParam_B4SOImstar = 0.5 + atan(pParam_B4SOIminv) / `M_PI;
        if (B4SOIvgstcvMod == 0 && VERSION >= 4.1)
            $strobe("vgstcvMod = 0, users are suggested to use vgstcvMod = 1 or 2.");
        /* v4.1 add mstarcv for Vgsteffcv */
        pParam_B4SOImstarcv = 0.5 + atan(pParam_B4SOIminvcv) / `M_PI;

        T0 = (TempRatio - 1.0);

        pParam_B4SOIuatemp = pParam_B4SOIua;  /*  save ua, ub, and uc for b4soild.c */
        pParam_B4SOIubtemp = pParam_B4SOIub;
        pParam_B4SOIuctemp = pParam_B4SOIuc;
        pParam_B4SOIrds0denom = pow(pParam_B4SOIweff * 1E6, pParam_B4SOIwr);

        /* v2.2 release */
        pParam_B4SOIrth = B4SOIrth0 / (B4SOInf * (pParam_B4SOIweff + B4SOIwth0)) * B4SOInseg;
        pParam_B4SOIcth = B4SOIcth0 * (B4SOInf * (pParam_B4SOIweff + B4SOIwth0)) / B4SOInseg;

        /* v2.2.2 adding layout-dependent Frbody multiplier */
        if (B4SOIrbody == 0)
            pParam_B4SOIrbody = 0.0;
        else
            pParam_B4SOIrbody = B4SOIfrbody * B4SOIrbody
                * B4SOIrhalo / (2 * B4SOIrbody + B4SOIrhalo * pParam_B4SOIleff)
                * pParam_B4SOIweff / B4SOInseg / B4SOInf;

        pParam_B4SOIoxideRatio = pow(B4SOItoxref/B4SOItoxqm, B4SOIntox)
                                                        /B4SOItoxqm/B4SOItoxqm;
        /* v2.2 release */

        pParam_B4SOIua = pParam_B4SOIua + pParam_B4SOIua1 * T0;
        pParam_B4SOIub = pParam_B4SOIub + pParam_B4SOIub1 * T0;
        pParam_B4SOIuc = pParam_B4SOIuc + pParam_B4SOIuc1 * T0;
        if (pParam_B4SOIu0 > 1.0)
            pParam_B4SOIu0 = pParam_B4SOIu0 / 1.0e4;

        pParam_B4SOIu0temp = pParam_B4SOIu0 * pow(TempRatio, pParam_B4SOIute);
        pParam_B4SOIvsattemp = pParam_B4SOIvsat - pParam_B4SOIat * T0;
        pParam_B4SOIrds0 = (pParam_B4SOIrdsw + pParam_B4SOIprt * T0)
                                  / pParam_B4SOIrds0denom;

        if (B4SOIrdsMod == 1) begin /* v4.0 */ // {     /* 2013.enh5, 2015.enh1 */ /* v4.6 */
            PowWeffWr = pParam_B4SOIrds0denom * B4SOInf;
            T10 = pParam_B4SOIprt * T0;

            /* External Rd(V) */
            T1 = pParam_B4SOIrdw + T10;
            T2 = B4SOIrdwmin + T10;
            if (T1 < 0.0) begin
                T1 = 0.0;
                $strobe("Warning: Rdw at current temperature is negative; set to 0.");
            end
            if (T2 < 0.0) begin
                T2 = 0.0;
                $strobe("Warning: Rdwmin at current temperature is negative; set to 0.");
            end
            pParam_B4SOIrd0 = T1 / PowWeffWr;
            pParam_B4SOIrdwmin = T2 / PowWeffWr;

            /* External Rs(V) */
            T3 = pParam_B4SOIrsw + T10;
            T4 = B4SOIrswmin + T10;
            if (T3 < 0.0) begin
                T3 = 0.0;
                $strobe("Warning: Rsw at current temperature is negative; set to 0.");
            end
            if (T4 < 0.0) begin
                T4 = 0.0;
                $strobe("Warning: Rswmin at current temperature is negative; set to 0.");
            end
            pParam_B4SOIrs0 = T3 / PowWeffWr;
            pParam_B4SOIrswmin = T4 / PowWeffWr;
        end else begin // }{
            pParam_B4SOIrd0 = 0;
            pParam_B4SOIrdwmin = 0;
            pParam_B4SOIrs0 = 0;
            pParam_B4SOIrswmin = 0;
        end // }

        if (B4SOIcgdo < 0.0) begin
            $strobe("Warning: cgdo = %g is negative. Set to zero.", B4SOIcgdo);
            B4SOIcgdo = 0.0;
        end
        if (B4SOIcgso < 0.0) begin
            $strobe("Warning: cgso = %g is negative. Set to zero.", B4SOIcgso);
            B4SOIcgso = 0.0;
        end
        if (B4SOIcgeo < 0.0) begin
            $strobe("Warning: cgeo = %g is negative. Set to zero.", B4SOIcgeo);
            B4SOIcgeo = 0.0;
        end

        pParam_B4SOIcgdo = (B4SOIcgdo + pParam_B4SOIcf) * pParam_B4SOIwdiodCV;
        pParam_B4SOIcgso = (B4SOIcgso + pParam_B4SOIcf) * pParam_B4SOIwdiosCV;
        pParam_B4SOIcgeo = B4SOIcgeo * pParam_B4SOIleffCV * B4SOInf;        /* v4.0 */

        if (!$param_given(NCH) && $param_given(GAMMA1)) begin
            T0 = pParam_B4SOIgamma1 * B4SOIcox;
            pParam_B4SOInpeak = 3.021E22 * T0 * T0;
        end
        /* Check of Nch and Body thickness for SOIMOD = 2 */
        if (B4SOIsoiMod == 2) begin
            if (B4SOImtrlMod) begin
                NchMax = (B4SOIbg0sub - 0.1) / `Charge_q * 2e-6 * epssub / (B4SOIetsi * B4SOIetsi);
                if (pParam_B4SOInpeak > NchMax ) begin
                    $strobe("SOIMOD=2 cannot support given Nch=%g cm^-3 and Etsi=%g m ",pParam_B4SOInpeak,B4SOIetsi);
                    $strobe("Exceeds maximum allowed band bending of (Eg-0.1)eV");
                    $strobe("Nch is set to  %g cm^-3", NchMax);
                    pParam_B4SOInpeak = NchMax;
                end
            end else begin
                NchMax = (1.12 - 0.1) / `Charge_q * 2e-6 * epssub / (B4SOItsi * B4SOItsi);
                if (pParam_B4SOInpeak > NchMax ) begin
                    $strobe("SOIMOD=2 cannot support given Nch=%g cm^-3 and Tsi=%g m ",pParam_B4SOInpeak,B4SOItsi);
                    $strobe("Exceeds maximum allowed band bending of (Eg-0.1)eV");
                    $strobe("Nch is set to  %g cm^-3", NchMax);
                    pParam_B4SOInpeak = NchMax;
                end
            end
        end

        /* process effective silicon film thickness */
        B4SOIcbox = 3.453133e-11 / B4SOItbox;
        if (B4SOImtrlMod) begin
            B4SOIcsi = `EPSSI / B4SOIetsi;
        end else begin
            B4SOIcsi = `EPSSI / B4SOItsi;
        end
        // Cboxt = B4SOIcbox * B4SOIcsi / (B4SOIcbox + B4SOIcsi);
        /* v3.2 */
        if (B4SOImtrlMod) begin
            Qsi = `Charge_q * pParam_B4SOInpeak
                    * (1.0 + B4SOIlpe0 / B4SOIl) * 1e6 * B4SOIetsi;
        end else begin
            Qsi = `Charge_q * pParam_B4SOInpeak
                    * (1.0 + B4SOIlpe0 / B4SOIl) * 1e6 * B4SOItsi;
        end
        Vbs0t = 0.8 - 0.5 * Qsi / B4SOIcsi + pParam_B4SOIvbsa;

        if (B4SOIsoiMod == 3) begin /* auto selection */
            if (Vbs0t > pParam_B4SOIvbs0fd) begin
                B4SOIsoiMod = 2; /* ideal FD mode */
            end else begin
                if (Vbs0t < pParam_B4SOIvbs0pd) begin
                    B4SOIsoiMod = 0; /* BSIMPD */
                end else begin
                    B4SOIsoiMod = 1;
                end
            end
        end
        T4 = `Eg300 / B4SOIvtm * (TempRatio - 1.0);
        /* source side */
        T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndiode;
        `DEXP(T7, T0)
        T7 = pParam_B4SOIxdif * T4 / pParam_B4SOIndiode;
        `DEXP(T7, T1)
        T7 = pParam_B4SOIxrec * T4 / pParam_B4SOInrecf0;
        `DEXP(T7, T2)

        pParam_B4SOIahli0s = pParam_B4SOIahli * T0;
        pParam_B4SOIjbjts = pParam_B4SOIisbjt * T0;
        pParam_B4SOIjdifs = pParam_B4SOIisdif * T1;
        pParam_B4SOIjrecs = pParam_B4SOIisrec * T2;
        T7 = pParam_B4SOIxtun * (TempRatio - 1);
        `DEXP(T7, T0)
        pParam_B4SOIjtuns = pParam_B4SOIistun * T0;

        /* drain side */
        T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndioded;
        `DEXP(T7, T0)
        T7 = pParam_B4SOIxdifd * T4 / pParam_B4SOIndioded;
        `DEXP(T7, T1)
        T7 = pParam_B4SOIxrecd * T4 / pParam_B4SOInrecf0d;
        `DEXP(T7, T2)

        pParam_B4SOIahli0d = pParam_B4SOIahlid * T0;
        pParam_B4SOIjbjtd = pParam_B4SOIidbjt * T0;
        pParam_B4SOIjdifd = pParam_B4SOIiddif * T1;
        pParam_B4SOIjrecd = pParam_B4SOIidrec * T2;
        T7 = pParam_B4SOIxtund * (TempRatio - 1);
        `DEXP(T7, T0)
        pParam_B4SOIjtund = pParam_B4SOIidtun * T0;

        if (pParam_B4SOInsub > 0)
            pParam_B4SOIvfbb = -B4SOItype * B4SOIvtm *
                                  lln(pParam_B4SOInpeak/ pParam_B4SOInsub);
        else
            pParam_B4SOIvfbb = -B4SOItype * B4SOIvtm *
                                  lln(-pParam_B4SOInpeak* pParam_B4SOInsub/ni/ni);

        if (!$param_given(VSDFB)) begin
            if (pParam_B4SOInsub > 0)
                    pParam_B4SOIvsdfb = -B4SOItype *
                                                (B4SOIvtm*lln(1e20 *
                                                pParam_B4SOInsub / ni /ni) - 0.3);
            else if (pParam_B4SOInsub < 0)
                    pParam_B4SOIvsdfb = -B4SOItype *
                                                (B4SOIvtm*lln(-1e20 /
                                                pParam_B4SOInsub) + 0.3);
        end

        /* Phi  & Gamma */
        SDphi = 2.0*B4SOIvtm*lln(abs(pParam_B4SOInsub) / ni);
        SDgamma = sqrt2qeps * sqrt(abs(pParam_B4SOInsub)) / B4SOIcbox;

        if (!$param_given(VSDTH)) begin
            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                 ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) )
                pParam_B4SOIvsdth = pParam_B4SOIvsdfb + SDphi +
                                        SDgamma * sqrt(SDphi);
            else
                pParam_B4SOIvsdth = pParam_B4SOIvsdfb - SDphi -
                                        SDgamma * sqrt(SDphi);
        end

        if (!$param_given(CSDMIN)) begin
                 /* Cdmin */
            tmp = sqrt(2.0 * epssub * SDphi / (`Charge_q *
                           abs(pParam_B4SOInsub) * 1.0e6));
            tmp1 = epssub / tmp;
            B4SOIcsdmin = tmp1 * B4SOIcbox / (tmp1 + B4SOIcbox);
        end

        pParam_B4SOIphi = 2.0 * B4SOIvtm * lln(pParam_B4SOInpeak / ni);

        pParam_B4SOIsqrtPhi = sqrt(pParam_B4SOIphi);

        pParam_B4SOIXdep0 = sqrt(2.0 * epssub / (`Charge_q
                                           * pParam_B4SOInpeak * 1.0e6))
                                           * pParam_B4SOIsqrtPhi;
        pParam_B4SOIsqrtXdep0 = sqrt(pParam_B4SOIXdep0);

        /*4.1*/
        if (B4SOImtrlMod == 0)
            pParam_B4SOIlitl = sqrt(3.0 *3.9/epsrox* pParam_B4SOIxj * B4SOItox);
        else
            /* pParam_B4SOIlitl = sqrt(epssub * pParam_B4SOIxj * B4SOItox/(epsrox*`EPS0)); */ /* Bug fix # 13 Jun 09 'not reported by vendors'*/
                        pParam_B4SOIlitl = sqrt(epssub * pParam_B4SOIxj * toxe/(epsrox*`EPS0));
                        pParam_B4SOIvbi = B4SOIvtm * lln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
                        pParam_B4SOIcdep0 = sqrt(`Charge_q * epssub
                                   * pParam_B4SOInpeak * 1.0e6 / 2.0
                                   / pParam_B4SOIphi);

        /* v3.0 */
        /*4.1  */
        if (B4SOImtrlMod ==0) begin
            if (pParam_B4SOIngate > 0.0)
                pParam_B4SOIvfbsd = Vtm0 * lln(pParam_B4SOIngate / 1.0e20);
            else
                pParam_B4SOIvfbsd = 0.0;
        end else begin
            T0 = Vtm0 * lln(pParam_B4SOInsd/ni);
            T1 = 0.5 * Eg0;
            if (T0 > T1)
                T0 = T1;
            T2 = B4SOIeasub + T1 - B4SOItype * T0;
            pParam_B4SOIvfbsd = B4SOIphig - T2;
        end

        pParam_B4SOIToxRatio = exp(B4SOIntox * lln(B4SOItoxref /B4SOItoxqm))
                                  /B4SOItoxqm /B4SOItoxqm;
        pParam_B4SOIToxRatioEdge = exp(B4SOIntox * lln(B4SOItoxref
                                  / (B4SOItoxqm * pParam_B4SOIpoxedge)))
                                  / B4SOItoxqm / B4SOItoxqm
                                  / pParam_B4SOIpoxedge / pParam_B4SOIpoxedge;
        pParam_B4SOIAechvb = (B4SOItype == `NMOS) ? agbc2p : agbc2n;
        pParam_B4SOIBechvb = (B4SOItype == `NMOS) ? bgbc2p : bgbc2n;  /* v4.3.1 -Tanvir */
        pParam_B4SOIAechvbEdges = pParam_B4SOIAechvb
                                    * (pParam_B4SOIweff/B4SOInseg + B4SOIpsbcp)
                                    * pParam_B4SOIdlcig * pParam_B4SOIToxRatioEdge;
        pParam_B4SOIAechvbEdged = pParam_B4SOIAechvb
                                    * (pParam_B4SOIweff/B4SOInseg + B4SOIpdbcp)
                                    * pParam_B4SOIdlcig * pParam_B4SOIToxRatioEdge;
        pParam_B4SOIBechvbEdge = -pParam_B4SOIBechvb
                                    * B4SOItoxqm * pParam_B4SOIpoxedge;
        pParam_B4SOIAechvb = pParam_B4SOIAechvb * pParam_B4SOIToxRatio
                                    * (pParam_B4SOIweff/B4SOInseg
                                        * pParam_B4SOIleff + B4SOIagbcpd/B4SOInf);

        pParam_B4SOIBechvb = pParam_B4SOIBechvb * (  -B4SOItoxqm);
        /* v3.0 */

        if ($param_given(K1) || $param_given(K2)) begin // {
            if (!$param_given(K1)) begin
                $strobe( "Warning: k1 should be specified with k2.");
                pParam_B4SOIk1 = 0.53;
            end
            if (!$param_given(K2)) begin
                $strobe( "Warning: k2 should be specified with k1.");
                pParam_B4SOIk2 = -0.0186;
            end
            if ($param_given(XT))
                $strobe( "Warning: xt is ignored because k1 or k2 is given.");
            if ($param_given(VBX))
                $strobe( "Warning: vbx is ignored because k1 or k2 is given.");
            if ($param_given(VBM))
                $strobe( "Warning: vbm is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA1))
                $strobe( "Warning: gamma1 is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA2))
                $strobe( "Warning: gamma2 is ignored because k1 or k2 is given.");
        end else begin // }{
            if (!$param_given(VBX)) begin
                if (B4SOImtrlMod)
                    T0 = `Charge_q / (2.0 * epssub) * 1.0e6;
                else
                    T0 = 7.7348e-4; /* constant from v4.3.0 and earlier */
                pParam_B4SOIvbx = pParam_B4SOIphi - T0 * pParam_B4SOInpeak
                                             * pParam_B4SOIxt * pParam_B4SOIxt;
            end
            if (pParam_B4SOIvbx > 0.0)
                pParam_B4SOIvbx = -pParam_B4SOIvbx;
            if (pParam_B4SOIvbm > 0.0)
                pParam_B4SOIvbm = -pParam_B4SOIvbm;

            if (!$param_given(GAMMA1))
                pParam_B4SOIgamma1 = sqrt2qeps * sqrt(pParam_B4SOInpeak) / B4SOIcox;
            if (!$param_given(GAMMA2))
                pParam_B4SOIgamma2 = sqrt2qeps * sqrt(pParam_B4SOInsub) / B4SOIcox;

            T0 = pParam_B4SOIgamma1 - pParam_B4SOIgamma2;
            T1 = sqrt(pParam_B4SOIphi - pParam_B4SOIvbx) - pParam_B4SOIsqrtPhi;

            /*T2 = sqrt(pParam_B4SOIphi * (pParam_B4SOIphi - pParam_B4SOIvbm))
                - pParam_B4SOIphi;*/ //Bug fixed by Pankaj in May 2012
            T2 = pParam_B4SOIsqrtPhi * (sqrt(pParam_B4SOIphi - pParam_B4SOIvbm)- pParam_B4SOIsqrtPhi);


            pParam_B4SOIk2 = T0 * T1 / (2.0 * T2 + pParam_B4SOIvbm);
            pParam_B4SOIk1 = pParam_B4SOIgamma2 - 2.0
                                * pParam_B4SOIk2 * sqrt(pParam_B4SOIphi - pParam_B4SOIvbm);
        end // }

        T0 = pParam_B4SOIweff + pParam_B4SOIk1w2;
        if (T0 < 1e-8)
            T0 = 1e-8;
        pParam_B4SOIk1eff = pParam_B4SOIk1 * (1 + pParam_B4SOIk1w1/T0);

        /* v4.1 */
        if (!$param_given(VFB)) begin
            if ($param_given(VTH0) || $param_given(VTHO)) begin
                    pParam_B4SOIvfb = B4SOItype * pParam_B4SOIvth0
                                         - pParam_B4SOIphi - pParam_B4SOIk1eff
                                         * pParam_B4SOIsqrtPhi;
                end else begin
                    pParam_B4SOIvfb = -1.0;
                end
        end

        if (!$param_given(VTH0)) begin
            pParam_B4SOIvth0 = B4SOItype * (pParam_B4SOIvfb
                                        + pParam_B4SOIphi + pParam_B4SOIk1eff
                                        * pParam_B4SOIsqrtPhi);
        end

        /* v4.0 */
        pParam_B4SOIk1ox = pParam_B4SOIk1eff * B4SOItox / B4SOItoxm;
        T1 = B4SOIfactor1 * pParam_B4SOIsqrtXdep0;

        T0 = exp(-0.5 * pParam_B4SOIdsub * pParam_B4SOIleff / T1);
        pParam_B4SOItheta0vb0 = (T0 + 2.0 * T0 * T0);

        T0 = exp(-0.5 * pParam_B4SOIdrout * pParam_B4SOIleff / T1);
        T2 = (T0 + 2.0 * T0 * T0);
        pParam_B4SOIthetaRout = pParam_B4SOIpdibl1 * T2
                                   + pParam_B4SOIpdibl2;

        /* New DITS term (added in 4.1) */
        pParam_B4SOIdvtp2factor = pParam_B4SOIdvtp2 / exp(pParam_B4SOIdvtp3
                                     * lln(pParam_B4SOIleff));

        /* stress effect */
        if (B4SOIwlod < 0.0) begin
            $strobe( "Warning: WLOD = %g is less than 0. Set to 0.0",B4SOIwlod);
            B4SOIwlod = 0.0;
        end

        T0 = pow(Ldrn, B4SOIllodku0);
        W_tmp = Wdrn + B4SOIwlod;
        T1 = pow(W_tmp, B4SOIwlodku0);
        tmp1 = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);
        pParam_B4SOIku0 = 1.0 + tmp1;

        T0 = pow(Ldrn, B4SOIllodvth);
        T1 = pow(W_tmp, B4SOIwlodvth);
        tmp1 = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
        pParam_B4SOIkvth0 = 1.0 + tmp1;
        pParam_B4SOIkvth0 = sqrt( pParam_B4SOIkvth0
                                     * pParam_B4SOIkvth0 + `DELTA_);

        /*T0 = (TRatio - 1.0);*/
        T0 = (TempRatio - 1.0);  /* bug fix v4.1 */
        pParam_B4SOIku0temp = pParam_B4SOIku0 * (1.0 + B4SOItku0 * T0) + `DELTA_;

        Inv_saref = 1.0 / (B4SOIsaref + 0.5 * Ldrn);
        Inv_sbref = 1.0 / (B4SOIsbref + 0.5 * Ldrn);
        pParam_B4SOIinv_od_ref = Inv_saref + Inv_sbref;
        pParam_B4SOIrho_ref = B4SOIku0 / pParam_B4SOIku0temp
                                                 * pParam_B4SOIinv_od_ref;
        /* stress effect end */

        /*  v4.0 stress effect */    /* Bug Fix # 17 Jul09 Code 1484-1560 is moved up from lines 1884-1958 of old version*/
        if( (B4SOIsa > 0.0) && (B4SOIsb > 0.0) &&
            ( (B4SOInf == 1.0) ||
              ((B4SOInf > 1.0) && (B4SOIsd > 0.0))
            )
          ) begin // {
            Inv_sa = 0;
            Inv_sb = 0;

            if (B4SOIkvsat < -1.0 ) begin
                $strobe( "Warning: KVSAT = %g is too small; Reset to -1.0.",B4SOIkvsat);
                B4SOIkvsat = -1.0;
            end else if (B4SOIkvsat > 1.0) begin
                $strobe( "Warning: KVSAT = %g is too big; Reset to 1.0.",B4SOIkvsat);
                B4SOIkvsat = 1.0;
            end else begin
                B4SOIkvsat = B4SOIkvsat;
            end

            for (i = 0; i < B4SOInf; i = i+1) begin : forloop
                  real T0, T1;
                  T0 = 1.0 / B4SOInf / (B4SOIsa
                           + 0.5*Ldrn + i * (B4SOIsd +Ldrn));
                  T1 = 1.0 / B4SOInf / (B4SOIsb
                           + 0.5*Ldrn + i * (B4SOIsd +Ldrn));
                  Inv_sa = Inv_sa + T0;
                  Inv_sb = Inv_sb + T1;
            end

            Inv_ODeff = Inv_sa + Inv_sb;
            B4SOIInv_ODeff = Inv_ODeff;
            rho = B4SOIku0 / pParam_B4SOIku0temp * Inv_ODeff;
            T0 = (1.0 + rho)/(1.0 + pParam_B4SOIrho_ref);
            here_B4SOIu0temp = pParam_B4SOIu0temp * T0;

            T1 = (1.0 + B4SOIkvsat * rho)/(1.0 + B4SOIkvsat * pParam_B4SOIrho_ref);/*self-heating bug fix*/
            here_B4SOIvsattemp = pParam_B4SOIvsattemp * T1;

            OD_offset = Inv_ODeff - pParam_B4SOIinv_od_ref;
            dvth0_lod = B4SOIkvth0 / pParam_B4SOIkvth0 * OD_offset;
            dk2_lod = B4SOIstk2 / pow(pParam_B4SOIkvth0, B4SOIlodk2) * OD_offset;
            deta0_lod = B4SOIsteta0 / pow(pParam_B4SOIkvth0, B4SOIlodeta0) * OD_offset;
            deta0cv_lod = B4SOIsteta0cv / pow(pParam_B4SOIkvth0, B4SOIlodeta0cv) * OD_offset;

            here_B4SOIvth0 = pParam_B4SOIvth0 + dvth0_lod;
            here_B4SOIk2 = pParam_B4SOIk2 + dk2_lod;
            here_B4SOIeta0 = pParam_B4SOIeta0 + deta0_lod;
            here_B4SOIeta0cv = pParam_B4SOIeta0cv + deta0cv_lod;
        end else begin // }{
            here_B4SOIu0temp = pParam_B4SOIu0temp;
            here_B4SOIvth0 = pParam_B4SOIvth0;
            here_B4SOIvsattemp = pParam_B4SOIvsattemp;
            here_B4SOIk2 = pParam_B4SOIk2;
            here_B4SOIeta0 = pParam_B4SOIeta0;
            here_B4SOIeta0cv = pParam_B4SOIeta0cv;
            B4SOIInv_ODeff = 0;
            pParam_B4SOIinv_od_ref = 0; /*Stress bug fix*/
            B4SOIkvsat = 0; /*Stress bug fix*/
        end // } /* v4.0 stress effect end */

        here_B4SOIk2ox = here_B4SOIk2 * B4SOItox / B4SOItoxm;        /* v4.0 */
        here_B4SOIvth0 = here_B4SOIvth0 + B4SOIdelvto; /* v4.0 */
        here_B4SOIvfb = pParam_B4SOIvfb + B4SOItype * B4SOIdelvto;
        /* Bug Fix # 17 Jul09 Code 1479-1545 is moved up from lines 1884-1950 of old version, 1954-2035 in this version*/

        B4SOIcsbox = B4SOIcbox*B4SOIsourceArea;
        B4SOIcsmin = B4SOIcsdmin*B4SOIsourceArea;
        B4SOIcdbox = B4SOIcbox*B4SOIdrainArea;
        B4SOIcdmin = B4SOIcsdmin*B4SOIdrainArea;

        if (B4SOIcsdmin > 0) begin
            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                 ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) ) begin

                T0 = pParam_B4SOIvsdth - pParam_B4SOIvsdfb;
                pParam_B4SOIsdt1 = pParam_B4SOIvsdfb + B4SOIasd * T0;
                T1 = B4SOIcsbox - B4SOIcsmin;
                T2 = T1 / T0 / T0;
                pParam_B4SOIst2 = T2 / B4SOIasd;
                pParam_B4SOIst3 = T2 /( 1 - B4SOIasd);
                B4SOIst4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcsmin * pParam_B4SOIvsdfb;

                T1 = B4SOIcdbox - B4SOIcdmin;
                T2 = T1 / T0 / T0;
                pParam_B4SOIdt2 = T2 / B4SOIasd;
                pParam_B4SOIdt3 = T2 /( 1 - B4SOIasd);
                B4SOIdt4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcdmin * pParam_B4SOIvsdfb;
            end else begin

                T0 = pParam_B4SOIvsdfb - pParam_B4SOIvsdth;
                pParam_B4SOIsdt1 = pParam_B4SOIvsdth + B4SOIasd * T0;
                T1 = B4SOIcsmin - B4SOIcsbox;
                T2 = T1 / T0 / T0;
                pParam_B4SOIst2 = T2 / B4SOIasd;
                pParam_B4SOIst3 = T2 /( 1 - B4SOIasd);
                B4SOIst4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcsbox * pParam_B4SOIvsdth;

                T1 = B4SOIcdmin - B4SOIcdbox;
                T2 = T1 / T0 / T0;
                pParam_B4SOIdt2 = T2 / B4SOIasd;
                pParam_B4SOIdt3 = T2 /( 1 - B4SOIasd);
                B4SOIdt4 =  T0 * T1 * (1 + B4SOIasd) / 3
                                         - B4SOIcdbox * pParam_B4SOIvsdth;
            end
        end else begin
            pParam_B4SOIsdt1 = 0;
            pParam_B4SOIst2 = 0;
            pParam_B4SOIst3 = 0;
            B4SOIst4 = 0;
            pParam_B4SOIdt2 = 0;
            pParam_B4SOIdt3 = 0;
            B4SOIdt4 = 0;
        end

        /* v4.4 Sidewall Fringing Capacitance Enhancement */
        if (B4SOIcfrcoeff < 1.0 || B4SOIcfrcoeff > 2.0) begin
            $strobe("Warning: CfrCoeff = %g is outside valid range [1,2], set to 1. \n", B4SOIcfrcoeff);
            B4SOIcfrcoeff = 1.0;
        end
        /* v2.2.2 bug fix */
        T0 = B4SOIcsdesw * lln(B4SOIcfrcoeff * (1 + B4SOItsi / B4SOItbox));
        T1 = B4SOIsourcePerimeter - B4SOIw;
        if (T1 > 0.0)
            B4SOIcsesw = T0 * T1;
        else
            B4SOIcsesw = 0.0;
        T1 = B4SOIdrainPerimeter - B4SOIw;
        if (T1 > 0.0)
            B4SOIcdesw = T0 * T1;
        else
            B4SOIcdesw = 0.0;

        /* process source/drain series resistance */
        B4SOIdrainResistance = B4SOIsheetResistance * B4SOIdrainSquares;
        if (B4SOIdrainResistance <= 1.0e-3)        /* 2013.enh5, 2015.enh1 */ /* v4.6 */
            B4SOIdrainResistance = 1.0e-3;

        B4SOIsourceResistance = B4SOIsheetResistance * B4SOIsourceSquares;

        if (B4SOIsourceResistance <= 1.0e-3)       /* 2013.enh5, 2015.enh1 */ /* v4.6 */
            B4SOIsourceResistance = 1.0e-3;

        /* v2.0 release */
        if (B4SOIln < 1e-15) B4SOIln = 1e-15;
        T0 = -0.5 * pParam_B4SOIleff * pParam_B4SOIleff / B4SOIln / B4SOIln;
        `DEXP(T0,T1)
        pParam_B4SOIarfabjt = T1;

        T0 = pParam_B4SOIlbjt0 * (1.0 / pParam_B4SOIleff + 1.0 / B4SOIln);
        pParam_B4SOIlratio = pow(T0,pParam_B4SOInbjt);
        pParam_B4SOIlratiodif = 1.0 + B4SOIldif0 * pow(T0,pParam_B4SOIndif);
        pParam_B4SOIvearly = pParam_B4SOIvabjt + pParam_B4SOIaely * pParam_B4SOIleff;
        if (pParam_B4SOIvearly < 1)
            pParam_B4SOIvearly = 1;

        /*4.1 toxp calculation*/
        if (B4SOImtrlMod == 0) begin
            B4SOItoxp = B4SOItox - B4SOIdtoxcv;
        end else begin // {
                 /* Calculate TOXP from EOT */
              /* Calculate Vgs_eff @ Vgs = VDD with Poly Depletion Effect */
            Vtm0eot = `KboQ * B4SOItempeot;
            Vtmeot  = Vtm0eot;
            vbieot = Vtm0eot * lln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
            phieot = 2.0 * Vtm0eot * lln(pParam_B4SOInpeak / ni);
            sqrtphieot = sqrt(phieot);
            tmp2 = here_B4SOIvfb + phieot;
            vddeot = B4SOItype * B4SOIvddeot;

            T0 = B4SOIepsrgate * `EPS0;
            if ((pParam_B4SOIngate > 1.0e18) && (pParam_B4SOIngate < 1.0e25)
                    && (vddeot > tmp2) && (T0!=0)) begin
                T1 = 1.0e6 * `Charge_q * epssub * pParam_B4SOIngate
                                         / (B4SOIcox * B4SOIcox);
                T4 = sqrt(1.0 + 2.0 * (vddeot - T0) / T1);
                T2 = T1 * (T4 - 1.0);
                T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
                T7 = eggdep - T3 - 0.05;
                T6 = sqrt(T7 * T7 + 0.224);
                T5 = eggdep - 0.5 * (T7 + T6);
                Vgs_eff = vddeot - T5;
            end else begin
                Vgs_eff = vddeot;
            end

            /* Calculate Vth @ Vds=Vbs=0 */

            V0 = vbieot - phieot;
            T3 = pParam_B4SOIsqrtXdep0;

            lt1 = B4SOIfactor1 * T3;
            ltw = B4SOIfactor1 * T3 ;

            T0 = -0.5 * pParam_B4SOIdvt1 * B4SOIleffeot / lt1;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end

            /* Calculate n */
            T2 = pParam_B4SOInfactor * epssub / pParam_B4SOIXdep0;
            T3 = pParam_B4SOIcdsc ;
            T4 = (T2 + T3 * Theta0 + pParam_B4SOIcit) / B4SOIcox;

            if (T4 >= -0.5) begin
                n = 1.0 + T4;
            end else begin
                /* avoid  discontinuity problems caused by T4 */
                T0 = 1.0 / (3.0 + 8.0 * T4);
                n = (1.0 + 3.0 * T4) * T0;
            end

            /* v4.0 DITS */
            if (pParam_B4SOIdvtp0 > 0.0) begin
                T3 = B4SOIleffeot + 2.0 * pParam_B4SOIdvtp0;
                T4 = Vtmeot * lln(B4SOIleffeot / T3);
                DITS_Sft = n * T4;
            end else begin
                DITS_Sft = 0.0;
            end

            B4SOIthetavth = pParam_B4SOIdvt0 * Theta0;
            Delt_vth = B4SOIthetavth * V0;

            T0 = -0.5 * pParam_B4SOIdvt1w * B4SOIweffeot * B4SOIleffeot / ltw;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                T2 = T1 * (1.0 + 2.0 * T1);
            end

            T0 = pParam_B4SOIdvt0w * T2;
            DeltVthw = T0 * V0;

            TempRatioMinus1 = B4SOItempeot / B4SOItnom - 1.0;

            T0 = sqrt(1.0 + pParam_B4SOIlpe0 / B4SOIleffeot);
            T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / B4SOIleffeot);
            DeltVthtemp = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtphieot
                                + T1 * TempRatioMinus1; /* v4.0 */

            tmp2 = toxe * phieot / (B4SOIweffeot + pParam_B4SOIw0);

            DIBL_Sft = 0.0;
            DITS_Sft2 = 0.0;

            Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / B4SOIleffeot);

            sqrtPhisExt = sqrtphieot;

            Vth = B4SOItype * here_B4SOIvth0
                              + (pParam_B4SOIk1ox * sqrtPhisExt
                              - pParam_B4SOIk1eff * sqrtphieot) * Lpe_Vb
                              - Delt_vth - DeltVthw
                              + pParam_B4SOIk3 * tmp2
                              + DeltVthtemp - DIBL_Sft -DITS_Sft - DITS_Sft2;

            Vgst = Vgs_eff - Vth;

            T10 = n * Vtmeot; /* v4.0 */
            VgstNVt = pParam_B4SOImstar * Vgst / T10; /* v4.0 */
            ExpArg = (pParam_B4SOIvoff - (1- pParam_B4SOImstar) * Vgst)
                                             / T10;                /* v4.0 */

            /* MCJ: Very small Vgst */
            if (VgstNVt > `EXPL_THRESHOLD) begin
                Vgsteff = Vgst;
            end else if (ExpArg > `EXPL_THRESHOLD) begin
                T0 = (Vgst - pParam_B4SOIvoff) / (n * Vtmeot);
                ExpVgst = exp(T0);
                Vgsteff = Vtmeot * pParam_B4SOIcdep0 / B4SOIcox * ExpVgst;
            end else begin
                ExpVgst = exp(VgstNVt);
                T1 = T10 * lln(1.0 + ExpVgst);
                T4 = -B4SOIcox / (Vtm0eot * pParam_B4SOIcdep0)
                        * exp(ExpArg) * (1 - pParam_B4SOImstar);
                T2 = pParam_B4SOImstar - T10 * T4
                        / (1.0 - pParam_B4SOImstar);
                Vgsteff = T1 / T2;
            end

            /* calculating Toxp */
            T3 = B4SOItype * here_B4SOIvth0 - here_B4SOIvfb - phieot;
            vtfbphi2eot = 4.0 * T3;
            if (vtfbphi2eot < 0.0)
                vtfbphi2eot = 0.0;

            niter = 0;
            toxpf = toxe;
            toxpi = 1e6; // force while loop
            while ((niter<=4)&&(abs(toxpf-toxpi)>1e-12)) begin : whileloop //
                real T0, T1;
                toxpi = toxpf;
                tmp2 = 2.0e8 * toxpf;
                T0 = (Vgsteff + vtfbphi2eot) / tmp2;
                T1 = 1.0 + exp(B4SOIbdos * 0.7 * lln(T0));
                Tcen = B4SOIados * 1.9e-9 / T1;
                toxpf = toxe - epsrox/B4SOIepsrsub * Tcen;
                niter = niter + 1;
            end // while
            B4SOItoxp = toxpf;
            /*B4SOIcoxp = epsrox * `EPS0 / B4SOItoxp;*/

        end // }/*End of Toxp*/

        /* vfbzb calculation for capMod 3 */
        tmp = pParam_B4SOIsqrtXdep0;
        tmp1 = pParam_B4SOIvbi - pParam_B4SOIphi;
        tmp2 = B4SOIfactor1 * tmp;

        T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * pParam_B4SOIleff / tmp2;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T2 = T1 * (1.0 + 2.0 * T1);
        end
        T0 = pParam_B4SOIdvt0w * T2;
        T2 = T0 * tmp1;

        T0 = -0.5 * pParam_B4SOIdvt1 * pParam_B4SOIleff / tmp2;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T3 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T3 = T1 * (1.0 + 2.0 * T1);
        end
        T3 = pParam_B4SOIdvt0 * T3 * tmp1;

        /* v2.2.3 */
        /*4.1*/
        /* T4 = (B4SOItox - B4SOIdtoxcv) * pParam_B4SOIphi
                / (pParam_B4SOIweff + pParam_B4SOIw0);
        */
        T4 = B4SOItoxp * pParam_B4SOIphi
                / (pParam_B4SOIweff + pParam_B4SOIw0);
        T0 = sqrt(1.0 + pParam_B4SOIlpe0 / pParam_B4SOIleff); /*v4.0*/
        T5 = pParam_B4SOIk1ox * (T0 - 1.0) * pParam_B4SOIsqrtPhi
                + (pParam_B4SOIkt1 + pParam_B4SOIkt1l / pParam_B4SOIleff)
                * (TempRatio - 1.0);        /* v4.0 */

        tmp3 = B4SOItype * pParam_B4SOIvth0
                - T2 - T3 + pParam_B4SOIk3 * T4 + T5;
        pParam_B4SOIvfbzb = tmp3 - pParam_B4SOIphi - pParam_B4SOIk1
                                         * pParam_B4SOIsqrtPhi;
        /* End of vfbzb */

        /* v4.6 */ /* 2014bug6: Used binning parameter for "npeak" */
        pParam_B4SOIqsi = `Charge_q * pParam_B4SOInpeak
                                 * (1.0 + pParam_B4SOIlpe0 / pParam_B4SOIleff)
                                 * 1e6 * B4SOItsi;


        /* v3.1 added for RF */
        B4SOIgrgeltd = B4SOIrshg * (B4SOIxgw
                               + pParam_B4SOIweff / B4SOInseg
                                    / 3.0 / B4SOIngcon) /
                              (B4SOIngcon * B4SOInf * (B4SOIl - B4SOIxgl));
        if (B4SOIgrgeltd > 0.0) begin
            B4SOIgrgeltd = 1.0 / B4SOIgrgeltd;
        end else begin
            B4SOIgrgeltd = 1.0e3; /* mho */
            if (B4SOIrgateMod !=0)
                $strobe("Warning: The gate conductance reset to 1.0e3 mho.");
        end
        /* v3.1 added for RF end */

        /* v4.0 rbodyMod */
        if (B4SOIrbodyMod) begin
            if (B4SOIrbdb < 1.0e-3)
                B4SOIgrbdb = 1.0e3; /* in mho */
            else
                B4SOIgrbdb = B4SOIgbmin + 1.0 / B4SOIrbdb;

            if (B4SOIrbsb < 1.0e-3)
                B4SOIgrbsb = 1.0e3;
            else
                B4SOIgrbsb = B4SOIgbmin + 1.0 / B4SOIrbsb;
        end else begin
            B4SOIgrbdb = 0;
            B4SOIgrbsb = 0;
        end
        /* v4.0 rbodyMod end */
        /* Bug Fix # 17 Jul09 Stress effect code (lines: 1954-2020) is moved up to lines 1479-1545*/

        B4SOIvfbzb = pParam_B4SOIvfbzb + B4SOItype * B4SOIdelvto;

        pParam_B4SOIldeb = sqrt(epssub * Vtm0 /
                               (`Charge_q * pParam_B4SOInpeak * 1.0e6)) / 3.0;

        /*For high k mobility*/
        T1 = B4SOItype * here_B4SOIvth0 - here_B4SOIvfb - pParam_B4SOIphi;
        T2 = T1 + T1;
        T3 = 2.5 * T1;
        B4SOIvtfbphi1 = (B4SOItype == `NMOS) ? T2 : T3;
        if (B4SOIvtfbphi1 < 0.0)
            B4SOIvtfbphi1 = 0.0;

        /*Calculate VgsteffVth for mobMod=4*/
        if (B4SOImobMod == 4) begin // {
            /*Calculate n @ Vbs=Vds=0*/
            lt1 = B4SOIfactor1* pParam_B4SOIsqrtXdep0;
            T0 = pParam_B4SOIdvt1 * pParam_B4SOIleff / lt1;
            if (T0 < `EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXPL;
                Theta0 = T1 / T4;
            end else begin
                Theta0 = 1.0 / (`MAX_EXPL - 2.0);
            end

            tmp1 = epssub / pParam_B4SOIXdep0;
            tmp2 = pParam_B4SOInfactor * tmp1;
            tmp3 = (tmp2 + pParam_B4SOIcdsc * Theta0 + pParam_B4SOIcit) / B4SOIcox;
            if (tmp3 >= -0.5) begin
                n0 = 1.0 + tmp3;
            end else begin
                T0 = 1.0 / (3.0 + 8.0 * tmp3);
                n0 = (1.0 + 3.0 * tmp3) * T0;
            end

            T0 = n0 * Vtm0;
            T1 = pParam_B4SOIvoff;
            T2 = T1/T0;
            if (T2 < -`EXPL_THRESHOLD) begin
                T3 = B4SOIcox * `MIN_EXPL / pParam_B4SOIcdep0;
                T4 = pParam_B4SOImstar + T3 * n0;
            end else if (T2 > `EXPL_THRESHOLD) begin
                T3 = B4SOIcox * `MAX_EXPL / pParam_B4SOIcdep0;
                T4 = pParam_B4SOImstar + T3 * n0;
            end else begin
                T3 = exp(T2)* B4SOIcox / pParam_B4SOIcdep0;
                T4 = pParam_B4SOImstar + T3 * n0;
            end

            B4SOIvgsteffvth = T0 * `M_LN2/T4;

        end else begin
            B4SOIvgsteffvth = 0;
        end // }

    end // b4soi_temp // }
`ifdef __XYCE__
    end // initialize_instance
`endif

    begin : b4soi_check // {
        integer Fatal_Flag;

        Fatal_Flag = 0;

        if (pParam_B4SOIlpe0 < -pParam_B4SOIleff) begin
            $strobe("Fatal: Lpe0 = %g is less than -Leff.", pParam_B4SOIlpe0);
            Fatal_Flag = 1;
        end

        if((B4SOIsa > 0.0) && (B4SOIsb > 0.0) &&
            ((B4SOInf == 1.0) || ((B4SOInf > 1.0) && (B4SOIsd > 0.0))) ) begin
            if (B4SOIsaref <= 0.0) begin
                $strobe("Fatal: SAref = %g is not positive.", B4SOIsaref);
                Fatal_Flag = 1;
            end
            if (B4SOIsbref <= 0.0) begin
                $strobe("Fatal: SBref = %g is not positive.", B4SOIsbref);
                Fatal_Flag = 1;
            end
        end

        if (pParam_B4SOIlpeb < -pParam_B4SOIleff) begin
            $strobe("Fatal: Lpeb = %g is less than -Leff.", pParam_B4SOIlpeb);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIfprout < 0.0) begin
            $strobe("Fatal: fprout = %g is negative.", pParam_B4SOIfprout);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIpdits < 0.0) begin
            $strobe("Fatal: pdits = %g is negative.", pParam_B4SOIpdits);
            Fatal_Flag = 1;
        end
        if (B4SOIpditsl < 0.0) begin
            $strobe("Fatal: pditsl = %g is negative.", B4SOIpditsl);
            Fatal_Flag = 1;
        end

        if (B4SOItox <= 0.0) begin
            $strobe("Fatal: Tox = %g is not positive.", B4SOItox);
            Fatal_Flag = 1;
        end
        if (B4SOIleffeot <= 0.0) begin
            $strobe("Fatal: Leffeot = %g is not positive.", B4SOIleffeot);
            Fatal_Flag = 1;
        end
        if (B4SOIweffeot <= 0.0) begin
            $strobe("Fatal: Weffeot = %g is not positive.", B4SOIweffeot);
            Fatal_Flag = 1;
        end
        if (B4SOItoxp <= 0.0) begin
            $strobe("Fatal: Toxp = %g is not positive.", B4SOItoxp);
            Fatal_Flag = 1;
        end
        if (B4SOIepsrgate < 0.0) begin
            $strobe("Fatal: Epsrgate = %g is not positive.", B4SOIepsrgate);
            Fatal_Flag = 1;
        end

        if (B4SOItoxm <= 0.0) begin
            $strobe("Fatal: Toxm = %g is not positive.", B4SOItoxm);
            Fatal_Flag = 1;
        end

        if (B4SOInf < 1.0) begin
            $strobe("Fatal: Number of finger = %g is smaller than one.", B4SOInf);
            Fatal_Flag = 1;
        end

        if (B4SOItox - B4SOIdtoxcv <= 0.0) begin
            $strobe("Fatal: Tox - dtoxcv = %g is not positive.", B4SOItox - B4SOIdtoxcv);
            Fatal_Flag = 1;
        end

        if (B4SOItbox <= 0.0) begin
            $strobe("Fatal: Tbox = %g is not positive.", B4SOItbox);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOInpeak <= 0.0) begin
            $strobe("Fatal: Nch = %g is not positive.", pParam_B4SOInpeak);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIngate < 0.0) begin
            $strobe("Fatal: Ngate = %g Ngate is not positive.", pParam_B4SOIngate);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIngate > 1.0e25) begin
            $strobe("Fatal: Ngate = %g Ngate is too high", pParam_B4SOIngate);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdvt1 < 0.0) begin
            $strobe("Fatal: Dvt1 = %g is negative.", pParam_B4SOIdvt1);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdvt1w < 0.0) begin
            $strobe("Fatal: Dvt1w = %g is negative.", pParam_B4SOIdvt1w);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIw0 == -pParam_B4SOIweff) begin
            $strobe("Fatal: (W0 + Weff) = 0 causing divided-by-zero.");
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdsub < 0.0) begin
            $strobe("Fatal: Dsub = %g is negative.", pParam_B4SOIdsub);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIb1 == -pParam_B4SOIweff) begin
            $strobe("Fatal: (B1 + Weff) = 0 causing divided-by-zero.");
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIu0temp <= 0.0) begin
            $strobe("Fatal: u0 at current temperature = %g is not positive.",
                pParam_B4SOIu0temp);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdelta < 0.0) begin
            $strobe("Fatal: Delta = %g is less than zero.", pParam_B4SOIdelta);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIvsattemp <= 0.0) begin
            $strobe("Fatal: Vsat at current temperature = %g is not positive.",
                pParam_B4SOIvsattemp);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIpclm <= 0.0) begin
            $strobe("Fatal: Pclm = %g is not positive.", pParam_B4SOIpclm);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIdrout < 0.0) begin
            $strobe("Fatal: Drout = %g is negative.", pParam_B4SOIdrout);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOIclc < 0.0) begin
            $strobe("Fatal: Clc = %g is negative.", pParam_B4SOIclc);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOInoff < 0.1) begin
            $strobe("Warning: Noff = %g is too small.", pParam_B4SOInoff);
        end else if (pParam_B4SOInoff > 4.0) begin
            $strobe("Warning: Noff = %g is too large.", pParam_B4SOInoff);
        end

        if (pParam_B4SOInoff2 < 0.1) begin               /* v4.6 */      /* 2015enh2 */
            $strobe("Warning: Noff2 = %g is too small.", pParam_B4SOInoff2);
        end else if (pParam_B4SOInoff2 > 4.0) begin
            $strobe("Warning: Noff2 = %g is too large.", pParam_B4SOInoff2);
        end

        if( (B4SOIsa > 0.0) && (B4SOIsb > 0.0) &&
            ((B4SOInf == 1.0) || ((B4SOInf > 1.0) && (B4SOIsd > 0.0))) ) begin

            if (B4SOIlodk2 <= 0.0)
                $strobe("Warning: LODK2 = %g is not positive.",B4SOIlodk2);
            if (B4SOIlodeta0 <= 0.0)
                $strobe("Warning: LODETA0 = %g is not positive.",B4SOIlodeta0);
            if (B4SOIlodeta0cv <= 0.0)
                $strobe("Warning: LODETA0CV = %g is not positive.",B4SOIlodeta0cv);

        end

        if (pParam_B4SOImoin < 5.0)
            $strobe("Warning: Moin = %g is too small.", pParam_B4SOImoin);
        if (pParam_B4SOImoin > 25.0)
            $strobe("Warning: Moin = %g is too large.", pParam_B4SOImoin);
        if (pParam_B4SOImoinfd < 5.0)
            $strobe("Warning: MoinFD = %g is too small.", pParam_B4SOImoinfd);

        if (B4SOIcapMod == 3) begin
            if (pParam_B4SOIacde < 0.1)
                $strobe("Warning: Acde = %g is too small.", pParam_B4SOIacde);
            else if (pParam_B4SOIacde > 1.6)
                $strobe("Warning: Acde = %g is too large.", pParam_B4SOIacde);
        end


        /* checks that set Fatal_Flag are moved out of PARAMCHK block in 4.4 */
        if (B4SOIcsdmin > 0 && (B4SOIasd <= 0.0 || B4SOIasd >= 1.0)) begin
            $strobe("Fatal: Asd = %g should be within (0, 1).", B4SOIasd);
            Fatal_Flag = 1;
        end

        if (pParam_B4SOInigc <= 0.0) begin
            $strobe("Fatal: nigc = %g is non-positive.", pParam_B4SOInigc);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIpoxedge <= 0.0) begin
            $strobe("Fatal: poxedge = %g is non-positive.", pParam_B4SOIpoxedge);
            Fatal_Flag = 1;
        end
        if (pParam_B4SOIpigcd <= 0.0) begin
            $strobe("Fatal: pigcd = %g is non-positive.", pParam_B4SOIpigcd);
            Fatal_Flag = 1;
        end

        if (B4SOItoxref < 0.0) begin
            $strobe("Warning:  Toxref = %g is negative.", B4SOItoxref);
            Fatal_Flag = 1;
        end
        if (B4SOItoxqm <= 0.0) begin
            $strobe("Fatal: Toxqm = %g is not positive.", B4SOItoxqm);
            Fatal_Flag = 1;
        end

        if (VERSION >= 4.4 || PARAMCHK) begin
            if (pParam_B4SOIa2 < 0.01) begin
                $strobe("Warning: A2 = %g is too small. Set to 0.01.", pParam_B4SOIa2);
                pParam_B4SOIa2 = 0.01;
            end else if (pParam_B4SOIa2 > 1.0) begin
                $strobe("Warning: A2 = %g is larger than 1. A2 is set to 1 and A1 is set to 0.",
                    pParam_B4SOIa2);
                pParam_B4SOIa2 = 1.0;
                pParam_B4SOIa1 = 0.0;
            end
        end

        if (pParam_B4SOIrdsw < 0.0) begin
            $strobe("Warning: Rdsw = %g is negative. Set to zero.",
                pParam_B4SOIrdsw);
            pParam_B4SOIrdsw = 0.0;
            pParam_B4SOIrds0 = 0.0;
        end else if (pParam_B4SOIrds0 < 0.001 && pParam_B4SOIrds0 != 0.0) begin
            $strobe("Warning: Rds at current temperature = %g is less than 0.001 ohm. Set to zero.",
                pParam_B4SOIrds0);
            pParam_B4SOIrds0 = 0.0;
        end

        if (PARAMCHK) begin // {
            if (pParam_B4SOIleff <= 5.0e-8)
                $strobe("Warning: Leff = %g may be too small.", pParam_B4SOIleff);
            if (pParam_B4SOIleffCV <= 5.0e-8)
                $strobe("Warning: Leff for CV = %g may be too small.", pParam_B4SOIleffCV);

            if (pParam_B4SOIweff <= 1.0e-7)
                $strobe("Warning: Weff = %g may be too small.", pParam_B4SOIweff);

            if (pParam_B4SOIweffCV <= 1.0e-7)
                $strobe("Warning: Weff for CV = %g may be too small.",
                   pParam_B4SOIweffCV);

            if (pParam_B4SOIlpe0 < 0.0)
               $strobe("Warning: Lpe0 = %g is negative.", pParam_B4SOIlpe0);

            if (B4SOItox < 1.0e-9)
                $strobe("Warning: Tox = %g is less than 10A.", B4SOItox);

            if (pParam_B4SOInpeak <= 1.0e15)
                $strobe("Warning: Nch = %g may be too small.", pParam_B4SOInpeak);
            else if (pParam_B4SOInpeak >= 1.0e21)
                $strobe("Warning: Nch = %g may be too large.", pParam_B4SOInpeak);

            if (abs(pParam_B4SOInsub) >= 1.0e21)
                $strobe("Warning: Nsub = %g may be too large.", pParam_B4SOInsub);

            if ((pParam_B4SOIngate > 0.0) && (pParam_B4SOIngate <= 1.0e18))
                $strobe("Warning: Ngate = %g is less than 1.E18cm^-3.", pParam_B4SOIngate);

            if (pParam_B4SOIdvt0 < 0.0)
                $strobe("Warning: Dvt0 = %g is negative.", pParam_B4SOIdvt0);

            if (abs(1.0e-6 / (pParam_B4SOIw0 + pParam_B4SOIweff)) > 10.0)
                $strobe("Warning: (W0 + Weff) may be too small.");

            if (B4SOInsd > 1.0e23)
                $strobe("Warning: Nsd = %g is too large, should be specified in cm^-3.", B4SOInsd);
            if (B4SOIngate > 1.0e23)
                $strobe("Warning: Ngate = %g is too large, should be specified in cm^-3.", B4SOIngate);

            if (pParam_B4SOInfactor < 0.0)
                $strobe("Warning: Nfactor = %g is negative.", pParam_B4SOInfactor);
            if (pParam_B4SOIcdsc < 0.0)
                $strobe("Warning: Cdsc = %g is negative.", pParam_B4SOIcdsc);
            if (pParam_B4SOIcdscd < 0.0)
                $strobe("Warning: Cdscd = %g is negative.", pParam_B4SOIcdscd);

            if (pParam_B4SOIeta0 < 0.0)
                $strobe("Warning: Eta0 = %g is negative.", pParam_B4SOIeta0);

            if (pParam_B4SOIeta0cv < 0.0)
                $strobe("Warning: Eta0CV = %g is negative.", pParam_B4SOIeta0cv);

            if (abs(1.0e-6 / (pParam_B4SOIb1 + pParam_B4SOIweff)) > 10.0)
                $strobe("Warning: (B1 + Weff) may be too small.");

            if (pParam_B4SOIvsattemp < 1.0e3)
                $strobe("Warning: Vsat at current temperature = %g may be too small.", pParam_B4SOIvsattemp);

            if (pParam_B4SOIpdibl1 < 0.0)
                $strobe("Warning: Pdibl1 = %g is negative.", pParam_B4SOIpdibl1);
            if (pParam_B4SOIpdibl2 < 0.0)
                $strobe("Warning: Pdibl2 = %g is negative.", pParam_B4SOIpdibl2);

            if (B4SOIntun < 0.0)
                $strobe("Warning: Ntuns = %g is negative.", B4SOIntun);
            if (B4SOIntund < 0.0)
                $strobe("Warning: Ntund = %g is negative.", B4SOIntund);

            if (B4SOIndiode < 0.0)
                $strobe("Warning: Ndiode = %g is negative.", B4SOIndiode);
            if (B4SOIndioded < 0.0)
                $strobe("Warning: Ndioded = %g is negative.", B4SOIndioded);

            if (B4SOIisbjt < 0.0)
                $strobe("Warning: Isbjt = %g is negative.", B4SOIisbjt);
            if (B4SOIidbjt < 0.0)
                $strobe("Warning: Idbjt = %g is negative.", B4SOIidbjt);

            if (B4SOIisdif < 0.0)
                $strobe("Warning: Isdif = %g is negative.", B4SOIisdif);
            if (B4SOIiddif < 0.0)
                $strobe("Warning: Iddif = %g is negative.", B4SOIiddif);

            if (B4SOIisrec < 0.0)
                $strobe("Warning: Isrec = %g is negative.", B4SOIisrec);
            if (B4SOIidrec < 0.0)
                $strobe("Warning: Idrec = %g is negative.", B4SOIidrec);

            if (B4SOIistun < 0.0)
                $strobe("Warning: Istun = %g is negative.", B4SOIistun);
            if (B4SOIidtun < 0.0)
                $strobe("Warning: Idtun = %g is negative.", B4SOIidtun);

            if (B4SOItt < 0.0)
                $strobe("Warning: Tt = %g is negative.", B4SOItt);

            if (B4SOIcsdmin < 0.0)
                $strobe("Warning: Csdmin = %g is negative.", B4SOIcsdmin);

            if (B4SOIcsdesw < 0.0)
                $strobe("Warning: Csdesw = %g is negative.", B4SOIcsdesw);

            if (B4SOIrth0 < 0.0)
                $strobe("Warning: Rth0 = %g is negative.", B4SOIrth0);
            if (B4SOIcth0 < 0.0)
                $strobe("Warning: Cth0 = %g is negative.", B4SOIcth0);
            if (B4SOIwth0 < 0.0)
                $strobe("Warning:  Wth0 = %g is negative.", B4SOIwth0);

            if (B4SOIrbody < 0.0)
                $strobe("Warning: Rbody = %g is negative.", B4SOIrbody);
            if (B4SOIrbsh < 0.0)
                $strobe("Warning: Rbsh = %g is negative.", B4SOIrbsh);
            if (B4SOIrhalo < 0.0)
                $strobe("Warning:  Rhalo = %g is negative.", B4SOIrhalo);

            if (B4SOIntox < 0.0)
                $strobe("Warning:  Ntox = %g is negative.", B4SOIntox);

            if (B4SOIebg < 0.0)
                $strobe("Warning:  Ebg = %g is negative.", B4SOIebg);
            if (B4SOIvevb < 0.0)
                $strobe("Warning:  Vevb = %g is negative.", B4SOIvevb);
            if (pParam_B4SOIalphaGB1 < 0.0)
                $strobe("Warning:  AlphaGB1 = %g is negative.", pParam_B4SOIalphaGB1);
            if (pParam_B4SOIbetaGB1 < 0.0)
                $strobe("Warning:  BetaGB1 = %g is negative.", pParam_B4SOIbetaGB1);
            if (B4SOIvgb1 < 0.0)
                $strobe("Warning:  Vgb1 = %g is negative.", B4SOIvgb1);
            if (B4SOIvecb < 0.0)
                $strobe("Warning:  Vecb = %g is negative.", B4SOIvecb);
            if (pParam_B4SOIalphaGB2 < 0.0)
                $strobe("Warning:  AlphaGB2 = %g is negative.", pParam_B4SOIalphaGB2);
            if (pParam_B4SOIbetaGB2 < 0.0)
                $strobe("Warning:  BetaGB2 = %g is negative.", pParam_B4SOIbetaGB2);
            if (B4SOIvgb2 < 0.0)
                $strobe("Warning:  Vgb2 = %g is negative.", B4SOIvgb2);

            if (B4SOIvoxh < 0.0)
                $strobe("Warning:  Voxh = %g is negative.", B4SOIvoxh);
            if (B4SOIdeltavox <= 0.0)
                $strobe("Fatal: Deltavox = %g is not positive.", B4SOIdeltavox);

            if (B4SOIk1w1 < 0.0)
                $strobe("Warning:  K1w1 = %g is negative.", B4SOIk1w1);
            if (B4SOIk1w2 < 0.0)
                $strobe("Warning:  K1w2 = %g is negative.", B4SOIk1w2);
            if (B4SOIketas < 0.0)
                $strobe("Warning:  Ketas = %g is negative.", B4SOIketas);
            if (B4SOIdwbc < 0.0)
                $strobe("Warning:  Dwbc = %g is negative.", B4SOIdwbc);
            if (B4SOIbeta0 < 0.0)
                $strobe("Warning:  Beta0 = %g is negative.", B4SOIbeta0);
            if (B4SOIbeta1 < 0.0)
                $strobe("Warning:  Beta1 = %g is negative.", B4SOIbeta1);
            if (B4SOIbeta2 < 0.0)
                $strobe("Warning:  Beta2 = %g is negative.", B4SOIbeta2);
            if (B4SOIlii < 0.0)
                $strobe("Warning:  Lii = %g is negative.", B4SOIlii);
            if (B4SOIsii1 < 0.0)
                $strobe("Warning:  Sii1 = %g is negative.", B4SOIsii1);
            if (B4SOIsii2 < 0.0)
                $strobe("Warning:  Sii2 = %g is negative.", B4SOIsii2);
            if (B4SOIsiid < 0.0)
                $strobe("Warning:  Siid = %g is negative.", B4SOIsiid);
            if (B4SOIfbjtii < 0.0)
                $strobe("Warning:  fbjtii = %g is negative.", B4SOIfbjtii);
            if (B4SOIvrec0 < 0.0)
                $strobe("Warning:  Vrec0s = %g is negative.", B4SOIvrec0);
            if (B4SOIvrec0d < 0.0)
                $strobe("Warning:  Vrec0d = %g is negative.", B4SOIvrec0d);
            if (B4SOIvtun0 < 0.0)
                $strobe("Warning:  Vtun0s = %g is negative.", B4SOIvtun0);
            if (B4SOIvtun0d < 0.0)
                $strobe("Warning:  Vtun0d = %g is negative.", B4SOIvtun0d);
            if (B4SOInbjt < 0.0)
                $strobe("Warning:  Nbjt = %g is negative.", B4SOInbjt);
            if (B4SOIaely < 0.0)
                $strobe("Warning:  Aely = %g is negative.", B4SOIaely);
            if (B4SOIahli < 0.0)
                $strobe("Warning:  Ahlis = %g is negative.", B4SOIahli);
            if (B4SOIahlid < 0.0)
                $strobe("Warning:  Ahlid = %g is negative.", B4SOIahlid);

            if ((B4SOIacde < 0.1) || (B4SOIacde > 1.6))
                $strobe("Warning:  Acde = %g is out of range.", B4SOIacde);
            if ((B4SOImoin < 5.0)||(B4SOImoin > 25.0))
                $strobe("Warning:  Moin = %g is out of range.", B4SOImoin);
            if (B4SOIdlbg < 0.0)
                $strobe("Warning:  dlbg = %g is negative.", B4SOIdlbg);

            if (B4SOIagidl < 0.0)
                $strobe("Warning:  Agidl = %g is negative.", B4SOIagidl);
            if (B4SOIbgidl < 0.0)
                $strobe("Warning:  Bgidl = %g is negative.", B4SOIbgidl);
            if (abs(B4SOIcgidl) < 1e-9)
                $strobe("Warning:  Cgidl = %g is smaller than 1e-9.", B4SOIcgidl);
            if (B4SOIegidl < 0.0)
                $strobe("Warning:  Egidl = %g is negative.", B4SOIegidl);

            if (B4SOIagisl < 0.0)
                $strobe("Warning:  Agidl = %g is negative.", B4SOIagidl);
            if (B4SOIbgisl < 0.0)
                $strobe("Warning:  Bgisl = %g is negative.", B4SOIbgisl);
            if (abs(B4SOIcgisl) < 1e-9)
                $strobe("Warning:  Cgisl = %g is smaller than 1e-9.", B4SOIcgisl);
            if (B4SOIegisl < 0.0)
                $strobe("Warning:  Egisl = %g is negative.", B4SOIegisl);

            if (B4SOIesatii < 0.0)
                $strobe("Warning: Esatii = %g is negative.", B4SOIesatii);

            if (pParam_B4SOIxj > B4SOItsi)
                $strobe("Warning: Xj = %g is thicker than Tsi = %g.",
                    pParam_B4SOIxj, B4SOItsi);

        end // } PARAMCHK

        if (Fatal_Flag)
            $finish(0);

    end // b4soi_check // }


    /*  Calculate temperature dependent values for self-heating effect (v4.6 ) */ /* 2014bug2*/
`ifdef PORT_CONNECTED
    if ((SHMOD ==1) && (RTH0 !=0.0)) begin
        if (TNODEOUT && !$port_connected(t)) begin
            if ($port_connected(b)) begin       //last terminal is 'b'
                delTemp = V(b);
            end else if ($port_connected(p)) begin      //last terminal is 'p'
                delTemp = V(p);
            end else begin      // 4-terminal mode ('t' is internal)
                delTemp = Temp(t);
            end
        end else begin
            delTemp = Temp(t);
        end
    end else begin
        delTemp = 0;
    end
`else
    if ((SHMOD == 1) && (RTH0 != 0.0))
        delTemp = Temp(t);
    else
        delTemp = 0;
`endif
    DevTemp = $temperature + DTEMP;
    DevTemp = delTemp + DevTemp;
    TempRatio = DevTemp / B4SOItnom;
    /* TempRatio used for Vth and mobility */
    TempRatioMinus1 = DevTemp / B4SOItnom - 1.0;

    B4SOITempSH = DevTemp;          /*v4.2 added for portability of SH Temp */
    T_TOTAL_K = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    T_DELTA_SH = Temp(t);
    begin : load // {
        real VgstNVt, ExpVgst;
        real arg;
        real Vfbeff, V3, V4;
        real PhiBSWG, MJSWG;
        real vbd, vbs, vds, vgd, vgs;
        real Vds, Vgs, Vbs;
        real Vgs_eff, Vfb;
        real Phis, sqrtPhis, Vth;
        real Vgst;
        real n, Vtm;
        real ExpArg, V0;
        real ueff, Esat, Vdsat, EsatL;
        real Va, Vasat;
        real Vbseff;
        real CoxWL;
        real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
        real dT2_dVg, dT3_dVb;
        real tmp, Abulk, Abulk0;
        real VACLM, VADIBL;
        real Xdep, lt1, ltw;
        real Delt_vth;
        real Theta0;
        real tmp1, tmp2, tmp3, tmp4;
        real DIBL_Sft, Lambda;

        real Vgsteff, Vdseff, VdseffCV;
        real diffVds;
        real dAbulk_dVg;
        real beta, gche, fgche1, fgche2;
        real Idl, Ids;
        real CoxWovL;
        real Rds, WVCox, WVCoxRds;
        real Vgst2Vtm, VdsatCV;
        real Leff, Weff;
        real AbulkCV;
        real qgdo, qgso;

        real ves, ved, vbp;
        real Vbd, Ves, Vesfb, DeltVthtemp;
        real DeltVthw;
        real Igidl, Igisl;
        real Ibp, Iii;
        real qjd, qjs;
        real ni, Eg, Cbox, CboxWL;
        real qinv, qgate, qbody, qdrn, qsrc, qsub;
        real Vdsatii;
        real Ibd1, Ibd2, Ibd3, Ibd4;
        real Ibs1, Ibs2, Ibs3, Ibs4;
        real WTsi, NVtm1, NVtm2;
        real Ic, Ibs, Ibd;
        real Denomi;
        real Qsub0, Qac0, Qe1;

        /*  for self-heating  */
        real vbi, vfbb, phi, sqrtPhi, Xdep0, u0temp, vsattemp;
        real jdifs, jdifd;
        real jbjts, jbjtd;
        real jrecs, jrecd;
        real jtuns, jtund;
        real rds0, ua, ub, uc;
        real rho, rho_ref, ku0temp; /* v4.0 */

        /* v2.0 release */
        real Vbsh;
        real sqrtPhisExt;
        real T13, T14;
        real Vdsatii0;
        real VgsStep, Ratio;
        real Vdiff;
        real NVtmf, NVtmr;
        real Ahlis, Ahlid;
        real WsTsi, WdTsi;
        real cjsbs, cjdbs, dcjdbs_dT, dcjsbs_dT, dPhiBSWG_dT;
        real CoxWLb, CoxWLcenb;
        real ExpVbsNVtm, ExpVbdNVtm;
        real Ien, Iendif;
        real Ibsdif, Ibddif;
        real Ehlis, Ehlid;
        real EhlisFactor, EhlidFactor;
        real E2ndFactor;
        real DioMax;
        real wdios, wdiod;

        /* for capMod3 */
        real Cox, Tox, Tcen, LINK, Ccen, Coxeff;
        real CoxWLcen, DeltaPhi;
        real qinoi, qbulk;
        real T3zb, lt1zb, ltwzb, Theta0zb;
        real Delt_vthzb;
        real DeltVthwzb;
        real DeltVthtempzb;
        real Vthzb, Vfbzb;

        /* v3.2 */
        real noff;
        real noff2;         /* 2015enh2 */
        /* v3.1 added for RF */
        real vgms, vgmd;

        /* v3.0 */
        real Igc, Igs, Igd, Igcs, Igcd;
        real vgs_eff, vgd_eff;
        real VxNVt, ExpVxNVt;

        /* v3.0 */
        real Vbsitf, Vbs0, Vbs0mos, Vbsmos;
        real PhiON, PhiFD, Vbs0t, VthFD;
        real VtgsFD, ExpVtgsFD, VgstFD, ExpVgstFD;
        real VtgseffFD, VgsteffFD;

        /*New Variables due to introduction of ETA0CV and ETABCV by Pankaj in May 2012*/

        real Vbseff_CV;
        real Vbsh_CV;
        real Vbsitf_CV, Vbs0_CV,Vbsmos_CV;
        real PhiON_CV, PhiFD_CV, Vbs0t_CV, VthFD_CV;
        real Phis_CV, sqrtPhis_CV, Xdep_CV;
        real lt1_CV, ltw_CV;
        real Theta0_CV, n_CV;
        real VtgsFD_CV, ExpVtgsFD_CV, VgstFD_CV, ExpVgstFD_CV;
        real VtgseffFD_CV, VgsteffFD_CV;
        real tmp2_CV;
        real Delt_vth_CV, DeltVthw_CV, DeltVthtemp_CV, DIBL_Sft_CV, DITS_Sft_CV;
        real sqrtPhisExt_CV;
        real Vth_CV;
        real Abulk0_CV;


        /* v2.2 release */
        real Vgb, Vox;
        real OxideRatio, Vaux;
        real Igb;
        real Voxeff, Voxacc, Voxdepinv;
        real Igb1, Igb2;

        /* v4.0 */
        real IdlovVdseff, IdovVds;
        real vsbs, vdbd;
        real Lpe_Vb; /* v4.0 for Vth */
        real DITS_Sft, DITS_Sft2;
        real FP;
        real VADITS; /* for DITS */
        real PowWeffWr, rd0, rs0, rdwmin, rswmin, Rd, Rs;
        /*4.1*/
        real Tnom, Eg0, Vtm0;
        real Vbci, Idsmosfet, Iiibjt;
        real VgsteffVth;
        /* v4.1 */
        /* Jun 09 */
        real toxe_mob ;
        /* Jun 09 */

        real Vgd, Vgd_eff;
        real Ig_agbcp2;
        real vgp_eff, vgp;

        /* improved body contact charge model */
        real CoxWL2, CoxWLb2;
        real ExpVgst2, Vgsteff2, VgstNVt2, ExpArg2;
        real T02, T22;
        real Qac02, Qsub02;
        real Vgs_eff2;
        real Vfbzb2, Vfb2, Vfbeff2, VdsatCV2, VdseffCV2;
        real Tcen2, Ccen2, Coxeff2, CoxWLcen2, CoxWLcenb2;
        real DeltaPhi2;
        real qsrc2, qbulk2;
        real DELTA_3_SOI2;
        real cdep0, theta0vb0, thetaRout;
        real agidl, bgidl, cgidl, egidl, rgidl, kgidl, fgidl;
        real agisl, bgisl, cgisl, egisl, rgisl, kgisl, fgisl;
        real ucs, ud;

        // initialization to prevent hidden state warnings
        // variables used and set for B4SOIagbcp2 > 0
        Coxeff2 = 0; CoxWLcen2 = 0; CoxWLcenb2 = 0;
        DeltaPhi2 = 0;
        Tcen2 = 0;
        T02 = 0; T12 = 0; T22 = 0;
        VdseffCV2 = 0;
        Vfb2 = 0;
        Vfbeff2 = 0;
        Vfbzb2 = 0;
        Vgsteff2 = 0;

        // rdsmod         /* 2013.enh5, 2015.enh1 */ /* v4.6 */
        rds0 = pParam_B4SOIrds0;
        rd0 = pParam_B4SOIrd0;
        rs0 = pParam_B4SOIrs0;
        rdwmin = pParam_B4SOIrdwmin;
        rswmin = pParam_B4SOIrswmin;



        if ((SHMOD == 1) && (RTH0 != 0.0)) begin // {
            if (B4SOImtrlMod == 0) begin // {
                Vtm = `KboQ * DevTemp;

                T0 = 1108.0 + DevTemp;
                T5 = DevTemp * DevTemp;
                Eg = 1.16 - 7.02e-4 * T5 / T0;

                T2 = 1.9230584e-4;  /*  T2 = 1 / 300.15^(3/2)  */
                T5 = sqrt(DevTemp);
                T3 = 1.45e10 * DevTemp * T5 * T2;

                /*T4 = exp(21.5565981 - Eg / (2.0 * Vtm)) is limited at extremely low temperature by Pankaj in May 2012*/

                T6=21.5565981 - Eg / (2.0 * Vtm);
                if (T6 >-`EXPL_THRESHOLD)
                    T4 = exp(T6);
                else
                    T4=exp(-`EXPL_THRESHOLD);


                ni = T3 * T4;

                T0 = lln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
                vbi = Vtm * T0;
            end else begin // }{
                Tnom = B4SOItnom;
                Vtm  = `KboQ * DevTemp;
                Vtm0 = `KboQ * Tnom;

                Eg0 = B4SOIeg0;
                Eg = B4SOIbg0sub - B4SOItbgasub * DevTemp * DevTemp
                    / (DevTemp + B4SOItbgbsub);

                T2 = 1/sqrt(Tnom*Tnom*Tnom);
                T5 = sqrt(DevTemp);
                T3 = B4SOIni0sub * DevTemp * T5 * T2;
                T4 = exp(Eg0/(2.0*Vtm0) - Eg / (2.0 * Vtm));
                ni = T3 * T4;

                T0 = lln(1.0e20 * pParam_B4SOInpeak / (ni * ni));
                vbi = Vtm * T0;
            end // }

            if (pParam_B4SOInsub > 0) begin
                T0 = lln(pParam_B4SOInpeak / pParam_B4SOInsub);
                vfbb = -B4SOItype * Vtm * T0;
            end else begin
                T0 = lln(-pParam_B4SOInpeak * pParam_B4SOInsub / ni / ni);
                vfbb = -B4SOItype * Vtm * T0;
            end

            /* V4.0 changed phi */
            phi = 2.0 * Vtm * lln(pParam_B4SOInpeak / ni);
            sqrtPhi = sqrt(phi);
            Xdep0 = sqrt(2.0 * epssub / (`Charge_q
                    * pParam_B4SOInpeak * 1.0e6))
                    * sqrtPhi;

            /* cdep0 = sqrt(`Charge_q * `EPSSI
                    * pParam_B4SOInpeak * 1.0e6 / 2.0) / sqrtPhi;    */   /* Bug fix #2 Jun 09 Body type is generalized for mtrlMod 1*/
            cdep0 = sqrt(`Charge_q * epssub                                    /* Fix */
                    * pParam_B4SOInpeak * 1.0e6 / 2.0) / sqrtPhi;

            /* T1 = sqrt(`EPSSI / (B4SOIepsrox * `EPSOX / 3.9)       */   /* Bug fix #3 Jun 09 Body type is generalized for mtrlMod 1*/
            /*  * B4SOItox * Xdep0); */

            T1 = sqrt(epssub / (epsrox * `EPS0)                                /* Fix */
                    * toxe * Xdep0);
            T0 = exp(-0.5 * pParam_B4SOIdsub * pParam_B4SOIleff / T1);
            theta0vb0 = (T0 + 2.0 * T0 * T0);
            T0 = exp(-0.5 * pParam_B4SOIdrout * pParam_B4SOIleff / T1);
            T2 = (T0 + 2.0 * T0 * T0);
            thetaRout = pParam_B4SOIpdibl1 * T2 + pParam_B4SOIpdibl2;

            /*  Save the values below for phi calculation in B4SOIaccept()  */
            B4SOIvtm = Vtm;

            T3 = TempRatio - 1.0;
            T4 = `Eg300 / Vtm * T3;

            T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndiode;
            `DEXP(T7, T0)

            if (pParam_B4SOIxbjt == pParam_B4SOIxdif) begin
                T1 = T0;
            end else begin
                T7 = pParam_B4SOIxdif * T4 / pParam_B4SOIndiode;
                `DEXP(T7, T1)
            end

            T7 = pParam_B4SOIxrec * T4 / pParam_B4SOInrecf0;
            `DEXP(T7, T2)

            Ahlis = pParam_B4SOIahli * T0; /* high level injection */
            jbjts = pParam_B4SOIisbjt * T0;
            jdifs = pParam_B4SOIisdif * T1;
            jrecs = pParam_B4SOIisrec * T2;

            T7 = pParam_B4SOIxtun * T3;
            `DEXP(T7, T0)
            jtuns = pParam_B4SOIistun * T0;

            /* drain side */
            T7 = pParam_B4SOIxbjt * T4 / pParam_B4SOIndioded;
            `DEXP(T7, T0)

            if (pParam_B4SOIxbjt == pParam_B4SOIxdifd) begin
                T1 = T0;
            end else begin
                T7 = pParam_B4SOIxdifd * T4 / pParam_B4SOIndioded;
                `DEXP(T7, T1)
            end

            T7 = pParam_B4SOIxrecd * T4 / pParam_B4SOInrecf0d;
            `DEXP(T7, T2)

            Ahlid = pParam_B4SOIahlid * T0; /* high level injection */
            jbjtd = pParam_B4SOIidbjt * T0;
            jdifd = pParam_B4SOIiddif * T1;
            jrecd = pParam_B4SOIidrec * T2;

            T7 = pParam_B4SOIxtund * T3;
            `DEXP(T7, T0)
            jtund = pParam_B4SOIidtun * T0;

            u0temp = pParam_B4SOIu0 * pow(TempRatio, pParam_B4SOIute);
            if (VERSION < 4.2) // backwards compatibility
                ku0temp = pParam_B4SOIku0 * (1.0 + B4SOItku0 * TempRatio) + `DELTA_;
            else
                ku0temp = pParam_B4SOIku0 * (1.0 + B4SOItku0 * T3) + `DELTA_;
            T7 = B4SOIku0 * pParam_B4SOIinv_od_ref;
            rho_ref = T7 / ku0temp;
            T4 = B4SOIku0 * B4SOIInv_ODeff;
            rho = T4 / ku0temp;
            T2 = (1.0 + rho);
            T7 = (1.0 + rho_ref);
            T0 = T2 / T7;
            u0temp = u0temp * T0;

            vsattemp = pParam_B4SOIvsat - pParam_B4SOIat * T3;
            T2 = (1.0 + B4SOIkvsat * rho);
            T7 = (1.0 + B4SOIkvsat * rho_ref);
            T0 = T2 / T7;
            vsattemp = vsattemp * T0;

            if (B4SOIrdsMod != 1) begin   /* 2013.enh5, 2015.enh1 */ /* v4.6 */
                rds0 = (pParam_B4SOIrdsw + pParam_B4SOIprt * T3)
                        / pParam_B4SOIrds0denom;
                rd0 = 0;
                rs0 = 0;
            end else begin /* v4.0 */    /* 2013.enh5, 2015.enh1 */ /* v4.6 */
                rds0 = 0;
                PowWeffWr = pParam_B4SOIrds0denom * B4SOInf;
                T10 = pParam_B4SOIprt * T3;

                /* External Rd(V) */
                T1 = pParam_B4SOIrdw + T10;
                T2 = B4SOIrdwmin + T10;
                rd0 = T1 / PowWeffWr;
                rdwmin = T2 / PowWeffWr;

                /* External Rs(V) */
                T7 = pParam_B4SOIrsw + T10;
                T4 = B4SOIrswmin + T10;
                rs0 = T7 / PowWeffWr;
                rswmin = T4 / PowWeffWr;
            end

            ua = pParam_B4SOIuatemp + pParam_B4SOIua1 * T3;
            ub = pParam_B4SOIubtemp + pParam_B4SOIub1 * T3;
            uc = pParam_B4SOIuctemp + pParam_B4SOIuc1 * T3;

        end else begin // }{

            vbi = pParam_B4SOIvbi;
            vfbb = pParam_B4SOIvfbb;
            phi = pParam_B4SOIphi;
            sqrtPhi = pParam_B4SOIsqrtPhi;
            Xdep0 = pParam_B4SOIXdep0;
            /* Eg = B4SOIeg0; */                          /* Bug fix #11 Jun 09 'Eg is evaluated at DevTemp, not Tnom' */
            Eg = B4SOIeg;                                /* 'B4SOIeg' computed in b4soitemp.c */
            /* v4.1 */                                        /* Since selfheat=0, using Eg from b4soitemp.c*/
            cdep0 = pParam_B4SOIcdep0;
            theta0vb0 = pParam_B4SOItheta0vb0;
            thetaRout = pParam_B4SOIthetaRout;

            jbjts = pParam_B4SOIjbjts;    /* v4.0 */
            jbjtd = pParam_B4SOIjbjtd;
            jdifs = pParam_B4SOIjdifs;
            jdifd = pParam_B4SOIjdifd;
            jrecs = pParam_B4SOIjrecs;
            jrecd = pParam_B4SOIjrecd;
            jtuns = pParam_B4SOIjtuns;
            jtund = pParam_B4SOIjtund;

            /* v2.2.2 bug fix */
            Ahlis = pParam_B4SOIahli0s;
            Ahlid = pParam_B4SOIahli0d;

            u0temp = here_B4SOIu0temp;
            vsattemp = here_B4SOIvsattemp;
            ua = pParam_B4SOIua;
            ub = pParam_B4SOIub;
            uc = pParam_B4SOIuc;
        end // }

        if ($param_given(K1) || $param_given(K2)) begin // {
            if (!$param_given(K1)) begin
                $strobe( "Warning: k1 should be specified with k2.");
                pParam_B4SOIk1 = 0.53;
            end
            if (!$param_given(K2)) begin
                $strobe( "Warning: k2 should be specified with k1.");
                pParam_B4SOIk2 = -0.0186;
            end
            if ($param_given(XT))
                $strobe( "Warning: xt is ignored because k1 or k2 is given.");
            if ($param_given(VBX))
                $strobe( "Warning: vbx is ignored because k1 or k2 is given.");
            if ($param_given(VBM))
                $strobe( "Warning: vbm is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA1))
                $strobe( "Warning: gamma1 is ignored because k1 or k2 is given.");
            if ($param_given(GAMMA2))
                $strobe( "Warning: gamma2 is ignored because k1 or k2 is given.");
        end else begin // }{
            if (!$param_given(VBX)) begin
                if (B4SOImtrlMod)
                    T0 = `Charge_q / (2.0 * epssub) * 1.0e6;
                else
                    T0 = 7.7348e-4; /* constant from v4.3.0 and earlier */
                pParam_B4SOIvbx = phi - T0 * pParam_B4SOInpeak
                                             * pParam_B4SOIxt * pParam_B4SOIxt;
            end
            if (pParam_B4SOIvbx > 0.0)
                pParam_B4SOIvbx = -pParam_B4SOIvbx;
            if (pParam_B4SOIvbm > 0.0)
                pParam_B4SOIvbm = -pParam_B4SOIvbm;

            if (!$param_given(GAMMA1))
                pParam_B4SOIgamma1 = sqrt2qeps * sqrt(pParam_B4SOInpeak) / B4SOIcox;

            if (!$param_given(GAMMA2))
                pParam_B4SOIgamma2 = sqrt2qeps * sqrt(pParam_B4SOInsub) / B4SOIcox;

            T0 = pParam_B4SOIgamma1 - pParam_B4SOIgamma2;
            T1 = sqrt(phi - pParam_B4SOIvbx) - sqrtPhi;
            T2 = sqrtPhi * (sqrt(phi - pParam_B4SOIvbm)- sqrtPhi);
            T3= T0 * T1 / (2.0 * T2 + pParam_B4SOIvbm);
            here_B4SOIk2=here_B4SOIk2-pParam_B4SOIk2 + T3;
            pParam_B4SOIk1 = pParam_B4SOIgamma2 - 2.0
                                * here_B4SOIk2 * sqrt(phi - pParam_B4SOIvbm);
        end // }

        T0 = pParam_B4SOIweff + pParam_B4SOIk1w2;
        if (T0 < 1e-8)
            T0 = 1e-8;
        pParam_B4SOIk1eff = pParam_B4SOIk1 * (1 + pParam_B4SOIk1w1/T0);

        /* v4.1 */

         if (!$param_given(VFB)) begin
            if ($param_given(VTH0) || $param_given(VTHO)) begin
                    here_B4SOIvfb = here_B4SOIvfb - pParam_B4SOIvfb + B4SOItype * here_B4SOIvth0 - phi - pParam_B4SOIk1eff* sqrtPhi;
                end else begin
                    here_B4SOIvfb = here_B4SOIvfb;
                end
         end


        if (!$param_given(VTH0)) begin
            here_B4SOIvth0= B4SOItype * (here_B4SOIvfb + phi + pParam_B4SOIk1eff*sqrtPhi);
         end

        if (VERSION < 4.2) begin
            // for backwards-compatibility: self-heating temperature-adjusted
            // parameters were not used in actual equations below
            rd0 = pParam_B4SOIrd0;
            rdwmin = pParam_B4SOIrdwmin;
            cdep0 = pParam_B4SOIcdep0;
            theta0vb0 = pParam_B4SOItheta0vb0;
            thetaRout = pParam_B4SOIthetaRout;
            if (B4SOImobMod == 4) begin
                ua = pParam_B4SOIua;
                uc = pParam_B4SOIuc;
            end
        end

        vds  = B4SOItype * V(di,si);
        vbs  = B4SOItype * V(b, si);
        vgs  = B4SOItype * V(gi,si);
        ves  = B4SOItype * V(e, si);
        vbp  = B4SOItype * V(b, p);
        vgp  = B4SOItype * V(gi,p);
        vsbs = B4SOItype * V(sb,si);
        vdbd = B4SOItype * V(db,di);
        vgms = B4SOItype * V(gm,si);

        /* determine DC current and derivatives */
        vbd = vbs - vds;
        vgd = vgs - vds;
        ved = ves - vds;

        /* v3.1 added for RF */
        vgmd = vgms - vds;
        /* v3.1 added for RF end */

        if (vds >= 0.0) begin   /* normal mode */
            B4SOImode = 1;
            Vds = vds;
            Vgs = vgs;
            Vbs = vbs;
            Vbd = vbd;
            Ves = ves;
            Vgd = vgd;

            wdios = pParam_B4SOIwdios;
            wdiod = pParam_B4SOIwdiod;

            agidl = pParam_B4SOIagidl;
            bgidl = pParam_B4SOIbgidl;
            cgidl = pParam_B4SOIcgidl;
            egidl = pParam_B4SOIegidl;
            rgidl = pParam_B4SOIrgidl;
            kgidl = pParam_B4SOIkgidl;
            fgidl = pParam_B4SOIfgidl;

            agisl = pParam_B4SOIagisl;
            bgisl = pParam_B4SOIbgisl;
            cgisl = pParam_B4SOIcgisl;
            egisl = pParam_B4SOIegisl;
            rgisl = pParam_B4SOIrgisl;
            kgisl = pParam_B4SOIkgisl;
            fgisl = pParam_B4SOIfgisl;

        end else begin   /* inverse mode */
            B4SOImode = -1;
            Vds = -vds;
            Vgs = vgd;
            Vbs = vbd;
            Vbd = vbs;
            Ves = ved;
            Vgd = vgs;

            wdios = pParam_B4SOIwdiod;
            wdiod = pParam_B4SOIwdios;

            agidl = pParam_B4SOIagisl;
            bgidl = pParam_B4SOIbgisl;
            cgidl = pParam_B4SOIcgisl;
            egidl = pParam_B4SOIegisl;
            rgidl = pParam_B4SOIrgisl;
            kgidl = pParam_B4SOIkgisl;
            fgidl = pParam_B4SOIfgisl;

            agisl = pParam_B4SOIagidl;
            bgisl = pParam_B4SOIbgidl;
            cgisl = pParam_B4SOIcgidl;
            egisl = pParam_B4SOIegidl;
            rgisl = pParam_B4SOIrgidl;
            kgisl = pParam_B4SOIkgidl;
            fgisl = pParam_B4SOIfgidl;
        end

        Vesfb = Ves - vfbb;
        Cbox = B4SOIcbox;

        /* Poly Gate Si Depletion Effect */
        T0 = here_B4SOIvfb + phi;
        if (B4SOImtrlMod == 0)
            epsgate = epssub;
        else
            epsgate = B4SOIepsrgate * `EPS0;

        if ((pParam_B4SOIngate > 1.0e18) && (pParam_B4SOIngate < 1.0e25)
                && (Vgs > T0)&& (epsgate!=0)) begin
            /* added to avoid the problem caused by ngate */
            T1 = 1.0e6 * `Charge_q * epsgate * pParam_B4SOIngate
                    / (B4SOIcox * B4SOIcox);
            T4 = sqrt(1.0 + 2.0 * (Vgs - T0) / T1);
            T2 = T1 * (T4 - 1.0);
            T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
            T7 = eggdep - T3 - 0.05;
            T6 = sqrt(T7 * T7 + 0.224);
            T5 = eggdep - 0.5 * (T7 + T6);
            Vgs_eff = Vgs - T5;
        end else begin
            Vgs_eff = Vgs;
        end

        if ((pParam_B4SOIngate > 1.0e18) && (pParam_B4SOIngate < 1.0e25)/* Bug fix # 25/26 Vgd_eff defined */
                && (Vgd > T0)&& (epsgate!=0)) begin
            /* added to avoid the problem caused by ngate */
            T1 = 1.0e6 * `Charge_q * epsgate * pParam_B4SOIngate
                    / (B4SOIcox * B4SOIcox);
            T4 = sqrt(1.0 + 2.0 * (Vgd - T0) / T1);
            T2 = T1 * (T4 - 1.0);
            T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
            T7 = eggdep - T3 - 0.05;
            T6 = sqrt(T7 * T7 + 0.224);
            T5 = eggdep - 0.5 * (T7 + T6);
            Vgd_eff = Vgd - T5;
        end else begin
            Vgd_eff = Vgd;
        end

        /* v4.1 for improved BT charge model, no poly depletion  */
        Vgs_eff2 = Vgs;
        /* end v4.1 for improved BT charge model */

        Leff = pParam_B4SOIleff;

        if ((SHMOD == 1) && (RTH0 != 0.0)) begin
            Vtm = `KboQ * DevTemp;
        end else begin
            Vtm = B4SOIvtm;
        end

        V0 = vbi - phi;

        /* begin of v3.0 block addition */
        /* B/S built-in potential lowering calculation */
        if (B4SOIsoiMod == 0) begin /* BSIMPD */ /* v3.2 */ // {
            Vbsmos = Vbs;
            Vbsmos_CV = Vbs;
        end else begin // }{
            /* soiMod = 1 or 2: adding FD module on top of BSIMPD */
            /* prepare Vbs0 & Vbs0mos for VthFD and VthFD_CV calculation */
            if (B4SOIfdMod == 0) begin /* v4.0 */
                T0 = -pParam_B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T1 = pParam_B4SOIdvbd0 * (exp(0.5*T0) + 2*exp(T0));
                T2 = T1 * (vbi - phi);
                T3 = 0.5 * pParam_B4SOIqsi / B4SOIcsi; /* v3.2 */
                Vbs0t = phi - T3 + pParam_B4SOIvbsa + T2;


                T0 = 1 + B4SOIcsi / Cbox;
                T3 = -pParam_B4SOIdk2b * pParam_B4SOIleff / pParam_B4SOIlitl;
                T5 = pParam_B4SOIk2b * (exp(0.5*T3) + 2*exp(T3));
                T1 = (pParam_B4SOIk1b - T5) / T0;
                T2 = T1 * Vesfb;
                T4 = 1.0/(1 + Cbox / B4SOIcsi);
                Vbs0 = T4 * Vbs0t + T2;


            end else begin
                T0 = 1.0/(B4SOIcsi + Cbox + pParam_B4SOIcdsbs);
                T1 = -pParam_B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T2 = pParam_B4SOIdvbd0 * (exp(0.5*T1) + 2*exp(T1));
                T3 = T2 * (Vds + pParam_B4SOIvsce);
                T4 = 0.5 * pParam_B4SOIqsi / B4SOIcsi;
                T5 = B4SOIcsi * T0 * (phi - T4 + pParam_B4SOIvbsa);
                T6 = pParam_B4SOIcdsbs * T0 * T3;
                Vbs0t = T5 + T6;

                T7 = Cbox * T0 * Vesfb;
                Vbs0 = Vbs0t + T7;
            end

            /* zero field body potential cal. */
            T1 = Vbs0t - Vbs0 - 0.005;
            T2 = sqrt(T1 * T1 + (2.5e-5));
            T3 = 0.5 * (T1 + T2);
            T4 = T3 * B4SOIcsi / pParam_B4SOIqsi; /* v3.2 */
            Vbs0mos = Vbs0 - 0.5 * T3 * T4;

            /* set the upper bound of Vbs0mos to be phi for square root calc. */
            T1 = phi - 0.02;
            T2 = T1 - Vbs0mos - 0.005;
            T3 = sqrt(T2 * T2 + 4.0 * 0.005);
            Vbs0mos = T1 - 0.5 * (T2 + T3);

            /* VthFD and VthFD_CV calculation */
            Phis = phi - Vbs0mos;
            sqrtPhis = sqrt(Phis);

            Xdep = Xdep0 * sqrtPhis / sqrtPhi;

            T3 = sqrt(Xdep);
            T0 = pParam_B4SOIdvt2 * Vbs0mos;
            if (T0 >= - 0.5) begin
                T1 = 1.0 + T0;
            end else begin
                /* Added to avoid any discontinuity problems caused by dvt2 */
                T4 = 1.0 / (3.0 + 8.0 * T0);
                T1 = (1.0 + 3.0 * T0) * T4;
            end
            lt1 = B4SOIfactor1 * T3 * T1;

            T0 = pParam_B4SOIdvt2w * Vbs0mos;
            if (T0 >= - 0.5) begin
                T1 = 1.0 + T0;
            end else begin
                /* Added to avoid any discontinuity problems caused by dvt2w */
                T4 = 1.0 / (3.0 + 8.0 * T0);
                T1 = (1.0 + 3.0 * T0) * T4;
            end
            ltw = B4SOIfactor1 * T3 * T1;

            T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                Theta0 = T1 * (1.0 + 2.0 * T1);
            end

            T2 = pParam_B4SOInfactor * epssub / Xdep;
            /* T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbseff
                    + pParam_B4SOIcdscd * Vds;*/
            /* v4.1 */
            T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbs0mos
                    + pParam_B4SOIcdscd * Vds;
            T4 = (T2 + T3 * Theta0 + pParam_B4SOIcit) / B4SOIcox;

            if (T4 >= -0.5) begin
                n = 1.0 + T4;
            end else begin /* avoid  discontinuity problems caused by T4 */
                T0 = 1.0 / (3.0 + 8.0 * T4);
                n = (1.0 + 3.0 * T4) * T0;
            end

            if (pParam_B4SOIdvtp0 > 0.0) begin /* v4.0 */
                T0 = -pParam_B4SOIdvtp1 * Vds;
                if (T0 < -`EXPL_THRESHOLD) begin
                    T2 = `MIN_EXPL;
                end else begin
                    T2 = exp(T0);
                end

                T3 = Leff + pParam_B4SOIdvtp0 * (1.0 + T2);
                T4 = Vtm * lln(Leff / T3);
                DITS_Sft = n * T4;
            end else begin
                DITS_Sft = 0.0;
            end

            B4SOIthetavth = pParam_B4SOIdvt0 * Theta0;
            Delt_vth = B4SOIthetavth * V0;

            T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltw;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                T2 = T1 * (1.0 + 2.0 * T1);
            end

            T0 = pParam_B4SOIdvt0w * T2;
            DeltVthw = T0 * V0;

            T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
            T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff
                    + pParam_B4SOIkt2 * Vbs0mos);

            /* v4.0 */
            /* DeltVthtemp = pParam_B4SOIk1eff * (T0 - 1.0) * sqrtPhi + T1 * TempRatioMinus1; */
            DeltVthtemp = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                            + T1 * TempRatioMinus1;
            /* v4.0 end */

            tmp2 = toxe * phi / (pParam_B4SOIweff + pParam_B4SOIw0);

            T3 = here_B4SOIeta0 + pParam_B4SOIetab * Vbs0mos;/*v4.0*/

            if (T3 < 1.0e-4) begin /* avoid  discontinuity problems caused by etab */
                T9 = 1.0 / (3.0 - 2.0e4 * T3);
                T3 = (2.0e-4 - T3) * T9;
            end
            DIBL_Sft = T3 * theta0vb0 * Vds;

            /* DIBL_Sft_CV due to introduction of ETA0CV and ETABCV */
            T3 = here_B4SOIeta0cv + pParam_B4SOIetabcv * Vbs0mos;

            if (T3 < 1.0e-4) begin /* avoid  discontinuity problems caused by etabcv */
                T9 = 1.0 / (3.0 - 2.0e4 * T3);
                T3 = (2.0e-4 - T3) * T9;
            end
            DIBL_Sft_CV = T3 * theta0vb0 * Vds;

            Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / Leff);

            /* 4.1 */
            T0 = exp(2.0 * pParam_B4SOIdvtp4 * Vds);
            DITS_Sft2 = pParam_B4SOIdvtp2factor * (T0-1) / (T0+1);

            VthFD = B4SOItype * here_B4SOIvth0
                    + (pParam_B4SOIk1ox * sqrtPhis
                    - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                    - here_B4SOIk2ox * Vbs0mos- Delt_vth - DeltVthw
                    + (pParam_B4SOIk3 + pParam_B4SOIk3b * Vbs0mos)
                    * tmp2 + DeltVthtemp - DIBL_Sft - DITS_Sft - DITS_Sft2;

            VthFD_CV = B4SOItype * here_B4SOIvth0
                    + (pParam_B4SOIk1ox * sqrtPhis
                    - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                    - here_B4SOIk2ox * Vbs0mos- Delt_vth - DeltVthw
                    + (pParam_B4SOIk3 + pParam_B4SOIk3b * Vbs0mos)
                    * tmp2 + DeltVthtemp - DIBL_Sft_CV - DITS_Sft - DITS_Sft2;


            /*VthFD_CV =VthFD + DIBL_Sft -DIBL_Sft_CV;*/

            /* VtgseffFD calculation for PhiFD */
            VtgsFD = VthFD - Vgs_eff;
            T10 = pParam_B4SOInofffd * Vtm;
            `DEXP((VtgsFD - pParam_B4SOIvofffd)/ T10, ExpVtgsFD)
            VtgseffFD = T10 * ln(1.0 + ExpVtgsFD);

            /* surface potential modeling at strong inversion: PhiON */
            VgstFD = Vgs_eff - VthFD;
            `DEXP((VgstFD - pParam_B4SOIvofffd)/ T10, ExpVgstFD)
            VgsteffFD = T10 * ln(1.0 + ExpVgstFD);

            /* T1 = pParam_B4SOImoinfd*pParam_B4SOIk1eff*Vtm*Vtm;  */
            T1 = pParam_B4SOImoinfd*pParam_B4SOIk1ox*Vtm*Vtm;
            T2 = VgsteffFD + 2*pParam_B4SOIk1eff*sqrt(phi);
            T0 = 1 + VgsteffFD * T2 / T1;
            PhiON = phi + Vtm * lln(T0) ;

           /* surface potential from subthreshold to inversion: PhiFD */
            T0 = B4SOIcox / (B4SOIcox + 1.0/(1.0/B4SOIcsi + 1.0/Cbox));
            PhiFD = PhiON - T0 * VtgseffFD;

          /* built-in potential lowering: Vbs0 */
            if (B4SOIfdMod == 0) begin /* v4.0 */
                T0 = -pParam_B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T1 = pParam_B4SOIdvbd0 * (exp(0.5*T0) + 2*exp(T0));
                T2 = T1 * (vbi - phi);
                T3 = 0.5 * pParam_B4SOIqsi / B4SOIcsi; /* v3.2 */
                Vbs0t = PhiFD - T3 + pParam_B4SOIvbsa + T2;

                T0 = 1 + B4SOIcsi / Cbox;
                T3 = -pParam_B4SOIdk2b * pParam_B4SOIleff / pParam_B4SOIlitl;
                T5 = pParam_B4SOIk2b * (exp(0.5*T3) + 2*exp(T3));
                T1 = (pParam_B4SOIk1b - T5) / T0;
                T2 = T1 * Vesfb;
                T0 = 1.0/(1 + Cbox / B4SOIcsi);
                Vbs0 = T0 * Vbs0t + T2;
          end else begin
                 /* v4.1 */
                T0 = 1.0/(B4SOIcsi + Cbox + pParam_B4SOIcdsbs);
                T1 = -pParam_B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T2 = pParam_B4SOIdvbd0 * (exp(0.5*T1) + 2*exp(T1));
                T3 = T2 * (Vds + pParam_B4SOIvsce);
                T4 = 0.5 * pParam_B4SOIqsi / B4SOIcsi;
                T5 = B4SOIcsi * T0 * (PhiFD - T4 + pParam_B4SOIvbsa);
                T6 = pParam_B4SOIcdsbs * T0 * T3;
                Vbs0t = T5 + T6;

                T7 = Cbox * T0 * Vesfb;
                Vbs0 = Vbs0t + T7;
          end

          /* set lower bound of Vbs (from SPICE) to Vbs0: Vbsitf (Vbs at back interface) */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* v3.1 ideal FD: Vbsitf is pinned at Vbs0 */
                Vbsitf = Vbs0 + `OFF_Vbsitf;
                Vbs = Vbs0 + `OFF_Vbsitf;
            end else begin
                /* soiMod = 1 */
                T1 = Vbs - (Vbs0 + `OFF_Vbsitf) - 0.01;
                T2 = sqrt(T1*T1 + 0.0001);
                Vbsitf = (Vbs0 + `OFF_Vbsitf) + 0.5 * (T1 + T2);
            end

         /* Based on Vbsitf, calculate zero-field body potential for MOS: Vbsmos */
            T1 = Vbs0t - Vbsitf - 0.005;
            T2 = sqrt(T1 * T1 + (2.5e-5));
            T3 = 0.5 * (T1 + T2);
            T4 = T3 * B4SOIcsi / pParam_B4SOIqsi; /* v3.2 */
            Vbsmos = Vbsitf - 0.5 * T3 * T4;

         /* VtgseffFD_CV, PhiON_CV, PhiFD_CV, Vbs0_CV, Vbsitf_CV, and Vbsmos_CV calculation by Pankaj in May 2012 */

          /* VtgseffFD_CV calculation for PhiFD_CV */
            VtgsFD_CV = VthFD_CV - Vgs_eff;
            T10 = pParam_B4SOInofffd * Vtm;
            `DEXP((VtgsFD_CV - pParam_B4SOIvofffd)/ T10, ExpVtgsFD_CV)
            VtgseffFD_CV = T10 * ln(1.0 + ExpVtgsFD_CV);

          /* surface potential modeling at strong inversion: PhiON_CV */
            VgstFD_CV = Vgs_eff - VthFD_CV;
            `DEXP((VgstFD_CV - pParam_B4SOIvofffd)/ T10, ExpVgstFD_CV)
            VgsteffFD_CV = T10 * ln(1.0 + ExpVgstFD_CV);

          /* T1 = pParam_B4SOImoinfd*pParam_B4SOIk1eff*Vtm*Vtm;*/
            T1 = pParam_B4SOImoinfd*pParam_B4SOIk1ox*Vtm*Vtm;
            T2 = VgsteffFD_CV + 2*pParam_B4SOIk1eff*sqrt(phi);
            T0 = 1 + VgsteffFD_CV * T2 / T1;
            PhiON_CV = phi + Vtm * lln(T0) ;

          /* surface potential from subthreshold to inversion: PhiFD_CV */
            T0 = B4SOIcox / (B4SOIcox + 1.0/(1.0/B4SOIcsi + 1.0/Cbox));
            PhiFD_CV = PhiON_CV - T0 * VtgseffFD_CV;

          /* built-in potential lowering: Vbs0_CV */
            if (B4SOIfdMod == 0) begin
                T0 = -pParam_B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T1 = pParam_B4SOIdvbd0 * (exp(0.5*T0) + 2*exp(T0));
                T2 = T1 * (vbi - phi);
                T3 = 0.5 * pParam_B4SOIqsi / B4SOIcsi; /* v3.2 */
                Vbs0t_CV=PhiFD_CV - T3 + pParam_B4SOIvbsa + T2;

                T0 = 1 + B4SOIcsi / Cbox;
                T3 = -pParam_B4SOIdk2b * pParam_B4SOIleff / pParam_B4SOIlitl;
                T5 = pParam_B4SOIk2b * (exp(0.5*T3) + 2*exp(T3));
                T1 = (pParam_B4SOIk1b - T5) / T0;
                T2 = T1 * Vesfb;
                T0 = 1.0/(1 + Cbox / B4SOIcsi);
                Vbs0_CV = T0 * Vbs0t_CV + T2;
            end else begin
                T0 = 1.0/(B4SOIcsi + Cbox + pParam_B4SOIcdsbs);
                T1 = -pParam_B4SOIdvbd1 * pParam_B4SOIleff / pParam_B4SOIlitl;
                T2 = pParam_B4SOIdvbd0 * (exp(0.5*T1) + 2*exp(T1));
                T3 = T2 * (Vds + pParam_B4SOIvsce);
                T4 = 0.5 * pParam_B4SOIqsi / B4SOIcsi;
                T5 = B4SOIcsi * T0 * (PhiFD_CV - T4 + pParam_B4SOIvbsa);
                T6 =pParam_B4SOIcdsbs * T0 * T3;
                Vbs0t_CV = T5 + T6;
                T7 = Cbox * T0 * Vesfb;
                Vbs0_CV = Vbs0t_CV + T7;
            end


            /* set lower bound of Vbs (from SPICE) to Vbs0_CV: Vbsitf_CV (Vbs at back interface) */
            if (B4SOIsoiMod == 2) begin
                Vbsitf_CV = Vbs0_CV + `OFF_Vbsitf;
                Vbs = Vbs0_CV + `OFF_Vbsitf;
            end else begin
                /* soiMod = 1 */
                T1 = Vbs - (Vbs0_CV + `OFF_Vbsitf) - 0.01;
                T2 = sqrt(T1*T1 + 0.0001);
                Vbsitf_CV = (Vbs0_CV + `OFF_Vbsitf) + 0.5 * (T1 + T2);
            end

            /* Based on Vbsitf_CV, calculate zero-field body potential for MOS: Vbsmos_CV */
            T1 = Vbs0t_CV - Vbsitf_CV - 0.005;
            T2 = sqrt(T1 * T1 + (2.5e-5));
            T3 = 0.5 * (T1 + T2);
            T4 = T3 * B4SOIcsi / pParam_B4SOIqsi; /* v3.2 */
            Vbsmos_CV = Vbsitf_CV - 0.5 * T3 * T4;

            /* Vbsmos/Vbsmos_CV should be used in MOS after some limiting (Vbseff) */

        end // }
        /* end of v3.0 block edition */

        /* v3.0 modification */

        /* T2 is Vbsmos limited above Vbsc=-5 */
        T0 = Vbsmos + 5 - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * (-5));
        T2 = (-5) + 0.5 * (T0 + T1);

        /* Vbsh is T2 limited below 1.5 */
        T0 = 1.5;
        T1 = T0 - T2 - 0.002;
        T3 = sqrt(T1 * T1 + 0.008 * T0);
        Vbsh = T0 - 0.5 * (T1 + T3);

        /* Vbseff is Vbsh limited to 0.95*phi */
        T0 = 0.95 * phi;
        T1 = T0 - Vbsh - 0.002;
        T2 = sqrt(T1 * T1 + 0.008 * T0);
        Vbseff = T0 - 0.5 * (T1 + T2);

        /* Vbsmos_CV, Vbsh_CV, and Vbseff_CV calculation by Pankaj in May 2012 */

        /* T2 is Vbsmos_CV limited above Vbsc=-5 */
        T0 = Vbsmos_CV + 5 - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * (-5));
        T2 = (-5) + 0.5 * (T0 + T1);

        /* Vbsh_CV is T2 limited below 1.5 */
        T0 = 1.5;
        T1 = T0 - T2 - 0.002;
        T3 = sqrt(T1 * T1 + 0.008 * T0);
        Vbsh_CV = T0 - 0.5 * (T1 + T3);

        /* Vbseff_CV is Vbsh_CV limited to 0.95*phi */
        T0 = 0.95 * phi;
        T1 = T0 - Vbsh_CV - 0.002;
        T2 = sqrt(T1 * T1 + 0.008 * T0);
        Vbseff_CV = T0 - 0.5 * (T1 + T2);

        /* end of v3.0 modification */

        /* Below all the variables refer to Vbseff */

        Phis = phi - Vbseff;
        sqrtPhis = sqrt(Phis);
        Xdep = Xdep0 * sqrtPhis / sqrtPhi;

        /* Calculate nstar v3.2 */
        B4SOInstar = B4SOIvtm / `Charge_q *
                (B4SOIcox + epssub / Xdep + pParam_B4SOIcit);

        /* Vth Calculation */
        T3 = sqrt(Xdep);

        T0 = pParam_B4SOIdvt2 * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2 */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        lt1 = B4SOIfactor1 * T3 * T1;

        T0 = pParam_B4SOIdvt2w * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2w */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        ltw = B4SOIfactor1 * T3 * T1;

        T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            Theta0 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            Theta0 = T1 * (1.0 + 2.0 * T1);
        end

        /* Calculate n */
        T2 = pParam_B4SOInfactor * epssub / Xdep;
        T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbseff
                + pParam_B4SOIcdscd * Vds;
        T4 = (T2 + T3 * Theta0 + pParam_B4SOIcit) / B4SOIcox;
        if (T4 >= -0.5) begin
            n = 1.0 + T4;
        end else begin
            /* avoid  discontinuity problems caused by T4 */
            T0 = 1.0 / (3.0 + 8.0 * T4);
            n = (1.0 + 3.0 * T4) * T0;
        end

        /* v4.0 DITS */
        if (pParam_B4SOIdvtp0 > 0.0) begin
            T0 = -pParam_B4SOIdvtp1 * Vds;
            if (T0 < -`EXPL_THRESHOLD) begin
                T2 = `MIN_EXPL;
            end else begin
                T2 = exp(T0);
            end

            T3 = Leff + pParam_B4SOIdvtp0 * (1.0 + T2);
            T4 = Vtm * lln(Leff / T3);
            DITS_Sft = n * T4;
        end else begin
            DITS_Sft = 0.0;
        end

        B4SOIthetavth = pParam_B4SOIdvt0 * Theta0;
        Delt_vth = B4SOIthetavth * V0;

        T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltw;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T2 = T1 * (1.0 + 2.0 * T1);
        end

        T0 = pParam_B4SOIdvt0w * T2;
        DeltVthw = T0 * V0;

        T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
        T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff
                + pParam_B4SOIkt2 * Vbseff);
        DeltVthtemp = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                + T1 * TempRatioMinus1; /* v4.0 */

        tmp2 = toxe * phi / (pParam_B4SOIweff + pParam_B4SOIw0);

        T3 = here_B4SOIeta0 + pParam_B4SOIetab * Vbseff;
        if (T3 < 1.0e-4) begin
            /* avoid  discontinuity problems caused by etab */
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end
        DIBL_Sft = T3 * theta0vb0 * Vds;

        Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / Leff);

        T9 =  2.2361 / sqrtPhi;
        sqrtPhisExt = sqrtPhis - T9 * (Vbsh - Vbseff);

        /* 4.1 */
        T0 = exp(2.0 * pParam_B4SOIdvtp4 * Vds);
        DITS_Sft2 = pParam_B4SOIdvtp2factor * (T0-1) / (T0+1);

        Vth = B4SOItype * here_B4SOIvth0
                + (pParam_B4SOIk1ox * sqrtPhisExt
                - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                - here_B4SOIk2ox * Vbseff- Delt_vth - DeltVthw
                +(pParam_B4SOIk3 + pParam_B4SOIk3b * Vbseff) * tmp2
                + DeltVthtemp - DIBL_Sft - DITS_Sft - DITS_Sft2;

        VTH = Vth;


       /* Calculation of Vth_CV for CV due to introduction of ETA0CV and ETABCV by Pankaj in May2012*/

        Phis_CV = phi - Vbseff_CV;
        sqrtPhis_CV = sqrt(Phis_CV);
        Xdep_CV = Xdep0 * sqrtPhis_CV / sqrtPhi;

        /* Calculate nstar v3.2 */
        B4SOInstar = B4SOIvtm / `Charge_q *
                (B4SOIcox + epssub / Xdep_CV + pParam_B4SOIcit);

        /* Vth_CV Calculation */

        T3 = sqrt(Xdep_CV);
        T0 = pParam_B4SOIdvt2 * Vbseff_CV;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2 */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        lt1_CV = B4SOIfactor1 * T3 * T1;

        T0 = pParam_B4SOIdvt2w * Vbseff_CV;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end else begin
            /* Added to avoid any discontinuity problems caused by dvt2w */
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
        end
        ltw_CV = B4SOIfactor1 * T3 * T1;

        T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1_CV;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            Theta0_CV = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            Theta0_CV = T1 * (1.0 + 2.0 * T1);
        end

        /* Calculate n_CV */

        T2 = pParam_B4SOInfactor * epssub / Xdep_CV;
        T3 = pParam_B4SOIcdsc + pParam_B4SOIcdscb * Vbseff_CV
                + pParam_B4SOIcdscd * Vds;
        T4 = (T2 + T3 * Theta0_CV + pParam_B4SOIcit) / B4SOIcox;
        if (T4 >= -0.5) begin
            n_CV = 1.0 + T4;
        end else begin
            /* avoid  discontinuity problems caused by T4 */
            T0 = 1.0 / (3.0 + 8.0 * T4);
            n_CV = (1.0 + 3.0 * T4) * T0;
        end

        /* v4.0 DITS */
        if (pParam_B4SOIdvtp0 > 0.0) begin
            T0 = -pParam_B4SOIdvtp1 * Vds;
            if (T0 < -`EXPL_THRESHOLD) begin
                T2 = `MIN_EXPL;
            end else begin
                T2 = exp(T0);
            end

            T3 = Leff + pParam_B4SOIdvtp0 * (1.0 + T2);
            T4 = Vtm * lln(Leff / T3);
            DITS_Sft_CV = n_CV * T4;
        end else begin
            DITS_Sft_CV = 0.0;
        end

        B4SOIthetavth = pParam_B4SOIdvt0 * Theta0_CV;
        Delt_vth_CV = B4SOIthetavth * V0;

        T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltw_CV;
        if (T0 > -`EXPL_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end else begin
            T1 = `MIN_EXPL;
            T2 = T1 * (1.0 + 2.0 * T1);
        end

        T0 = pParam_B4SOIdvt0w * T2;
        DeltVthw_CV = T0 * V0;

        T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
        T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff
                + pParam_B4SOIkt2 * Vbseff_CV);
        DeltVthtemp_CV = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                + T1 * TempRatioMinus1; /* v4.0 */

        tmp2_CV = toxe * phi / (pParam_B4SOIweff + pParam_B4SOIw0);

        /* Introduction of ETA0CV and ETABCV by Pankaj in May 2012*/

        T3 = here_B4SOIeta0cv + pParam_B4SOIetabcv * Vbseff_CV;
        if (T3 < 1.0e-4) begin
            /* avoid  discontinuity problems caused by ETABCV */
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end
        DIBL_Sft_CV = T3 * theta0vb0 * Vds;

        Lpe_Vb = sqrt(1.0 + pParam_B4SOIlpeb / Leff);

        T9 =  2.2361 / sqrtPhi;
        sqrtPhisExt_CV = sqrtPhis_CV - T9 * (Vbsh_CV - Vbseff_CV);

        T0 = exp(2.0 * pParam_B4SOIdvtp4 * Vds);
        DITS_Sft2 = pParam_B4SOIdvtp2factor * (T0-1) / (T0+1);

        Vth_CV = B4SOItype * here_B4SOIvth0
                + (pParam_B4SOIk1ox * sqrtPhisExt_CV
                - pParam_B4SOIk1eff * sqrtPhi) * Lpe_Vb
                - here_B4SOIk2ox * Vbseff_CV- Delt_vth_CV - DeltVthw_CV
                +(pParam_B4SOIk3 + pParam_B4SOIk3b * Vbseff_CV) * tmp2_CV
                + DeltVthtemp_CV - DIBL_Sft_CV - DITS_Sft_CV - DITS_Sft2;

        /* dVthzb_dT calculation */
        if ((B4SOIcapMod == 3) && (SHMOD == 1) && (RTH0 != 0.0)) begin
            T3zb = sqrt(Xdep0);
            lt1zb = B4SOIfactor1 * T3zb;
            ltwzb = B4SOIfactor1 * T3zb;

            T0 = -0.5 * pParam_B4SOIdvt1 * Leff / lt1zb;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                Theta0zb = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                Theta0zb = T1 * (1.0 + 2.0 * T1);
            end
            Delt_vthzb = pParam_B4SOIdvt0 * Theta0zb * V0;

            T0 = -0.5 * pParam_B4SOIdvt1w * pParam_B4SOIweff * Leff / ltwzb;
            if (T0 > -`EXPL_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 * (1.0 + 2.0 * T1);
            end else begin
                T1 = `MIN_EXPL;
                T2 = T1 * (1.0 + 2.0 * T1);
            end
            T0 = pParam_B4SOIdvt0w * T2;
            DeltVthwzb = T0 * V0;

            T0 = sqrt(1.0 + pParam_B4SOIlpe0 / Leff);
            T1 = (pParam_B4SOIkt1 + pParam_B4SOIkt1l / Leff);
            DeltVthtempzb = pParam_B4SOIk1ox * (T0 - 1.0) * sqrtPhi
                    + T1 * TempRatioMinus1;

            Vthzb = B4SOItype * here_B4SOIvth0
                    - Delt_vthzb - DeltVthwzb + pParam_B4SOIk3 * tmp2_CV
                    + DeltVthtempzb;
        end else
            Vthzb = 0;

        /* Effective Vgst (Vgsteff) Calculation */

        Vgst = Vgs_eff - Vth;

        T10 = n * Vtm; /* v4.0 */
        VgstNVt = pParam_B4SOImstar * Vgst / T10; /* v4.0 */
        ExpArg = (pParam_B4SOIvoff - (1- pParam_B4SOImstar) * Vgst)
                / T10;        /* v4.0 */

        /* MCJ: Very small Vgst */
        if (VgstNVt > `EXPL_THRESHOLD) begin
            Vgsteff = Vgst;
            ExpVgst = 0; // prevent hidden state
        end else if (ExpArg > `EXPL_THRESHOLD) begin
            T0 = (Vgst - pParam_B4SOIvoff) / (n * Vtm);
            ExpVgst = exp(T0);
            Vgsteff = Vtm * cdep0 / B4SOIcox * ExpVgst; /* v4.2 bug fix */
        end else begin
            ExpVgst = exp(VgstNVt);
            T1 = T10 * ln(1.0 + ExpVgst);
            dT2_dVg = -B4SOIcox / (Vtm * cdep0)
                    * exp(ExpArg) * (1 - pParam_B4SOImstar);
            T2 = pParam_B4SOImstar - T10 * dT2_dVg
                    / (1.0 - pParam_B4SOImstar);
            Vgsteff = T1 / T2;
        end
        Vgst2Vtm = Vgsteff + 2.0 * Vtm;
        B4SOIVgsteff = Vgsteff; /* v2.2.3 bug fix */

        /* v4.0 F-factor (degradation factor due to pocket implant) */
        if (pParam_B4SOIfprout <= 0.0) begin
            FP = 1.0;
        end else begin
            T9 = pParam_B4SOIfprout * sqrt(Leff) / Vgst2Vtm;
            FP = 1.0 / (1.0 + T9);
        end

        /* Calculate Effective Channel Geometry */
        T9 = sqrtPhis - sqrtPhi;
        Weff = pParam_B4SOIweff - (2.0 - B4SOInbc)
                * (pParam_B4SOIdwg * Vgsteff + pParam_B4SOIdwb * T9);

        if (Weff < 2.0e-8) begin /* to avoid the discontinuity problem due to Weff*/
            T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
            Weff = 2.0e-8 * (4.0e-8 - Weff) * T0;
        end

        if (B4SOIrdsMod == 1) begin   /* v4.0 */
            Rds = 0.0;
        end else begin
            T0 = pParam_B4SOIprwg * Vgsteff + pParam_B4SOIprwb * T9;
            if (T0 >= -0.9) begin
                Rds = rds0 * (1.0 + T0);
            end else begin
                /* to avoid the discontinuity problem due to prwg and prwb*/
                T1 = 1.0 / (17.0 + 20.0 * T0);
                Rds = rds0 * (0.8 + T0) * T1;
            end
        end
        /* v4.6 */
        if (B4SOIrdsMod == 2) begin
            Rds = B4SOIdrainResistance + Rds + B4SOIsourceResistance;
        end
        B4SOIrds = Rds / B4SOInf; /* Fix v4.31 bug in Thermal noise for TNOIMOD=0 */

        /* Calculate Abulk */

        if (pParam_B4SOIa0 == 0.0) begin // {
            Abulk = 1.0;
            Abulk0 = 1.0;
        end else begin // }{

            T10 = pParam_B4SOIketa * Vbsh;

            /*Old Limting of 1.0/(1.0 + T10) */
            /*
             if (T10 >= -0.9) begin
                 T11 = 1.0 / (1.0 + T10);
             end else begin // added to avoid the problems caused by Keta
                 T12 = 1.0 / (0.8 + T10);
                 T11 = (17.0 + 20.0 * T10) * T12;

            end
            */

           /*New Limting of 1.0/(1.0 + T10) on May 2012 by Pankaj*/

            if (T10 >=-0.5) begin
                T11 = 1.0 / (1.0 + T10);
            end else begin // added to avoid the problems caused by Keta

                T12=-1.0/((1.0 - 0.5)*(1.0 - 0.5));
                T13=1.0/((1.0 - 0.5))+T12*0.5;
                T11=T12*T10+T13;
            end


            /* v3.0 bug fix */
            T10 = phi + pParam_B4SOIketas;

            T13 = (Vbsh * T11) / T10;




            /* limit 1/sqrt(1-T13) to 6, starting at T13=0.96 */

            /*
              if (T13 < 0.96) begin
                T14 = 1 / sqrt(1-T13);
               end else begin
                T11 = 1.0 / (1.0 - 1.0593220339 * T13);
                T14 = (6.0169491525 - 6.3559322034 * T13) * T11;
              end
            */

          /*New Limting of 1.0/sqrt(1.0 - T13) in May 2012 by Pankaj*/
          /*Point around which limiting is done may be chnaged*/
           if (T13 < 0.50) begin
                T14 = 1.0 / sqrt(1.0-T13);
           end else begin
                T11=1.0/(2*(1-0.50)*sqrt(1-0.50));
                T12=(1/sqrt(1.0 - 0.50))-T11*0.50;
                T14=T11*T13+T12;
           end

            T10 = 0.5 * pParam_B4SOIk1ox * Lpe_Vb/ sqrt(phi + pParam_B4SOIketas);     /* v4.0 */
            T1 = T10 * T14;
            T9 = sqrt(pParam_B4SOIxj * Xdep);
            tmp1 = Leff + 2.0 * T9;
            T5 = Leff / tmp1;
            tmp2 = pParam_B4SOIa0 * T5;
            tmp3 = pParam_B4SOIweff + pParam_B4SOIb1;
            tmp4 = pParam_B4SOIb0 / tmp3;
            T2 = tmp2 + tmp4;
            T6 = T5 * T5;
            T7 = T5 * T6;

            Abulk0 = 1 + T1 * T2;


            T8 = pParam_B4SOIags * pParam_B4SOIa0 * T7;
            dAbulk_dVg = -T1 * T8;
            Abulk = Abulk0 + dAbulk_dVg * Vgsteff;
        end

        if (Abulk0 < 0.01) begin
            T9 = 1.0 / (3.0 - 200.0 * Abulk0);
            Abulk0 = (0.02 - Abulk0) * T9;
        end

        if (Abulk < 0.01) begin
            T9 = 1.0 / (3.0 - 200.0 * Abulk);
            Abulk = (0.02 - Abulk) * T9;
        end

        B4SOIAbulk = Abulk; /*v3.2 for noise */

        /* Calculation of Abulk0_CV by Pankaj in May 2012*/

        if (pParam_B4SOIa0 == 0.0) begin // {
            Abulk0_CV = 1.0;
        end else begin // }{

            T10 = pParam_B4SOIketa * Vbsh_CV;

            if (T10 >=-0.5) begin
                T11 = 1.0 / (1.0 + T10);
            end else begin /* added to avoid the problems caused by Keta */

                T12=-1.0/((1.0 - 0.5)*(1.0 - 0.5));
                T13=1.0/((1.0 - 0.5))+T12*0.5;
                T11=T12*T10+T13;
            end

            T10 = phi + pParam_B4SOIketas;
            T13 = (Vbsh_CV * T11) / T10;

           if (T13 < 0.50) begin
                T14 = 1.0 / sqrt(1.0-T13);
           end else begin
                T11=1.0/(2*(1-0.50)*sqrt(1-0.50));
                T12=(1/sqrt(1.0 - 0.50))-T11*0.50;
                T14=T11*T13+T12;
           end

            T10 = 0.5 * pParam_B4SOIk1ox * Lpe_Vb/ sqrt(phi + pParam_B4SOIketas);     /* v4.0 */
            T1 = T10 * T14;
            T9 = sqrt(pParam_B4SOIxj * Xdep_CV);
            tmp1 = Leff + 2.0 * T9;
            T5 = Leff / tmp1;
            tmp2 = pParam_B4SOIa0 * T5;
            tmp3 = pParam_B4SOIweff + pParam_B4SOIb1;
            tmp4 = pParam_B4SOIb0 / tmp3;
            T2 = tmp2 + tmp4;
            T6 = T5 * T5;
            T7 = T5 * T6;
            Abulk0_CV = 1 + T1 * T2;

        end

        if (Abulk0_CV < 0.01) begin
            T9 = 1.0 / (3.0 - 200.0 * Abulk0_CV);
            Abulk0_CV = (0.02 - Abulk0_CV) * T9;
        end

        /* Mobility calculation */
        if (B4SOImtrlMod) begin
            T14 = 2.0 * B4SOItype *(B4SOIphig - B4SOIeasub - 0.5 * Eg + 0.45);
            toxe_mob = B4SOIeot * B4SOIepsrsub / 3.9;            /* Bug fix #4 Jun 09 implementing Eeff correctly*/
        end else begin
            T14 = 0.0;
            toxe_mob = B4SOItox;                                        /* Bug fix #4 Jun 09 implementing Eeff correctly*/
        end
        if (B4SOImobMod == 1) begin
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = ua + uc * Vbseff;
            T3 = T0 / toxe_mob;                                            /* Bug fix #4 Jun 09 implementing Eeff correctly*/
            T5 = T3 * (T2 + ub * T3);
        end else if (B4SOImobMod == 2) begin                                   /* Bug fix #5 Jun 09 implementing Eeff correctly*/
            T5 = (Vgsteff -T14)/ toxe * (ua                                /* MobMod=2 does not use Eeff */
                    + uc * Vbseff + ub * (Vgsteff -T14)                /* 'toxe' keeps code consistent with BSIMSOI4.1 Manual*/
                    / toxe);
        end else if (B4SOImobMod == 3) begin
            /*  mobMod == 3  */
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = 1.0 + uc * Vbseff;
            T3 = T0 / toxe_mob;                                            /* Bug fix #4 Jun 09 implementing Eeff correctly*/
            T4 = T3 * (ua + ub * T3);
            T5 = T4 * T2;
        end else begin
            /*  mobMod == 4  */
            /*universal mobility*/
            T0 = (Vgsteff + B4SOIvtfbphi1)* 1.0e-8 / toxe/6.0;
            T1 = exp(pParam_B4SOIeu * lln(T0));
            T2 = ua + uc * Vbseff;

            /*Coulombic*/
            /* pParam_B4SOIucs = pParam_B4SOIucs * pow(TempRatio, pParam_B4SOIucste);    Bug# 21 Jul09*/
            /* pParam_B4SOIud = pParam_B4SOIud * pow(TempRatio, pParam_B4SOIud1) ;         Bug# 21 Jul09 */
            ucs = pParam_B4SOIucs * pow(TempRatio, pParam_B4SOIucste);
            ud = pParam_B4SOIud * pow(TempRatio, pParam_B4SOIud1) ;
            VgsteffVth = B4SOIvgsteffvth;

            /*T10 = exp(pParam_B4SOIucs * ln(0.5 + 0.5 * Vgsteff/VgsteffVth));*/
            /* T10 = exp(pParam_B4SOIucs * ln(1.0 +  Vgsteff/VgsteffVth));                Bug# 21 Jul09 */
            /* T11 =  pParam_B4SOIud/T10;                                                    Bug# 21 Jul09 */
            T10 = exp(ucs * lln(1.0 +  Vgsteff/VgsteffVth));                    /* Bug Fix # 21 Jul09*/
            T11 = ud/T10;                                                        /* Bug Fix # 21 Jul09*/
            T5 = T1 * T2 + T11;
        end
        if (T5 >= -0.8) begin
            Denomi = 1.0 + T5;
        end else begin
            /* Added to avoid the discontinuity problem caused by ua and ub*/
            T9 = 1.0 / (7.0 + 10.0 * T5);
            Denomi = (0.6 + T5) * T9;
        end

        ueff = u0temp / Denomi;
        B4SOIueff = ueff;

        /* Saturation Drain Voltage  Vdsat */
        WVCox = Weff * vsattemp * B4SOIcox;
        WVCoxRds = WVCox * Rds;

        Esat = 2.0 * vsattemp / ueff;
        EsatL = Esat * Leff;

        /* Sqrt() */
        if (pParam_B4SOIa1 == 0.0) begin
            Lambda = pParam_B4SOIa2;
        end else if (pParam_B4SOIa1 > 0.0) begin
            /* Added to avoid the discontinuity problem caused by a1 and a2 (Lambda) */
            T0 = 1.0 - pParam_B4SOIa2;
            T1 = T0 - pParam_B4SOIa1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * T0);
            Lambda = pParam_B4SOIa2 + T0 - 0.5 * (T1 + T2);
        end else begin
            T1 = pParam_B4SOIa2 + pParam_B4SOIa1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * pParam_B4SOIa2);
            Lambda = 0.5 * (T1 + T2);
        end

        B4SOIAbovVgst2Vtm = Abulk /Vgst2Vtm; /* v2.2.3 bug fix */

        if ((Rds == 0.0) && (Lambda == 1.0)) begin
            T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
            T3 = EsatL * Vgst2Vtm;
            Vdsat = T3 * T0;
        end else begin
            T9 = Abulk * WVCoxRds;
            T7 = Vgst2Vtm * T9;
            T6 = Vgst2Vtm * WVCoxRds;
            T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda);
            T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
            T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
            T3 = sqrt(T1 * T1 - 2.0 * T0 * T2);
            Vdsat = (T1 - T3) / T0;
        end
        VDSAT = Vdsat;

        /* Effective Vds (Vdseff) Calculation */
        T1 = Vdsat - Vds - pParam_B4SOIdelta;
        T2 = sqrt(T1 * T1 + 4.0 * pParam_B4SOIdelta * Vdsat);
        Vdseff = Vdsat - 0.5 * (T1 + T2);

        if (Vdseff > Vds)
            Vdseff = Vds; /* This code is added to fixed the problem
                             caused by computer precision when
                             Vds is very close to Vdseff. */
        diffVds = Vds - Vdseff;
        B4SOIVdseff = Vdseff; /* v2.2.3 bug fix */

        /* Calculate VAsat */
        tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
        T9 = WVCoxRds * Vgsteff;
        T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
        T9 = WVCoxRds * Abulk;
        T1 = 2.0 / Lambda - 1.0 + T9;
        Vasat = T0 / T1;

        /* Calculate VACLM */
        if ((pParam_B4SOIpclm > 0.0) && (diffVds > 1.0e-10)) begin
            T0 = 1.0 / (pParam_B4SOIpclm * Abulk * pParam_B4SOIlitl);
            T2 = Vgsteff / EsatL;
            T1 = Leff * (Abulk + T2);
            T9 = T0 * T1;
            VACLM = T9 * diffVds;
        end else begin
            VACLM = `MAX_EXPL;
        end

        /* Calculate VADIBL */
        if (thetaRout > 0.0) begin
            T8 = Abulk * Vdsat;
            T0 = Vgst2Vtm * T8;
            T1 = Vgst2Vtm + T8;
            T2 = thetaRout;
            VADIBL = (Vgst2Vtm - T0 / T1) / T2;

            T7 = pParam_B4SOIpdiblb * Vbseff;
            if (T7 >= -0.9) begin
                T3 = 1.0 / (1.0 + T7);
                VADIBL = VADIBL * T3;
            end else begin
                /* Added to avoid the discontinuity problem caused by pdiblcb */
                T4 = 1.0 / (0.8 + T7);
                T3 = (17.0 + 20.0 * T7) * T4;
                VADIBL = VADIBL * T3;
            end
        end else begin
            VADIBL = `MAX_EXPL;
        end

        /* v4.0 DITS */
        T0 = pParam_B4SOIpditsd * Vds;
        if (T0 > `EXPL_THRESHOLD) begin
            T1 = `MAX_EXPL;
        end else begin
            T1 = exp(T0);
        end
        if (pParam_B4SOIpdits > `MIN_EXPL) begin
            T2 = 1.0 + B4SOIpditsl * Leff;
            VADITS = (1.0 + T2 * T1) / pParam_B4SOIpdits;
            VADITS = VADITS * FP;
        end else begin
            VADITS = `MAX_EXPL;
        end

        /* Calculate VA */

        T8 = pParam_B4SOIpvag / EsatL;
        T9 = T8 * Vgsteff;
        if (T9 > -0.9) begin
            T0 = 1.0 + T9;
        end else begin
            /* Added to avoid the discontinuity problems caused by pvag */
            T1 = 1.0 / (17.0 + 20.0 * T9);
            T0 = (0.8 + T9) * T1;
        end

        tmp3 = VACLM + VADIBL;
        T1 = VACLM * VADIBL / tmp3;

        /* v4.0 adding DITS */
        tmp3 = T1 + VADITS;
        T2 = T1 * VADITS / tmp3;
        /* v4.0 */
        Va = Vasat + T0 * T2;

        /* Calculate Ids */
        CoxWovL = B4SOIcox * Weff / Leff;
        beta = ueff * CoxWovL;

        T0 = 1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm;
        fgche1 = Vgsteff * T0;

        T9 = Vdseff / EsatL;
        fgche2 = 1.0 + T9;

        gche = beta * fgche1 / fgche2;

        T0 = 1.0 + gche * Rds;
        T9 = Vdseff / T0;
        Idl = gche * T9;
        IdlovVdseff = gche / T0;

        T9 =  diffVds / Va;
        T0 =  1.0 + T9;
        Ids = Idl * T0 / B4SOInseg;

        B4SOIidovVds = IdlovVdseff * T0 / B4SOInseg;
        if (B4SOIidovVds < 1e-9) B4SOIidovVds = 1e-9;
        /* v4.0 bug fix */
        IdovVds = IdlovVdseff * T0 / B4SOInseg; /* v4.0 */

        /* v3.1 */
        if (B4SOIsoiMod != 2) begin /* v3.2 */ // {
            /*  calculate GISL/GIDL current  */
            /*4.1*/
            if (B4SOImtrlMod == 0)
                T0 = 3.0 * 3.9 / epsrox * toxe;
            else
                T0 = B4SOIepsrsub * toxe / epsrox;

            if (B4SOIgidlMod == 0) begin // {
                if (B4SOImtrlMod == 0)
                   T1 = (- Vds - Vgd_eff - egisl) / T0;
                else
                   T1 = (- Vds - Vgd_eff - egisl+pParam_B4SOIvfbsd) / T0;

                /* GISL */

                if ((agisl <= 0.0) || (bgisl <= 0.0) ||
                     (cgisl < 0.0)) begin
                     Igisl = 0.0;
                end else begin

                    T1 = hypsmooth(T1, 1.0E-2);
                    T2 = bgisl / (T1+1.0E-3);
                    Igisl = wdios * agisl * T1 * exp(-T2);

                    T4 = Vbs * Vbs;
                    T5 = -Vbs * T4;
                    T6 = cgisl + abs(T5) + 1.0E-9;
                    T7 = hypsmooth(T5 / T6, 1.0E-6) - 1.0E-6;
                    Igisl = Igisl * T7;

                end
                /* End of GISL */

                if (B4SOImtrlMod == 0)
                    T1 = (Vds - Vgs_eff - egidl) / T0;
                else
                    T1 = (Vds - Vgs_eff - egidl+pParam_B4SOIvfbsd) / T0;

                /* GIDL */

                if ((agidl <= 0.0) || (bgidl <= 0.0)||
                    (cgidl < 0.0)) begin
                    Igidl = 0.0;
                end else begin

                    T1 = hypsmooth(T1, 1.0E-2);
                    T2 = bgidl / (T1+1.0E-3);
                    Igidl = wdiod * agidl * T1 * exp(-T2);

                    T4 = Vbd * Vbd;
                    T5 = -Vbd * T4;
                    T6 = cgidl + abs(T5) + 1.0E-9;
                    T7 = hypsmooth(T5 / T6, 1.0E-6) - 1.0E-6;
                    Igidl = Igidl * T7;

                end
                /* End of GIDL*/

            end else begin // }{

                if (B4SOImtrlMod == 0)
                   T1 = (-Vds - rgisl*Vgd_eff - egisl) / T0;         /* Bug # 26 Jul09*/
                else
                   T1 = (-Vds - rgisl*Vgd_eff - egisl+pParam_B4SOIvfbsd) / T0;        /* Bug # 26 Jul09*/

                /* GISL */
                if ((agisl <= 0.0) || (bgisl <= 0.0)||
                    (cgisl < 0.0)  ) begin
                    Igisl = 0.0;
                end else begin
                    T1 = hypsmooth(T1, 1.0E-2);
                    T2 = bgisl / (T1+1.0E-3);
                    Igisl = wdios * agisl * T1 * exp(-T2);
                    T4 = Vbs - fgisl;
                    if (T4 >= -1.0/`EXPL_THRESHOLD)
                        T5 = -kgisl * `EXPL_THRESHOLD;
                    else
                        T5 = kgisl/T4;
                    T6 = exp(T5);
                    Igisl = Igisl * T6;

                end
                /* End of GISL */

                if (B4SOImtrlMod == 0)
                    T1 = (Vds - rgidl*Vgs_eff - egidl) / T0;
                else
                    T1 = (Vds - rgidl*Vgs_eff - egidl+pParam_B4SOIvfbsd) / T0;

                /* GIDL */
                if ((agidl <= 0.0) || (bgidl <= 0.0)||
                    (cgidl < 0.0)) begin
                    Igidl = 0.0;
                end else begin
                    T1 = hypsmooth(T1, 1.0E-2);
                    T2 = bgidl / (T1+1.0E-3);
                    Igidl = wdiod * agidl * T1 * exp(-T2);
                    T4 = Vbd - fgidl;
                    if (T4 >= -1.0/`EXPL_THRESHOLD)
                        T5 = -kgidl * `EXPL_THRESHOLD;
                    else
                        T5 = kgidl/T4;
                    T6 = exp(T5);
                    Igidl = Igidl * T6;
                end
                /* End of GIDL */

            end // }

            /* calculate diode and BJT current */
            WsTsi = pParam_B4SOIwdios * B4SOItsi;
            WdTsi = pParam_B4SOIwdiod * B4SOItsi;

            NVtm1 = Vtm * pParam_B4SOIndiode;
            T0 = vsbs / NVtm1; /* v4.0 */
            `DEXP(T0, ExpVbsNVtm)

            NVtm1 = Vtm * pParam_B4SOIndioded; /* v4.0 drain side */
            T0 = vdbd / NVtm1; /* v4.0 */
            `DEXP(T0, ExpVbdNVtm)

            /* Ibs1: diffusion current */
            if (jdifs == 0) begin
                Ibs1 = 0;
            end else begin
                T0 = WsTsi * jdifs;
                Ibs1 = T0 * (ExpVbsNVtm - 1);
            end

            /* Ibd1: diffusion current */
            if (jdifd == 0) begin
                Ibd1 = 0;
            end else begin
                T0 = WdTsi * jdifd;
                Ibd1 = T0 * (ExpVbdNVtm - 1);
            end

            /* Ibs2:recombination/trap-assisted tunneling current */

            if (jrecs == 0) begin
                Ibs2 = 0;
            end else begin
                /* forward bias */
                NVtmf = Vtm00 * pParam_B4SOInrecf0
                        * (1 + pParam_B4SOIntrecf * (TempRatio - 1));
                NVtmr = Vtm00 * pParam_B4SOInrecr0
                        * (1 + pParam_B4SOIntrecr * (TempRatio - 1));
                T0 = vsbs / NVtmf; /* v4.0 */
                `DEXP(T0,T10)

                /* reverse bias */
                if ((pParam_B4SOIvrec0 - vsbs) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vsbs / NVtmr * pParam_B4SOIvrec0 * T1;
                    //T11 = -exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/
                    `DEXP(T0,T11)
                    T11=-T11;
                end else begin
                    T1 = 1 / (pParam_B4SOIvrec0 - vsbs);
                    T0 = -vsbs / NVtmr * pParam_B4SOIvrec0 * T1;
                    `DEXP(T0, T11)
                    T11 = -T11;
                end
                T3 = WsTsi * jrecs;
                Ibs2 = T3 * (T10 + T11);
            end

            if (jrecd == 0) begin
                Ibd2 = 0;
            end else begin
                NVtmf = Vtm00 * pParam_B4SOInrecf0d
                        * (1 + pParam_B4SOIntrecf * (TempRatio - 1));
                NVtmr = Vtm00 * pParam_B4SOInrecr0d
                        * (1 + pParam_B4SOIntrecr * (TempRatio - 1));
                T0 = vdbd / NVtmf;
                `DEXP(T0,T10)

                if ((pParam_B4SOIvrec0d - vdbd) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vdbd / NVtmr * pParam_B4SOIvrec0d * T1;
                    //T11 = -exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/
                    `DEXP(T0,T11)
                    T11=-T11;
                end else begin
                    T1 = 1 / (pParam_B4SOIvrec0d - vdbd);
                    T0 = -vdbd / NVtmr * pParam_B4SOIvrec0d * T1;
                    `DEXP(T0, T11)
                    T11 = - T11;
                end
                T3 = WdTsi * jrecd;
                Ibd2 = T3 * (T10 + T11);
            end

            /* Ibs3/Ibd3:  recombination current in neutral body */
            WTsi = pParam_B4SOIweff / B4SOInseg * B4SOItsi;
            if (jbjts == 0.0 && jbjtd == 0.0) begin // {
                Ibs3 = 0.0;
                Ibd3 = 0.0;
                Ibsdif = 0;
                Ibddif = 0;
                Ic = 0.0;
            end else begin // }{
                /* high level injection of source side */
                Ehlis = Ahlis * (ExpVbsNVtm - 1);
                if (Ehlis < 1e-5) begin
                    Ehlis = 0;
                    EhlisFactor = 1;
                end else begin
                    EhlisFactor = 1.0 / sqrt(1 + Ehlis);
                end

                /* high level injection of drain side */
                Ehlid = Ahlid * (ExpVbdNVtm - 1);
                if (Ehlid < 1e-5) begin
                    Ehlid = 0;
                    EhlidFactor = 1;
                end else begin
                    EhlidFactor = 1.0 / sqrt(1 + Ehlid);
                end

                /* v3.1.1 bug fix for Ibjt(L) discontinuity */
                T0 = 1 - pParam_B4SOIarfabjt;

                Ien = WTsi * jbjts * pParam_B4SOIlratio;
                T1 = T0 * Ien;
                Ibs3 = T1 * (ExpVbsNVtm - 1) * EhlisFactor;

                Ien = WTsi * jbjtd * pParam_B4SOIlratio;
                T1 = T0 * Ien;
                Ibd3 = T1 * (ExpVbdNVtm - 1) * EhlidFactor;

                /* effective diffusion current for capacitance calcu. */
                Iendif = WTsi * jbjts * pParam_B4SOIlratiodif;
                Ibsdif = Iendif * (ExpVbsNVtm - 1) * EhlisFactor;

                Iendif = WTsi * jbjtd * pParam_B4SOIlratiodif;
                Ibddif = Iendif * (ExpVbdNVtm - 1) * EhlidFactor;

                /* Ic: Bjt collector current */
                if (B4SOIbjtoff == 1) begin
                    Ic = 0.0;
                end else begin
                    /* second order effects */
                    T0 = 1 + (vsbs + vdbd) / pParam_B4SOIvearly;
                    T1 = Ehlis + Ehlid;
                    T3 = sqrt(T0 * T0 + 4 * T1);
                    T2 = (T0 + T3) / 2.0;
                    if (T2 < 0.1) begin
                        E2ndFactor = 10.0;
                    end else begin
                        E2ndFactor = 1.0 / T2;
                    end

                    T0 = pParam_B4SOIarfabjt * Ien;    /* here Ien refers to the drain side to simplify the code */
                    Ic = T0 * (ExpVbsNVtm - ExpVbdNVtm) * E2ndFactor;
                end
            end // }

            /* Ibs4/Ibd4 : tunneling */
            if (jtuns == 0 && jtund == 0) begin
                Ibd4 = 0;
                Ibs4 = 0;
            end else begin
                NVtm2 = Vtm00 * pParam_B4SOIntun;
                if ((pParam_B4SOIvtun0 - vsbs) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vsbs / NVtm2 * pParam_B4SOIvtun0 * T1;
                    //T1 = exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/
                    `DEXP(T0,T1)
                    T3 = WsTsi * jtuns;
                    Ibs4 = T3 * (1- T1);
                end else begin
                    T1 = 1 / (pParam_B4SOIvtun0 - vsbs);
                    T0 = -vsbs / NVtm2 * pParam_B4SOIvtun0 * T1;
                    `DEXP(T0, T1)
                    T3 = WsTsi * jtuns;
                    Ibs4 =  T3 * (1- T1);
                end

                NVtm2 = Vtm00 * pParam_B4SOIntund;
                if ((pParam_B4SOIvtun0d - vdbd) < 1e-3) begin
                    /* v2.2.3 bug fix */
                    T1 = 1e3;
                    T0 = -vdbd / NVtm2 * pParam_B4SOIvtun0d * T1;
                    //T1 = exp(T0);
                    /* exp(T0) limited by Pankaj, Jun 2012*/
                    `DEXP(T0,T1)
                    T3 = WdTsi * jtund;
                    Ibd4 = T3 * (1- T1);
                end else begin
                    T1 = 1 / (pParam_B4SOIvtun0d - vdbd);
                    T0 = -vdbd / NVtm2 * pParam_B4SOIvtun0d * T1;
                    `DEXP(T0, T1)
                    T3 = WdTsi * jtund;
                    Ibd4 =  T3 * (1- T1);
                end
            end

            Ibs = Ibs1 + Ibs2 + Ibs3 + Ibs4;
            Ibd = Ibd1 + Ibd2 + Ibd3 + Ibd4;

        end else begin // }{
            /* v3.1 soiMod=2: ideal FD */
            Igidl = 0.0;
            Igisl = 0.0;
            Ibs = 0;
            Ibd = 0;
            Ibsdif = 0;
            Ibddif = 0;
            Ic = 0.0;

        end // }

        /* v3.0: gate-tunneling */
        if ((B4SOIigbMod != 0) || (B4SOIigcMod != 0)) begin // {
            Vgb = Vgs_eff - Vbs;

            /* Calculate Vox first */
            Vfb = B4SOItype * here_B4SOIvth0  /* v4.0 */
                    - phi - pParam_B4SOIk1eff * sqrtPhi;

            T3 = Vfb - Vgs_eff + Vbs - `DELTA_3;

            if (Vfb <= 0.0) begin
                T0 = sqrt(T3 * T3 - 4.0 * `DELTA_3 * Vfb);
            end else begin
                T0 = sqrt(T3 * T3 + 4.0 * `DELTA_3 * Vfb);
            end

            Vfbeff = Vfb - 0.5 * (T3 + T0);

            Voxacc = Vfb - Vfbeff;
            if (Voxacc < 0.0) begin
                Voxacc = 0.0;
            end

            if (pParam_B4SOIk1ox == 0.0) /* v4.0 */ begin
                Voxdepinv = 0.0;
            end else begin
                T0 = Vgs_eff - Vgsteff - Vfbeff - Vbseff;
                if (T0 < 0.0) begin
                    T1 = T0/pParam_B4SOIk1ox;
                end else begin
                    T1 = pParam_B4SOIk1ox/2*(-1 + sqrt(1 +
                            4*T0/pParam_B4SOIk1ox/pParam_B4SOIk1ox));
                end

                Voxdepinv = Vgs_eff - (T1*T1 + Vbs) - Vfb;
            end
        end else begin // }{
            Vfb = 0;
            Vgb = 0;
            Voxacc = 0;
            Voxdepinv = 0;
        end // }

        /* gate-channel tunneling component */
        if (B4SOIigcMod) begin // {
            T0 = Vtm * pParam_B4SOInigc;
            VxNVt = (Vgs_eff - B4SOItype * here_B4SOIvth0)
                    / T0; /* Vth instead of Vth0 may be used */
            if (VxNVt > `EXPL_THRESHOLD) begin
                Vaux = Vgs_eff - B4SOItype * here_B4SOIvth0;
            end else if (VxNVt < -`EXPL_THRESHOLD) begin
                Vaux = T0 * ln(1.0 + `MIN_EXPL);
            end else begin   ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end

            T2 = Vgs_eff * Vaux;

            T11 = pParam_B4SOIAechvb;
            T12 = pParam_B4SOIBechvb;
            T3 = pParam_B4SOIaigc * pParam_B4SOIcigc
                    - pParam_B4SOIbigc;
            T4 = pParam_B4SOIbigc * pParam_B4SOIcigc;
            T5 = T12 * (pParam_B4SOIaigc + T3 * Voxdepinv
                    - T4 * Voxdepinv * Voxdepinv);

            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end

            Igc = T11 * T2 * T6;

            T7 = -pParam_B4SOIpigcd * Vds;
            T8 = T7 * T7 + 2.0e-4;
            if (T7 > `EXPL_THRESHOLD) begin
                T9 = `MAX_EXPL;
            end else if (T7 < -`EXPL_THRESHOLD) begin
                T9 = `MIN_EXPL;
            end else begin
                T9 = exp(T7);
            end

            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;
            Igcs = Igc * T10;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            Igcd = Igc * T10;

            T0 = vgs - pParam_B4SOIvfbsd;
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgs * vgs_eff;
            T13 = pParam_B4SOIAechvbEdges;
            T14 = pParam_B4SOIAechvbEdged;
            T12 = pParam_B4SOIBechvbEdge;
            T3 = pParam_B4SOIaigsd * pParam_B4SOIcigsd
                    - pParam_B4SOIbigsd;
            T4 = pParam_B4SOIbigsd * pParam_B4SOIcigsd;
            T5 = T12 * (pParam_B4SOIaigsd + T3 * vgs_eff
                    - T4 * vgs_eff * vgs_eff);
            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end
            Igs = T13 * T2 * T6;

            T0 = vgd - pParam_B4SOIvfbsd;
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgd * vgd_eff;
            T5 = T12 * (pParam_B4SOIaigsd + T3 * vgd_eff
                    - T4 * vgd_eff * vgd_eff);
            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end
            Igd = T14 * T2 * T6;

        end else begin // }{
            Igd = 0.0;
            Igs = 0.0;
            Igcd = 0.0;
            Igcs = 0.0;
        end // }

        /* gate-body tunneling component */
        if ((B4SOIigbMod!= 0) && (B4SOIsoiMod != 2)) begin /* v3.2 */ // {
            /* v3.1: the Igb calculation is skipped for the ideal FD mode */
            OxideRatio = pParam_B4SOIoxideRatio;

            Vox = Voxdepinv;
            /* Voxeff is Vox limited below Voxh */
            T0 = B4SOIvoxh;
            T1 = T0 - Vox - B4SOIdeltavox;
            T3 = sqrt(T1 * T1 + 4*B4SOIdeltavox * T0);
            Voxeff = T0 - 0.5 * (T1 + T3);
            Vox = Voxeff;

            T0 = (Vox - B4SOIebg)/B4SOIvevb;

            `DEXP(T0, T1) /* T1=exp(T0), T2=dT1_dT0 */

            Vaux = B4SOIvevb * ln(1 + T1);

            if (B4SOIvgb1 != 0) begin
                T0 = 1 - Vox / B4SOIvgb1;
            end else begin
                T0 = 1;
            end

            if (T0 < 0.01) begin
                T0 = 0.01;
            end

            T1 = (Leff * Weff / B4SOInseg + B4SOIagbcpd/B4SOInf)
                    * agb1 * OxideRatio;

            T2 = bgb1 * B4SOItoxqm;
            T3 = pParam_B4SOIalphaGB1;
            T4 = pParam_B4SOIbetaGB1;

            T6 = T2*(T3 - T4 * Vox) / T0;

            `DEXP(T6, T5) /* T5=exp(T6), T7=dT5_dT6 */
            Igb1 = T1 * Vgb * Vaux * T5;

            Vox = Voxacc;
            /* Voxeff is Vox limited below Voxh */
            T0 = B4SOIvoxh;
            T1 = T0 - Vox - B4SOIdeltavox;
            T3 = sqrt(T1 * T1 + 4*B4SOIdeltavox * T0);
            Voxeff = T0 - 0.5 * (T1 + T3);
            Vox = Voxeff;

            T0 = (-Vgb+(Vfb))/B4SOIvecb;

            `DEXP(T0, T1) /* T1=exp(T0), T2=dT1_dT0 */

            Vaux = B4SOIvecb* ln(1 + T1);

            if (B4SOIvgb2 != 0) begin
                T0 = 1 - Vox / B4SOIvgb2;
            end else begin
                T0 = 1;
            end

            if (T0 < 0.01) begin
                T0 = 0.01;
            end

            T1 = (Leff * Weff / B4SOInseg + B4SOIagbcpd/B4SOInf)
                    * agb2 * OxideRatio;

            T2 = bgb2 * B4SOItoxqm;
            T3 = pParam_B4SOIalphaGB2;
            T4 = pParam_B4SOIbetaGB2;

            T6 = T2*(T3 - T4 * Vox) / T0;

            `DEXP(T6, T5) /* T5=exp(T6), T7=dT5_dT6 */
            Igb2 = T1 * Vgb * Vaux * T5;

            /* Igb1 dominates in inversion region, while Igb2 dominates in accumulation */
            /* v2.2.3 bug fix for residue at low Vgb */
            if (Vgb >= 0) begin
                Igb = Igb1;
            end else begin
                Igb = Igb2;
            end
            Vfb2 = Vfb + eggbcp2;
        end else begin // }{
            Igb = 0.0;
        end // }
        B4SOIig = B4SOItype * Igb;

        /* v4.1 */
        /* gate tunneling component in the AGBCP2 region */
        /* Vfb2 = Vfb + 1.12;   Bug fix #18 Jul09 Code moved to 4370 where Vfb definition is valid*/

        if ((B4SOIigbMod!= 0) && (B4SOIsoiMod != 2) &&
            (B4SOIbodyMod != 0) && (B4SOIagbcp2 > 0) &&
            (vgp < Vfb2)) begin
            /* v4.1: the Igb2_agbcp2 calculation is skipped for the ideal FD mode or if there is no "p" node */
            T0 = vgp - Vfb2;

            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgp_eff = 0.5 * (-T0 + T1 - 1.0e-2);

            /* T11=A*  T12=B* */
            T11 = (B4SOItype == `NMOS) ? agbc2n : agbc2p;
            T12 = (B4SOItype == `NMOS) ? bgbc2n : bgbc2p;  /* v4.3.1 -Tanvir */

            T2 = vgp * vgp_eff;
            T3 = pParam_B4SOIaigbcp2 * pParam_B4SOIcigbcp2
                    - pParam_B4SOIbigbcp2;
            T4 = pParam_B4SOIbigbcp2 * pParam_B4SOIcigbcp2;
            T5 = (-T12) * B4SOItoxqm * (pParam_B4SOIaigbcp2
                    + T3 * vgp_eff - T4 * vgp_eff * vgp_eff);
            if (T5 > `EXPL_THRESHOLD) begin
                T6 = `MAX_EXPL;
            end else if (T5 < -`EXPL_THRESHOLD) begin
                T6 = `MIN_EXPL;
            end else begin
                T6 = exp(T5);
            end
            /* T11 = T11 * B4SOIagbcp2 * pParam_B4SOIoxideRatio/B4SOInf */ /* B4SOInf removed by Pankaj in May 2012 */
            T11 = T11 * B4SOIagbcp2 * pParam_B4SOIoxideRatio;
            Ig_agbcp2 = T11 * T2 * T6;
        end else begin
            Ig_agbcp2 = 0.0;
        end
        B4SOIigp = B4SOItype * Ig_agbcp2;

        /* end of gate-body tunneling */
        /* end of v3.0 gate-tunneling  */

        /* v3.1 */
        if (B4SOIsoiMod != 2) begin /* v3.2 */ // {
            if (B4SOIiiiMod == 0 ) begin // {
                /* calculate substrate current Iii */
                if (pParam_B4SOIalpha0 <= 0.0) begin
                    Iii = 0.0;
                end else begin
                    Vdsatii0 = pParam_B4SOIvdsatii0 * (1 + B4SOItii * (TempRatio-1.0))
                            - pParam_B4SOIlii / Leff;

                    /* Calculate VgsStep */
                    T0 = pParam_B4SOIesatii * Leff; /* v3.0 bug fix: T0 is dimensionless (i.e., scaled by 1V) */
                    T1 = pParam_B4SOIsii0 * T0 / (1.0 + T0);

                    T0 = 1 / (1 + pParam_B4SOIsii1 * Vgsteff);
                    T3 = T0 + pParam_B4SOIsii2;
                    T2 = Vgst * T3;
                    T3 = 1 / (1 + pParam_B4SOIsiid * Vds);
                    VgsStep = T1 * T2 * T3;
                    Vdsatii = Vdsatii0 + VgsStep;
                    Vdiff = Vds - Vdsatii;

                    T0 = pParam_B4SOIbeta2 + pParam_B4SOIbeta1 * Vdiff
                            + pParam_B4SOIbeta0 * Vdiff * Vdiff;
                    if (T0 < 1e-5) begin
                        T0 = 1e-5;
                    end

                    if ((T0 < Vdiff / `EXPL_THRESHOLD) && (Vdiff > 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MAX_EXPL;
                    end else if ((T0 < -Vdiff / `EXPL_THRESHOLD) && (Vdiff < 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MIN_EXPL;
                    end else begin
                        Ratio = pParam_B4SOIalpha0 * exp(Vdiff / T0);
                    end

                    /* Avoid too high ratio */
                    if (Ratio > 10.0) begin
                        Ratio = 10.0;
                    end

                    T0 = Ids + pParam_B4SOIfbjtii * B4SOImode * Ic;
                    Iii = Ratio * T0;

                end
            end else begin // }{
                 /*new Iii model*/
                /*Idsmosfet part*/
                if (pParam_B4SOIalpha0 <= 0.0) begin
                    Idsmosfet = 0.0;

                end else begin
                    Vdsatii0 = pParam_B4SOIvdsatii0 * (1 + B4SOItii * (TempRatio-1.0))
                            - pParam_B4SOIlii / Leff;

                    /* Calculate VgsStep */
                    T0 = pParam_B4SOIesatii * Leff; /* v3.0 bug fix: T0 is dimensionless (i.e., scaled by 1V) */
                    T1 = pParam_B4SOIsii0 * T0 / (1.0 + T0);

                    T0 = 1 / (1 + pParam_B4SOIsii1 * Vgsteff);
                    T3 = T0 + pParam_B4SOIsii2;
                    T2 = Vgst * T3;
                    T3 = 1 / (1 + pParam_B4SOIsiid * Vds);
                    VgsStep = T1 * T2 * T3;
                    Vdsatii = Vdsatii0 + VgsStep;
                    Vdiff = Vds - Vdsatii;

                    T0 = pParam_B4SOIbeta2 + pParam_B4SOIbeta1 * Vdiff
                            + pParam_B4SOIbeta0 * Vdiff * Vdiff;
                    if (T0 < 1e-5) begin
                        T0 = 1e-5;
                    end

                    if ((T0 < Vdiff / `EXPL_THRESHOLD) && (Vdiff > 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MAX_EXPL;
                    end else if ((T0 < -Vdiff / `EXPL_THRESHOLD) && (Vdiff < 0.0)) begin
                        Ratio = pParam_B4SOIalpha0 * `MIN_EXPL;
                    end else begin
                        Ratio = pParam_B4SOIalpha0 * exp(Vdiff / T0);
                    end

                    /* Avoid too high ratio */
                    if (Ratio > 10.0) begin
                        Ratio = 10.0;
                    end

                    T0 = Ids;
                    Idsmosfet = Ratio * T0;
                end
                /*New BJT part*/

                T0 = (pParam_B4SOIcbjtii + pParam_B4SOIebjtii * Leff)/Leff;

                Vbci = pParam_B4SOIvbci*(1.0+B4SOItvbci*(TempRatio-1.0));
                if (B4SOImode > 0)
                    T1 = Vbci - vdbd;
                else
                    T1 = Vbci - vsbs;

                T2 = pParam_B4SOImbjtii -1.0;

                if (T1 <= 0.0)
                    T3 = 0.0;
                else
                    T3 = -pParam_B4SOIabjtii * pow(T1,T2);

                if (T3> `EXPL_THRESHOLD)
                    T4 = `MAX_EXPL;
                else if (T3 < -`EXPL_THRESHOLD)
                    T4 = `MIN_EXPL;
                else
                    T4 = exp(T3);

                Iiibjt = T0 * B4SOImode * Ic * T1 * T4;

                /*Total Iii*/
                Iii = Idsmosfet + Iiibjt;

            end // }

            /* Current through body resistor */
            /* Current going out is +ve */
            if ((B4SOIbodyMod == 0) || (B4SOIbodyMod == 2)) begin
                Ibp = 0;
            end else begin /* B4SOIbodyMod == 1 */
                if (pParam_B4SOIrbody < 1e-3) begin
                    if (B4SOIrbodyext <= 1e-3)
                        T0 = 1.0 / 1e-3;
                    else
                        T0 = 1.0 / B4SOIrbodyext;
                    Ibp = vbp * T0;
                end else begin
                    Ibp = vbp / (pParam_B4SOIrbody + B4SOIrbodyext);
                end
            end

        end else begin // }{
             /* v3.1 soiMod=2: ideal FD */
            Iii = 0.0;
            Ibp = 0.0;
        end // }
        /* v3.1 */

        /* v3.1 for RF */
        /* Calculate Rg */
        if (B4SOIrgateMod >1) begin
            T9 = pParam_B4SOIxrcrg2 * B4SOIvtm;
            T0 = T9 * beta;
            B4SOIgcrg = pParam_B4SOIxrcrg1 * (T0 + IdovVds);

            if (B4SOInf != 1.0) begin
                B4SOIgcrg = B4SOIgcrg * B4SOInf;
            end

            if (B4SOIrgateMod == 2) begin
                T11 = B4SOIgrgeltd + B4SOIgcrg;
                B4SOIgcrg = B4SOIgrgeltd * B4SOIgcrg / T11;
            end

            /* v3.1 added Rg for RF end */
        end else begin
            B4SOIgcrg = 0;
        end

        /* v4.0 Calculate bias-dependent external S/D resistance */
        if (B4SOIrdsMod == 1) begin  /* 2013.enh5, 2015.enh1 */ /* Updated in v4.6 */
            Rds = 0.0;
            /* Rs(V) */
            T0 = vgs - pParam_B4SOIvfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgs_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + pParam_B4SOIprwg * vgs_eff;
            T1 = -pParam_B4SOIprwb * vbs;
            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = rs0 * 0.5;
            Rs = rswmin + T3 * T4 + B4SOIsourceResistance;

            /* Rd(V) */
            T0 = vgd - pParam_B4SOIvfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgd_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + pParam_B4SOIprwg * vgd_eff;
            T1 = -pParam_B4SOIprwb * vbd;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);
            T4 = rd0 * 0.5;
            Rd = rdwmin + T3 * T4 + B4SOIdrainResistance;

        end else begin
            Rs = B4SOIsourceResistance;
            Rd = B4SOIdrainResistance;

        end
        if (B4SOIrdsMod == 2) begin /* 2013.enh5, 2015.enh1 */ /* v4.6 */
            Rs = 0;
            Rd = 0;
        end

        /* Calculate Qinv for Noise analysis */
        T1 = Vgsteff * (1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm);
        B4SOIqinv = -B4SOIcox * pParam_B4SOIweff
                * B4SOInf * Leff * T1; /* v4.0 */

        if (B4SOInf != 1) begin
            Ids = Ids * B4SOInf;
            Ic  = Ic  * B4SOInf;
            B4SOIidovVds = B4SOIidovVds * B4SOInf;

            Ibs = Ibs * B4SOInf;
            Ibd = Ibd * B4SOInf;

            Igcs = Igcs * B4SOInf;
            Igcd = Igcd * B4SOInf;

            Igs = Igs * B4SOInf;
            Igd = Igd * B4SOInf;

            Iii = Iii * B4SOInf;

            B4SOIig = B4SOIig * B4SOInf;

            Igidl = Igidl * B4SOInf;
            Igisl = Igisl * B4SOInf;
        end

        B4SOIgm = B4SOItype * ddx(Ids, V(gi));
        if (B4SOImode > 0)
            B4SOIgds = B4SOItype * ddx(Ids, V(di));
        else
            B4SOIgds = B4SOItype * ddx(Ids, V(si));
        B4SOIgmbs = B4SOItype * ddx(Ids, V(b));


        /*  Begin CV (charge) model  */
        CoxWL  = B4SOIcox * (pParam_B4SOIweffCV
                / B4SOInseg * B4SOInf /* v4.0 */
                * pParam_B4SOIleffCV + B4SOIagbcp);
        CoxWLb = B4SOIfbody * B4SOIcox
                * (pParam_B4SOIweffCV / B4SOInseg
                * B4SOInf    /* v4.0 */
                * pParam_B4SOIleffCVb + B4SOIagbcp);

        /* v4.1 for improved BT charge model */
        CoxWL2  = B4SOIcox * B4SOIagbcp2;
        CoxWLb2 = B4SOIfbody * B4SOIcox * B4SOIagbcp2;
        /* end v4.1 */

        /* v3.2 Separate VgsteffCV with noff */

        /* New Vgst(Vgs_eff -Vth_CV) and n_CV introduced by Pankaj in May 2012 */

        Vgst=Vgs_eff-Vth_CV;

        T10 = n_CV*Vtm;
        VgstNVt = pParam_B4SOImstar * Vgst / T10;

                /*noff = n * pParam_B4SOInoff*Vtm;*/
        noff = n_CV * pParam_B4SOInoff * Vtm;
        noff2 = n_CV * pParam_B4SOInoff2 * Vtm;   /* 2015enh2 */       /* v4.6 */
        if (B4SOIvgstcvMod == 0) begin
            if ((VgstNVt > -`EXPL_THRESHOLD) && (VgstNVt < `EXPL_THRESHOLD)) begin
                //ExpVgst = ExpVgst * ExpVgst;            //------Navid, Cadence
                ExpVgst = exp(VgstNVt) * exp(VgstNVt);    //------Navid, Cadence
                ExpVgst = ExpVgst * exp( -(pParam_B4SOIdelvt / noff));
                Vgsteff = noff * lln(1.0 + ExpVgst);
                if (B4SOIagbcp2 > 0) begin
                    ExpVgst2 = ExpVgst * exp(-eggbcp2 / noff2 / (Vtm*Vtm));          /* 2015enh2 */    /* v4.6 */
                    Vgsteff2 = noff2 * lln(1.0 + ExpVgst2);
                end
            end
        end else if (B4SOIvgstcvMod == 1) begin
                    /*VgstNvt is limited by Pankaj in May 2012*/
                    if ((VgstNVt > -`EXPL_THRESHOLD) && (VgstNVt < `EXPL_THRESHOLD)) begin
                        ExpVgst = exp(VgstNVt/(pParam_B4SOImstar * pParam_B4SOInoff));
                        ExpVgst = ExpVgst * exp( -(pParam_B4SOIdelvt / noff));
                        Vgsteff = noff * lln(1.0 + ExpVgst);
                    /* v4.6 */
                        if (B4SOIagbcp2 > 0) begin
                          ExpVgst2 = ExpVgst * exp(-eggbcp2 / noff2 / (Vtm*Vtm));          /* 2015enh2 */   /* v4.6 */
                          Vgsteff2 = noff2 * lln(1.0 + ExpVgst2);
                        end
                    end

        end else begin
            VgstNVt = pParam_B4SOImstarcv * (Vgst - pParam_B4SOIdelvt) / noff;
            ExpArg = (pParam_B4SOIvoffcv -
                    (1 - pParam_B4SOImstarcv) * (Vgst - pParam_B4SOIdelvt))/ noff;

            /* MCJ: Very small Vgst */
            if (VgstNVt > `EXPL_THRESHOLD) begin
                Vgsteff = Vgst - pParam_B4SOIdelvt;
            end else if (ExpArg > `EXPL_THRESHOLD) begin
                T0 = (Vgst - pParam_B4SOIdelvt - pParam_B4SOIvoffcv) / noff;
                ExpVgst = exp(T0);
                Vgsteff = Vtm * cdep0 / B4SOIcox * ExpVgst;
            end else begin
                ExpVgst = exp(VgstNVt);
                T1 = noff * lln(1.0 + ExpVgst);
                dT2_dVg = -B4SOIcox / (Vtm * cdep0)
                        * exp(ExpArg) * (1 - pParam_B4SOImstarcv);
                T2 = pParam_B4SOImstarcv - noff * dT2_dVg
                        / (1.0 - pParam_B4SOImstarcv);
                Vgsteff = T1 / T2;
            end

            if (B4SOIagbcp2 > 0) begin
                VgstNVt2 = pParam_B4SOImstarcv * (Vgst - pParam_B4SOIdelvt - eggbcp2) / noff2;
                ExpArg2 = (pParam_B4SOIvoffcv -
                        (1 - pParam_B4SOImstarcv) * (Vgst - pParam_B4SOIdelvt - eggbcp2))/ noff2;

                /* MCJ: Very small Vgst */
                if (VgstNVt2 > `EXPL_THRESHOLD) begin
                    Vgsteff2 = Vgst - pParam_B4SOIdelvt - eggbcp2;
                end else if (ExpArg2 > `EXPL_THRESHOLD) begin
                    T0 = (Vgst - pParam_B4SOIdelvt - pParam_B4SOIvoffcv - eggbcp2) / noff2;         /* 2015enh2 */ /* v4.6 */
                    ExpVgst2 = exp(T0);
                    Vgsteff2 = Vtm * cdep0 / B4SOIcox * ExpVgst2;
                end else begin
                    ExpVgst2 = exp(VgstNVt2);
                    T1 = noff2 * lln(1.0 + ExpVgst2);
                    dT2_dVg = -B4SOIcox / (Vtm * cdep0)
                            * exp(ExpArg2) * (1 - pParam_B4SOImstarcv);
                    T2 = pParam_B4SOImstarcv - noff2 * dT2_dVg
                            / (1.0 - pParam_B4SOImstarcv);
                    Vgsteff2 = T1 / T2;
                end
            end
        end
        /* v3.2 */

        /* New Vth (Vth_CV), sqrtPhis (sqrtPhis_CV), Vbseff (Vbseff_CV) */
        Vth=Vth_CV;
        sqrtPhis=sqrtPhis_CV;
        Vbseff=Vbseff_CV;


        if (B4SOIcapMod == 2) begin // {
            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qac0 = 0.0;
                Qsub0 = 0.0;
            end else begin
                /* soiMod = 0 or 1 */

                Vfb = Vth - phi - pParam_B4SOIk1eff * sqrtPhis + pParam_B4SOIdelvt;

                V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3_SOI;
                if (Vfb <= 0.0) begin
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3_SOI * Vfb);
                end else begin
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3_SOI * Vfb);
                end
                Vfbeff = Vfb - 0.5 * (V3 + T0);

                Qac0 = CoxWLb * (Vfbeff - Vfb);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                             /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' Jun 09 */
                    ( B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    Vfb2 = Vfb + eggbcp2;
                    DELTA_3_SOI2 = `DELTA_3_SOI;
                    V3 = Vfb2 - Vgs_eff2 + Vbseff - DELTA_3_SOI2;
                    if (Vfb2 <= 0.0) begin
                        T0 = sqrt(V3 * V3 - 100.0 * DELTA_3_SOI2 * Vfb2);
                    end else begin
                        T0 = sqrt(V3 * V3 + 100.0 * DELTA_3_SOI2 * Vfb2);
                    end
                    Vfbeff2 = Vfb2 - 0.5 * (V3 + T0);
                    Qac0 = Qac0 + CoxWLb2 * (Vfbeff2 - Vfb2);
                end
                /* end v4.1 */
                T0 = 0.5 * pParam_B4SOIk1ox;
                T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
                if (pParam_B4SOIk1ox == 0.0) begin
                    T1 = 0.0;
                end else if (T3 < 0.0) begin
                    T1 = T0 + T3 / pParam_B4SOIk1ox;
                end else begin
                    T1 = sqrt(T0 * T0 + T3);
                end

                Qsub0 = CoxWLb * pParam_B4SOIk1ox * (T1 - T0); /* 4.1 bug fix */
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                            /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T3 = Vgs_eff2- Vfbeff2 - Vbseff - Vgsteff2;
                    if (T3 < 0.0) begin
                        T1 = T0 + T3 / pParam_B4SOIk1ox;
                    end else begin
                        T1 = sqrt(T0 * T0 + T3);
                    end
                    Qsub0 = Qsub0 + CoxWLb2 * pParam_B4SOIk1ox * (T1 - T0);
                end
            end
            /* v3.1 */

            AbulkCV = Abulk0 * pParam_B4SOIabulkCVfactor;

            VdsatCV = Vgsteff / AbulkCV;

            V4 = VdsatCV - Vds - `DELTA_4;
            T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
            VdseffCV = VdsatCV - 0.5 * (V4 + T0);

            /* v4.1 */
            if (B4SOIagbcp2 > 0) begin
                VdsatCV2 = Vgsteff2 / AbulkCV;
                V4 = VdsatCV2 - Vds - `DELTA_4;
                T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV2);
                VdseffCV2 = VdsatCV2 - 0.5 * (V4 + T0);
            end
            /* end v4.1 */

            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                qbulk = 0;
            end else begin
                T0 = AbulkCV * VdseffCV;
                T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1e-20);
                T2 = VdseffCV / T1;
                T3 = T0 * T2;
                T7 = 1.0 - AbulkCV;
                qbulk = CoxWLb * T7 * (0.5 * VdseffCV - T3);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T0 = AbulkCV * VdseffCV2;
                    T1 = 12.0 * (Vgsteff2 - 0.5 * T0 + 1e-20);
                    T2 = VdseffCV2 / T1;
                    T3 = T0 * T2;
                    T7 = 1.0 - AbulkCV;
                    qbulk = qbulk + CoxWLb2 * T7 * (0.5 * VdseffCV2 - T3);
                end
                /* end  v4.1 */
            end
            /* v3.1 */

            /* Total inversion charge */
            T0 = AbulkCV * VdseffCV;
            T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1e-20);
            /* T2 = VdseffCV / T1;
            */
            T2 = T0 / T1;
            T3 = T0 * T2;

            /* qinv = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);
            */
            qinv = CoxWL * (Vgsteff - 0.5 * T0 + T3);

            B4SOIqinv = -qinv; /* for noise v3.2 */

            /* v4.1 */
            if ((B4SOIsoiMod != 2) &&                /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                T02 = AbulkCV * VdseffCV2;
                T12 = 12.0 * (Vgsteff2 - 0.5 * T02 + 1e-20);
                T2 = T02 / T12;
                T3 = T02 * T2;

                qinv = qinv + CoxWL2 * (Vgsteff2 - 0.5 * T02 + T3);
                B4SOIqinv = -qinv;
            end
            /* end v4.1 */
            /* Inversion charge partitioning into S / D */
            if (B4SOIxpart > 0.5) begin
                /* 0/100 Charge partition model */
                T1 = T1 + T1;
                qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0
                        - T0 * T0 / T1);

                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&             /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T12 = T12 + T12;
                    qsrc = qsrc -CoxWL2 * (0.5 * Vgsteff2 + 0.25 * T02- T02 * T02 / T12);
                end
                /* end v4.1 */

            end else if (B4SOIxpart < 0.5) begin
                /* 40/60 Charge partition model */
                T1 = T1 / 12.0;
                T2 = 0.5 * CoxWL / (T1 * T1);
                T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff
                        * (Vgsteff - 4.0 * T0 / 3.0))
                        - 2.0 * T0 * T0 * T0 / 15.0;
                qsrc = -T2 * T3;
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&         /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 >0) begin
                    T12 = T12 /12.0;
                    T2 = 0.5 * CoxWL2 / (T12 * T12);
                    T3 = Vgsteff2 * (2.0 * T02 * T02 / 3.0 + Vgsteff2
                            * (Vgsteff2 - 4.0 * T02 / 3.0))
                            - 2.0 * T02 * T02 * T02 / 15.0;
                    qsrc2 = -T2 * T3;
                    qsrc = qsrc + qsrc2;
                end

                /* end v4.1 */
            end else begin
                /* 50/50 Charge partition model */
                qsrc = - 0.5 * (qinv + qbulk);
            end

            /* Backgate charge */
            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qe1 = 0;
            end else begin
                /* soiMod = 0 or 1 */
                CboxWL = pParam_B4SOIkb1 * B4SOIfbody * Cbox
                        * (pParam_B4SOIweffCV / B4SOInseg * B4SOInf
                        * pParam_B4SOIleffCVbg + B4SOIaebcp);
                Qe1 = CboxWL * (Vesfb - Vbs);
            end
            /* v3.1 */

            qgate = qinv + Qac0 + Qsub0;
            qbody = (qbulk - Qac0 - Qsub0 - Qe1);
            qsub = Qe1;
            qdrn = -(qgate + qsrc + qbody + qsub);

            /* End of if capMod == 2 */
        end else if (B4SOIcapMod == 3) begin // }{

            if (B4SOImtrlMod == 0)
                Cox = 3.453133e-11 / B4SOItoxp;
            else
                Cox = epsrox * `EPS0 / B4SOItoxp;

            CoxWL = CoxWL * toxe / B4SOItoxp;
            CoxWLb = CoxWLb * B4SOItox/ B4SOItoxp;
            Tox = 1.0e8*B4SOItoxp;

            /* v4.1 */
            if (B4SOIagbcp2 > 0) begin
                CoxWL2 = CoxWL2 * B4SOItox / B4SOItoxp;
                CoxWLb2 = CoxWLb2 * B4SOItox / B4SOItoxp;
            end
            /* end v4.1 */

            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qac0 = 0.0;
                Qsub0 = 0.0;
                Vfbzb = 0;
            end else begin
                /* soiMod = 0 or 1 */
                if ((SHMOD == 1) && (RTH0 != 0.0)) begin
                    Vfbzb = Vthzb - phi - pParam_B4SOIk1eff * sqrtPhi
                            + pParam_B4SOIdelvt;
                end else begin
                    Vfbzb = B4SOIvfbzb + pParam_B4SOIdelvt;
                end

                V3 = Vfbzb - Vgs_eff + Vbseff - `DELTA_3;
                if (Vfbzb <= 0.0) begin
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfbzb);
                end else begin
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfbzb);
                end
                Vfbeff = Vfbzb - 0.5 * (V3 + T0);

                /* v4.1 */
                if (B4SOIagbcp2 >0) begin
                    Vfbzb2 = Vfbzb + eggbcp2;
                    V3 = Vfbzb2 - Vgs_eff2 + Vbseff - `DELTA_3;
                    if (Vfbzb2 <= 0.0) begin                                /* Bug fix #12 Jun 09 Vfbzb changed to Vfbzb2 */
                        T0 = sqrt(V3 * V3 - 100.0 * `DELTA_3 * Vfbzb2);    /* Value of 100 instead of 4 is used to make transition smooth*/
                    end else begin
                        T0 = sqrt(V3 * V3 + 100.0 * `DELTA_3 * Vfbzb2);
                    end
                    Vfbeff2 = Vfbzb2 - 0.5 * (V3 + T0);
                end
                /* end v4.1 */

                T0 = (Vgs_eff - Vbseff - Vfbzb) / Tox;

                tmp = T0 * pParam_B4SOIacde;
                if ((-`EXPL_THRESHOLD < tmp) && (tmp < `EXPL_THRESHOLD)) begin
                    Tcen = pParam_B4SOIldeb * exp(tmp);
                end else if (tmp <= -`EXPL_THRESHOLD) begin
                    Tcen = pParam_B4SOIldeb * `MIN_EXPL;
                end else begin
                    Tcen = pParam_B4SOIldeb * `MAX_EXPL;
                end

                /*LINK = 1.0e-3 * (toxe - B4SOIdtoxcv);  v2.2.3 */
                LINK = 1.0e-3 * B4SOItoxp;
                V3 = pParam_B4SOIldeb - Tcen - LINK;
                V4 = sqrt(V3 * V3 + 4.0 * LINK * pParam_B4SOIldeb);
                Tcen = pParam_B4SOIldeb - 0.5 * (V3 + V4);
                /* v4.1 small Tcen can introduce numerical issue  */
                if (Tcen < 1e-15) begin
                    Tcen = 1e-15;
                end  /* end */

                /* v4.1 */
                if (B4SOIagbcp2 > 0) begin
                    T0 = (Vgs_eff2 - Vbseff - Vfbzb2) / Tox;

                    tmp = T0 * pParam_B4SOIacde;
                    if ((-`EXPL_THRESHOLD < tmp) && (tmp < `EXPL_THRESHOLD)) begin
                        Tcen2 = pParam_B4SOIldeb * exp(tmp);
                    end else if (tmp <= -`EXPL_THRESHOLD) begin
                        Tcen2 = pParam_B4SOIldeb * `MIN_EXPL;
                    end else begin
                        Tcen2 = pParam_B4SOIldeb * `MAX_EXPL;
                    end

                    V3 = pParam_B4SOIldeb - Tcen2 - LINK;
                    V4 = sqrt(V3 * V3 + 4.0 * LINK * pParam_B4SOIldeb);
                    Tcen2 = pParam_B4SOIldeb - 0.5 * (V3 + V4);
                    if (Tcen2 < 1e-15) begin
                        Tcen2 = 1e-15;
                    end
                end
                /* end v4.1 */

                Ccen = epssub / Tcen;
                T2 = Cox / (Cox + Ccen);
                Coxeff = T2 * Ccen;
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    /* Ccen2 = `EPSSI / Tcen2; */                /* Bug Fix # 30 Jul09 `EPSSI changed to epssub */
                    Ccen2 = epssub / Tcen2;
                    T2 = Cox / (Cox + Ccen2);
                    Coxeff2 = T2 * Ccen2;
                end
                /* end v4.1 */
                CoxWLcenb = CoxWLb * Coxeff / Cox;
                /* v4.1 */
                if (B4SOIagbcp2 > 0) begin
                    CoxWLcenb2 = CoxWLb2 * Coxeff2 / Cox;
                end
                /* end v4.1 */
                Qac0 = CoxWLcenb * (Vfbeff - Vfbzb);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    Qac02 = CoxWLcenb2 * (Vfbeff2 - Vfbzb2);
                    Qac0 = Qac0 + Qac02;
                end
                /* end v4.1 */

                T0 = 0.5 * pParam_B4SOIk1ox;
                T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
                if (pParam_B4SOIk1ox == 0.0) begin
                    T1 = 0.0;
                end else if (T3 < 0.0) begin
                    T1 = T0 + T3 / pParam_B4SOIk1ox;
                end else begin
                    T1 = sqrt(T0 * T0 + T3);
                end

                Qsub0 = CoxWLcenb * pParam_B4SOIk1ox * (T1 - T0);

                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&             /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T3 = Vgs_eff2 - Vfbeff2 - Vbseff - Vgsteff2;
                    if (pParam_B4SOIk1ox == 0.0) begin
                        T1 = 0.0;
                    end else if (T3 < 0.0) begin
                        T1 = T0 + T3 / pParam_B4SOIk1ox;
                    end else begin
                        T1 = sqrt(T0 * T0 + T3);
                    end

                    Qsub02 = CoxWLcenb2 * pParam_B4SOIk1ox * (T1 - T0);
                    Qsub0 = Qsub0 + Qsub02;
                end
                /* end v4.1 */

            end
            /* v3.1 */

            /* Gate-bias dependent delta Phis begins */
            if (pParam_B4SOIk1ox <= 0.0) begin
                Denomi = 0.25 * pParam_B4SOImoin * Vtm;
                T0 = 0.5 * pParam_B4SOIsqrtPhi;
            end else begin
                Denomi = pParam_B4SOImoin * Vtm
                        * pParam_B4SOIk1ox * pParam_B4SOIk1ox;
                T0 = pParam_B4SOIk1ox * pParam_B4SOIsqrtPhi;
            end
            T1 = 2.0 * T0 + Vgsteff;

            DeltaPhi = Vtm * lln(1.0 + T1 * Vgsteff / Denomi);

            /* v4.1 */
            if (B4SOIagbcp2 > 0) begin
                T1 = 2.0 * T0 + Vgsteff2;
                DeltaPhi2 = Vtm * lln(1.0 + T1 * Vgsteff2 / Denomi);
            end
            /* end v4.1 */
            /* End of delta Phis */

            /* v3.1.1 bug fix for discontinuity */
            T3 = 4.0 * (Vth - Vfbzb - phi);
            T2 = sqrt(T3*T3 + 0.0001);
            T4 = 0.5 * (T3 + T2);

            Tox = Tox + Tox;
            T0 = (Vgsteff + T4) / Tox;
            //tmp = exp(0.7 * ln(T0)); /*BDOS added in May 2012 by Pankaj*/
            tmp = exp(B4SOIbdos*0.7 * lln(T0));
            T1 = 1.0 + tmp;
            /*Tcen = 1.9e-9 / T1;*//*ADOS added in May 2012 by Pankaj*/
            Tcen = B4SOIados*1.9e-9 / T1;
            Ccen = epssub / Tcen;
            T0 = Cox / (Cox + Ccen);
            Coxeff = T0 * Ccen;
            CoxWLcen = CoxWL * Coxeff / Cox;
            CoxWLcenb = CoxWLb * Coxeff / Cox;
            /* v4.1 */
            if ((B4SOIsoiMod != 2) &&              /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                T3 = 4.0 * (Vth + eggbcp2 - Vfbzb2 - phi);
                T2 = sqrt(T3*T3 + 0.0001);
                T4 = 0.5 * (T3 + T2);
                /* Tox = Tox + Tox; */
                T0 = (Vgsteff2 + T4) / Tox;
                /*tmp = exp(0.7 * ln(T0));*//*BDOS added on May 2012 by Pankaj*/
                tmp = exp(B4SOIbdos*0.7 * lln(T0));
                T1 = 1.0 + tmp;
                /*Tcen2 = 1.9e-9 / T1;*//*ADOS added on May 2012 by Pankaj*/
                Tcen2 = B4SOIados*1.9e-9 / T1;
                /*Ccen2 = `EPSSI / Tcen2;*//*Bug Fix # 30 Jul09*/
                Ccen2 = epssub/ Tcen2;
                T0 = Cox / (Cox + Ccen2);
                Coxeff2 = T0 * Ccen2;
                CoxWLcen2 = CoxWL2 * Coxeff2 / Cox;
                CoxWLcenb2 = CoxWLb2 * Coxeff2 / Cox;
            end
            /* end v4.1 */

            T1 = Vgsteff - DeltaPhi;
            AbulkCV = Abulk0 * pParam_B4SOIabulkCVfactor;
            VdsatCV = T1 / AbulkCV;
            V4 = VdsatCV - Vds - `DELTA_4;
            T0 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
            VdseffCV = VdsatCV - 0.5 * (V4 + T0);

            T0 = AbulkCV * VdseffCV;
            T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
            T3 = T0 / T2;

            qinv = CoxWLcen * (T1 - T0 * (0.5 - T3));
            qinoi = qinv;
            qgate = qinv;

            /* v4.1 */
            if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                T12 = Vgsteff2 - DeltaPhi2;
                VdsatCV2 = T12 / AbulkCV;
                V4 = VdsatCV2 - Vds - `DELTA_4;
                T02 = sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV2);
                VdseffCV2 = VdsatCV2 - 0.5 * (V4 + T02);

                T02 = AbulkCV * VdseffCV2;
                T22 = 12.0 * (T12 - 0.5 * T02 + 1.0e-20);
                T3 = T02 / T22;
                T7 = CoxWLcen2 * (T12 - T02 * (0.5 - T3));
                qinv = qinv + T7;
                qinoi = qinv;
                qgate = qinv;
            end
            /* end v4.1 */

            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                qbulk = 0;
            end else begin
                /* soiMod = 0 or 1 */
                T7 = 1.0 - AbulkCV;
                qbulk = CoxWLcenb * T7 * (0.5 * VdseffCV - T0 * VdseffCV / T2);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                    /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin

                    qbulk2 = CoxWLcenb2 * T7 * (0.5 * VdseffCV2 - T02 * VdseffCV2 / T22);
                    qbulk = qbulk + qbulk2;
                end

                /* end v4.1 */

            end
            /* v3.1 */

            if (B4SOIxpart > 0.5) begin   /* 0/100 partition */
                qsrc = -CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 * T0 * T0 / T2);
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    qsrc2 = -CoxWLcen2 * ( (Vgsteff2 - DeltaPhi2) / 2.0 + T02 / 4.0
                            - 0.5 * T02 * T02 / T22);
                    qsrc = qsrc + qsrc2;
                end
                /* end v4.1 */

            end else if (B4SOIxpart < 0.5) begin   /* 40/60 partition */
                T2 = T2 / 12.0;
                T3 = 0.5 * CoxWLcen / (T2 * T2);
                T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0
                        * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                qsrc = -T3 * T4;
                /* v4.1 */
                if ((B4SOIsoiMod != 2) &&                 /* Bug fix #10 Jun 09 'opposite type Q/C evaluated only if bodymod=1' */
                    (B4SOIbodyMod != 0) && B4SOIagbcp2 > 0) begin
                    T22 = T22 / 12.0;
                    T3 = 0.5 * CoxWLcen2 / (T22 * T22);
                    T4 = T12 * (2.0 * T02 * T02 / 3.0 + T12 * (T12 - 4.0
                            * T02 / 3.0)) - 2.0 * T02 * T02 * T02 / 15.0;
                    qsrc2 = -T3 * T4;
                    qsrc = qsrc + qsrc2;
                end
                /* end v4.1 */
            end else begin   /* 50/50 partition */
                qsrc = -0.5 * qgate;
            end

            /* Backgate charge */
            /* v3.1 */
            if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */
                Qe1 = 0;
            end else begin
                /* soiMod = 0 or 1 */
                CboxWL = pParam_B4SOIkb1 * B4SOIfbody * Cbox
                        * (pParam_B4SOIweffCV / B4SOInseg * B4SOInf
                        * pParam_B4SOIleffCVbg + B4SOIaebcp);
                Qe1 = CboxWL * (Vesfb - Vbs);
            end
            /* v3.1 */

            qgate = qgate + Qac0 + Qsub0 - qbulk;
            qbody = qbulk - Qac0 - Qsub0 - Qe1;
            qsub = Qe1;
            qdrn = -(qgate + qbody + qsub + qsrc);

            B4SOIqinv = -qinoi;

            /* End of if capMod ==3 */
        end else begin /* v4.0 */ // }{
            Qac0 = 0.0;
            Qsub0 = 0.0;
            qsub = 0.0;
            qbody = 0.0;
            qsrc = 0.0;
            qdrn = 0.0;
            qgate = 0.0;
        end // }

        /*
        *  COMPUTE EQUIVALENT DRAIN CURRENT SOURCE
        */
        /* Intrinsic S/D junction charge */

        if (B4SOIsoiMod == 2) begin /* v3.2 */ /* ideal FD */ // {
            qjd = 0.0;
            qjs = 0.0;
        end else begin /* soiMod = 0 or 1 */ // }{
            PhiBSWG = B4SOIGatesidewallJctSPotential;
            dPhiBSWG_dT = -B4SOItpbswg;
            PhiBSWG = PhiBSWG + dPhiBSWG_dT * (DevTemp - B4SOItnom);
            MJSWG = B4SOIbodyJctGateSideSGradingCoeff;

            cjsbs = B4SOIunitLengthGateSidewallJctCapS
                    * pParam_B4SOIwdiosCV * B4SOItsi * B4SOInf / 1e-7;
            dcjsbs_dT = cjsbs * B4SOItcjswg;
            cjsbs = cjsbs + dcjsbs_dT * (DevTemp - B4SOItnom);

            cjdbs = B4SOIunitLengthGateSidewallJctCapD
                    * pParam_B4SOIwdiodCV * B4SOItsi * B4SOInf / 1e-7;
            dcjdbs_dT = cjdbs * B4SOItcjswgd;
            cjdbs = cjdbs + dcjdbs_dT * (DevTemp - B4SOItnom);

            DioMax = 0.9 * (PhiBSWG);

            arg = 1.0 - (vsbs > DioMax ? DioMax : vsbs) / PhiBSWG;

            if (MJSWG == 0.5) begin
                dT3_dVb = 1.0 / sqrt(arg);
            end else begin
                dT3_dVb = exp(-MJSWG * lln(arg));
            end
            T3 = (1.0 - arg * dT3_dVb) * PhiBSWG / (1.0 - MJSWG);

            if (vsbs > DioMax)
                T3 = T3 + dT3_dVb * (vsbs - DioMax);

            qjs = cjsbs * T3 + B4SOItt * Ibsdif * B4SOInf;

            PhiBSWG = B4SOIGatesidewallJctDPotential;
            dPhiBSWG_dT = -B4SOItpbswgd;
            PhiBSWG = PhiBSWG + dPhiBSWG_dT * (DevTemp - B4SOItnom);
            MJSWG = B4SOIbodyJctGateSideDGradingCoeff;

            DioMax = 0.9 * (PhiBSWG);
            arg = 1.0 - (vdbd > DioMax ? DioMax : vdbd) / PhiBSWG;

            if (MJSWG == 0.5) begin
                dT3_dVb = 1.0 / sqrt(arg);
            end else begin
                dT3_dVb = exp(-MJSWG * lln(arg));
            end
            T3 = (1.0 - arg * dT3_dVb) * PhiBSWG / (1.0 - MJSWG);

            if (vdbd > DioMax)
                T3 = T3 + dT3_dVb * (vdbd - DioMax);

            qjd = cjdbs * T3 + B4SOItt * Ibddif * B4SOInf;
        end // }

        /* Extrinsic Bottom S/D to substrate charge */
        T10 = -B4SOItype * ves;
        /* T10 is vse without type conversion */
        T11 = B4SOItype * (vds - ves);
        /* T11 is vde without type conversion */

        if (B4SOIcsdmin != 0.0) begin // {
            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                    ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) ) begin
                if (T10 < pParam_B4SOIvsdfb) begin
                    B4SOIqse = B4SOIcsbox * (T10 - pParam_B4SOIvsdfb);
                end else if (T10 < pParam_B4SOIsdt1) begin
                    T0 = T10 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqse = T0 * (B4SOIcsbox - pParam_B4SOIst2 / 3 * T1) ;
                end else if (T10 < pParam_B4SOIvsdth) begin
                    T0 = T10 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqse = B4SOIcsmin * T10 + B4SOIst4 +
                            pParam_B4SOIst3 / 3 * T0 * T1;
                end else begin
                    B4SOIqse = B4SOIcsmin * T10 + B4SOIst4;
                end
            end else begin
                if (T10 < pParam_B4SOIvsdth) begin
                    B4SOIqse = B4SOIcsmin * (T10 - pParam_B4SOIvsdth);
                end else if (T10 < pParam_B4SOIsdt1) begin
                    T0 = T10 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqse = T0 * (B4SOIcsmin - pParam_B4SOIst2 / 3 * T1) ;
                end else if (T10 < pParam_B4SOIvsdfb) begin
                    T0 = T10 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqse = B4SOIcsbox * T10 + B4SOIst4 +
                            pParam_B4SOIst3 / 3 * T0 * T1;
                end else begin
                    B4SOIqse = B4SOIcsbox * T10 + B4SOIst4;
                end
            end

            if ( ((pParam_B4SOInsub > 0) && (B4SOItype > 0)) ||
                    ((pParam_B4SOInsub < 0) && (B4SOItype < 0)) ) begin
                if (T11 < pParam_B4SOIvsdfb) begin
                    B4SOIqde = B4SOIcdbox * (T11 - pParam_B4SOIvsdfb);
                end else if (T11 < pParam_B4SOIsdt1) begin
                    T0 = T11 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqde = T0 * (B4SOIcdbox - pParam_B4SOIdt2 / 3 * T1) ;
                end else if (T11 < pParam_B4SOIvsdth) begin
                    T0 = T11 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqde = B4SOIcdmin * T11 + B4SOIdt4 +
                            pParam_B4SOIdt3 / 3 * T0 * T1;
                end else begin
                    B4SOIqde = B4SOIcdmin * T11 + B4SOIdt4;
                end
            end else begin
                if (T11 < pParam_B4SOIvsdth) begin
                    B4SOIqde = B4SOIcdmin * (T11 - pParam_B4SOIvsdth);
                end else if (T11 < pParam_B4SOIsdt1) begin
                    T0 = T11 - pParam_B4SOIvsdth;
                    T1 = T0 * T0;
                    B4SOIqde = T0 * (B4SOIcdmin - pParam_B4SOIdt2 / 3 * T1) ;
                end else if (T11 < pParam_B4SOIvsdfb) begin
                    T0 = T11 - pParam_B4SOIvsdfb;
                    T1 = T0 * T0;
                    B4SOIqde = B4SOIcdbox * T11 + B4SOIdt4 +
                            pParam_B4SOIdt3 / 3 * T0 * T1;
                end else begin
                    B4SOIqde = B4SOIcdbox * T11 + B4SOIdt4;
                end
            end
        end else begin // }{
            B4SOIqse = B4SOIcsbox * T10;
            B4SOIqde = B4SOIcdbox * T11;
        end // }

        /* Extrinsic : Sidewall fringing S/D charge */
        B4SOIqse = B4SOIqse + B4SOIcsesw * T10;
        B4SOIqde = B4SOIqde + B4SOIcdesw * T11;

        /* bulk and channel charge plus overlaps */

        if (B4SOIrgateMod == 3)
            T0 = vgmd + `DELTA_1; /* v3.2 bug fix */
        else
            T0 = vgd + `DELTA_1;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
        T2 = 0.5 * (T0 - T1);

        /* v2.2.3 bug fix */
        T3 = pParam_B4SOIwdiodCV * pParam_B4SOIcgdl; /* v3.1 bug fix */

        T4 = sqrt(1.0 - 4.0 * T2 / pParam_B4SOIckappa);
        if (B4SOIrgateMod == 3) begin /* v3.2 bug fix */
            qgdo = (pParam_B4SOIcgdo + T3) * vgmd - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end else begin
            qgdo = (pParam_B4SOIcgdo + T3) * vgd - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end

        if (B4SOIrgateMod == 3)
            T0 = vgms + `DELTA_1; /* v3.2 bug fix */
        else
            T0 = vgs + `DELTA_1;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
        T2 = 0.5 * (T0 - T1);

        /* v2.2.3 bug fix */
        T3 = pParam_B4SOIwdiosCV * pParam_B4SOIcgsl; /* v3.1 bug fix */

        T4 = sqrt(1.0 - 4.0 * T2 / pParam_B4SOIckappa);
        if (B4SOIrgateMod == 3) begin /* v3.2 bug fix */
            qgso = (pParam_B4SOIcgso + T3) * vgms - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end else begin
            qgso = (pParam_B4SOIcgso + T3) * vgs - T3 * (T2
                    + 0.5 * pParam_B4SOIckappa * (T4 - 1.0));
        end

        if (B4SOInf != 1.0) begin
            qgdo = qgdo * B4SOInf;
            qgso = qgso * B4SOInf;
        end

// [Nov 2016] : adding overlap charges (qgso + qgdo) to qgate
// [Qov depends on V(gm,si) for RGATEMOD=3, else on V(gi,si)]
        qgi   = qgate;
        qov   = qgso + qgdo;
        qgate = qgi + qov;

        begin : noise // {
            real cd, cdmin, logcdmin, wefftot, leffBcox;
            real thermalNoiseContrib, flickerNoiseContrib;
            real esat, npart_beta, npart_theta, igsquare;

`ifdef  _TNOIMOD3_
    real npart_c;
    real eta, gamma, delta, epsilon;
    real Lvsat;
    real sid, sf;
    real ctnoi, B4SOInoiGd0, GammaGd0, C0;
`endif

            if (B4SOImode > 0)
                cd = abs(Ids + Ic - Ibd + Iii + Igidl);
            else
                cd = abs(Ids - Ic - Ibs + Iii + Igidl);

            fourkt = 4.0 * `P_K * B4SOITempSH;
            if (B4SOIrdsMod != 2) begin
                gdnoise = 1 / Rd ;
                gsnoise = 1 / Rs ;
            end else begin
                gdnoise = 0.0;
                gsnoise = 0.0;
            end
         case(TNOIMOD)
         0 : begin
          thermalNoiseContrib = B4SOIntnoi * B4SOIueff*abs(B4SOIqinv/(pParam_B4SOIleff*pParam_B4SOIleff+B4SOIueff*abs(B4SOIqinv)
          *B4SOIrds) );

          I(di,si) <+ white_noise(`MFACTOR_USE * abs(fourkt * thermalNoiseContrib), "id");

         end
         1: begin
                T0 = B4SOIgm + B4SOIgds + B4SOIgmbs;
                T0 = T0 * T0;
                esat = 2.0 * vsattemp / B4SOIueff;
                T5 = B4SOIVgsteff / (esat * pParam_B4SOIleff);
                T5 = T5 * T5;
                npart_beta = B4SOIrnoia * (1.0 + T5 * B4SOItnoia
                                                    * pParam_B4SOIleff);
                npart_theta = B4SOIrnoib * (1.0 + T5 * B4SOItnoib
                                                     * pParam_B4SOIleff);
                if (npart_theta > 0.9)
                    npart_theta = 0.9;
                if (npart_theta > 0.9 * npart_beta)
                    npart_theta = 0.9 * npart_beta;

                igsquare = npart_theta * npart_theta * T0 / B4SOIidovVds;
                T1 = npart_beta * (B4SOIgm + B4SOIgmbs) + B4SOIgds;
                T2 = T1 * T1 / B4SOIidovVds;
                thermalNoiseContrib = T2 - igsquare;

                if (B4SOImode > 0)
                    gsnoise = gsnoise * (1.0 + npart_theta * npart_theta
                                                * gsnoise / B4SOIidovVds);
                else
                    gdnoise = gdnoise * (1.0 + npart_theta * npart_theta
                                                * gdnoise / B4SOIidovVds);

               I(di,si) <+ white_noise(`MFACTOR_USE * abs(fourkt * thermalNoiseContrib), "id");
          end

         3: begin

//Correlated Thermal Noise by Navid, July 2013
`ifdef _TNOIMOD3_

        eta   = 1.0 - B4SOIVdseff*B4SOIAbovVgst2Vtm ;
        T0    = 1.0 - eta;
        T1    = 1.0 + eta;
        T2    = T1 + 2.0*B4SOIAbulk*B4SOIvtm/(B4SOIVgsteff+1.0e-10);
        Lvsat = Leff*(1.0 + B4SOIVdseff /EsatL) ;
        T6    = Leff / Lvsat ;
        gamma = T6*(0.5*T1 + T0*T0/(6.0*T2));

        T3      = T2*T2;
        T4      = T0*T0;
        T5      = T3*T3;
        delta   = ((T1/T3)-(5.0*T1 + T2)*T4/(15.0*T5) + T4*T4/(9.0*T5*T2))/(6.0*T6*T6*T6);
        T7      = T0/T2;
        epsilon = (T7 + T7*T7*T7/3.0)/(6.0*T6);

        T8      = B4SOIVgsteff / (EsatL);
        T8      = T8 * T8;
        npart_c = B4SOIrnoic * (1.0 + T8 * B4SOItnoic * Leff);
        ctnoi   = epsilon / sqrt( gamma * delta) * (2.5316 * npart_c);

        if (ctnoi > 1)
            ctnoi=1;
        if (ctnoi < 0)
            ctnoi=0;
        npart_beta  = B4SOIrnoia * (1.0 + T8 * B4SOItnoia * Leff);
        npart_theta = B4SOIrnoib * (1.0 + T8 * B4SOItnoib * Leff);
        gamma       = gamma * (3.0  * npart_beta  * npart_beta);
        delta       = delta * (3.75 * npart_theta * npart_theta);

        B4SOInoiGd0 = B4SOInf * beta * B4SOIVgsteff / (1.0 + gche * Rds);
        GammaGd0    = gamma * B4SOInoiGd0;
        sid         = fourkt * GammaGd0;
        C0          = B4SOInf * B4SOIcox * pParam_B4SOIweffCV * pParam_B4SOIleffCV;
        //sigrat      = C0 / B4SOInoiGd0 * sqrt(delta / gamma);
        sf = (B4SOInoiGd0+1e-15)/sqrt(delta/gamma);

        I(di,si) <+  white_noise(`MFACTOR_USE * sid*abs(1.0-ctnoi * ctnoi), "id");
        I(N)     <+  `MFACTOR_USE * V(N) * sf * SCALEN;
        I(N)     <+  white_noise(`MFACTOR_USE * sid/(sf*sf*SCALEN*SCALEN), "corl");

        I(di,si) <+  `MFACTOR_USE * ctnoi * V(N)*sf*SCALEN ;
        I(gi,si) <+  `MFACTOR_USE * ddt(0.5 * C0 * SCALEN * V(N));
        I(gi,di) <+  `MFACTOR_USE * ddt(0.5 * C0 * SCALEN * V(N));
`else
        $strobe("[BSIMSOI] Although the model selector TNOIMOD is set to 3, the new correlated thermal noise model is not activated in the Verilog-A code.  Please uncomment \"`define _TNOIMOD3_\" in the beginning of the Verilog-A code.");

`endif
        end

        2: begin

         thermalNoiseContrib = 2.0/3.0 * B4SOIntnoi*abs(B4SOIgm + B4SOIgds + B4SOIgmbs);
         I(di,si) <+ white_noise(`MFACTOR_USE * abs(fourkt * thermalNoiseContrib), "id");
      end
      endcase


            wefftot = B4SOInf * pParam_B4SOIweff;
            if (B4SOIbf == 1)
                leffBcox =  pParam_B4SOIleff * B4SOIcox;
            else if (B4SOIbf == 2)
                leffBcox =  pParam_B4SOIleff * pParam_B4SOIleff * B4SOIcox;
            else
                leffBcox =  pow(pParam_B4SOIleff, B4SOIbf) * B4SOIcox;

            if (FNOIMOD == 0) begin // {
                if (B4SOIw0flk > 0) begin
                    cdmin = cd / wefftot * B4SOIw0flk;
                    if (cdmin < `N_MINLOG)
                        cdmin = `N_MINLOG;
                    logcdmin = ln(cdmin);
                    flickerNoiseContrib = wefftot/B4SOIw0flk * B4SOIkf
                                          * exp(B4SOIaf * logcdmin) / leffBcox;
                end else begin
                    if (cd < `N_MINLOG)
                        cdmin = `N_MINLOG;
                    else
                        cdmin = cd;
                    logcdmin = ln(cdmin);
                    flickerNoiseContrib = B4SOIkf * exp(B4SOIaf * logcdmin)
                                                                / leffBcox;
                end
            end else begin : Eval1ovFNoise // }{
                real esat, DelClm, N0, Nl, Nratio, logem38;
                real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
                real Ssi, Swi;
                logem38 = ln(1e-38);
                esat = 2.0 * vsattemp / B4SOIueff;

                /* v2.2.3 bug fix */
                if (B4SOIem <= 0.0)
                    DelClm = 0.0;
                else begin
                    T0 = ((((Vds - B4SOIVdseff) / pParam_B4SOIlitl)
                        + B4SOIem) / esat);
                    if (T0 < 1e-38)
                        DelClm = pParam_B4SOIlitl * logem38;
                    else
                        DelClm = pParam_B4SOIlitl * ln(T0);
                end

                T1 = `Charge_q * `Charge_q * `P_K * cd * B4SOITempSH * B4SOIueff;
                T2 = 1.0e10 * B4SOIAbulk * B4SOIcox
                   * pParam_B4SOIleff * pParam_B4SOIleff;

                /* v2.2.3 bug fix */
                N0 = B4SOIcox * B4SOIVgsteff / `Charge_q;
                Nl = B4SOIcox * B4SOIVgsteff
                     * (1.0 - B4SOIAbovVgst2Vtm * B4SOIVdseff) / `Charge_q;

                Nratio = (N0 + B4SOInstar) / (Nl + B4SOInstar);
                if (Nratio < 1e-38)
                    T3 = B4SOIoxideTrapDensityA * logem38;
                else
                    T3 = B4SOIoxideTrapDensityA * ln(Nratio);
                T4 = B4SOIoxideTrapDensityB * (N0 - Nl);
                T5 = B4SOIoxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl);

                T6 = `P_K * B4SOITempSH * cd * cd;
                T7 = 1.0e10 * pParam_B4SOIleff
                   * pParam_B4SOIleff * wefftot;
                T8 = B4SOIoxideTrapDensityA + B4SOIoxideTrapDensityB * Nl
                   + B4SOIoxideTrapDensityC * Nl * Nl;
                T9 = (Nl + B4SOInstar) * (Nl + B4SOInstar);

                Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
                T10 = B4SOIoxideTrapDensityA * `P_K * B4SOITempSH;
                T11 = wefftot * pParam_B4SOIleff
                        * 1.0e10 * B4SOInstar * B4SOInstar ;
                Swi = T10 / T11 * cd * cd;
                T1 = Swi + Ssi;
                if (T1 > 0.0 && Ssi > 0.0 && Swi > 0.0)
                    flickerNoiseContrib = (Ssi * Swi ) / T1;
                else
                    flickerNoiseContrib = 0;

            end // }

            I(di,si) <+ flicker_noise(`MFACTOR_USE * flickerNoiseContrib, B4SOIef, "flicker");

      end // noise // }


        // Load currents and charges:
       /* Absolute values of fourkt * gdnoise and fourkt * gsnoise used by Pankaj in May 2012*/

        if (B4SOIrdsMod != 2) begin                      /* 2013.enh5, 2015.enh1 */ /* v4.6 */
            I(d, di) <+ `MFACTOR_USE * V(d,di) / Rd ;
            I(d, di) <+ white_noise( `MFACTOR_USE * abs(fourkt * gdnoise), "rd");
            I(s, si) <+ `MFACTOR_USE * V(s,si) / Rs ;
            I(s, si) <+ white_noise( `MFACTOR_USE * abs(fourkt * gsnoise), "rs");
        end else begin
            V(d, di) <+ 0.0;
            V(s, si) <+ 0.0;
        end

        if (B4SOImode > 0) begin
            I(di,si)  <+ `MFACTOR_USE * B4SOItype * (Ids + Ic);
            I(di,b)   <+ `MFACTOR_USE * B4SOItype * Iii;
            B4SOIigidl = B4SOItype * Igidl;
            B4SOIigisl = B4SOItype * Igisl;
            B4SOIIgcd  = B4SOItype * Igcd;
            B4SOIIgcs  = B4SOItype * Igcs;
            B4SOIqdrn  = B4SOItype * qdrn;
            B4SOIqsrc  = B4SOItype * qsrc;
        end else begin
            I(si,di)  <+ `MFACTOR_USE * B4SOItype * (Ids - Ic);
            I(si,b)   <+ `MFACTOR_USE * B4SOItype * Iii;
            B4SOIigisl = B4SOItype * Igidl;
            B4SOIigidl = B4SOItype * Igisl;
            B4SOIIgcs  = B4SOItype * Igcd;
            B4SOIIgcd  = B4SOItype * Igcs;
            B4SOIqsrc  = B4SOItype * qdrn;
            B4SOIqdrn  = B4SOItype * qsrc;
        end
        B4SOIIgd = B4SOItype * Igd;
        B4SOIIgs = B4SOItype * Igs;

        I(di,b)  <+ `MFACTOR_USE * B4SOIigidl;
        I(si,b)  <+ `MFACTOR_USE * B4SOIigisl;
        I(db,di) <+ `MFACTOR_USE * B4SOItype * Ibd;
        I(sb,si) <+ `MFACTOR_USE * B4SOItype * Ibs;
        I(gi,di) <+ `MFACTOR_USE * (B4SOIIgd + B4SOIIgcd);
        I(gi,si) <+ `MFACTOR_USE * (B4SOIIgs + B4SOIIgcs);
        I(gi,b)  <+ `MFACTOR_USE * B4SOIig;
        I(gi,p)  <+ `MFACTOR_USE * B4SOIigp;
        if ((B4SOIbodyMod == 0) || (B4SOIbodyMod == 2))
            V(b, p)  <+ 0;
        else
            begin
                I(b, p)  <+ `MFACTOR_USE * B4SOItype * Ibp;
                I(b, p)  <+ white_noise(`MFACTOR_USE * fourkt*abs(Ibp)/(abs(vbp)+1.0e-9), "rbp");
            end

        /* Low frequency excess noise due to FBE */
        /* Absolute values of Ibd, Ibs, (B4SOIIgd + B4SOIIgcd), (B4SOIIgs + B4SOIIgcs), and B4SOIig used by Pankaj in May 2012 */

        I(db,di) <+ white_noise( `MFACTOR_USE * 2 * `Charge_q * B4SOInoif * abs(Ibd), "ibd");
        I(sb,si) <+ white_noise( `MFACTOR_USE * 2 * `Charge_q * B4SOInoif * abs(Ibs), "ibs");

        /* v3.2 for gate tunneling shot noise */
        I(gi,di) <+ white_noise( `MFACTOR_USE * 2 * `Charge_q * abs(B4SOIIgd + B4SOIIgcd), "igd");
        I(gi,si) <+ white_noise( `MFACTOR_USE * 2 * `Charge_q * abs(B4SOIIgs + B4SOIIgcs), "igs");
        I(gi,b)  <+ white_noise( `MFACTOR_USE * 2 * `Charge_q * abs(B4SOIig), "igb");

        I(di,b)  <+ `MFACTOR_USE * ddt(B4SOIqdrn);
        I(si,b)  <+ `MFACTOR_USE * ddt(B4SOIqsrc);
        I(gi,b)  <+ `MFACTOR_USE * B4SOItype * ddt(qgate);
        I(e, b)  <+ `MFACTOR_USE * B4SOItype * ddt(qsub);
        //I(b, b)  <+ `MFACTOR_USE * B4SOItype * ddt(qbody);

        I(db,di) <+ `MFACTOR_USE * B4SOItype * ddt(qjd);
        I(sb,si) <+ `MFACTOR_USE * B4SOItype * ddt(qjs);

        if (RGATEMOD == 3) begin
            I(gm,di) <+ `MFACTOR_USE * B4SOItype * ddt(qgdo);
            I(gm,si) <+ `MFACTOR_USE * B4SOItype * ddt(qgso);
            I(gm, e) <+ `MFACTOR_USE * ddt(V(gm,e) * pParam_B4SOIcgeo);
        end else begin
            I(gi,di) <+ `MFACTOR_USE * B4SOItype * ddt(qgdo);
            I(gi,si) <+ `MFACTOR_USE * B4SOItype * ddt(qgso);
            I(gi, e) <+ `MFACTOR_USE * ddt(V(gi,e) * pParam_B4SOIcgeo);
        end
        I(di,e)  <+ `MFACTOR_USE * ddt(B4SOIqde);
        I(si,e)  <+ `MFACTOR_USE * ddt(B4SOIqse);

        if (RGATEMOD == 0 || RGATEMOD == 2) begin
            V(g, gm) <+ 0;
        end else begin
            I(g, gm) <+ `MFACTOR_USE * V(g, gm) * B4SOIgrgeltd;
            /* Absolute value of fourkt * B4SOIgrgeltd used by Pankaj in May 2012 */
            I(g, gm) <+ white_noise( `MFACTOR_USE * abs(fourkt * B4SOIgrgeltd), "rg");
        end

        if (RGATEMOD == 0 || RGATEMOD == 1) begin
            V(gm,gi) <+ 0;
        end else begin
            I(gm,gi) <+ `MFACTOR_USE * V(gm,gi) * B4SOIgcrg;

            if (RGATEMOD == 2) begin : rgate2
                real T0;
                T0 = 1.0 + B4SOIgrgeltd / B4SOIgcrg;
                /* Absolute value of fourkt * B4SOIgrgeltd / (T0 * T0) used by Pankaj in May 2012 */
                I(gm,gi) <+ white_noise( `MFACTOR_USE * abs(fourkt * B4SOIgrgeltd / (T0 * T0)), "rg");
            end
        end

        if (B4SOIrbodyMod) begin
            I(b, db) <+ `MFACTOR_USE * V(b, db) * B4SOIgrbdb;
            I(b, sb) <+ `MFACTOR_USE * V(b, sb) * B4SOIgrbsb;
            /* Absolute values of fourkt * B4SOIgrbdb and fourkt * B4SOIgrbsb used by Pankaj in May 2012 */
            I(b, db) <+ white_noise( `MFACTOR_USE * abs(fourkt * B4SOIgrbdb), "rbdb");
            I(b, sb) <+ white_noise( `MFACTOR_USE * abs(fourkt * B4SOIgrbsb), "rbsb");
        end else begin
            V(b, db) <+ 0;
            V(b, sb) <+ 0;
        end

        if (B4SOIsoiMod == 2)
            V(b, si) <+ 0;

        // self-heating network (v4.6)
        // Xyce hack:  all contributions modified to
        // separate dynamic and static terms due to limitation
        // of Xyce/ADMS.
`ifdef PORT_CONNECTED
        if ((SHMOD == 1) && (RTH0 != 0.0)) begin /* 2014bug2 */ /* v4.6 */
            if (TNODEOUT && !$port_connected(t)) begin
                if ($port_connected(b)) begin // last terminal is 'b'
                    I(b) <+ `MFACTOR_USE*(-Ids * Vds  + delTemp / pParam_B4SOIrth);
                    I(b) <+  `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
                end else if ($port_connected(p)) begin  // last terminal is 'p'
                    I(p) <+ `MFACTOR_USE*(-Ids * Vds + delTemp / pParam_B4SOIrth);
                    I(p) <+ `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
                end else begin  // 4-terminal mode ('t' is internal)
                    Pwr(t) <+ `MFACTOR_USE*(-Ids * Vds + delTemp / pParam_B4SOIrth);
                    Pwr(t) <+ `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
                end
            end else begin
                Pwr(t) <+ `MFACTOR_USE*(-Ids * Vds + delTemp / pParam_B4SOIrth);
                Pwr(t) <+ `MFACTOR_USE*ddt(delTemp * pParam_B4SOIcth);
            end
        end else begin
            if (TNODEOUT && !$port_connected(t)) begin
                if ($port_connected(b)) begin // last terminal is 'b'
                   $strobe("Error:  you have specified a temperature node as the 6th node with TNODEOUT=0 and self-heating disabled.  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 6th node.");
                   $finish(1);
                   // V(b) <+0;
                end else if ($port_connected(p)) begin // last terminal is 'p'
                   $strobe("Error:  you have specified a temperature node as the 5th node with TNODEOUT=0 and self-heating disabled.  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 5th node.");
                   $finish(1);
                   // V(p) <+ 0;
                end else begin // 4-terminal mode ('t' is internal)
                   $strobe("Error:  you have specified a temperature node as the 7th node with TNODEOUT=0 and self-heating disabled.  This node is not used in this mode and Xyce cannot deal with it being externally specified.  Please remove the 7th node.");
                   $finish(1);
                   // Temp(t) <+ 0;
                end
            end else begin
                Temp(t) <+ 0;
            end
        end
`else
        if ((SHMOD == 1) && (RTH0 != 0.0)) begin
            Pwr(t) <+ `MFACTOR_USE * (-Ids * Vds + delTemp / pParam_B4SOIrth);
            Pwr(t) <+ `MFACTOR_USE * ddt(delTemp * pParam_B4SOIcth);
        end else
            Temp(t) <+ 0;
`endif
        // operating-point information
        IDS   = B4SOItype * Ids;
        GM    = B4SOIgm;
        GDS   = B4SOIgds;
        GMBS  = B4SOIgmbs;
        IC    = B4SOItype * Ic;
        IBS   = B4SOItype * Ibs;
        IBD   = B4SOItype * Ibd;
        IGIDL = B4SOIigidl;
        IGISL = B4SOIigisl;
        IGS   = B4SOIIgs;
        IGD   = B4SOIIgd;
        IGB   = B4SOIig;
        IGCS  = B4SOIIgcs;
        IGCD  = B4SOIIgcd;
        QG    = B4SOItype * qgate;
        QGI   = B4SOItype * qgi; // Nov 2016
        QOV   = B4SOItype * qov; // Nov 2016
        QB    = B4SOItype * qbody;
        QD    = B4SOIqdrn;
        QS    = B4SOIqsrc;

        if (RGATEMOD == 3) begin
                CGG   =  ddx(QGI, V(gi)) + ddx(QOV, V(gm));
        end else begin
                CGG   =  ddx(QG, V(gi));
        end

        CGS   = -ddx(QG, V(si));
        CGD   = -ddx(QG, V(di));
        CBG   = -ddx(QB, V(gi));
        CBD   = -ddx(QB, V(di));
        CBS   = -ddx(QB, V(si));
        CDG   = -ddx(QD, V(gi));
        CDD   =  ddx(QD, V(di));
        CDS   = -ddx(QD, V(si));
        QJD   = B4SOItype * qjd;
        QJS   = B4SOItype * qjs;
        CAPBD = ddx(QJD, V(db));
        CAPBS = ddx(QJS, V(sb));
    end // load // }

end // analog
endmodule
