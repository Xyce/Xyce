//======================================================================================
//======================================================================================
// Filename: PSP103_module.include
//======================================================================================
//======================================================================================
//
//  (c) Copyright notice
//
//  Since 2015 until today, PSP has been co-developed by NXP Semiconductors and
//  CEA-Leti. For this part of the model, each claim undivided ownership and copyrights
//  Since 2012 until 2015, PSP has been co-developed by NXP Semiconductors and
//  Delft University of Technology. For this part of the model, each claim undivided
//  ownership and copyrights
//  Until and including 2011, PSP has been co-developed by NXP Semiconductors and
//  Arizona State University. For this part of the model, NXP Semiconductors claims
//  undivided ownership and copyrights.
//
//
//  Version: 103.4.0 (PSP), 200.5.0 (JUNCAP), August 2016
//
//======================================================================================
//======================================================================================
//
// Further information can be found in the file releasenotesPSP103.txt
//
    //  --------------------------------------------------------------------------------------------------------------
    //  Node definitions
    //  --------------------------------------------------------------------------------------------------------------

        `ifdef SelfHeating
            inout      D, G, S, B, DT;
        `else // SelfHeating
            inout      D, G, S, B;
        `endif // SelfHeating
        electrical D;
        electrical G;
        electrical S;
        electrical B;
        `ifdef SelfHeating
            thermal DT;
            branch     (DT) br_rth, br_ith;
        `endif // SelfHeating

        // Internal nodes and branches for correlated drain and gate noise
        electrical NOI;
`ifdef _XYCE_HACK
        electrical NOI2;
`endif         
        branch (NOI) NOII;
        branch (NOI) NOIR;
        branch (NOI) NOIC;

        // Internal nodes for gate and bulk resistors
        electrical GP;
        electrical SI;
        electrical DI;
        electrical BP;
        electrical BI;
        electrical BS;
        electrical BD;

        // Internal nodes and branches for spline collocation (NQS)
        `ifdef NQSmodel
        electrical INT1;
        electrical INT2;
        electrical INT3;
        electrical INT4;
        electrical INT5;
        electrical INT6;
        electrical INT7;
        electrical INT8;
        electrical INT9;
        branch(INT1) SPLINE1;
        branch(INT2) SPLINE2;
        branch(INT3) SPLINE3;
        branch(INT4) SPLINE4;
        branch(INT5) SPLINE5;
        branch(INT6) SPLINE6;
        branch(INT7) SPLINE7;
        branch(INT8) SPLINE8;
        branch(INT9) SPLINE9;
        branch(INT1) RES1;
        branch(INT2) RES2;
        branch(INT3) RES3;
        branch(INT4) RES4;
        branch(INT5) RES5;
        branch(INT6) RES6;
        branch(INT7) RES7;
        branch(INT8) RES8;
        branch(INT9) RES9;
        `endif // NQSmodel

    //  --------------------------------------------------------------------------------------------------------------
    //  Special model parameters and switch parameters
    //  --------------------------------------------------------------------------------------------------------------

        //  Special model parameters, some are also simulator global variables
        `MPInb(LEVEL          ,103        ,""                                   ,"Model level")
        `MPIty(TYPE           ,1          ,""                                   ,"Channel type parameter, +1=NMOS -1=PMOS")
        `MPRco(TR             ,21.0       ,"degC"        ,-273.0      ,inf         ,"nominal (reference) temperature")

        //  Switch parameters that turn models or effects on or off
        `MPIcc(SWGEO          ,1          ,""         ,0           ,2           ,"Flag for geometrical model, 0=local, 1=global, 2=binning") 
        `MPIcc(SWIGATE        ,0          ,""         ,0           ,1           ,"Flag for gate current, 0=turn off IG") 
        `MPIcc(SWIMPACT       ,0          ,""         ,0           ,1           ,"Flag for impact ionization current, 0=turn off II") 
        `MPIcc(SWGIDL         ,0          ,""         ,0           ,1           ,"Flag for GIDL current, 0=turn off IGIDL")
        `MPIcc(SWJUNCAP       ,0          ,""         ,0           ,3           ,"Flag for juncap, 0=turn off juncap")
        `MPIcc(SWJUNASYM      ,0          ,""         ,0           ,1           ,"Flag for asymmetric junctions; 0=symmetric, 1=asymmetric")
        `MPIcc(SWNUD          ,0          ,""         ,0           ,2           ,"Flag for NUD-effect; 0=off, 1=on, 2=on+CV-correction")
        `MPIcc(SWEDGE         ,0          ,""         ,0           ,1           ,"Flag for drain current of edge transistors; 0=off, 1=on")
        `MPIcc(SWDELVTAC      ,0          ,""         ,0           ,1           ,"Flag for separate capacitance calculation; 0=off, 1=on")
        `MPIcc(SWIGN          ,1          ,""         ,0           ,1           ,"Flag for induced gate noise; 0=off, 1=on")
        `ifdef NQSmodel
        `MPIcc(SWNQS          ,0          ,""         ,0           ,9           ,"Flag for NQS, 0=off, 1, 2, 3, 5, or 9=number of collocation points")
        `endif // NQSmodel
        `MPRcz(QMC            ,1.0        ,""                                   ,"Quantum-mechanical correction factor")

    //  --------------------------------------------------------------------------------------------------------------
    //  Instance parameters
    //  --------------------------------------------------------------------------------------------------------------

        // Instance parameters for global and binning models only
        `IPRco(L              ,1.0e-5     ,"m"        ,1.0e-9      ,inf         ,"Design length")
        `IPRco(W              ,1.0e-5     ,"m"        ,1.0e-9      ,inf         ,"Design width")
        `IPRnb(SA             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from one side")
        `IPRnb(SB             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly from other side")
        `IPRnb(SD             ,0.0        ,"m"                                  ,"Distance between neighbouring fingers")
        `IPRcz(SCA            ,0.0        ,""                                   ,"Integral of the first distribution function for scattered well dopants")
        `IPRcz(SCB            ,0.0        ,""                                   ,"Integral of the second distribution function for scattered well dopants")
        `IPRcz(SCC            ,0.0        ,""                                   ,"Integral of the third distribution function for scattered well dopants")
        `IPRnb(SC             ,0.0        ,"m"                                  ,"Distance between OD-edge and nearest well edge")
        `IPRco(NF             ,1.0        ,""         ,1.0         ,inf         ,"Number of fingers")
        `IPRcc(NGCON          ,1.0        ,""         ,1.0         ,2.0         ,"Number of gate contacts")
        `IPRnb(XGW            ,1.0e-7     ,"m"                                  ,"Distance from the gate contact to the channel edge")
        `IPRnb(NRS            ,0.0        ,""                                   ,"Number of squares of source diffusion")
        `IPRnb(NRD            ,0.0        ,""                                   ,"Number of squares of drain diffusion")

        // Instance parameters for local model only
        `IPRco(JW             ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source/drain junction")

        // Instance parameters for global, binning, and local models
        `IPRnb(DELVTO         ,0.0        ,"V"                                  ,"Threshold voltage shift parameter")
        `IPRcz(FACTUO         ,1.0        ,""                                   ,"Zero-field mobility pre-factor")
        `IPRnb(DELVTOEDGE     ,0.0        ,"V"                                  ,"Threshold voltage shift parameter of edge transistor")
        `IPRcz(FACTUOEDGE     ,1.0        ,""                                   ,"Zero-field mobility pre-factor of edge transistor")
        `IPRco(ABSOURCE       ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
        `IPRco(LSSOURCE       ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of source junction")
        `IPRco(LGSOURCE       ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of source junction")
        `IPRco(ABDRAIN        ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
        `IPRco(LSDRAIN        ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"STI-edge length of drain junction")
        `IPRco(LGDRAIN        ,1.0e-6     ,"m"        ,`LG_cliplow ,inf         ,"Gate-edge length of drain junction")
        `IPRco(AS             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of source junction")
        `IPRco(PS             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of source junction")
        `IPRco(AD             ,1.0e-12    ,"m^2"      ,`AB_cliplow ,inf         ,"Bottom area of drain junction")
        `IPRco(PD             ,1.0e-6     ,"m"        ,`LS_cliplow ,inf         ,"Perimeter of drain junction")
        `IPRco(MULT           ,1.0        ,""         ,0.0         ,inf         ,"Number of devices in parallel")

// XYCE MOD:  Add aliasparam for M to be a synonym for MULT
        aliasparam M=MULT;

    //  --------------------------------------------------------------------------------------------------------------
    //  PSP local model parameters
    //  --------------------------------------------------------------------------------------------------------------

        //  Process parameters
        `MPRnb(VFB            ,-1.0       ,"V"                                  ,"Flat band voltage at TR")
        `MPRnb(STVFB          ,5.0e-4     ,"V/K"                                ,"Temperature dependence of VFB")
        `MPRco(TOX            ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"Gate oxide thickness")
        `MPRco(EPSROX         ,3.9        ,""         ,1.0         ,inf         ,"Relative permittivity of gate dielectric")
        `MPRcc(NEFF           ,5.0e23     ,"m^-3"     ,1.0e20      ,1.0e26      ,"Effective substrate doping")
        `MPRcz(FACNEFFAC      ,1.0        ,""                                   ,"Pre-factor for effective substrate doping in separate charge calculation")
        `MPRco(GFACNUD        ,1.0        ,""         ,0.01        ,inf         ,"Body-factor change due to NUD-effect")
        `MPRcz(VSBNUD         ,0.0        ,"V"                                  ,"Lower Vsb value for NUD-effect")
        `MPRco(DVSBNUD        ,1.0        ,"V"        ,0.1         ,inf         ,"Vsb-range for NUD-effect")
        `MPRnb(VNSUB          ,0.0        ,"V"                                  ,"Effective doping bias-dependence parameter")
        `MPRco(NSLP           ,0.05       ,"V"        ,1.0e-3      ,inf         ,"Effective doping bias-dependence parameter")
        `MPRcc(DNSUB          ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Effective doping bias-dependence parameter")
        `MPRnb(DPHIB          ,0.0        ,"V"                                  ,"Offset parameter for PHIB")
        `MPRnb(DELVTAC        ,0.0        ,"V"                                  ,"Offset parameter for PHIB in separate charge calculation")
        `MPRcz(NP             ,1.0e26     ,"m^-3"                               ,"Gate poly-silicon doping")
        `MPRcz(CT             ,0.0        ,""                                   ,"Interface states factor")
        `MPRco(TOXOV          ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness")
        `MPRco(TOXOVD         ,2.0e-09    ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness for drain side")
        `MPRcc(NOV            ,5.0e25     ,"m^-3"     ,1.0e23      ,1.0e27      ,"Effective doping of overlap region")
        `MPRcc(NOVD           ,5.0e25     ,"m^-3"     ,1.0e23      ,1.0e27      ,"Effective doping of overlap region for drain side")

        //  DIBL parameters
        `MPRcz(CF             ,0.0        ,""                                   ,"DIBL-parameter")
        `MPRcz(CFD            ,0.0        ,"V^-1"                               ,"Drain voltage dependence of CF")
        `MPRcc(CFB            ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Back bias dependence of CF")

        //  Subthreshold slope parameters of short channel transistor 
        `MPRcz(PSCE           ,0.0        ,""                                   ,"Subthreshold slope coefficient for short channel transistor")
        `MPRcc(PSCEB          ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel transistor")
        `MPRcz(PSCED          ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel transistor")

        //  Mobility parameters
        `MPRcz(BETN           ,7.0e-2     ,"m^2/V/s"                            ,"Channel aspect ratio times zero-field mobility")
        `MPRnb(STBET          ,1.0        ,""                                   ,"Temperature dependence of BETN")
        `MPRcz(MUE            ,0.5        ,"m/V"                                ,"Mobility reduction coefficient at TR")
        `MPRnb(STMUE          ,0.0        ,""                                   ,"Temperature dependence of MUE")
        `MPRcz(THEMU          ,1.5        ,""                                   ,"Mobility reduction exponent at TR")
        `MPRnb(STTHEMU        ,1.5        ,""                                   ,"Temperature dependence of THEMU")
        `MPRcz(CS             ,0.0        ,""                                   ,"Coulomb scattering parameter at TR")
        `MPRnb(STCS           ,0.0        ,""                                   ,"Temperature dependence of CS")
        `MPRcz(XCOR           ,0.0        ,"V^-1"                               ,"Non-universality factor")
        `MPRnb(STXCOR         ,0.0        ,""                                   ,"Temperature dependence of XCOR")
        `MPRcz(FETA           ,1.0        ,""                                   ,"Effective field parameter")

        //  Series-resistance parameters (for resistance modeling as part of intrinsic mobility reduction)
        `MPRcz(RS             ,30.0       ,"Ohm"                                ,"Series resistance at TR")
        `MPRnb(STRS           ,1.0        ,""                                   ,"Temperature dependence of RS")
        `MPRcc(RSB            ,0.0        ,"V^-1"     ,-0.5        ,1.0         ,"Back-bias dependence of series resistance")
        `MPRco(RSG            ,0.0        ,"V^-1"     ,-0.5        ,inf         ,"Gate-bias dependence of series resistance")

        //  Velocity saturation parameters
        `MPRcz(THESAT         ,1.0        ,"V^-1"                               ,"Velocity saturation parameter at TR")
        `MPRnb(STTHESAT       ,1.0        ,""                                   ,"Temperature dependence of THESAT")
        `MPRcc(THESATB        ,0.0        ,"V^-1"     ,-0.5        ,1.0         ,"Back-bias dependence of velocity saturation")
        `MPRco(THESATG        ,0.0        ,"V^-1"     ,-0.5        ,inf         ,"Gate-bias dependence of velocity saturation")
 
        //  Saturation voltage parameters
        `MPRco(AX             ,3.0        ,""         ,2.0         ,inf         ,"Linear/saturation transition factor")

        //  Channel length modulation (CLM) parameters
        `MPRcz(ALP            ,0.01       ,""                                   ,"CLM pre-factor")
        `MPRcz(ALP1           ,0.0        ,"V"                                  ,"CLM enhancement factor above threshold")
        `MPRcz(ALP2           ,0.0        ,"V^-1"                               ,"CLM enhancement factor below threshold")
        `MPRco(VP             ,0.05       ,"V"        ,1.0e-10     ,inf         ,"CLM logarithm dependence factor")

        //  Impact ionization (II) parameters
        `MPRcz(A1             ,1.0        ,""                                   ,"Impact-ionization pre-factor")
        `MPRcz(A2             ,10.0       ,"V"                                  ,"Impact-ionization exponent at TR")
        `MPRnb(STA2           ,0.0        ,"V"                                  ,"Temperature dependence of A2")
        `MPRcz(A3             ,1.0        ,""                                   ,"Saturation-voltage dependence of impact-ionization")
        `MPRcz(A4             ,0.0        ,"V^-0.5"                             ,"Back-bias dependence of impact-ionization")

        //  Gate current parameters
        `MPRcc(GCO            ,0.0        ,""         ,-10.0       ,10.0        ,"Gate tunnelling energy adjustment")
        `MPRcz(IGINV          ,0.0        ,"A"                                  ,"Gate channel current pre-factor")
        `MPRcz(IGOV           ,0.0        ,"A"                                  ,"Gate overlap current pre-factor")
        `MPRcz(IGOVD          ,0.0        ,"A"                                  ,"Gate overlap current pre-factor for drain side")
        `MPRnb(STIG           ,2.0        ,""                                   ,"Temperature dependence of IGINV and IGOV")
        `MPRcc(GC2            ,0.375      ,""         ,0.0         ,10.0        ,"Gate current slope factor")
        `MPRcc(GC3            ,0.063      ,""         ,-2.0        ,2.0         ,"Gate current curvature factor")
        `MPRco(CHIB           ,3.1        ,"V"        ,1.0         ,inf         ,"Tunnelling barrier height")

        //  Gate Induced Drain/Source Leakage (GIDL) parameters
        `MPRcz(AGIDL          ,0.0        ,"A/V^3"                              ,"GIDL pre-factor")
        `MPRcz(AGIDLD         ,0.0        ,"A/V^3"                              ,"GIDL pre-factor for drain side")
        `MPRcz(BGIDL          ,41.0       ,"V"                                  ,"GIDL probability factor at TR")
        `MPRcz(BGIDLD         ,41.0       ,"V"                                  ,"GIDL probability factor at TR for drain side")
        `MPRnb(STBGIDL        ,0.0        ,"V/K"                                ,"Temperature dependence of BGIDL")
        `MPRnb(STBGIDLD       ,0.0        ,"V/K"                                ,"Temperature dependence of BGIDL for drain side")
        `MPRnb(CGIDL          ,0.0        ,""                                   ,"Back-bias dependence of GIDL")
        `MPRnb(CGIDLD         ,0.0        ,""                                   ,"Back-bias dependence of GIDL for drain side")

        //  Charge model parameters
        `MPRcz(COX            ,1.0e-14    ,"F"                                  ,"Oxide capacitance for intrinsic channel")
        `MPRcz(CGOV           ,1.0e-15    ,"F"                                  ,"Oxide capacitance for gate-drain/source overlap")
        `MPRcz(CGOVD          ,1.0e-15    ,"F"                                  ,"Oxide capacitance for gate-drain overlap")
        `MPRcz(CGBOV          ,0.0        ,"F"                                  ,"Oxide capacitance for gate-bulk overlap")
        `MPRcz(CFR            ,0.0        ,"F"                                  ,"Outer fringe capacitance")
        `MPRcz(CFRD           ,0.0        ,"F"                                  ,"Outer fringe capacitance for drain side")

        //  Noise parameters
        `MPRcz(FNT            ,1.0        ,""                                   ,"Thermal noise coefficient")
        `MPRcz(FNTEXC         ,0.0        ,""                                   ,"Excess noise coefficient")
        `MPRcz(NFA            ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise")
        `MPRcz(NFB            ,3.0e07     ,"V^-1/m^2"                           ,"Second coefficient of flicker noise")
        `MPRcz(NFC            ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise")
        `MPRcz(EF             ,1.0        ,""                                   ,"Flicker noise frequency exponent")

        // Edge transistor parameters: PSP 103.4
        `MPRnb(VFBEDGE        ,-1.0       ,"V"                                  ,"Flat band voltage of edge transistors at TR")
        `MPRnb(STVFBEDGE      ,5.0e-4     ,"V/K"                                ,"Temperature dependence of VFBEDGE")
        `MPRnb(DPHIBEDGE      ,0.0        ,"V"                                  ,"Offset parameter for PHIB of edge transistors")
        `MPRcc(NEFFEDGE       ,5.0e23     ,"m^-3"     ,1.0e20      ,1.0e26      ,"Effective substrate doping of edge transistors")
        `MPRcz(CTEDGE         ,0.0        ,""                                   ,"Interface states factor of edge transistors")
        `MPRcz(BETNEDGE       ,5.0e-4     ,"m^2/V/s"                            ,"Channel aspect ratio times zero-field mobility of edge transistor")
        `MPRnb(STBETEDGE      ,1.0        ,""                                   ,"Temperature dependence of BETNEDGE")
        `MPRcz(PSCEEDGE       ,0.0        ,""                                   ,"Subthreshold slope coefficient for short channel edge transistors")
        `MPRcc(PSCEBEDGE      ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
        `MPRcz(PSCEDEDGE      ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
        `MPRcz(CFEDGE         ,0.0        ,""                                   ,"DIBL parameter of edge transistors")
        `MPRcz(CFDEDGE        ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of DIBL-parameter of edge transistors")
        `MPRcc(CFBEDGE        ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of DIBL-parameter of edge transistors")
        `MPRcz(FNTEDGE        ,1.0        ,""                                   ,"Thermal noise coefficient of edge transistors")
        `MPRcz(NFAEDGE        ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise of edge transistors")
        `MPRcz(NFBEDGE        ,3.0e07     ,"V^-1/m^2"                           ,"Second coefficient of flicker noise of edge transistors")
        `MPRcz(NFCEDGE        ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise of edge transistors")
        `MPRcz(EFEDGE         ,1.0        ,""                                   ,"Flicker noise frequency exponent of edge transistors")

        //  NQS parameters
        `ifdef NQSmodel
        `MPRcz(MUNQS          ,1.0        ,""                                   ,"Relative mobility for NQS modelling")
        `endif // NQSmodel

        // Parasitic resistance parameters
        `MPRcz(RG             ,0.0        ,"Ohm"                                ,"Gate resistance")
        `MPRcz(RSE            ,0.0        ,"Ohm"                                ,"External source resistance")
        `MPRcz(RDE            ,0.0        ,"Ohm"                                ,"External drain resistance")
        `MPRcz(RBULK          ,0.0        ,"Ohm"                                ,"Bulk resistance between node BP and BI")
        `MPRcz(RWELL          ,0.0        ,"Ohm"                                ,"Well resistance between node BI and B")
        `MPRcz(RJUNS          ,0.0        ,"Ohm"                                ,"Source-side bulk resistance between node BI and BS")
        `MPRcz(RJUND          ,0.0        ,"Ohm"                                ,"Drain-side bulk resistance between node BI and BD")

        // Self heating effect parameters
        `ifdef SelfHeating
        `MPRcz(RTH            ,0.0        ,"K/W"                                ,"Thermal resistance")
        `MPRcz(CTH            ,0.0        ,"J/K"                                ,"Thermal capacitance")
        `MPRnb(STRTH          ,0.0        ,""                                   ,"Temperature sensitivity of RTH")
        `endif // SelfHeating

    //  --------------------------------------------------------------------------------------------------------------
    //  PSP global model parameters (binning)
    //  --------------------------------------------------------------------------------------------------------------

        `include "PSP103_binpars.include"

    //  --------------------------------------------------------------------------------------------------------------
    //  PSP global model parameters
    //  --------------------------------------------------------------------------------------------------------------

        // Process Parameters
        `MPRnb(LVARO          ,0.0        ,"m"                                  ,"Geom. independent difference between actual and programmed gate length")
        `MPRnb(LVARL          ,0.0        ,""                                   ,"Length dependence of LVAR")
        `MPRnb(LVARW          ,0.0        ,""                                   ,"Width dependence of LVAR")
        `MPRnb(LAP            ,0.0        ,"m"                                  ,"Effective channel length reduction per side")
        `MPRnb(WVARO          ,0.0        ,"m"                                  ,"Geom. independent difference between actual and programmed field-oxide opening")
        `MPRnb(WVARL          ,0.0        ,""                                   ,"Length dependence of WVAR")
        `MPRnb(WVARW          ,0.0        ,""                                   ,"Width dependence of WVAR")
        `MPRnb(WOT            ,0.0        ,"m"                                  ,"Effective channel width reduction per side")
        `MPRnb(DLQ            ,0.0        ,"m"                                  ,"Effective channel length reduction for CV")
        `MPRnb(DWQ            ,0.0        ,"m"                                  ,"Effective channel width reduction for CV")
        `MPRnb(VFBO           ,-1.0       ,"V"                                  ,"Geometry-independent flat-band voltage at TR")
        `MPRnb(VFBL           ,0.0        ,"V"                                  ,"Length dependence of flat-band voltage")
        `MPRnb(VFBW           ,0.0        ,"V"                                  ,"Width dependence of flat-band voltage")
        `MPRnb(VFBLW          ,0.0        ,"V"                                  ,"Area dependence of flat-band voltage")
        `MPRnb(STVFBO         ,5.0e-4     ,"V/K"                                ,"Geometry-independent temperature dependence of VFB")
        `MPRnb(STVFBL         ,0.0        ,"V/K"                                ,"Length dependence of temperature dependence of VFB")
        `MPRnb(STVFBW         ,0.0        ,"V/K"                                ,"Width dependence of temperature dependence of VFB")
        `MPRnb(STVFBLW        ,0.0        ,"V/K"                                ,"Area dependence of temperature dependence of VFB")
        `MPRco(TOXO           ,2.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Gate oxide thickness")
        `MPRco(EPSROXO        ,3.9        ,""         ,1.0         ,inf         ,"Relative permittivity of gate dielectric")
        `MPRco(NSUBO          ,3.0e23     ,"m^-3"     ,1.0e20      ,inf         ,"Geometry independent substrate doping")
        `MPRnb(NSUBW          ,0.0        ,""                                   ,"Width dependence of background doping NSUBO due to segregation")
        `MPRco(WSEG           ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Char. length of segregation of background doping NSUBO")
        `MPRcz(NPCK           ,1.0e24     ,"m^-3"                               ,"Pocket doping level")
        `MPRnb(NPCKW          ,0.0        ,""                                   ,"Width dependence of pocket doping NPCK due to segregation")
        `MPRco(WSEGP          ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Char. length of segregation of pocket doping NPCK")
        `MPRco(LPCK           ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Char. length of lateral doping profile")
        `MPRnb(LPCKW          ,0.0        ,""                                   ,"Width dependence of char. length of lateral doping profile")
        `MPRnb(FOL1           ,0.0        ,""                                   ,"First length dependence coefficient for short channel body effect")
        `MPRnb(FOL2           ,0.0        ,""                                   ,"Second length dependence coefficient for short channel body effect")
        `MPRnb(FACNEFFACO     ,1.0        ,""                                   ,"Geom. independent pre-factor for effective substrate doping in separate charge calculation")
        `MPRnb(FACNEFFACL     ,0.0        ,""                                   ,"Length dependence of FACNEFFAC")
        `MPRnb(FACNEFFACW     ,0.0        ,""                                   ,"Width dependence of FACNEFFAC")
        `MPRnb(FACNEFFACLW    ,0.0        ,""                                   ,"Area dependence of FACNEFFAC")
        `MPRnb(GFACNUDO       ,1.0        ,""                                   ,"Geom. independent body-factor change due to NUD-effect")
        `MPRnb(GFACNUDL       ,0.0        ,""                                   ,"Length dependence of GFACNUD")
        `MPRnb(GFACNUDLEXP    ,1.0        ,""                                   ,"Exponent for length dependence of GFACNUD")
        `MPRnb(GFACNUDW       ,0.0        ,""                                   ,"Width dependence of GFACNUD")
        `MPRnb(GFACNUDLW      ,0.0        ,""                                   ,"Area dependence of GFACNUD")
        `MPRnb(VSBNUDO        ,0.0        ,"V"                                  ,"Lower Vsb value for NUD-effect")
        `MPRnb(DVSBNUDO       ,1.0        ,"V"                                  ,"Vsb range for NUD-effect")
        `MPRnb(VNSUBO         ,0.0        ,"V"                                  ,"Effective doping bias-dependence parameter")
        `MPRnb(NSLPO          ,0.05       ,"V"                                  ,"Effective doping bias-dependence parameter")
        `MPRnb(DNSUBO         ,0.0        ,"V^-1"                               ,"Effective doping bias-dependence parameter")
        `MPRnb(DPHIBO         ,0.0        ,"V"                                  ,"Geometry independent offset of PHIB")
        `MPRnb(DPHIBL         ,0.0        ,"V"                                  ,"Length dependence offset of PHIB")
        `MPRnb(DPHIBLEXP      ,1.0        ,""                                   ,"Exponent for length dependence of offset of PHIB")
        `MPRnb(DPHIBW         ,0.0        ,"V"                                  ,"Width dependence of offset of PHIB")
        `MPRnb(DPHIBLW        ,0.0        ,"V"                                  ,"Area dependence of offset of PHIB")
        `MPRnb(DELVTACO       ,0.0        ,"V"                                  ,"Geom. independent offset parameter for PHIB in separate charge calculation")
        `MPRnb(DELVTACL       ,0.0        ,"V"                                  ,"Length dependence of DELVTAC")
        `MPRnb(DELVTACLEXP    ,1.0        ,""                                   ,"Exponent for length dependence of offset of DELVTAC")
        `MPRnb(DELVTACW       ,0.0        ,"V"                                  ,"Width dependence of DELVTAC")
        `MPRnb(DELVTACLW      ,0.0        ,"V"                                  ,"Area dependence of DELVTAC")
        `MPRnb(NPO            ,1.0e26     ,"m^-3"                               ,"Geometry-independent gate poly-silicon doping")
        `MPRnb(NPL            ,0.0        ,""                                   ,"Length dependence of gate poly-silicon doping")
        `MPRnb(CTO            ,0.0        ,""                                   ,"Geometry-independent interface states factor")
        `MPRnb(CTL            ,0.0        ,""                                   ,"Length dependence of interface states factor")
        `MPRnb(CTLEXP         ,1.0        ,""                                   ,"Exponent for length dependence of interface states factor")
        `MPRnb(CTW            ,0.0        ,""                                   ,"Width dependence of interface states factor")
        `MPRnb(CTLW           ,0.0        ,""                                   ,"Area dependence of interface states factor")
        `MPRco(TOXOVO         ,2.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness")
        `MPRco(TOXOVDO        ,2.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Overlap oxide thickness for drain side")
        `MPRcz(LOV            ,0.0        ,"m"                                  ,"Overlap length for gate/drain and gate/source overlap capacitance")
        `MPRcz(LOVD           ,0.0        ,"m"                                  ,"Overlap length for gate/drain overlap capacitance")
        `MPRnb(NOVO           ,5e25       ,"m^-3"                               ,"Effective doping of overlap region")
        `MPRnb(NOVDO          ,5e25       ,"m^-3"                               ,"Effective doping of overlap region for drain side")

        // DIBL Parameters
        `MPRnb(CFL            ,0.0        ,""                                   ,"Length dependence of DIBL-parameter")
        `MPRnb(CFLEXP         ,2.0        ,""                                   ,"Exponent for length dependence of CF")
        `MPRnb(CFW            ,0.0        ,""                                   ,"Width dependence of CF")
        `MPRcz(CFDO           ,0.0        ,"V^-1"                               ,"Drain voltage dependence of CF")
        `MPRnb(CFBO           ,0.0        ,"V^-1"                               ,"Back-bias dependence of CF")

        //  Subthreshold slope parameters of short channel transistor 
        `MPRnb(PSCEL          ,0.0        ,""                                   ,"Length dependence of subthreshold slope coefficient for short channel transistor")
        `MPRnb(PSCELEXP       ,2.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel transistor")
        `MPRnb(PSCEW          ,0.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel transistor")
        `MPRcc(PSCEBO         ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel transistor")
        `MPRcz(PSCEDO         ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel transistor")

        // Mobility Parameters
        `MPRcz(UO             ,5.0e-2     ,"m^2/V/s"                            ,"Zero-field mobility at TR")
        `MPRnb(FBET1          ,0.0        ,""                                   ,"Relative mobility decrease due to first lateral profile")
        `MPRnb(FBET1W         ,0.0        ,""                                   ,"Width dependence of relative mobility decrease due to first lateral profile")
        `MPRco(LP1            ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Mobility-related characteristic length of first lateral profile")
        `MPRnb(LP1W           ,0.0        ,""                                   ,"Width dependence of mobility-related characteristic length of first lateral profile")
        `MPRnb(FBET2          ,0.0        ,""                                   ,"Relative mobility decrease due to second lateral profile")
        `MPRco(LP2            ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Mobility-related characteristic length of second lateral profile")
        `MPRnb(BETW1          ,0.0        ,""                                   ,"First higher-order width scaling coefficient of BETN")
        `MPRnb(BETW2          ,0.0        ,""                                   ,"Second higher-order width scaling coefficient of BETN")
        `MPRco(WBET           ,1.0e-9     ,"m"        ,1.0e-10     ,inf         ,"Characteristic width for width scaling of BETN")
        `MPRnb(STBETO         ,1.0        ,""                                   ,"Geometry independent temperature dependence of BETN")
        `MPRnb(STBETL         ,0.0        ,""                                   ,"Length dependence of temperature dependence of BETN")
        `MPRnb(STBETW         ,0.0        ,""                                   ,"Width dependence of temperature dependence of BETN")
        `MPRnb(STBETLW        ,0.0        ,""                                   ,"Area dependence of temperature dependence of BETN")
        `MPRnb(MUEO           ,0.5        ,"m/V"                                ,"Geometry independent mobility reduction coefficient at TR")
        `MPRnb(MUEW           ,0.0        ,""                                   ,"Width dependence of mobility reduction coefficient at TR")
        `MPRnb(STMUEO         ,0.0        ,""                                   ,"Temperature dependence of MUE")
        `MPRnb(THEMUO         ,1.5        ,""                                   ,"Mobility reduction exponent at TR")
        `MPRnb(STTHEMUO       ,1.5        ,""                                   ,"Temperature dependence of THEMU")
        `MPRnb(CSO            ,0.0        ,""                                   ,"Geometry independent coulomb scattering parameter at TR")
        `MPRnb(CSL            ,0.0        ,""                                   ,"Length dependence of CS")
        `MPRnb(CSLEXP         ,1.0        ,""                                   ,"Exponent for length dependence of CS")
        `MPRnb(CSW            ,0.0        ,""                                   ,"Width dependence of CS")
        `MPRnb(CSLW           ,0.0        ,""                                   ,"Area dependence of CS")
        `MPRnb(STCSO          ,0.0        ,""                                   ,"Temperature dependence of CS")
        `MPRnb(XCORO          ,0.0        ,"V^-1"                               ,"Geometry independent non-universality parameter")
        `MPRnb(XCORL          ,0.0        ,""                                   ,"Length dependence of non-universality parameter")
        `MPRnb(XCORW          ,0.0        ,""                                   ,"Width dependence of non-universality parameter")
        `MPRnb(XCORLW         ,0.0        ,""                                   ,"Area dependence of non-universality parameter")
        `MPRnb(STXCORO        ,0.0        ,""                                   ,"Temperature dependence of XCOR")
        `MPRnb(FETAO          ,1.0        ,""                                   ,"Effective field parameter")

        // Series Resistance
        `MPRnb(RSW1           ,50.0       ,"Ohm"                                ,"Source/drain series resistance for 1 um wide channel at TR")
        `MPRnb(RSW2           ,0.0        ,""                                   ,"Higher-order width scaling of RS")
        `MPRnb(STRSO          ,1.0        ,""                                   ,"Temperature dependence of RS")
        `MPRnb(RSBO           ,0.0        ,"V^-1"                               ,"Back-bias dependence of series resistance")
        `MPRnb(RSGO           ,0.0        ,"V^-1"                               ,"Gate-bias dependence of series resistance")

        // Velocity Saturation
        `MPRnb(THESATO        ,0.0        ,"V^-1"                               ,"Geometry independent velocity saturation parameter at TR")
        `MPRnb(THESATL        ,0.05       ,"V^-1"                               ,"Length dependence of THESAT")
        `MPRnb(THESATLEXP     ,1.0        ,""                                   ,"Exponent for length dependence of THESAT")
        `MPRnb(THESATW        ,0.0        ,""                                   ,"Width dependence of velocity saturation parameter")
        `MPRnb(THESATLW       ,0.0        ,""                                   ,"Area dependence of velocity saturation parameter")
        `MPRnb(STTHESATO      ,1.0        ,""                                   ,"Geometry independent temperature dependence of THESAT")
        `MPRnb(STTHESATL      ,0.0        ,""                                   ,"Length dependence of temperature dependence of THESAT")
        `MPRnb(STTHESATW      ,0.0        ,""                                   ,"Width dependence of temperature dependence of THESAT")
        `MPRnb(STTHESATLW     ,0.0        ,""                                   ,"Area dependence of temperature dependence of THESAT")
        `MPRnb(THESATBO       ,0.0        ,"V^-1"                               ,"Back-bias dependence of velocity saturation")
        `MPRnb(THESATGO       ,0.0        ,"V^-1"                               ,"Gate-bias dependence of velocity saturation")

        // Saturation Voltage
        `MPRnb(AXO            ,18.0       ,""                                   ,"Geometry independent linear/saturation transition factor")
        `MPRcz(AXL            ,0.4        ,""                                   ,"Length dependence of AX")

        // Channel Length Modulation
        `MPRnb(ALPL           ,5.0e-4     ,""                                   ,"Length dependence of ALP")
        `MPRnb(ALPLEXP        ,1.0        ,""                                   ,"Exponent for length dependence of ALP")
        `MPRnb(ALPW           ,0.0        ,""                                   ,"Width dependence of ALP")
        `MPRnb(ALP1L1         ,0.0        ,"V"                                  ,"Length dependence of CLM enhancement factor above threshold")
        `MPRnb(ALP1LEXP       ,0.5        ,""                                   ,"Exponent for length dependence of ALP1")
        `MPRcz(ALP1L2         ,0.0        ,""                                   ,"Second_order length dependence of ALP1")
        `MPRnb(ALP1W          ,0.0        ,""                                   ,"Width dependence of ALP1")
        `MPRnb(ALP2L1         ,0.0        ,"V^-1"                               ,"Length dependence of CLM enhancement factor below threshold")
        `MPRnb(ALP2LEXP       ,0.5        ,""                                   ,"Exponent for length dependence of ALP2")
        `MPRcz(ALP2L2         ,0.0        ,""                                   ,"Second_order length dependence of ALP2")
        `MPRnb(ALP2W          ,0.0        ,""                                   ,"Width dependence of ALP2")
        `MPRnb(VPO            ,0.05       ,"V"                                  ,"CLM logarithmic dependence parameter")

        // Weak-avalanche parameters
        `MPRnb(A1O            ,1.0        ,""                                   ,"Geometry independent impact-ionization pre-factor")
        `MPRnb(A1L            ,0.0        ,""                                   ,"Length dependence of A1")
        `MPRnb(A1W            ,0.0        ,""                                   ,"Width dependence of A1")
        `MPRnb(A2O            ,10.0       ,"V"                                  ,"Impact-ionization exponent at TR")
        `MPRnb(STA2O          ,0.0        ,"V"                                  ,"Temperature dependence of A2")
        `MPRnb(A3O            ,1.0        ,""                                   ,"Geometry independent saturation-voltage dependence of II")
        `MPRnb(A3L            ,0.0        ,""                                   ,"Length dependence of A3")
        `MPRnb(A3W            ,0.0        ,""                                   ,"Width dependence of A3")
        `MPRnb(A4O            ,0.0        ,"V^-0.5"                             ,"Geometry independent back-bias dependence of II")
        `MPRnb(A4L            ,0.0        ,""                                   ,"Length dependence of A4")
        `MPRnb(A4W            ,0.0        ,""                                   ,"Width dependence of A4")

        // Gate current parameters
        `MPRnb(GCOO           ,0.0        ,""                                   ,"Gate tunnelling energy adjustment")
        `MPRnb(IGINVLW        ,0.0        ,"A"                                  ,"Gate channel current pre-factor for 1 um**2 channel area")
        `MPRnb(IGOVW          ,0.0        ,"A"                                  ,"Gate overlap current pre-factor for 1 um wide channel")
        `MPRnb(IGOVDW         ,0.0        ,"A"                                  ,"Gate overlap current pre-factor for 1 um wide channel for drain side")
        `MPRnb(STIGO          ,2.0        ,""                                   ,"Temperature dependence of IGINV and IGOV")
        `MPRnb(GC2O           ,0.375      ,""                                   ,"Gate current slope factor")
        `MPRnb(GC3O           ,0.063      ,""                                   ,"Gate current curvature factor")
        `MPRnb(CHIBO          ,3.1        ,"V"                                  ,"Tunnelling barrier height")

        // Gate-induced drain leakage parameters
        `MPRnb(AGIDLW         ,0.0        ,"A/V^3"                              ,"Width dependence of GIDL pre-factor")
        `MPRnb(AGIDLDW        ,0.0        ,"A/V^3"                              ,"Width dependence of GIDL pre-factor for drain side")
        `MPRnb(BGIDLO         ,41.0       ,"V"                                  ,"GIDL probability factor at TR")
        `MPRnb(BGIDLDO        ,41.0       ,"V"                                  ,"GIDL probability factor at TR for drain side")
        `MPRnb(STBGIDLO       ,0.0        ,"V/K"                                ,"Temperature dependence of BGIDL")
        `MPRnb(STBGIDLDO      ,0.0        ,"V/K"                                ,"Temperature dependence of BGIDL for drain side")
        `MPRnb(CGIDLO         ,0.0        ,""                                   ,"Back-bias dependence of GIDL")
        `MPRnb(CGIDLDO        ,0.0        ,""                                   ,"Back-bias dependence of GIDL for drain side")

        // Charge Model Parameters
        `MPRnb(CGBOVL         ,0.0        ,"F"                                  ,"Oxide capacitance for gate-bulk overlap for 1 um long channel")
        `MPRnb(CFRW           ,0.0        ,"F"                                  ,"Outer fringe capacitance for 1 um wide channel")
        `MPRnb(CFRDW          ,0.0        ,"F"                                  ,"Outer fringe capacitance for 1 um wide channel for drain side")

        // Noise Model Parameters
        `MPRnb(FNTO           ,1.0        ,""                                   ,"Thermal noise coefficient")
        `MPRcz(FNTEXCL        ,0.0        ,""                                   ,"Length dependence coefficient of excess noise")
        `MPRnb(NFALW          ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise for 1 um**2 channel area")
        `MPRnb(NFBLW          ,3.0e7      ,"V^-1/m^2"                           ,"Second coefficient of flicker noise for 1 um**2 channel area")
        `MPRnb(NFCLW          ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise for 1 um**2 channel area")
        `MPRnb(EFO            ,1.0        ,""                                   ,"Flicker noise frequency exponent")
        `MPRnb(LINTNOI        ,0.0        ,"m"                                  ,"Length offset for flicker noise")
        `MPRnb(ALPNOI         ,2.0        ,""                                   ,"Exponent for length offset for flicker noise")

        // Edge transistor parameters: PSP 103.4
        `MPRcz(WEDGE          ,1.0e-8     ,"m"                                  ,"Electrical width of edge transistor per side")
        `MPRcz(WEDGEW         ,0.0        ,""                                   ,"Width dependence of edge WEDGE")
        `MPRnb(VFBEDGEO       ,-1.0       ,"V"                                  ,"Geometry-independent flat-band voltage of edge transistors at TR")
        `MPRnb(STVFBEDGEO     ,5.0e-4     ,"V/K"                                ,"Geometry-independent temperature dependence of VFBEDGE")
        `MPRnb(STVFBEDGEL     ,0.0        ,"V/K"                                ,"Length dependence of temperature dependence of VFBEDGE")
        `MPRnb(STVFBEDGEW     ,0.0        ,"V/K"                                ,"Width dependence of temperature dependence of VFBEDGE")
        `MPRnb(STVFBEDGELW    ,0.0        ,"V/K"                                ,"Area dependence of temperature dependence of VFBEDGE")
        `MPRnb(DPHIBEDGEO     ,0.0        ,"V"                                  ,"Geometry independent of edge transistor PHIB offset")
        `MPRnb(DPHIBEDGEL     ,0.0        ,"V"                                  ,"Length dependence of edge transistor PHIB offset")
        `MPRnb(DPHIBEDGELEXP  ,1.0        ,""                                   ,"Exponent for length dependence of edge transistor PHIB offset")
        `MPRnb(DPHIBEDGEW     ,0.0        ,"V"                                  ,"Width dependence of edge transistor PHIB offset")
        `MPRnb(DPHIBEDGELW    ,0.0        ,"V"                                  ,"Area dependence of edge transistor PHIB offset")
        `MPRco(NSUBEDGEO      ,5.0e23     ,"m^-3"     ,1.0e20      ,inf         ,"Geometry independent substrate doping of edge transistors")
        `MPRnb(NSUBEDGEL      ,0.0        ,""                                   ,"Length dependence of edge transistor substrate doping")
        `MPRnb(NSUBEDGEW      ,0.0        ,""                                   ,"Width dependence of edge transistor substrate doping")
        `MPRnb(NSUBEDGELW     ,0.0        ,""                                   ,"Area dependence of edge transistor substrate doping")
        `MPRnb(CTEDGEO        ,0.0        ,""                                   ,"Geometry-independent interface states factor of edge transistors")
        `MPRnb(CTEDGEL        ,0.0        ,""                                   ,"Length dependence of interface states factor of edge transistors")
        `MPRnb(CTEDGELEXP     ,1.0        ,""                                   ,"Exponent for length dependence of interface states factor of edge transistors")
        `MPRnb(FBETEDGE       ,0.0        ,""                                   ,"Length dependence of edge transistor mobility")
        `MPRco(LPEDGE         ,1.0e-8     ,"m"        ,1.0e-10     ,inf         ,"Exponent for length dependence of edge transistor mobility")
        `MPRnb(BETEDGEW       ,0.0        ,""                                   ,"Width scaling coefficient of edge transistor mobility")
        `MPRnb(STBETEDGEO     ,1.0        ,""                                   ,"Geometry independent temperature dependence of BETNEDGE")
        `MPRnb(STBETEDGEL     ,0.0        ,""                                   ,"Length dependence of temperature dependence of BETNEDGE")
        `MPRnb(STBETEDGEW     ,0.0        ,""                                   ,"Width dependence of temperature dependence of BETNEDGE")
        `MPRnb(STBETEDGELW    ,0.0        ,""                                   ,"Area dependence of temperature dependence of BETNEDGE")
        `MPRnb(PSCEEDGEL      ,0.0        ,""                                   ,"Length dependence of subthreshold slope coefficient for short channel edge transistors")
        `MPRnb(PSCEEDGELEXP   ,2.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel edge transistors")
        `MPRnb(PSCEEDGEW      ,0.0        ,""                                   ,"Exponent for length dependence of subthreshold slope coefficient for short channel edge transistor")
        `MPRcc(PSCEBEDGEO     ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
        `MPRcz(PSCEDEDGEO     ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of subthreshold slope coefficient for short channel edge transistors")
        `MPRnb(CFEDGEL        ,0.0        ,""                                   ,"Length dependence of DIBL-parameter of edge transistors")
        `MPRnb(CFEDGELEXP     ,2.0        ,""                                   ,"Exponent for length dependence of DIBL-parameter of edge transistors")
        `MPRnb(CFEDGEW        ,0.0        ,""                                   ,"Width dependence of DIBL-parameter of edge transistors")
        `MPRcz(CFDEDGEO       ,0.0        ,"V^-1"                               ,"Drain voltage dependence parameter of DIBL-parameter of edge transistors")
        `MPRcc(CFBEDGEO       ,0.0        ,"V^-1"     ,0.0         ,1.0         ,"Bulk voltage dependence parameter of DIBL-parameter of edge transistors")
        `MPRnb(FNTEDGEO       ,1.0        ,""                                   ,"Thermal noise coefficient")
        `MPRnb(NFAEDGELW      ,8.0e22     ,"V^-1/m^4"                           ,"First coefficient of flicker noise for 1 um**2 channel area")
        `MPRnb(NFBEDGELW      ,3.0e7      ,"V^-1/m^2"                           ,"Second coefficient of flicker noise for 1 um**2 channel area")
        `MPRnb(NFCEDGELW      ,0.0        ,"V^-1"                               ,"Third coefficient of flicker noise for 1 um**2 channel area")
        `MPRnb(EFEDGEO        ,1.0        ,""                                   ,"Flicker noise frequency exponent")

        // Well proximity effect Parameters
        `MPRnb(KVTHOWEO       ,0.0        ,""                                   ,"Geometrical independent threshold shift parameter")
        `MPRnb(KVTHOWEL       ,0.0        ,""                                   ,"Length dependent threshold shift parameter")
        `MPRnb(KVTHOWEW       ,0.0        ,""                                   ,"Width dependent threshold shift parameter")
        `MPRnb(KVTHOWELW      ,0.0        ,""                                   ,"Area dependent threshold shift parameter")
        `MPRnb(KUOWEO         ,0.0        ,""                                   ,"Geometrical independent mobility degradation factor")
        `MPRnb(KUOWEL         ,0.0        ,""                                   ,"Length dependent mobility degradation factor")
        `MPRnb(KUOWEW         ,0.0        ,""                                   ,"Width dependent mobility degradation factor")
        `MPRnb(KUOWELW        ,0.0        ,""                                   ,"Area dependent mobility degradation factor")

    //  --------------------------------------------------------------------------------------------------------------
    //  Parameters that occur in both global and binning model
    //  --------------------------------------------------------------------------------------------------------------

        // NQS parameters
        `ifdef NQSmodel
        `MPRnb(MUNQSO         ,1.0        ,""                                   ,"Relative mobility for NQS modelling")
        `endif // NQSmodel

        // Parasitic resistance parameters
        `MPRnb(RGO            ,0.0        ,"Ohm"                                ,"Gate resistance")
        `MPRcz(RINT           ,0.0        ,"Ohm m^2"                            ,"Contact resistance between silicide and ploy")
        `MPRcz(RVPOLY         ,0.0        ,"Ohm m^2"                            ,"Vertical poly resistance")
        `MPRcz(RSHG           ,0.0        ,"Ohm/sq"                             ,"Gate electrode diffusion sheet resistance")
        `MPRnb(DLSIL          ,0.0        ,"m"                                  ,"Silicide extension over the physical gate length")
        `MPRnb(RSH            ,0.0        ,"Ohm/sq"                             ,"Sheet resistance of source diffusion")
        `MPRnb(RSHD           ,0.0        ,"Ohm/sq"                             ,"Sheet resistance of drain diffusion")
        `MPRnb(RBULKO         ,0.0        ,"Ohm"                                ,"Bulk resistance between node BP and BI")
        `MPRnb(RWELLO         ,0.0        ,"Ohm"                                ,"Well resistance between node BI and B")
        `MPRnb(RJUNSO         ,0.0        ,"Ohm"                                ,"Source-side bulk resistance between node BI and BS")
        `MPRnb(RJUNDO         ,0.0        ,"Ohm"                                ,"Drain-side bulk resistance between node BI and BD")

        // Self heating effect parameters
        `ifdef SelfHeating
        `MPRnb(RTHO           ,0.0        ,"K/W"                                ,"Geometry independent part of thermal resistance")
        `MPRnb(RTHW1          ,0.0        ,"K/W"                                ,"Width dependence of thermal resistance")
        `MPRnb(RTHW2          ,0.0        ,""                                   ,"Offset in width dependence of thermal resistance")
        `MPRnb(RTHLW          ,0.0        ,""                                   ,"Length-correction to width dependence of thermal resistance")
        `MPRnb(CTHO           ,0.0        ,"J/K"                                ,"Geometry independent part of thermal capacitance")
        `MPRnb(CTHW1          ,0.0        ,"J/K"                                ,"Width dependence of thermal capacitance")
        `MPRnb(CTHW2          ,0.0        ,""                                   ,"Offset in width dependence of thermal capacitance")
        `MPRnb(CTHLW          ,0.0        ,""                                   ,"Length-correction to width dependence of thermal capacitance")
        `MPRnb(STRTHO         ,0.0        ,""                                   ,"Temperature sensitivity of RTH")
        `endif // SelfHeating

        // Stress Model Parameters
        `MPRcc(SAREF          ,1.0e-6     ,"m"        ,1.0e-9      ,inf         ,"Reference distance between OD-edge and poly from one side")
        `MPRcc(SBREF          ,1.0e-6     ,"m"        ,1.0e-9      ,inf         ,"Reference distance between OD-edge and poly from other side")
        `MPRnb(WLOD           ,0.0        ,"m"                                  ,"Width parameter")
        `MPRnb(KUO            ,0.0        ,"m"                                  ,"Mobility degradation/enhancement coefficient")
        `MPRcc(KVSAT          ,0.0        ,"m"        ,-1.0        ,1.0         ,"Saturation velocity degradation/enhancement coefficient")
        `MPRnb(TKUO           ,0.0        ,""                                   ,"Temperature dependence of KUO")
        `MPRnb(LKUO           ,0.0        ,"m^LLODKUO"                          ,"Length dependence of KUO")
        `MPRnb(WKUO           ,0.0        ,"m^WLODKUO"                          ,"Width dependence of KUO")
        `MPRnb(PKUO           ,0.0        ,"m^(LLODKUO+WLODKUO)"                ,"Cross-term dependence of KUO")
        `MPRcz(LLODKUO        ,0.0        ,""                                   ,"Length parameter for UO stress effect")
        `MPRcz(WLODKUO        ,0.0        ,""                                   ,"Width parameter for UO stress effect")
        `MPRnb(KVTHO          ,0.0        ,"Vm"                                 ,"Threshold shift parameter")
        `MPRnb(LKVTHO         ,0.0        ,"m^LLODVTH"                          ,"Length dependence of KVTHO")
        `MPRnb(WKVTHO         ,0.0        ,"m^WLODVTH"                          ,"Width dependence of KVTHO")
        `MPRnb(PKVTHO         ,0.0        ,"m^(LLODVTH+WLODVTH)"                ,"Cross-term dependence of KVTHO")
        `MPRcz(LLODVTH        ,0.0        ,""                                   ,"Length parameter for VTH-stress effect")
        `MPRcz(WLODVTH        ,0.0        ,""                                   ,"Width parameter for VTH-stress effect")
        `MPRnb(STETAO         ,0.0        ,"m"                                  ,"Eta0 shift factor related to VTHO change")
        `MPRcz(LODETAO        ,1.0        ,""                                   ,"Eta0 shift modification factor for stress effect")

        // Well proximity effect Parameters
        `MPRcz(SCREF          ,1.0e-6     ,"m"                                  ,"Distance between OD-edge and well edge of a reference device")
        `MPRnb(WEB            ,0.0        ,""                                   ,"Coefficient for SCB")
        `MPRnb(WEC            ,0.0        ,""                                   ,"Coefficient for SCC")

    //  --------------------------------------------------------------------------------------------------------------
    //  JUNCAP Parameters
    //  --------------------------------------------------------------------------------------------------------------
        `include "JUNCAP200_parlist.include"

    //  --------------------------------------------------------------------------------------------------------------
    //  Other Parameters
    //  --------------------------------------------------------------------------------------------------------------
        `MPRnb(DTA            ,0.0        ,"K"                                  ,"Temperature offset w.r.t. ambient temperature")

    //  --------------------------------------------------------------------------------------------------------------
    //  Variables
    //  --------------------------------------------------------------------------------------------------------------

        // Variables for switch (initial_model parts)
        integer CHNL_TYPE, SWGEO_i, SWIGATE_i, SWIMPACT_i, SWGIDL_i, SWJUNCAP_i, SWJUNASYM_i, SWNUD_i, SWEDGE_i, SWDELVTAC_i, SWIGN_i;

        // Instance local variables
        real NF_i, invNF, L_i, W_i, SA_i, SB_i, SD_i, SC_i, XGW_i, JW_i, SCA_i, SCB_i, SCC_i, NGCON_i, MULT_i, FACTUO_i, DELVTO_i;
        real FACTUOEDGE_i, DELVTOEDGE_i;

        // Instance local variables for juncap
        real ABS_i, LSS_i, LGS_i, ABD_i, LSD_i, LGD_i, jwcorr, jww;

        // Variables of clipped global model parameters
        real TOXO_i, EPSROXO_i, NSUBO_i, WSEG_i, NPCK_i, WSEGP_i, LPCK_i, TOXOVO_i, TOXOVDO_i, LOV_i, LOVD_i, LP1_i, LP2_i, WBET_i;
        real AXL_i, ALP1L2_i, ALP2L2_i, SAREF_i, SBREF_i, KVSAT_i, LLODKUO_i, WLODKUO_i, LLODVTH_i, WLODVTH_i, LODETAO_i, SCREF_i;
        real WEB_i, WEC_i, RSHG_i, RSH_i, RSHD_i, RINT_i, RVPOLY_i, NSUBEDGEO_i, LPEDGE_i;

        // Variables of local model parameters
        real VFB_p, STVFB_p, TOX_p, EPSROX_p, NEFF_p, FACNEFFAC_p, GFACNUD_p, VSBNUD_p, DVSBNUD_p, VNSUB_p, NSLP_p, DNSUB_p, DPHIB_p;
        real DELVTAC_p, NP_p, CT_p, TOXOV_p, TOXOVD_p, NOV_p, NOVD_p, PSCE_p, PSCED_p, PSCEB_p, CF_p, CFD_p, CFB_p, BETN_p, STBET_p;
        real MUE_p, STMUE_p, THEMU_p, STTHEMU_p, CS_p, STCS_p, XCOR_p, STXCOR_p, FETA_p, RS_p, STRS_p, RSB_p, RSG_p, THESAT_p;
        real STTHESAT_p, THESATB_p, THESATG_p, AX_p, ALP_p, ALP1_p, ALP2_p, VP_p, A1_p, A2_p, STA2_p, A3_p, A4_p, GCO_p, IGINV_p;
        real IGOV_p, IGOVD_p, STIG_p, GC2_p, GC3_p, CHIB_p, AGIDL_p, AGIDLD_p, BGIDL_p, BGIDLD_p, STBGIDL_p, STBGIDLD_p, CGIDL_p;
        real CGIDLD_p, COX_p, CGOV_p, CGOVD_p, CGBOV_p, CFR_p, CFRD_p, FNT_p, FNTEXC_p, NFA_p, NFB_p, NFC_p, EF_p, VFBEDGE_p;
        real STVFBEDGE_p, DPHIBEDGE_p, NEFFEDGE_p, CTEDGE_p, BETNEDGE_p, STBETEDGE_p, PSCEEDGE_p, PSCEBEDGE_p, PSCEDEDGE_p, CFEDGE_p;
        real CFDEDGE_p, CFBEDGE_p, FNTEDGE_p, NFAEDGE_p, NFBEDGE_p, NFCEDGE_p, EFEDGE_p, RG_p, RSE_p, RDE_p, RWELL_p, RBULK_p, RJUNS_p;
        real RJUND_p;  
        `ifdef SelfHeating
        real RTH_p, CTH_p, STRTH_p; 
        `endif // SelfHeating
        `ifdef NQSmodel
        real MUNQS_p;
        `endif // NQSmodel

        // Variables of clipped local model parameters
        real TR_i, QMC_i, VFB_i, STVFB_i, TOX_i, EPSROX_i, NEFF_i, FACNEFFAC_i, GFACNUD_i, VSBNUD_i, DVSBNUD_i, VNSUB_i, NSLP_i;
        real DNSUB_i, DPHIB_i, DELVTAC_i, NP_i, CT_i, TOXOV_i, TOXOVD_i, NOV_i, NOVD_i, CF_i, CFD_i, CFB_i, PSCE_i, PSCEB_i, PSCED_i;
        real BETN_i, STBET_i, MUE_i, STMUE_i, THEMU_i, STTHEMU_i, CS_i, STCS_i, XCOR_i, STXCOR_i, FETA_i, RS_i, STRS_i, RSB_i, RSG_i;
        real THESAT_i, STTHESAT_i, THESATB_i, THESATG_i, AX_i, ALP_i, ALP1_i, ALP2_i, VP_i, A1_i, A2_i, STA2_i, A3_i, A4_i, GCO_i, IGINV_i;
        real IGOV_i, IGOVD_i, STIG_i, GC2_i, GC3_i, CHIB_i, AGIDL_i, AGIDLD_i, BGIDL_i, BGIDLD_i, STBGIDL_i, STBGIDLD_i, CGIDL_i, CGIDLD_i;
        real COX_i, CGOV_i, CGOVD_i, CGBOV_i, CFR_i, CFRD_i, FNT_i, FNTEXC_i, NFA_i, NFB_i, NFC_i, EF_i, VFBEDGE_i, STVFBEDGE_i, DPHIBEDGE_i;
        real NEFFEDGE_i, CTEDGE_i, BETNEDGE_i, STBETEDGE_i, PSCEEDGE_i, PSCEBEDGE_i, PSCEDEDGE_i, CFEDGE_i, CFDEDGE_i, CFBEDGE_i, FNTEDGE_i;
        real NFAEDGE_i, NFBEDGE_i, NFCEDGE_i, EFEDGE_i, RG_i, RSE_i, RDE_i, RBULK_i, RJUNS_i, RJUND_i, RWELL_i;
        `ifdef SelfHeating 
        real RTH_i, CTH_i, STRTH_i; 
        `endif // SelfHeating
        `ifdef NQSmodel
        real MUNQS_i;
         `endif // NQSmodel

        // Variables for scaling rules
        real iL, iW, delLPS, delWOD, LE, WE, LEcv, WEcv, Lcv, Wcv, iLE, iWE, L_f, L_slif, W_f, XGWE, NSUB0e, NPCKe, LPCKe, AA, BB, NSUB;
        real FBET1e, LP1e, GPE, GWE, tmpx, Lnoi, Lred, WE_edge, iWE_edge, GPE_edge, KVTHOWE, KUOWE;
        `ifdef SelfHeating
        real deltaRth;
        `endif // SelfHeating

        // Variables for binning-rules
        real iLEWE, iiLE, iiWE, iiLEWE, iiiLEWE, iLEcv, iiLEcv, iiWEcv, iiLEWEcv, iiiLEWEcv, iLcv, iiLcv, iiWcv, iiLWcv, iiiLWcv;

        // Variables for general temperature scaling
        real TKR, TKA, rTa, delTa, phita, inv_phita, TKD, TKD_sq, delT, rTn, ln_rTn, inv_phit, Eg, phibFac;

        // JUNCAP2 variables
        `include "JUNCAP200_varlist1.include"
        `include "JUNCAP200_varlist2.include"

        // Local parameters after temperature scaling and variables used in self heating effect
        real VFB_T, BETN_T, MUE_T, THEMU_T, CS_T, XCOR_T, RS_T, BGIDL_T, BGIDLD_T, A2_T, VFBEDGE_T, BETNEDGE_T;
        `ifdef SelfHeating 
        real RTH_T;
        `else // SelfHeating
        // in the self heating model, these variables are declared locally in the evaluate block
        real phit, phit0, BET_i, BETEDGE_i, nt0, nt, THESAT_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
        real ntedge;
        `endif // SelfHeating

        // Variables for channel temperature scaling (including self heating effect)
        real phib_dc, G_0_dc, kp, np, arg2max, qlim2, qb0, dphibq, sqrt_phib_dc, phix_dc, aphi_dc, bphi_dc, phix2, phix1_dc, alpha_b;
        real us1, us21, phib_ac, G_0_ac, phix_ac, aphi_ac, bphi_ac, phix1_ac, tf_bet, tf_mue, tf_cs, tf_xcor, tf_ther, THER_i, tf_thesat;
        real tf_betedge, phibedge, Gfedge, phixedge, aphiedge, bphiedge, phix2edge, phix1edge;

         // Variables used in instance initializing
        real EPSSI, EPSOX, CoxPrime, tox_sq, Cox_over_q, NEFFAC_i, qq, E_eff0, eta_mu, eta_mu1, inv_AX, inv_VP, CoxovPrime, CoxovPrime_d, GOV_s;
        real GOV_d, GOV2_s, GOV2_d, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d, inv_CHIB, B_fact, BCH;
        real BOV, BOV_d, GCQ, tf_ig, AGIDLs, AGIDLDs, BGIDLs, BGIDLDs, fac_exc, ggate, gsource, gdrain, gbulk, gjuns, gjund, gwell;

        // Variables for bias affectation
        real Vgs, Vds, Vsb, Vdb, Vgb, Vjun_s, Vjun_d, VgsPrime, VsbPrime, VdbPrime, VgdPrime;
        real Vdsx;

        // Global variables used in PSP103_SPCalculation.include
        real Vgbstar, Vgb1, Vdsp, delVg, Vdsat_lim, Vdsat;

        // Global variables used in current and charge calculations
        real xgs_ov, xgd_ov, Vsbstar_dc, Vsbstar_dc_tmp, Vmb, us, usnew, Vmbnew, qeff1_dc, Voxm_dc, GdL_dc, eta_p_dc, Gvsat_dc, Gmob_dL_dc, x_ds_dc;
        real x_m_dc, Gf_dc, Vdsat_dc, Udse_dc, SP_OV_xg, xs_ov, xd_ov, Vovs, Vovd, zg, TP, Fs1, Fs2, Fs3, Fs, Vm, Dch, arg2mina, psi_t, arg1;
        real Dsi, Dgate, Igc0, igc, igcd_h, u0, x, u0_div_H, Bg, Ag, xsq, inv_x, ex, inv_ex, Sg, Igc, Igb, Vtovd, Igidl, Vtovs, Igisl;
        real delVsat, Vsbstar_ac, xg_ac, qeff1_ac, Voxm_ac, alpha_ac, dps_ac, qim_ac, GdL_ac, H_ac, QG, QI, QD, QB, Fj, Fj2;
        real QCLM, Qg, Qd, Qb, Qs, Qgs_ov, Qgd_ov, Qgb_ov, Qfgs, Qfgd, rgatenoise, rsourcenoise, rdrainnoise, rbulknoise, rwellnoise, rjundnoise;
        real rjunsnoise;

        // Global variables used in macros
        real tme1, tme2;
        real inv_GOV, SP_OV_eps, SP_OV_delta, mutau, nu;
        real Q_EDGE_xsth, Q_EDGE_xth0, Q_EDGE_xth, Q_EDGE_n, Q_EDGE_n_inv, Q_EDGE_xgt, Q_EDGE_xgt0, Q_EDGE_xgt0e, Q_EDGE_qi0si, Q_EDGE_qi0;
        real Q_EDGE_exp_x, Q_EDGE_d0, Q_EDGE_d0p, Q_EDGE_sqerr, Q_EDGE_errq;

        // Global variables used in noise section
        real N1, Nm1, Delta_N1, Sfl, t1, sqt2, t2, r, lc, lcinv2, g_ideal, mid, temp2_exc, wsat_exc, temp_exc, thesat1_exc, zsat_exc, Gvsat_exc;
        real gfac, Sidexc, sqid, mig, migid, CGeff, sqig, c_igid, shot_igcsx, shot_igcdx, shot_igsov, shot_igdov, shot_iavl, jnoisex_s, jnoisex_d;
        real shot_igs, shot_igd, anoisedge, N1edge, Nm1edge, Delta_N1edge, H0edge, t1edge, sqt2edge, t2edge, redge, lcedge, lcinv2edge;
        real g_idealedge;

        // Variables used in NQS-calculations
        `ifdef NQSmodel
        integer SWNQS_i;
        real Gf_ac, xgm_dc, thesat1_dc, xgm_ac, x_m_ac, thesat1_ac, margin_dc, margin_ac;
        real Qp1_0, Qp2_0, Qp3_0, Qp4_0, Qp5_0, Qp6_0, Qp7_0, Qp8_0, Qp9_0, fk1, fk2, fk3, fk4, fk5, fk6, fk7, fk8, fk9, phi_p1, phi_p2, phi_p3;
        real phi_p4, phi_p5, phi_p6, phi_p7, phi_p8, phi_p9, Qp1, Qp2, Qp3, Qp4, Qp5, Qp6, Qp7, Qp8, Qp9, Qp0, QpN, QG_NQS, QS_NQS, QD_NQS, pd;
        real Gp, Gp2, a_factrp, marginp, x_sp, x_dp, zsat_nqs, dfQi, fQi, dQis, dQis_1, d2Qis, dQbs, dQy, d2Qy, dpsy2, ym, inorm, Tnorm, Qb_tmp;
        real QbSIGN, r_nqs, vnorm, vnorm_inv, NQS_xg1, NQS_yg, NQS_z, NQS_eta, NQS_a, NQS_c, NQS_tau, NQS_D0, NQS_xi, NQS_p, NQS_q, NQS_temp;
        real NQS_A_fac, NQS_xbar, NQS_w, NQS_x0, NQS_u, NQS_y0, xphi, fk0, thesat2, Fvsat, temp3, temp4, temp5, temp6, temp7, temp8, temp9;
        `endif // NQSmodel

    //  --------------------------------------------------------------------------------------------------------------
    //  Variables for operating point info
    //  --------------------------------------------------------------------------------------------------------------
        real id_op, is, ig, ib, P_D, facvsb, facvsb0, sig1k, vth_i, vts_i, ids_i;
        `OPP(ctype             ,""             ,"Flag for channel type")  
        `OPP(sdint             ,""             ,"Flag for source-drain interchange")
        `OPP(ise               ,"A"            ,"Total source current")
        `OPP(ige               ,"A"            ,"Total gate current")  
        `OPP(ide               ,"A"            ,"Total drain current") 
        `OPP(ibe               ,"A"            ,"Total bulk current")  
        `OPP(ids               ,"A"            ,"Drain current, excl. edge transistor currents, avalanche, tunnel, GISL, GIDL, and junction currents")
        `OPP(idb               ,"A"            ,"Drain to bulk current")
        `OPP(isb               ,"A"            ,"Source to bulk current")
        `OPP(igs               ,"A"            ,"Gate-source tunneling current")
        `OPP(igd               ,"A"            ,"Gate-drain tunneling current")
        `OPP(igb               ,"A"            ,"Gate-bulk tunneling current")
        `OPP(idedge            ,"A"            ,"Drain current of edge transistors")
        `OPP(igcs              ,"A"            ,"Gate-channel tunneling current (source component)")
        `OPP(igcd              ,"A"            ,"Gate-channel tunneling current (drain component)")
        `OPP(iavl              ,"A"            ,"Substrate current due to weak avelanche")
        `OPP(igisl             ,"A"            ,"Gate-induced source leakage current")
        `OPP(igidl             ,"A"            ,"Gate-induced drain leakage current")
        `OPP(ijs               ,"A"            ,"Total source junction current")
        `OPP(ijsbot            ,"A"            ,"Source junction current (bottom component)")
        `OPP(ijsgat            ,"A"            ,"Source junction current (gate-edge component)")
        `OPP(ijssti            ,"A"            ,"Source junction current (STI-edge component)")
        `OPP(ijd               ,"A"            ,"Total drain junction current")
        `OPP(ijdbot            ,"A"            ,"Drain junction current (bottom component)")
        `OPP(ijdgat            ,"A"            ,"Drain junction current (gate-edge component)")
        `OPP(ijdsti            ,"A"            ,"Drain junction current (STI-edge component)")
        `OPP(vds               ,"V"            ,"Drain-source voltage")
        `OPP(vgs               ,"V"            ,"Gate-source voltage")
        `OPP(vsb               ,"V"            ,"Source-bulk voltage")
        `OPP(vto               ,"V"            ,"Zero-bias threshold voltage")
        `OPP(vts               ,"V"            ,"Threshold voltage including back bias effects")
        `OPP(vth               ,"V"            ,"Threshold voltage including back bias and drain bias effects")
        `OPP(vgt               ,"V"            ,"Effective gate drive voltage including back bias and drain bias effects")
        `OPP(vdss              ,"V"            ,"Drain saturation voltage at actual bias")
        `OPP(vsat              ,""             ,"Saturation limit")
        `ifdef OPderiv
        `OPP(gm                ,"1/Ohm"        ,"Transconductance")
        `OPP(gmb               ,"1/Ohm"        ,"Substrate transconductance")
        `OPP(gds               ,"1/Ohm"        ,"Output conductance")
        `OPP(gjs               ,"1/Ohm"        ,"Source junction conductance")
        `OPP(gjd               ,"1/Ohm"        ,"Drain junction conductance")
        `OPP(cdd               ,"F"            ,"Drain capacitance")
        `OPP(cdg               ,"F"            ,"Drain-gate capacitance")
        `OPP(cds               ,"F"            ,"Drain-source capacitance")
        `OPP(cdb               ,"F"            ,"Drain-bulk capacitance")
        `OPP(cgd               ,"F"            ,"Gate-drain capacitance")
        `OPP(cgg               ,"F"            ,"Gate capacitance")
        `OPP(cgs               ,"F"            ,"Gate-source capacitance")
        `OPP(cgb               ,"F"            ,"Gate-bulk capacitance")
        `OPP(csd               ,"F"            ,"Source-drain capacitance")
        `OPP(csg               ,"F"            ,"Source-gate capacitance")
        `OPP(css               ,"F"            ,"Source capacitance")
        `OPP(csb               ,"F"            ,"Source-bulk capacitance")
        `OPP(cbd               ,"F"            ,"Bulk-drain capacitance")
        `OPP(cbg               ,"F"            ,"Bulk-gate capacitance")
        `OPP(cbs               ,"F"            ,"Bulk-source capacitance")
        `OPP(cbb               ,"F"            ,"Bulk capacitance")
        `OPP(cgsol             ,"F"            ,"Total gate-source overlap capacitance")
        `OPP(cgdol             ,"F"            ,"Total gate-drain overlap capacitance")
        `OPP(cjs               ,"F"            ,"Total source junction capacitance")
        `OPP(cjsbot            ,"F"            ,"Source junction capacitance (bottom component)")
        `OPP(cjsgat            ,"F"            ,"Source junction capacitance (gate-edge component)")
        `OPP(cjssti            ,"F"            ,"Source junction capacitance (STI-edge component)")
        `OPP(cjd               ,"F"            ,"Total drain junction capacitance")
        `OPP(cjdbot            ,"F"            ,"Drain junction capacitance (bottom component)")
        `OPP(cjdgat            ,"F"            ,"Drain junction capacitance (gate-edge component)")
        `OPP(cjdsti            ,"F"            ,"Drain junction capacitance (STI-edge component)")
        `endif // OPderiv
        `OPP(weff              ,"m"            ,"Effective channel width for geometrical models")
        `OPP(leff              ,"m"            ,"Effective channel length for geometrical models")
        `ifdef OPderiv
        `OPP(u                 ,""             ,"Transistor gain")
        `OPP(rout              ,"Ohm"          ,"Small-signal output resistance")
        `OPP(vearly            ,"V"            ,"Equivalent Early voltage")
        `OPP(beff              ,"A/V^2"        ,"Gain factor")
        `OPP(fug               ,"Hz"           ,"Unity gain frequency at actual bias")
        `OPP(rg                ,"Ohm"          ,"Gate resistance")
        `OPP(sfl               ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz")
        `OPP(sqrtsff           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density at 1 kHz")
        `OPP(sqrtsfw           ,"V/sqrt(Hz)"   ,"Input-referred RMS white noise voltage spectral density")
        `OPP(sid               ,"A^2/Hz"       ,"White noise current spectral density")
        `OPP(sig               ,"A^2/Hz"       ,"Induced gate noise current spectral density at 1 Hz")
        `OPP(cigid             ,""             ,"Imaginary part of correlation coefficient between Sig and Sid")
        `OPP(fknee             ,"Hz"           ,"Cross-over frequency above which white noise is dominant")
        `OPP(sigs              ,"A^2/Hz"       ,"Gate-source current noise spectral density")
        `OPP(sigd              ,"A^2/Hz"       ,"Gate-drain current noise spectral density")
        `OPP(siavl             ,"A^2/Hz"       ,"Impact ionization current noise spectral density")
        `OPP(ssi               ,"A^2/Hz"       ,"Total source junction current noise spectral density")
        `OPP(sdi               ,"A^2/Hz"       ,"Total drain junction current noise spectral density")
        `OPP(sfledge           ,"A^2/Hz"       ,"Flicker noise current spectral density at 1 Hz of edge transistors")
        `OPP(sidedge           ,"A^2/Hz"       ,"White noise current spectral density of edge transistors")
        `endif // OPderiv
        // local parameters after scaling, T-scaling, and clipping
        `OPP(lp_vfb            ,"V"            ,"Local parameter VFB after T-scaling and clipping")
        `OPP(lp_stvfb          ,"V/K"          ,"Local parameter STVFB after clipping")
        `OPP(lp_tox            ,"m"            ,"Local parameter TOX after clipping")
        `OPP(lp_epsrox         ,""             ,"Local parameter EPSROX after clipping")
        `OPP(lp_neff           ,"m^-3"         ,"Local parameter NEFF after clipping")
        `OPP(lp_facneffac      ,""             ,"Local parameter FACNEFFAC after clipping")
        `OPP(lp_gfacnud        ,""             ,"Local parameter GFACNUD after clipping")
        `OPP(lp_vsbnud         ,"V"            ,"Local parameter VSBNUD after clipping")
        `OPP(lp_dvsbnud        ,"V"            ,"Local parameter DVSBNUD after clipping")
        `OPP(lp_vnsub          ,"V"            ,"Local parameter VNSUB after clipping")
        `OPP(lp_nslp           ,"V"            ,"Local parameter NSLP after clipping")
        `OPP(lp_dnsub          ,"V^-1"         ,"Local parameter DNSUB after clipping")
        `OPP(lp_dphib          ,"V"            ,"Local parameter DPHIB after clipping")
        `OPP(lp_delvtac        ,"V"            ,"Local parameter DELVTAC after clipping")
        `OPP(lp_np             ,"m^-3"         ,"Local parameter NP after clipping")
        `OPP(lp_ct             ,""             ,"Local parameter CT after clipping")
        `OPP(lp_toxov          ,"m"            ,"Local parameter TOXOV after clipping")
        `OPP(lp_toxovd         ,"m"            ,"Local parameter TOXOVD after clipping")
        `OPP(lp_nov            ,"m^-3"         ,"Local parameter NOV after clipping")
        `OPP(lp_novd           ,"m^-3"         ,"Local parameter NOVD after clipping")
        `OPP(lp_cf             ,""             ,"Local parameter CF after clipping")
        `OPP(lp_cfd            ,"V^-1"         ,"Local parameter CFD after clipping")
        `OPP(lp_cfb            ,"V^-1"         ,"Local parameter CFB after clipping")
        `OPP(lp_psce           ,""             ,"Local parameter PSCE after clipping")
        `OPP(lp_psceb          ,"V^-1"         ,"Local parameter PSCEB after clipping")
        `OPP(lp_psced          ,"V^-1"         ,"Local parameter PSCED after clipping")
        `OPP(lp_betn           ,"m^2/(V s)"    ,"Local parameter BETN after T-scaling and clipping")
        `OPP(lp_stbet          ,""             ,"Local parameter STBET after clipping")
        `OPP(lp_mue            ,"m/V"          ,"Local parameter MUE after T-scaling and clipping")
        `OPP(lp_stmue          ,""             ,"Local parameter STMUE after clipping")
        `OPP(lp_themu          ,""             ,"Local parameter THEMU after T-scaling and clipping")
        `OPP(lp_stthemu        ,""             ,"Local parameter STTHEMU after clipping")
        `OPP(lp_cs             ,""             ,"Local parameter CS after T-scaling and clipping")
        `OPP(lp_stcs           ,""             ,"Local parameter STCS after clipping")
        `OPP(lp_xcor           ,"V^-1"         ,"Local parameter XCOR after T-scaling and clipping")
        `OPP(lp_stxcor         ,""             ,"Local parameter STXCOR after clipping")
        `OPP(lp_feta           ,""             ,"Local parameter FETA after clipping")
        `OPP(lp_rs             ,"Ohm"          ,"Local parameter RS after T-scaling and clipping")
        `OPP(lp_strs           ,""             ,"Local parameter STRS after clipping")
        `OPP(lp_rsb            ,"V^-1"         ,"Local parameter RSB after clipping")
        `OPP(lp_rsg            ,"V^-1"         ,"Local parameter RSG after clipping")
        `OPP(lp_thesat         ,"V^-1"         ,"Local parameter THESAT after T-scaling and clipping")
        `OPP(lp_stthesat       ,""             ,"Local parameter STTHESAT after clipping")
        `OPP(lp_thesatb        ,"V^-1"         ,"Local parameter THESATB after clipping")
        `OPP(lp_thesatg        ,"V^-1"         ,"Local parameter THESATG after clipping")
        `OPP(lp_ax             ,""             ,"Local parameter AX after clipping")
        `OPP(lp_alp            ,""             ,"Local parameter ALP after clipping")
        `OPP(lp_alp1           ,"V"            ,"Local parameter ALP1 after clipping")
        `OPP(lp_alp2           ,"V^-1"         ,"Local parameter ALP2 after clipping")
        `OPP(lp_vp             ,"V"            ,"Local parameter VP after clipping")
        `OPP(lp_a1             ,""             ,"Local parameter A1 after clipping")
        `OPP(lp_a2             ,"V"            ,"Local parameter A2 after T-scaling and clipping")
        `OPP(lp_sta2           ,""             ,"Local parameter STA2 after clipping")
        `OPP(lp_a3             ,""             ,"Local parameter A3 after clipping")
        `OPP(lp_a4             ,"1/sqrt(V)"    ,"Local parameter A4 after clipping")
        `OPP(lp_gco            ,""             ,"Local parameter GCO after clipping")
        `OPP(lp_iginv          ,"A"            ,"Local parameter IGINV after T-scaling and clipping")
        `OPP(lp_igov           ,"A"            ,"Local parameter IGOV after T-scaling and clipping")
        `OPP(lp_igovd          ,"A"            ,"Local parameter IGOVD after T-scaling and clipping")
        `OPP(lp_stig           ,""             ,"Local parameter STIG after clipping")
        `OPP(lp_gc2            ,""             ,"Local parameter GC2 after clipping")
        `OPP(lp_gc3            ,""             ,"Local parameter GC3 after clipping")
        `OPP(lp_chib           ,"V"            ,"Local parameter CHIB after clipping")
        `OPP(lp_agidl          ,"A/V^3"        ,"Local parameter AGIDL after clipping")
        `OPP(lp_agidld         ,"A/V^3"        ,"Local parameter AGIDLD after clipping")
        `OPP(lp_bgidl          ,"V"            ,"Local parameter BGIDL after T-scaling and clipping")
        `OPP(lp_bgidld         ,"V"            ,"Local parameter BGIDLD after T-scaling and clipping")
        `OPP(lp_stbgidl        ,"V/K"          ,"Local parameter STBGIDL after clipping")
        `OPP(lp_stbgidld       ,"V/K"          ,"Local parameter STBGIDLD after clipping")
        `OPP(lp_cgidl          ,""             ,"Local parameter CGIDL after clipping")
        `OPP(lp_cgidld         ,""             ,"Local parameter CGIDLD after clipping")
        `OPP(lp_cox            ,"F"            ,"Local parameter COX after clipping")
        `OPP(lp_cgov           ,"F"            ,"Local parameter CGOV after clipping")
        `OPP(lp_cgovd          ,"F"            ,"Local parameter CGOVD after clipping")
        `OPP(lp_cgbov          ,"F"            ,"Local parameter CGBOV after clipping")
        `OPP(lp_cfr            ,"F"            ,"Local parameter CFR after clipping")
        `OPP(lp_cfrd           ,"F"            ,"Local parameter CFRD after clipping")
        `OPP(lp_fnt            ,""             ,"Local parameter FNT after clipping")
        `OPP(lp_fntexc         ,""             ,"Local parameter FNTEXC after clipping")
        `OPP(lp_nfa            ,"1/(V m^4)"    ,"Local parameter NFA after clipping")
        `OPP(lp_nfb            ,"1/(V m^4)"    ,"Local parameter NFB after clipping")
        `OPP(lp_nfc            ,"V^-1"         ,"Local parameter NFC after clipping")
        `OPP(lp_ef             ,""             ,"Local parameter EF after clipping")
        `OPP(lp_vfbedge        ,"V"            ,"Local parameter VFBEDGE after T-scaling and clipping")
        `OPP(lp_stvfbedge      ,"V/K"          ,"Local parameter STVFBEDGE after clipping")
        `OPP(lp_dphibedge      ,"V"            ,"Local parameter DPHIBEDGE after clipping")
        `OPP(lp_neffedge       ,"m^-3"         ,"Local parameter NEFFEDGE after clipping")
        `OPP(lp_ctedge         ,""             ,"Local parameter CTEDGE after clipping")
        `OPP(lp_betnedge       ,"m^2/V/s"      ,"Local parameter BETNEDGE after T-scaling and clipping")
        `OPP(lp_stbetedge      ,""             ,"Local parameter STBETEDGE after clipping")
        `OPP(lp_psceedge       ,""             ,"Local parameter PSCEEDGE after clipping")
        `OPP(lp_pscebedge      ,"V^-1"         ,"Local parameter PSCEBEDGE after clipping")
        `OPP(lp_pscededge      ,"V^-1"         ,"Local parameter PSCEDEDGE after clipping")
        `OPP(lp_cfedge         ,"V"            ,"Local parameter CFEDGE after clipping")
        `OPP(lp_cfdedge        ,"V^-1"         ,"Local parameter CFDEDGE after clipping")
        `OPP(lp_cfbedge        ,"V^-1"         ,"Local parameter CFBEDGE after clipping")
        `OPP(lp_fntedge        ,""             ,"Local parameter FNTEDGE after clipping")
        `OPP(lp_nfaedge        ,"1/(V m^4)"    ,"Local parameter NFAEDGE after clipping")
        `OPP(lp_nfbedge        ,"1/(V m^4)"    ,"Local parameter NFBEDGE after clipping")
        `OPP(lp_nfcedge        ,"V^-1"         ,"Local parameter NFCEDGE after clipping")
        `OPP(lp_efedge         ,""             ,"Local parameter EFEDGE after clipping")
        `OPP(lp_rg             ,"Ohm"          ,"Local parameter RG after clipping")
        `OPP(lp_rse            ,"Ohm"          ,"Local parameter RSE after clipping")
        `OPP(lp_rde            ,"Ohm"          ,"Local parameter RDE after clipping")
        `OPP(lp_rbulk          ,"Ohm"          ,"Local parameter RBULK after clipping")
        `OPP(lp_rwell          ,"Ohm"          ,"Local parameter RWELL after clipping")
        `OPP(lp_rjuns          ,"Ohm"          ,"Local parameter RJUNS after clipping")
        `OPP(lp_rjund          ,"Ohm"          ,"Local parameter RJUND after clipping")
        `ifdef SelfHeating
        `OPP(lp_rth            ,"K/W"          ,"Local parameter RTH after T-scaling and clipping")
        `OPP(lp_cth            ,"J/K"          ,"Local parameter CTH after clipping")
        `OPP(lp_strth          ,""             ,"Local parameter STRTH after clipping")
        `OPP(pdiss             ,"W"            ,"Power dissipation")
        `OPP(dtsh              ,"K"            ,"Temperature rise due to self heating")
        `endif // SelfHeating
        `OPP(tk                ,"K"            ,"Device Temperature")
        `OPP(cjosbot           ,"F"            ,"Bottom component of total zero-bias source junction capacitance at device temperature")
        `OPP(cjossti           ,"F"            ,"STI-edge component of total zero-bias source junction capacitance at device temperature")
        `OPP(cjosgat           ,"F"            ,"Gate-edge component of total zero-bias source junction capacitance at device temperature")
        `OPP(vbisbot           ,"V"            ,"Built-in voltage of source-side bottom junction at device temperature")
        `OPP(vbissti           ,"V"            ,"Built-in voltage of source-side STI-edge junction at device temperature")
        `OPP(vbisgat           ,"V"            ,"Built-in voltage of source-side gate-edge junction at device temperature")
        `OPP(idsatsbot         ,"A"            ,"Total source-side bottom junction saturation current")
        `OPP(idsatssti         ,"A"            ,"Total source-side STI-edge junction saturation current")
        `OPP(idsatsgat         ,"A"            ,"Total source-side gate-edge junction saturation current")
        `OPP(cjosbotd          ,"F"            ,"Bottom component of total zero-bias drain junction capacitance at device temperature")
        `OPP(cjosstid          ,"F"            ,"STI-edge component of total zero-bias drain junction capacitance at device temperature")
        `OPP(cjosgatd          ,"F"            ,"Gate-edge component of total zero-bias drain junction capacitance at device temperature")
        `OPP(vbisbotd          ,"V"            ,"Built-in voltage of drain-side bottom junction at device temperature")
        `OPP(vbisstid          ,"V"            ,"Built-in voltage of drain-side STI-edge junction at device temperature")
        `OPP(vbisgatd          ,"V"            ,"Built-in voltage of drain-side gate-edge junction at device temperature")
        `OPP(idsatsbotd        ,"A"            ,"Total drain-side bottom junction saturation current")
        `OPP(idsatsstid        ,"A"            ,"Total drain-side STI-edge junction saturation current")
        `OPP(idsatsgatd        ,"A"            ,"Total drain-side gate-edge junction saturation current")
        `ifdef NQSmodel
        `OPP(lp_munqs          ,""             ,"Local parameter MUNQS after clipping")
        `endif // NQSmodel

//  --------------------------------------------------------------------------------------------------------------
//  Analog block with all calculations and contribs
//  --------------------------------------------------------------------------------------------------------------
        analog begin

            //  --------------------------------------------------------------------------------------------------------------
            //  Definition of bias/instance independent model variables
            //  --------------------------------------------------------------------------------------------------------------
`ifdef insideADMS
            @(initial_model)
`endif
            begin : initial_model
            
                // Clipping and rounding of switch parameters
                if (TYPE >= 0) begin
                    CHNL_TYPE   = `NMOS;
                end else begin
                    CHNL_TYPE   = `PMOS;
                end
                EPSSI       = `EPSO * `EPSRSI;
                SWGEO_i     =  floor(`CLIP_BOTH(SWGEO,     0.0, 2.0) + 0.5);
                SWIGATE_i   =  floor(`CLIP_BOTH(SWIGATE,   0.0, 1.0) + 0.5);
                SWIMPACT_i  =  floor(`CLIP_BOTH(SWIMPACT,  0.0, 1.0) + 0.5);
                SWGIDL_i    =  floor(`CLIP_BOTH(SWGIDL,    0.0, 1.0) + 0.5);
                SWJUNCAP_i  =  floor(`CLIP_BOTH(SWJUNCAP,  0.0, 3.0) + 0.5);
                SWJUNASYM_i =  floor(`CLIP_BOTH(SWJUNASYM, 0.0, 1.0) + 0.5);
                SWNUD_i     =  floor(`CLIP_BOTH(SWNUD,     0.0, 2.0) + 0.5);
                SWEDGE_i    =  floor(`CLIP_BOTH(SWEDGE,    0.0, 1.0) + 0.5);
                SWDELVTAC_i =  floor(`CLIP_BOTH(SWDELVTAC, 0.0, 1.0) + 0.5);
                SWIGN_i     =  floor(`CLIP_BOTH(SWIGN, 0.0, 1.0) + 0.5);
                QMC_i       = `CLIP_LOW(QMC, 0.0);
                `ifdef NQSmodel
                if (SWNQS < 0.5) begin
                    SWNQS_i     =  0;
                end else begin
                    if (SWNQS < 1.5) begin
                        SWNQS_i     =  1;
                    end else begin
                        if (SWNQS < 2.5) begin
                            SWNQS_i     =  2;
                        end else begin
                            if (SWNQS < 4.0) begin
                                SWNQS_i     =  3;
                            end else begin
                                if (SWNQS < 7.0) begin
                                    SWNQS_i     =  5;
                                end else begin
                                    SWNQS_i     =  9;
                                end
                            end
                        end
                    end
                end
                inorm       =  1.0e-12;
                r_nqs       =  1.0e3;
                vnorm       =  10.0;
                vnorm_inv   =  1.0 / vnorm;
                `endif // NQSmodel

                // Clipping of global model parameters
                TOXO_i      = `CLIP_LOW(TOXO, 1.0e-10);
                EPSROXO_i   = `CLIP_LOW(EPSROXO, 1.0);
                NSUBO_i     = `CLIP_LOW(NSUBO, 1.0e20);
                WSEG_i      = `CLIP_LOW(WSEG, 1.0e-10);
                NPCK_i      = `CLIP_LOW(NPCK, 0.0);
                WSEGP_i     = `CLIP_LOW(WSEGP, 1.0e-10);
                LPCK_i      = `CLIP_LOW(LPCK, 1.0e-10);
                TOXOVO_i    = `CLIP_LOW(TOXOVO, 1.0e-10);
                TOXOVDO_i   = `CLIP_LOW(TOXOVDO, 1.0e-10);
                LOV_i       = `CLIP_LOW(LOV, 0.0);
                LOVD_i      = `CLIP_LOW(LOVD, 0.0);
                LP1_i       = `CLIP_LOW(LP1, 1.0e-10);
                LP2_i       = `CLIP_LOW(LP2, 1.0e-10);
                WBET_i      = `CLIP_LOW(WBET, 1.0e-10);
                AXL_i       = `CLIP_LOW(AXL, 0.0);
                ALP1L2_i    = `CLIP_LOW(ALP1L2, 0.0);
                ALP2L2_i    = `CLIP_LOW(ALP2L2, 0.0);
                SAREF_i     = `CLIP_LOW(SAREF, 1.0e-9);
                SBREF_i     = `CLIP_LOW(SBREF, 1.0e-9);
                KVSAT_i     = `CLIP_BOTH(KVSAT, -1.0, 1.0);
                LLODKUO_i   = `CLIP_LOW(LLODKUO, 0.0);
                WLODKUO_i   = `CLIP_LOW(WLODKUO, 0.0);
                LLODVTH_i   = `CLIP_LOW(LLODVTH, 0.0);
                WLODVTH_i   = `CLIP_LOW(WLODVTH, 0.0);
                LODETAO_i   = `CLIP_LOW(LODETAO, 0.0);
                SCREF_i     = `CLIP_LOW(SCREF, 0.0);
                WEB_i       =  WEB;
                WEC_i       =  WEC;
                RSHG_i      = `CLIP_LOW(RSHG, 0.0);
                RSH_i       = `CLIP_LOW(RSH, 0.0);
                RSHD_i      = `CLIP_LOW(RSHD, 0.0);
                RINT_i      = `CLIP_LOW(RINT, 0.0);
                RVPOLY_i    = `CLIP_LOW(RVPOLY, 0.0);
                NSUBEDGEO_i = `CLIP_LOW(NSUBEDGEO, 1.0e20);
                LPEDGE_i    = `CLIP_LOW(LPEDGE, 1.0e-10);

                // Transistor temperature
                TR_i        = `CLIP_LOW(TR, -273.0);
                TKR         = `KELVINCONVERSION + TR_i;
                TKA         =  $temperature + DTA;
                rTa         =  TKA / TKR;
                delTa       =  TKA - TKR;
                phita       =  TKA * `KBOL / `QELE;
                inv_phita   =  1.0 / phita;
                `ifdef SelfHeating
                // do nothing
                `else // SelfHeating
                TKD         =  TKA;
                `TempInitialize
                `endif // SelfHeating

                // JUNCAP2
                `include "JUNCAP200_InitModel.include"

            end // initial_model

            //  --------------------------------------------------------------------------------------------------------------
            //  Definition of instance dependent and bias independent variables
            //  --------------------------------------------------------------------------------------------------------------
`ifdef insideADMS
            @(initial_instance)
`endif
            begin : initial_instance

                // Declaration of local variables
                real Invsa, Invsb, Invsaref, Invsbref, Kstressu0, rhobeta, rhobetaref, Kstressvth0;
                real temp0, temp00, templ, tempw, Lx, Wx, loop, tmpa, tmpb;

                // Instance variables
                NF_i        =  1.0;
                invNF       =  1.0;
                LE          =  0.0;
                WE          =  0.0;
                L_i         =  L;
                W_i         =  W;
                SA_i        =  SA;
                SB_i        =  SB;
                SD_i        =  SD;
                SC_i        =  SC;
                XGW_i       =  XGW;
                ABSOURCE_i  =  ABSOURCE;
                LSSOURCE_i  =  LSSOURCE;
                LGSOURCE_i  =  LGSOURCE;
                ABDRAIN_i   =  ABDRAIN;
                LSDRAIN_i   =  LSDRAIN;
                LGDRAIN_i   =  LGDRAIN;
                AS_i        =  AS;
                PS_i        =  PS;
                AD_i        =  AD;
                PD_i        =  PD;
                JW_i        =  JW;

                // Clipping of the instance parameters
                if ((SWGEO_i == 1) || (SWGEO_i == 2)) begin
                    NF_i        = `CLIP_LOW(NF, 1.0);
                    NF_i        =  floor(NF_i + 0.5); // round to nearest integer
                    invNF       =  1.0 / NF_i;
                end
                L_i          = `CLIP_LOW(L_i, 1.0e-9);
                W_i          = `CLIP_LOW(W_i * invNF, 1.0e-9);
                SCA_i        = `CLIP_LOW(SCA, 0.0);
                SCB_i        = `CLIP_LOW(SCB, 0.0);
                SCC_i        = `CLIP_LOW(SCC, 0.0);
                NGCON_i      =  (NGCON < 1.5) ? 1.0 : 2.0;

                // Geometrical device variables
                    // Transistor geometry

                    iL           = `LEN / L_i;
                    iW           = `WEN / W_i;
                    delLPS       =  LVARO * (1.0 + LVARL * iL) * (1.0 + LVARW * iW);
                    delWOD       =  WVARO * (1.0 + WVARL * iL) * (1.0 + WVARW * iW);
                    if (SWGEO_i == 2) begin
                        delLPS       =  LVARO * (1.0 + LVARL * iL);
                        delWOD       =  WVARO * (1.0 + WVARW * iW);
                    end
                    LE           = `CLIP_LOW(L_i + delLPS - 2.0 * LAP, 1.0e-9);
                    WE           = `CLIP_LOW(W_i + delWOD - 2.0 * WOT, 1.0e-9);
                    LEcv         = `CLIP_LOW(L_i + delLPS - 2.0 * LAP + DLQ, 1.0e-9);
                    WEcv         = `CLIP_LOW(W_i + delWOD - 2.0 * WOT + DWQ, 1.0e-9);
                    Lcv          = `CLIP_LOW(L_i + delLPS + DLQ, 1.0e-9);
                    Wcv          = `CLIP_LOW(W_i + delWOD + DWQ, 1.0e-9);
                    iLE          = `LEN / LE;
                    iWE          = `WEN / WE;

                    // Geometry for multi-finger devices
                    L_f          = `CLIP_LOW(L_i + delLPS, 1.0e-9);
                    L_slif       = `CLIP_LOW(L_f + DLSIL, 1.0e-9);
                    W_f          = `CLIP_LOW(W_i + delWOD, 1.0e-9);
                    XGWE         = `CLIP_LOW(XGW_i - 0.5 * delWOD, 1.0e-9);

                    // Local model parameters
                    VFB_p        =  VFB;
                    STVFB_p      =  STVFB;
                    TOX_p        =  TOX;
                    EPSROX_p     =  EPSROX;
                    NEFF_p       =  NEFF;
                    FACNEFFAC_p  =  FACNEFFAC;
                    GFACNUD_p    =  GFACNUD;
                    VSBNUD_p     =  VSBNUD;
                    DVSBNUD_p    =  DVSBNUD;
                    VNSUB_p      =  VNSUB;
                    NSLP_p       =  NSLP;
                    DNSUB_p      =  DNSUB;
                    DPHIB_p      =  DPHIB;
                    DELVTAC_p    =  DELVTAC;
                    NP_p         =  NP;
                    CT_p         =  CT;
                    TOXOV_p      =  TOXOV;
                    TOXOVD_p     =  TOXOVD;
                    NOV_p        =  NOV;
                    NOVD_p       =  NOVD;
                    PSCE_p       =  PSCE;
                    PSCED_p      =  PSCED;
                    PSCEB_p      =  PSCEB;
                    CF_p         =  CF;
                    CFD_p        =  CFD;
                    CFB_p        =  CFB;
                    BETN_p       =  BETN;
                    STBET_p      =  STBET;
                    MUE_p        =  MUE;
                    STMUE_p      =  STMUE;
                    THEMU_p      =  THEMU;
                    STTHEMU_p    =  STTHEMU;
                    CS_p         =  CS;
                    STCS_p       =  STCS;
                    XCOR_p       =  XCOR;
                    STXCOR_p     =  STXCOR;
                    FETA_p       =  FETA;
                    RS_p         =  RS;
                    STRS_p       =  STRS;
                    RSB_p        =  RSB;
                    RSG_p        =  RSG;
                    THESAT_p     =  THESAT;
                    STTHESAT_p   =  STTHESAT;
                    THESATB_p    =  THESATB;
                    THESATG_p    =  THESATG;
                    AX_p         =  AX;
                    ALP_p        =  ALP;
                    ALP1_p       =  ALP1;
                    ALP2_p       =  ALP2;
                    VP_p         =  VP;
                    A1_p         =  A1;
                    A2_p         =  A2;
                    STA2_p       =  STA2;
                    A3_p         =  A3;
                    A4_p         =  A4;
                    GCO_p        =  GCO;
                    IGINV_p      =  IGINV;
                    IGOV_p       =  IGOV;
                    IGOVD_p      =  IGOVD;
                    STIG_p       =  STIG;
                    GC2_p        =  GC2;
                    GC3_p        =  GC3;
                    CHIB_p       =  CHIB;
                    AGIDL_p      =  AGIDL;
                    AGIDLD_p     =  AGIDLD;
                    BGIDL_p      =  BGIDL;
                    BGIDLD_p     =  BGIDLD;
                    STBGIDL_p    =  STBGIDL;
                    STBGIDLD_p   =  STBGIDLD;
                    CGIDL_p      =  CGIDL;
                    CGIDLD_p     =  CGIDLD;
                    COX_p        =  COX;
                    CGOV_p       =  CGOV;
                    CGOVD_p      =  CGOVD;
                    CGBOV_p      =  CGBOV;
                    CFR_p        =  CFR;
                    CFRD_p       =  CFRD;
                    FNT_p        =  FNT;
                    FNTEXC_p     =  FNTEXC;
                    NFA_p        =  NFA;
                    NFB_p        =  NFB;
                    NFC_p        =  NFC;
                    EF_p         =  EF;
                    VFBEDGE_p    =  VFBEDGE;
                    STVFBEDGE_p  =  STVFBEDGE;
                    DPHIBEDGE_p  =  DPHIBEDGE;
                    NEFFEDGE_p   =  NEFFEDGE;
                    CTEDGE_p     =  CTEDGE;
                    BETNEDGE_p   =  BETNEDGE;
                    STBETEDGE_p  =  STBETEDGE;
                    PSCEEDGE_p   =  PSCEEDGE;
                    PSCEBEDGE_p  =  PSCEBEDGE;
                    PSCEDEDGE_p  =  PSCEDEDGE;
                    CFEDGE_p     =  CFEDGE;
                    CFDEDGE_p    =  CFDEDGE;
                    CFBEDGE_p    =  CFBEDGE;
                    FNTEDGE_p    =  FNTEDGE;
                    NFAEDGE_p    =  NFAEDGE;
                    NFBEDGE_p    =  NFBEDGE;
                    NFCEDGE_p    =  NFCEDGE;
                    EFEDGE_p     =  EFEDGE;
                    RG_p         =  RG;   
                    RSE_p        =  RSE;  
                    RDE_p        =  RDE;  
                    RWELL_p      =  RWELL;
                    RBULK_p      =  RBULK;
                    RJUNS_p      =  RJUNS;
                    RJUND_p      =  RJUND;
                    `ifdef SelfHeating
                    RTH_p        =  RTH;
                    CTH_p        =  CTH;
                    STRTH_p      =  STRTH;
                    `endif // SelfHeating
                    `ifdef NQSmodel
                    MUNQS_p      =  MUNQS;
                    `endif // NQSmodel

                    // Geometry scaling with physical scaling rules
                    if (SWGEO_i == 1) begin
                        // Process parameters
                        VFB_p        =  VFBO + VFBL * iLE + VFBW * iWE + VFBLW * iLE * iWE;
                        STVFB_p      =  STVFBO + STVFBL * iLE + STVFBW * iWE + STVFBLW * iLE * iWE;
                        TOX_p        =  TOXO;
                        EPSROX_p     =  EPSROXO;
                        NSUB0e       =  NSUBO_i * `MAX(( 1.0 + NSUBW * iWE * ln( 1.0 + WE / WSEG_i )), 1.0e-03);
                        NPCKe        =  NPCK_i * `MAX(( 1.0 + NPCKW * iWE * ln( 1.0 + WE / WSEGP_i )), 1.0e-03);
                        LPCKe        =  LPCK_i * `MAX(( 1.0 + LPCKW * iWE * ln( 1.0 + WE / WSEGP_i )), 1.0e-03);
                        if (LE > (2.0 * LPCKe)) begin
                            AA           =  7.5e10;
                            BB           =  sqrt(NSUB0e + 0.5 * NPCKe) - sqrt(NSUB0e);
                            NSUB         =  sqrt(NSUB0e) + AA * ln(1.0 + 2.0 * LPCKe / LE * (exp(BB / AA) - 1.0));
                            NSUB         =  NSUB * NSUB;
                        end else begin
                            if (LE >= LPCKe) begin
                                NSUB          =  NSUB0e + NPCKe * LPCKe / LE;
                            end else begin // LE < LPCK
                                NSUB          =  NSUB0e + NPCKe * (2.0 - LE / LPCKe);
                            end
                        end
                        NEFF_p       =  NSUB * (1.0 - FOL1 * iLE - FOL2 * iLE * iLE);
                        FACNEFFAC_p  =  FACNEFFACO + FACNEFFACL * iLE + FACNEFFACW * iWE + FACNEFFACLW * iLE * iWE;
                        GFACNUD_p    =  GFACNUDO + GFACNUDL * pow(iLE, GFACNUDLEXP) + GFACNUDW * iWE + GFACNUDLW * iLE * iWE;
                        VSBNUD_p     =  VSBNUDO;
                        DVSBNUD_p    =  DVSBNUDO;
                        VNSUB_p      =  VNSUBO;
                        NSLP_p       =  NSLPO;
                        DNSUB_p      =  DNSUBO;
                        DPHIB_p      =  DPHIBO + DPHIBL * pow(iLE, DPHIBLEXP) + DPHIBW * iWE + DPHIBLW * iLE * iWE;
                        DELVTAC_p    =  DELVTACO + DELVTACL * pow(iLE, DELVTACLEXP) + DELVTACW * iWE + DELVTACLW * iLE * iWE;
                        NP_p         =  NPO * `MAX(1.0e-6, (1.0 + NPL * iLE));
                        CT_p         =  (CTO + CTL * pow(iLE, CTLEXP)) * (1.0 + CTW * iWE) * (1.0 + CTLW * iLE * iWE);
                        TOXOV_p      =  TOXOVO;
                        TOXOVD_p     =  TOXOVDO;
                        NOV_p        =  NOVO;
                        NOVD_p       =  NOVDO;

                        // DIBL parameters
                        CF_p         =  CFL * pow(iLE, CFLEXP) * (1.0 + CFW * iWE);
                        CFD_p        =  CFDO;
                        CFB_p        =  CFBO;
                                        
                        // Subthreshold slope parameters of short channel transistor
                        PSCE_p       =  PSCEL * pow(iLE, PSCELEXP) * (1.0 + PSCEW * iWE);
                        PSCED_p      =  PSCEDO;
                        PSCEB_p      =  PSCEBO;

                        // Mobility parameters
                        FBET1e       =  FBET1 * (1.0 + FBET1W * iWE);
                        LP1e         =  LP1_i * `MAX(1.0 + LP1W * iWE, 1.0e-03);
                        GPE          =  1.0 + FBET1e * LP1e / LE * (1.0 - exp(-LE / LP1e)) + FBET2 * LP2_i / LE * (1.0 - exp(-LE / LP2_i));
                        GPE          = `MAX(GPE, 1.0e-15);
                        GWE          =  1.0 + BETW1 * iWE + BETW2 * iWE * ln(1.0 + WE / WBET_i);
                        BETN_p       =  UO * WE / (GPE * LE) * GWE;
                        STBET_p      =  STBETO + STBETL * iLE + STBETW * iWE + STBETLW * iLE * iWE;
                        MUE_p        =  MUEO * (1.0 + MUEW * iWE);
                        STMUE_p      =  STMUEO;
                        THEMU_p      =  THEMUO;
                        STTHEMU_p    =  STTHEMUO;
                        CS_p         =  (CSO + CSL * pow(iLE, CSLEXP)) * (1.0 + CSW * iWE) * (1.0 + CSLW * iLE * iWE);
                        STCS_p       =  STCSO;
                        XCOR_p       =  XCORO * (1.0 + XCORL * iLE) * (1.0 + XCORW * iWE) * (1.0 + XCORLW * iLE * iWE);
                        STXCOR_p     =  STXCORO;
                        FETA_p       =  FETAO;

                        // Series resistance
                        RS_p         =  RSW1 * iWE * (1.0 + RSW2 * iWE);
                        STRS_p       =  STRSO;
                        RSB_p        =  RSBO;
                        RSG_p        =  RSGO;

                        // Velocity saturation
                        THESAT_p     =  (THESATO + THESATL* GWE / GPE * pow(iLE, THESATLEXP)) * (1.0 + THESATW * iWE) * (1.0 + THESATLW * iLE * iWE);
                        STTHESAT_p   =  STTHESATO + STTHESATL * iLE + STTHESATW * iWE + STTHESATLW * iLE * iWE;
                        THESATB_p    =  THESATBO;
                        THESATG_p    =  THESATGO;

                        // Saturation voltage
                        AX_p         =  AXO / (1.0 + AXL_i * iLE);

                        // Channel length modulation
                        ALP_p        =  ALPL * pow(iLE, ALPLEXP) * (1.0 + ALPW * iWE);
                        tmpx         =  pow(iLE, ALP1LEXP);
                        ALP1_p       =  ALP1L1 * tmpx * (1.0 + ALP1W * iWE) / (1.0 + ALP1L2_i * iLE * tmpx);
                        tmpx         =  pow(iLE, ALP2LEXP);
                        ALP2_p       =  ALP2L1 * tmpx * (1.0 + ALP2W * iWE) / (1.0 + ALP2L2_i * iLE * tmpx);
                        VP_p         =  VPO;

                        // Impact ionization
                        A1_p         =  A1O * (1.0 + A1L * iLE) * (1.0 + A1W * iWE);
                        A2_p         =  A2O;
                        STA2_p       =  STA2O;
                        A3_p         =  A3O * (1.0 + A3L * iLE) * (1.0 + A3W * iWE);
                        A4_p         =  A4O * (1.0 + A4L * iLE) * (1.0 + A4W * iWE);

                        // Gate current
                        GCO_p        =  GCOO;
                        IGINV_p      =  IGINVLW / (iWE * iLE);
                        IGOV_p       =  IGOVW * LOV_i / (`LEN * iWE);
                        IGOVD_p      =  IGOVDW * LOVD_i / (`LEN * iWE);
                        STIG_p       =  STIGO;
                        GC2_p        =  GC2O;
                        GC3_p        =  GC3O;
                        CHIB_p       =  CHIBO;

                        // GIDL
                        AGIDL_p      =  AGIDLW * LOV_i / (`LEN * iWE);
                        AGIDLD_p     =  AGIDLDW * LOVD_i / (`LEN * iWE);
                        BGIDL_p      =  BGIDLO;
                        BGIDLD_p     =  BGIDLDO;
                        STBGIDL_p    =  STBGIDLO;
                        STBGIDLD_p   =  STBGIDLDO;
                        CGIDL_p      =  CGIDLO;
                        CGIDLD_p     =  CGIDLDO;

                        // Charge model parameters
                        COX_p        = `EPSO * EPSROXO_i * WEcv * LEcv / TOXO_i;
                        CGOV_p       = `EPSO * EPSROXO_i * WEcv * LOV_i / TOXOVO_i;
                        CGOVD_p      = `EPSO * EPSROXO_i * WEcv * LOVD_i / TOXOVDO_i;
                        CGBOV_p      =  CGBOVL * Lcv / `LEN;
                        CFR_p        =  CFRW * Wcv / `WEN;
                        CFRD_p       =  CFRDW * Wcv / `WEN;

                        // Noise model parameters
                        temp0        =  1.0 - 2.0 * LINTNOI * iLE / `LEN;
                        Lnoi         = `MAX(temp0, 1.0e-3);
                        Lred         =  1.0 / pow(Lnoi, ALPNOI);
                        FNT_p        =  FNTO;
                        FNTEXC_p     =  FNTEXCL * BETN_p * BETN_p * iWE * iWE;
                        NFA_p        =  Lred * iWE * iLE * NFALW;
                        NFB_p        =  Lred * iWE * iLE * NFBLW;
                        NFC_p        =  Lred * iWE * iLE * NFCLW;
                        EF_p         =  EFO;

                        // Edge transistors: PSP 103.4
                        WE_edge      =  2.0 * WEDGE + WEDGEW * WE;
                        iWE_edge     = `WEN / WE_edge;
                        VFBEDGE_p    =  VFBEDGEO;
                        STVFBEDGE_p  =  STVFBEDGEO + STVFBEDGEL * iLE + STVFBEDGEW * iWE + STVFBEDGELW * iLE * iWE;
                        DPHIBEDGE_p  =  DPHIBEDGEO + DPHIBEDGEL * pow(iLE, DPHIBEDGELEXP) + DPHIBEDGEW * iWE + DPHIBEDGELW * iLE * iWE;
                        NEFFEDGE_p   =  NSUBEDGEO_i * (1.0 + NSUBEDGEL * iLE ) * ( 1.0 + NSUBEDGEW * iWE) * ( 1.0 + NSUBEDGELW * iLE * iWE);
                        CTEDGE_p     =  CTEDGEO + CTEDGEL * pow(iLE, CTEDGELEXP);
                        GPE_edge     =  1.0 + FBETEDGE * LPEDGE_i / LE * (1.0 - exp(-LE / LPEDGE_i));
                        GPE_edge     = `MAX(GPE_edge, 1.0e-15);
                        BETNEDGE_p   =  UO * WE_edge / (GPE_edge * LE) * (1.0 + BETEDGEW * iWE);
                        STBETEDGE_p  =  STBETEDGEO + STBETEDGEL * iLE + STBETEDGEW * iWE + STBETEDGELW * iLE * iWE;
                        PSCEEDGE_p   =  PSCEEDGEL * pow(iLE, PSCEEDGELEXP) * (1.0 + PSCEEDGEW * iWE);
                        PSCEBEDGE_p  =  PSCEBEDGEO;
                        PSCEDEDGE_p  =  PSCEDEDGEO;
                        CFEDGE_p     =  CFEDGEL * pow(iLE, CFEDGELEXP) * (1.0 + CFEDGEW * iWE);
                        CFDEDGE_p    =  CFDEDGEO;
                        CFBEDGE_p    =  CFBEDGEO;
                        FNTEDGE_p    =  FNTEDGEO;
                        NFAEDGE_p    =  iWE_edge * iLE * NFAEDGELW;
                        NFBEDGE_p    =  iWE_edge * iLE * NFBEDGELW;
                        NFCEDGE_p    =  iWE_edge * iLE * NFCEDGELW;
                        EFEDGE_p     =  EFEDGEO;
                     end

                    // Well proximity effect parameters
                    KVTHOWE      =  KVTHOWEO + KVTHOWEL * iLE + KVTHOWEW * iWE + KVTHOWELW * iLE * iWE;
                    KUOWE        =  KUOWEO + KUOWEL * iLE + KUOWEW * iWE + KUOWELW * iLE * iWE;
 
                    // Geometry scaling with binning scaling rules
                    if (SWGEO_i == 2) begin
                        `include "PSP103_binning.include"
                    end

                    // Parasitic resistance parameters
                    if ((SWGEO_i == 1) || (SWGEO_i == 2)) begin
                        RG_p         =  RSHG_i * (`oneThird * W_f / NGCON_i + XGWE) / (NGCON_i * L_slif) + (RINT_i + RVPOLY_i) / (W_f * L_f) + NF_i * RGO;
                        if (SWJUNASYM == 0) begin
                            RSHD_i       =  RSH_i;
                        end
                        RSE_p        =  NRS * RSH_i;
                        RDE_p        =  NRD * RSHD_i;
                        RWELL_p      =  NF_i * RWELLO;
                        RBULK_p      =  NF_i * RBULKO;
                        RJUNS_p      =  NF_i * RJUNSO;
                        RJUND_p      =  NF_i * RJUNDO;

                        // Self heating effect parameters
                        `ifdef SelfHeating
                        deltaRth     =  RTHW2 + WE / `WEN * (1.0 + RTHLW * LE / `LEN);
                        deltaRth     = `MAX(deltaRth, 1.0e-6);
                        RTH_p        =  RTHO + RTHW1 / deltaRth;
                        CTH_p        =  CTHO + CTHW1 * (CTHW2 + WE / `WEN * (1.0 + CTHLW * LE / `LEN));
                        STRTH_p      =  STRTHO;
                        `endif // SelfHeating

                        // NQS parameters
                        `ifdef NQSmodel
                        MUNQS_p      =  MUNQSO;
                        `endif // NQSmodel

                        // Mechanical stress model
                        tmpa         =  0.0;
                        tmpb         =  0.0;
                        loop         =  0.0;
                        if ((SA_i > 0.0) && (SB_i > 0.0) && ((NF_i == 1.0) || ((NF_i > 1.0) && (SD_i > 0.0)))) begin
                            while (loop < (NF_i - 0.5)) begin
                                tmpa         =  tmpa + 1.0 / (SA_i + 0.5 * L_i + loop * (SD_i + L_i));
                                tmpb         =  tmpb + 1.0 / (SB_i + 0.5 * L_i + loop * (SD_i + L_i));
                                loop         =  loop + 1.0;
                            end
                            Invsa        =  tmpa * invNF;
                            Invsb        =  tmpb * invNF;
                            Invsaref     =  1.0 / (SAREF_i + 0.5 * L_i);
                            Invsbref     =  1.0 / (SBREF_i + 0.5 * L_i);
                            Lx           = `MAX(L_i + delLPS, 1.0e-9);
                            Wx           = `MAX(W_i + delWOD + WLOD, 1.0e-9);
                            templ        =  1.0 / pow(Lx, LLODKUO_i);
                            tempw        =  1.0 / pow(Wx, WLODKUO_i);
                            Kstressu0    =  (1.0 + LKUO * templ + WKUO * tempw + PKUO * templ * tempw) * (1.0 + TKUO * (rTa - 1.0));
                            rhobeta      =  KUO * (Invsa + Invsb) / Kstressu0;
                            rhobetaref   =  KUO * (Invsaref + Invsbref) / Kstressu0;
                            templ        =  1.0 / pow(Lx, LLODVTH_i);
                            tempw        =  1.0 / pow(Wx, WLODVTH_i);
                            Kstressvth0  =  1.0 + LKVTHO * templ + WKVTHO * tempw + PKVTHO * templ * tempw;
                            temp0        =  Invsa + Invsb - Invsaref - Invsbref;
                            //  Parameter adaptations
                            BETN_p       =  BETN_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                            THESAT_p     =  THESAT_p * (1.0 + rhobeta) * (1.0 + KVSAT_i * rhobetaref) / ((1.0 + rhobetaref) * (1.0  + KVSAT_i * rhobeta));
                            VFB_p        =  VFB_p + KVTHO * temp0 / Kstressvth0;
                            CF_p         =  CF_p + STETAO * temp0 / pow(Kstressvth0, LODETAO_i);
                            BETNEDGE_p   =  BETNEDGE_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                            VFBEDGE_p    =  VFBEDGE_p + KVTHO * temp0 / Kstressvth0;
                            CFEDGE_p     =  CFEDGE_p + STETAO * temp0 / pow(Kstressvth0, LODETAO_i);
                        end

                        // Well proximity effect equations
                        if ((SCA_i > 0.0) || (SCB_i > 0.0) || (SCC_i > 0.0) || (SC_i > 0.0)) begin
                            if ((SCA_i == 0.0) && (SCB_i == 0.0) && (SCC_i == 0.0)) begin
                                temp0        =  SC_i + W_i;
                                temp00       =  1.0 / SCREF_i;
                                SCA_i        =  SCREF_i * SCREF_i / (SC_i * temp0);
                                SCB_i        =  ((0.1 * SC_i + 0.01 * SCREF_i) * exp(-10.0 * SC_i * temp00) - (0.1 * temp0 + 0.01 * SCREF_i) * exp(-10.0 * temp0 * temp00)) / W_i;
                                SCC_i        =  ((0.05 * SC_i + 0.0025 * SCREF_i) * exp(-20.0 * SC_i * temp00) - (0.05 * temp0 + 0.0025 * SCREF_i) * exp(-20.0 * temp0 * temp00)) / W_i;
                            end
                            // Parameter adaptations
                            temp0        =  SCA_i + WEB_i * SCB_i + WEC_i * SCC_i;
                            VFB_p        =  VFB_p + KVTHOWE * temp0;
                            BETN_p       =  BETN_p * (1.0 + KUOWE * temp0);
                            VFBEDGE_p    =  VFBEDGE_p + KVTHOWE * temp0;
                            BETNEDGE_p   =  BETNEDGE_p * (1.0 + KUOWE * temp0);
                        end
                    end

                    // Internal parameters (including temperature scaling)
                        // Clipping of the local model parameters
                        VFB_i        =  VFB_p;
                        STVFB_i      =  STVFB_p;
                        TOX_i        = `CLIP_LOW(TOX_p, 1.0e-10);
                        EPSROX_i     = `CLIP_LOW(EPSROX_p, 1.0);
                        NEFF_i       = `CLIP_BOTH(NEFF_p, 1.0e20, 1.0e26);
                        FACNEFFAC_i  = `CLIP_LOW(FACNEFFAC_p, 0.0);
                        GFACNUD_i    = `CLIP_LOW(GFACNUD_p, 0.01);
                        VSBNUD_i     = `CLIP_LOW(VSBNUD_p, 0.0);
                        DVSBNUD_i    = `CLIP_LOW(DVSBNUD_p, 0.1);
                        VNSUB_i      =  VNSUB_p;
                        NSLP_i       = `CLIP_LOW(NSLP_p, 1.0e-3);
                        DNSUB_i      = `CLIP_BOTH(DNSUB_p, 0.0, 1.0);
                        DPHIB_i      =  DPHIB_p;
                        DELVTAC_i    =  DELVTAC_p;
                        NP_i         = `CLIP_LOW(NP_p, 0.0);
                        CT_i         = `CLIP_LOW(CT_p, 0.0);
                        TOXOV_i      = `CLIP_LOW(TOXOV_p, 1.0e-10);
                        TOXOVD_i     = `CLIP_LOW(TOXOVD_p, 1.0e-10);
                        NOV_i        = `CLIP_BOTH(NOV_p, 1.0e20, 1.0e27);
                        NOVD_i       = `CLIP_BOTH(NOVD_p, 1.0e20, 1.0e27);
                        CF_i         = `CLIP_LOW(CF_p, 0.0);
                        CFD_i        = `CLIP_LOW(CFD_p, 0.0);
                        CFB_i        = `CLIP_BOTH(CFB_p, 0.0, 1.0);
                        PSCE_i       = `CLIP_LOW(PSCE_p, 0.0);
                        PSCEB_i      = `CLIP_BOTH(PSCEB_p, 0.0, 1.0);
                        PSCED_i      = `CLIP_LOW(PSCED_p, 0.0);
                        BETN_i       = `CLIP_LOW(BETN_p, 0.0);
                        STBET_i      =  STBET_p;
                        MUE_i        = `CLIP_LOW(MUE_p, 0.0);
                        STMUE_i      =  STMUE_p;
                        THEMU_i      = `CLIP_LOW(THEMU_p, 0.0);
                        STTHEMU_i    =  STTHEMU_p;
                        CS_i         = `CLIP_LOW(CS_p,  0.0);
                        STCS_i       =  STCS_p;
                        XCOR_i       = `CLIP_LOW(XCOR_p, 0.0);
                        STXCOR_i     =  STXCOR_p;
                        FETA_i       = `CLIP_LOW(FETA_p, 0.0);
                        RS_i         = `CLIP_LOW(RS_p, 0.0);
                        STRS_i       =  STRS_p;
                        RSB_i        = `CLIP_BOTH(RSB_p, -0.5, 1.0);
                        RSG_i        = `CLIP_LOW(RSG_p, -0.5);
                        THESAT_i     = `CLIP_LOW(THESAT_p, 0.0);
                        STTHESAT_i   =  STTHESAT_p;
                        THESATB_i    = `CLIP_BOTH(THESATB_p, -0.5, 1.0);
                        THESATG_i    = `CLIP_LOW(THESATG_p, -0.5);
                        AX_i         = `CLIP_LOW(AX_p, 2.0);
                        ALP_i        = `CLIP_LOW(ALP_p, 0.0);
                        ALP1_i       = `CLIP_LOW(ALP1_p, 0.0);
                        ALP2_i       = `CLIP_LOW(ALP2_p, 0.0);
                        VP_i         = `CLIP_LOW(VP_p, 1.0e-10);
                        A1_i         = `CLIP_LOW(A1_p, 0.0);
                        A2_i         = `CLIP_LOW(A2_p, 0.0);
                        STA2_i       =  STA2_p;
                        A3_i         = `CLIP_LOW(A3_p, 0.0);
                        A4_i         = `CLIP_LOW(A4_p, 0.0);
                        GCO_i        = `CLIP_BOTH(GCO_p, -10.0, 10.0);
                        IGINV_i      = `CLIP_LOW(IGINV_p, 0.0);
                        IGOV_i       = `CLIP_LOW(IGOV_p, 0.0);
                        IGOVD_i      = `CLIP_LOW(IGOVD_p, 0.0);
                        STIG_i       =  STIG_p;
                        GC2_i        = `CLIP_BOTH(GC2_p, 0.0, 10.0);
                        GC3_i        = `CLIP_BOTH(GC3_p, -10.0, 10.0);
                        CHIB_i       = `CLIP_LOW(CHIB_p, 1.0);
                        AGIDL_i      = `CLIP_LOW(AGIDL_p, 0.0);
                        AGIDLD_i     = `CLIP_LOW(AGIDLD_p, 0.0);
                        BGIDL_i      = `CLIP_LOW(BGIDL_p, 0.0);
                        BGIDLD_i     = `CLIP_LOW(BGIDLD_p, 0.0);
                        STBGIDL_i    =  STBGIDL_p;
                        STBGIDLD_i   =  STBGIDLD_p;
                        CGIDL_i      =  CGIDL_p;
                        CGIDLD_i     =  CGIDLD_p;
                        COX_i        = `CLIP_LOW(COX_p, 0.0);
                        CGOV_i       = `CLIP_LOW(CGOV_p, 0.0);
                        CGOVD_i      = `CLIP_LOW(CGOVD_p, 0.0);
                        CGBOV_i      = `CLIP_LOW(CGBOV_p, 0.0);
                        CFR_i        = `CLIP_LOW(CFR_p, 0.0);
                        CFRD_i       = `CLIP_LOW(CFRD_p, 0.0);
                        FNT_i        = `CLIP_LOW(FNT_p, 0.0);
                        FNTEXC_i     = `CLIP_LOW(FNTEXC_p, 0.0);
                        NFA_i        = `CLIP_LOW(NFA_p, 0.0);
                        NFB_i        = `CLIP_LOW(NFB_p, 0.0);
                        NFC_i        = `CLIP_LOW(NFC_p, 0.0);
                        EF_i         = `CLIP_LOW(EF_p,  0.0);
                        VFBEDGE_i    =  VFBEDGE_p;
                        STVFBEDGE_i  =  STVFBEDGE_p;
                        DPHIBEDGE_i  =  DPHIBEDGE_p;
                        NEFFEDGE_i   = `CLIP_BOTH(NEFFEDGE_p, 1.0e20, 1.0e26);
                        CTEDGE_i     = `CLIP_LOW(CTEDGE_p, 0.0);
                        BETNEDGE_i   = `CLIP_LOW(BETNEDGE_p, 0.0);
                        STBETEDGE_i  =  STBETEDGE_p;
                        PSCEEDGE_i   = `CLIP_LOW(PSCEEDGE_p, 0.0);
                        PSCEBEDGE_i  = `CLIP_BOTH(PSCEBEDGE_p, 0.0, 1.0);
                        PSCEDEDGE_i  = `CLIP_LOW(PSCEDEDGE_p, 0.0);
                        CFEDGE_i     = `CLIP_LOW(CFEDGE_p, 0.0);
                        CFDEDGE_i    = `CLIP_LOW(CFDEDGE_p, 0.0);
                        CFBEDGE_i    = `CLIP_BOTH(CFBEDGE_p, 0.0, 1.0);
                        FNTEDGE_i    = `CLIP_LOW(FNTEDGE_p, 0.0);
                        NFAEDGE_i    = `CLIP_LOW(NFAEDGE_p, 0.0);
                        NFBEDGE_i    = `CLIP_LOW(NFBEDGE_p, 0.0);
                        NFCEDGE_i    = `CLIP_LOW(NFCEDGE_p, 0.0);
                        EFEDGE_i     = `CLIP_LOW(EFEDGE_p,  0.0);
                        RG_i         = `CLIP_LOW(RG_p, 0.0);
                        RSE_i        = `CLIP_LOW(RSE_p, 0.0);
                        RDE_i        = `CLIP_LOW(RDE_p, 0.0);
                        RBULK_i      = `CLIP_LOW(RBULK_p, 0.0);
                        RJUNS_i      = `CLIP_LOW(RJUNS_p, 0.0);
                        RJUND_i      = `CLIP_LOW(RJUND_p, 0.0);
                        RWELL_i      = `CLIP_LOW(RWELL_p, 0.0);
                        `ifdef SelfHeating
                        RTH_i        = `CLIP_LOW(RTH_p, 1.0e-4);
                        CTH_i        = `CLIP_LOW(CTH_p, 0.0);
                        STRTH_i      =  STRTH_p;
                        `endif // SelfHeating
                        MULT_i       = `CLIP_LOW(MULT * NF_i, 0.0); // Note: NF_i is set to 1 for local model
                        FACTUO_i     = `CLIP_LOW(FACTUO, 0.0);
                        DELVTO_i     =  DELVTO;
                        FACTUOEDGE_i = `CLIP_LOW(FACTUOEDGE, 0.0);
                        DELVTOEDGE_i =  DELVTOEDGE;
                        `ifdef NQSmodel
                        MUNQS_i      = `CLIP_LOW(MUNQS_p, 0.0);
                        `endif // NQSmodel

                        // Ignore drain-side values in case of symmetric junctions
                        if (SWJUNASYM_i == 0) begin
                            TOXOVD_i      =  TOXOV_i;
                            NOVD_i        =  NOV_i;
                            AGIDLD_i      =  AGIDL_i;
                            BGIDLD_i      =  BGIDL_i;
                            STBGIDLD_i    =  STBGIDL_i;
                            CGIDLD_i      =  CGIDL_i;
                            IGOVD_i       =  IGOV_i;
                            CGOVD_i       =  CGOV_i;
                            CFRD_i        =  CFR_i;
                        end

                        // Local process parameters
                        EPSOX        = `EPSO * EPSROX_i;
                        CoxPrime     =  EPSOX / TOX_i;
                        tox_sq       =  TOX_i * TOX_i;
                        Cox_over_q   =  CoxPrime / `QELE;
                        NEFFAC_i     =  FACNEFFAC_i * NEFF_i;
                        NEFFAC_i     = `CLIP_BOTH(NEFFAC_i, 1.0e20, 1.0e26);

                        // QM corrections: initially calculated in PSP103_macrodefs.include (PSP103.3)
                        qq           =  0.0;
                        if (QMC_i > 0.0) begin
                            qq           =  0.4 * `QMN * QMC_i * pow(CoxPrime, `twoThirds);
                            if (CHNL_TYPE==`PMOS) begin
                                qq           = `QMP / `QMN * qq;
                            end
                        end

                        // Electrical field parameters
                        E_eff0       =  1.0e-8 * CoxPrime / EPSSI;
                        eta_mu       =  0.5 * FETA_i;
                        eta_mu1      =  0.5;
                        if (CHNL_TYPE == `PMOS) begin
                            eta_mu       =  `oneThird * FETA_i;
                            eta_mu1      =  `oneThird;
                        end

                        // Linear-saturation transition parameter
                        inv_AX       =  1.0 / AX_i;

                        // CLM parameter
                        inv_VP       =  1.0 / VP_i;

                        // Gate overlap
                        CoxovPrime   =  EPSOX / TOXOV_i;
                        CoxovPrime_d =  EPSOX / TOXOVD_i;
                        GOV_s        =  sqrt(2.0 * `QELE * NOV_i * EPSSI * inv_phita) / CoxovPrime;
                        GOV_d        =  sqrt(2.0 * `QELE * NOVD_i * EPSSI * inv_phita) / CoxovPrime_d;
                        GOV2_s       =  GOV_s * GOV_s;
                        GOV2_d       =  GOV_d * GOV_d;
                        `sp_ovInit(GOV_s, GOV2_s, SP_OV_eps2_s, SP_OV_a_s, SP_OV_delta1_s)
                        `sp_ovInit(GOV_d, GOV2_d, SP_OV_eps2_d, SP_OV_a_d, SP_OV_delta1_d)

                        // Temperature scaling variables
                        `ifdef SelfHeating
                        // do nothing
                        `else // SelfHeating
                        // Initialize variables of edge transistor
                        `TempScaling
                        `endif // SelfHeating

                        // Gate to channel leakage parameters
                        inv_CHIB     =  1.0 / CHIB_i;
                        B_fact       =  4.0 * `oneThird * sqrt(2.0 * `QELE * `MELE * CHIB_i) / `HBAR;
                        BCH          =  B_fact * TOX_i;
                        BOV          =  B_fact * TOXOV_i;
                        BOV_d        =  B_fact * TOXOVD_i;
                        GCQ          =  0.0;
                        if (GC3_i < 0) begin
                            GCQ          =  -0.495 * GC2_i / GC3_i;
                        end
                        tf_ig        =  pow(rTa, STIG_i);
                        IGINV_i      =  IGINV_i * tf_ig;
                        IGOV_i       =  IGOV_i * tf_ig;
                        IGOVD_i      =  IGOVD_i * tf_ig;

                        // GIDL parameters
                        AGIDLs       =  AGIDL_i * 4.0e-18 / (TOXOV_i * TOXOV_i);
                        AGIDLDs      =  AGIDLD_i * 4.0e-18 / (TOXOVD_i * TOXOVD_i);
                        B_fact       = `MAX(1.0 + STBGIDL_i * delTa, 0.0);
                        BGIDL_T      =  BGIDL_i * B_fact;
                        BGIDLs       =  BGIDL_T * TOXOV_i * 5.0e8;
                        B_fact       = `MAX(1.0 + STBGIDLD_i * delTa, 0.0);
                        BGIDLD_T     =  BGIDLD_i * B_fact;
                        BGIDLDs      =  BGIDLD_T * TOXOVD_i * 5.0e8;

                        // Self Heating parameters
                        `ifdef SelfHeating
                            RTH_T        =  RTH_i * pow(rTa, STRTH_i);
                        `endif // SelfHeating

                        // Noise model parameters
                        fac_exc      = `MELE * 1.0e9 * FNTEXC_i;

                        // Conductance of parasitic resistance
                        if (RG_i > 0.0) begin
                            ggate        =  1.0 / RG_i;
                        end else begin
                            ggate        =  0.0;
                        end
                        if (RSE_i > 0.0) begin
                            gsource      =  1.0 / RSE_i;
                        end else begin
                            gsource      =  0.0;
                        end
                        if (RDE_i > 0.0) begin
                            gdrain       =  1.0 / RDE_i;
                        end else begin
                            gdrain       =  0.0;
                        end
                        if (RBULK_i > 0.0) begin
                            gbulk        =  1.0 / RBULK_i;
                        end else begin
                            gbulk        =  0.0;
                        end
                        if (RJUNS_i > 0.0) begin
                            gjuns        =  1.0 / RJUNS_i;
                        end else begin
                            gjuns        =  0.0;
                        end
                        if (RJUND_i > 0.0) begin
                            gjund        =  1.0 / RJUND_i;
                        end else begin
                            gjund        =  0.0;
                        end
                        if (RWELL_i > 0.0) begin
                            gwell        =  1.0 / RWELL_i;
                        end else begin
                            gwell        =  0.0;
                        end

                        // JUNCAP instance parameters
                        ABS_i        =  0.0;
                        LSS_i        =  0.0;
                        LGS_i        =  0.0;
                        ABD_i        =  0.0;
                        LSD_i        =  0.0;
                        LGD_i        =  0.0;
                        jwcorr       =  0.0;
                        jww          =  WE;
                        if (SWGEO_i == 0) begin
                            jww          = `CLIP_LOW(JW_i, `LG_cliplow);
                        end
                        if (SWJUNCAP_i == 3) begin
                            jwcorr       =  1.0;
                        end
                        ABS_i        =  ABSOURCE_i * invNF;
                        LSS_i        =  LSSOURCE_i * invNF;
                        LGS_i        =  LGSOURCE_i * invNF;
                        ABD_i        =  ABDRAIN_i * invNF;
                        LSD_i        =  LSDRAIN_i * invNF;
                        LGD_i        =  LGDRAIN_i * invNF;
                        if ((SWJUNCAP_i == 2) || (SWJUNCAP_i == 3)) begin
                            ABS_i        =  AS_i * invNF;
                            LSS_i        =  PS_i * invNF - jwcorr * jww;
                            LGS_i        =  jww;
                            ABD_i        =  AD_i * invNF;
                            LSD_i        =  PD_i * invNF - jwcorr * jww;
                            LGD_i        =  jww;
                        end
                        if ((SWJUNCAP_i == 1) || (SWJUNCAP_i == 2) || (SWJUNCAP_i == 3)) begin
                            ABSOURCE_i   = `CLIP_LOW(ABS_i, `AB_cliplow);
                            LSSOURCE_i   = `CLIP_LOW(LSS_i, `LS_cliplow);
                            LGSOURCE_i   = `CLIP_LOW(LGS_i, `LG_cliplow);
                            ABDRAIN_i    = `CLIP_LOW(ABD_i, `AB_cliplow);
                            LSDRAIN_i    = `CLIP_LOW(LSD_i, `LS_cliplow);
                            LGDRAIN_i    = `CLIP_LOW(LGD_i, `LG_cliplow);
                        end else begin
                            ABSOURCE_i   =  0.0;
                            LSSOURCE_i   =  0.0;
                            LGSOURCE_i   =  0.0;
                            ABDRAIN_i    =  0.0;
                            LSDRAIN_i    =  0.0;
                            LGDRAIN_i    =  0.0;
                        end

                        // Initialization of JUNCAP (global) variables; required for some verilog-A compilers
                        vbimin_s     =  0.0;
                        vbimin_d     =  0.0;
                        vfmin_s      =  0.0;
                        vfmin_d      =  0.0;
                        vch_s        =  0.0;
                        vch_d        =  0.0;
                        vbbtlim_s    =  0.0;
                        vbbtlim_d    =  0.0;
                        VMAX_s       =  0.0;
                        VMAX_d       =  0.0;
                        exp_VMAX_over_phitd_s =  0.0;
                        exp_VMAX_over_phitd_d =  0.0;
                        ISATFOR1_s   =  0.0;
                        ISATFOR1_d   =  0.0;
                        MFOR1_s      =  1.0;
                        MFOR1_d      =  1.0;
                        ISATFOR2_s   =  0.0;
                        ISATFOR2_d   =  0.0;
                        MFOR2_s      =  1.0;
                        MFOR2_d      =  1.0;
                        ISATREV_s    =  0.0;
                        ISATREV_d    =  0.0;
                        MREV_s       =  1.0;
                        MREV_d       =  1.0;
                        m0flag_s     =  0.0;
                        m0flag_d     =  0.0;
                        xhighf1_s    =  0.0;
                        xhighf1_d    =  0.0;
                        expxhf1_s    =  0.0;
                        expxhf1_d    =  0.0;
                        xhighf2_s    =  0.0;
                        xhighf2_d    =  0.0;
                        expxhf2_s    =  0.0;
                        expxhf2_d    =  0.0;
                        xhighr_s     =  0.0;
                        xhighr_d     =  0.0;
                        expxhr_s     =  0.0;
                        expxhr_d     =  0.0;
                        zflagbot_s   =  1.0;
                        zflagbot_d   =  1.0;
                        zflagsti_s   =  1.0;
                        zflagsti_d   =  1.0;
                        zflaggat_s   =  1.0;
                        zflaggat_d   =  1.0;
                        m0_rev       =  0.0;
                        mcor_rev     =  0.0;
                        I1_cor       =  0.0;
                        I2_cor       =  0.0;
                        I3_cor       =  0.0;
                        I4_cor       =  0.0;
                        I5_cor       =  0.0;
                        tt0          =  0.0;
                        tt1          =  0.0;
                        tt2          =  0.0;
                        zfrac        =  0.0;
                        alphaje      =  0.0;

                        if (SWJUNCAP_i > 0) begin
                            `JuncapInitInstance(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot,   idsatsti,   idsatgat,   vbibot,   vbisti,   vbigat,   PBOT_i,  PSTI_i,  PGAT_i,  VBIRBOT_i,  VBIRSTI_i,  VBIRGAT_i,  VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                            `JuncapInitInstance(ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  idsatbot_d, idsatsti_d, idsatgat_d, vbibot_d, vbisti_d, vbigat_d, PBOTD_i, PSTID_i, PGATD_i, VBIRBOTD_i, VBIRSTID_i, VBIRGATD_i, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)

                            if (SWJUNEXP_i == 1) begin : JUNCAPexpressInit
                                // Local variable declaration
                                `LocalGlobalVars

                                // results computed here are not used elsewhere
                                real ijunbot, ijunsti, ijungat, qjunbot, qjunsti, qjungat;

                                // Initialization of (local) variables; required for some verilog-A compilers
                                ysq          =  0.0;
                                terfc        =  0.0;
                                erfcpos      =  0.0;
                                h1           =  0.0;
                                h2           =  0.0;
                                h2d          =  0.0;
                                h3           =  0.0;
                                h4           =  0.0;
                                h5           =  0.0;
                                idmult       =  0.0;
                                vj           =  0.0;
                                z            =  0.0;
                                zinv         =  0.0;
                                two_psistar  =  0.0;
                                vjlim        =  0.0;
                                vjsrh        =  0.0;
                                vbbt         =  0.0;
                                vav          =  0.0;
                                tmp          =  0.0;
                                id           =  0.0;
                                isrh         =  0.0;
                                vbi_minus_vjsrh =  0.0;
                                wsrhstep     =  0.0;
                                dwsrh        =  0.0;
                                wsrh         =  0.0;
                                wdep         =  0.0;
                                asrh         =  0.0;
                                itat         =  0.0;
                                btat         =  0.0;
                                twoatatoverthreebtat =  0.0;
                                umaxbeforelimiting =  0.0;
                                umax         =  0.0;
                                sqrtumax     =  0.0;
                                umaxpoweronepointfive = 0.0;
                                wgamma       =  0.0;
                                wtat         =  0.0;
                                ktat         =  0.0;
                                ltat         =  0.0;
                                mtat         =  0.0;
                                xerfc        =  0.0;
                                erfctimesexpmtat =  0.0;
                                gammamax     =  0.0;
                                ibbt         =  0.0;
                                Fmaxr        =  0.0;
                                fbreakdown   =  0.0;
                                qjunbot      =  0.0;
                                qjunsti      =  0.0;
                                qjungat      =  0.0;

                                // Computation of JUNCAP-express internal parameters
                                `JuncapExpressInit1(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, VJUNREF_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT_i, CTATBOT_i, vbibot, wdepnulrbot, VBIRBOTinv, PBOT_i, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT_i, VBIRBOT_i, wdepnulrinvbot, fbbtbot, VBRBOT_i, VBRinvbot, PBRBOT_i, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI_i, CTATSTI_i, vbisti, wdepnulrsti, VBIRSTIinv, PSTI_i, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI_i, VBIRSTI_i, wdepnulrinvsti, fbbtsti, VBRSTI_i, VBRinvsti, PBRSTI_i, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT_i, CTATGAT_i, vbigat, wdepnulrgat, VBIRGATinv, PGAT_i, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT_i, VBIRGAT_i, wdepnulrinvgat, fbbtgat, VBRGAT_i, VBRinvgat, PBRGAT_i, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                                `JuncapExpressInit2(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT_i, CTATBOT_i, vbibot, wdepnulrbot, VBIRBOTinv, PBOT_i, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT_i, VBIRBOT_i, wdepnulrinvbot, fbbtbot, VBRBOT_i, VBRinvbot, PBRBOT_i, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI_i, CTATSTI_i, vbisti, wdepnulrsti, VBIRSTIinv, PSTI_i, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI_i, VBIRSTI_i, wdepnulrinvsti, fbbtsti, VBRSTI_i, VBRinvsti, PBRSTI_i, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT_i, CTATGAT_i, vbigat, wdepnulrgat, VBIRGATinv, PGAT_i, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT_i, VBIRGAT_i, wdepnulrinvgat, fbbtgat, VBRGAT_i, VBRinvgat, PBRGAT_i, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s)
                                `JuncapExpressInit3(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, idsatbot, idsatsti, idsatgat, ISATFOR1_s, MFOR1_s, ISATFOR2_s, MFOR2_s, ISATREV_s, MREV_s, m0flag_s)
                                `JuncapExpressInit4(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, FJUNQ_i, cjobot, cjosti, cjogat, zflagbot_s, zflagsti_s, zflaggat_s)
                                `JuncapExpressInit5(ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, ISATFOR1_s, ISATFOR2_s, ISATREV_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s)

                                `JuncapExpressInit1(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, VJUNREFD_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                                `JuncapExpressInit2(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d)
                                `JuncapExpressInit3(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, idsatbot_d, idsatsti_d, idsatgat_d, ISATFOR1_d, MFOR1_d, ISATFOR2_d, MFOR2_d, ISATREV_d, MREV_d, m0flag_d)
                                `JuncapExpressInit4(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, FJUNQD_i, cjobot_d, cjosti_d, cjogat_d, zflagbot_d, zflagsti_d, zflaggat_d)
                                `JuncapExpressInit5(ABDRAIN_i, LSDRAIN_i, LGDRAIN_i, ISATFOR1_d, ISATFOR2_d, ISATREV_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d)
                            end // JUNCAPexpressInit

                        end

            end // initial_instance

            begin : evaluateblock

                // Local variables
                real sigVds, dphit1, phit1, inv_phit1, xg_dc, alpha_dc, dps_dc, qim_dc, qim1_dc, H_dc, FdL_dc, Gvsatinv_dc, Ids, Iimpact;
                real mavl, Igdov, Igsov, Igcd, Igcs, eta_p_ac, Gvsat_ac, Gmob_dL_ac, H0, COX_qm, ijun_s, ijunbot_s, ijunsti_s, ijungat_s;
                real ijun_d, ijunbot_d, ijunsti_d, ijungat_d, qjun_s, qjunbot_s, qjunsti_s, qjungat_s, qjun_d, qjunbot_d, qjunsti_d;
                real qjungat_d, jnoise_s, jnoise_d, Gmob_dc, xitsb_dc, Vdse_dc, Vsbstaredge, Vsbxedge, dphit1edge, phit1edge, inv_phit1edge;
                real Vdspedge, delVgedge, xgedge, xbedge, dxthedge, xnedge_s, qseffedge, xnedge_d, qdseffedge, qdeffedge, qmeffedge, dsqredge;
                real alphabmedge, Idsedge, Sfledge, midedge, sqidedge;  
                `ifdef SelfHeating
                real Pdiss, phit, phit0, BET_i, BETEDGE_i, nt0, nt, THESAT_T, Sfl_prefac, phit0edge, Gfedge2, lnGfedge2, Sfl_prefac_edge;
                real ntedge;
                `endif // SelfHeating
                real temp, temp1, temp2;

                //  --------------------------------------------------------------------------------------------------------------
                //  DC bias dependent quantities (calculations for current contribs)
                //  --------------------------------------------------------------------------------------------------------------
                begin : evaluateStatic
                
                     // Initialize temporary variables
                     temp        =  0.0;
                     temp1       =  0.0;
                     temp2       =  0.0;

                    // Initialization of variables for SHE effect
                    `ifdef SelfHeating
                    TKD          =  TKA + Temp(br_rth);
                    `TempInitialize
                    `TempScaling
                    `endif // SelfHeating
                    QCLM         =  0.0;
                    xs_ov        =  0.0;
                    xd_ov        =  0.0;
                    Vovs         =  0.0;
                    Vovd         =  0.0;
                    Iimpact      =  0.0;
                    mavl         =  0.0;
                        
                    // Initialization of variables for NQS model
                    `ifdef NQSmodel
                    pd           =  1.0;
                    ym           =  0.0;
                    `endif // NQSmodel

                    // Voltage affectations
                    if (CHNL_TYPE == `NMOS) begin
                        Vgs          =  V(GP, SI);
                        Vds          =  V(DI, SI);
                        Vsb          =  V(SI, BP);
                        Vjun_s       = -V(SI, BS);
                        Vjun_d       = -V(DI, BD);
                    end else begin
                        Vgs          = -V(GP, SI);
                        Vds          = -V(DI, SI);
                        Vsb          = -V(SI, BP);
                        Vjun_s       =  V(SI, BS);
                        Vjun_d       =  V(DI, BD);
                    end

                    // Voltages NOT subject to S/D-interchange
                    VgsPrime     =  Vgs;
                    VsbPrime     =  Vsb;
                    VdbPrime     =  Vds + Vsb;
                    VgdPrime     =  Vgs - Vds;
                    xgs_ov       = -VgsPrime * inv_phita;
                    xgd_ov       = -VgdPrime * inv_phita;

                    // Source-drain interchange
                    sigVds       =  1.0;
                    if (Vds < 0.0) begin
                        sigVds       = -1.0;
                        Vgs          =  Vgs - Vds;
                        Vsb          =  Vsb + Vds;
                        Vds          = -Vds;
                    end
                    Vdb          =  Vds + Vsb;
                    Vdsx         =  Vds * Vds / (sqrt(Vds * Vds + 0.01) + 0.1);

                    // Core's model calculation for DC
                    begin : SPcalc_dc

                        // Local variable declaration
                        `SPcalcLocalVarDecl
                        real FdL, qim1_1, r1, r2, s2, dL1;

                        // Conditioning of terminal voltages
                        temp         = `MINA(Vdb, Vsb, bphi_dc) + phix_dc;
                        Vsbstar_dc   =  Vsb - `MINA(temp, 0, aphi_dc) + phix1_dc;
                        Vsbstar_dc_tmp = Vsbstar_dc;

                        // Adapt Vsb for NUD-effect
                        if ((SWNUD_i != 0) && (GFACNUD_i != 1.0)) begin
                            Vmb          =  Vsbstar_dc + 0.5 * (Vds - Vdsx);
                            us           =  sqrt(Vmb + phib_dc) - sqrt_phib_dc;
                            temp         =  2.0 * (us - us1) / us21 - 1.0;
                            usnew        =  us - 0.25 * (1.0 - GFACNUD_i) * us21 * (temp + sqrt(temp * temp + 0.4804530139182));
                            Vmbnew       =  usnew * usnew + (2.0 * sqrt_phib_dc) * usnew;
                            Vsbstar_dc   =  Vmbnew - 0.5 * (Vds - Vdsx);
                        end

                        // Set variables needed in PSP103_SPCalculation.include
                        phib         =  phib_dc;
                        G_0          =  G_0_dc;
                        Vsbstar      =  Vsbstar_dc;
                        FdL          =  1.0;

                        `include "PSP103_SPCalculation.include"

                        if (xg > 0.0) begin
                            qim1_1       =  1.0 / qim1;
                            r1           =  qim * qim1_1;
                            r2           =  phit1 * (alpha * qim1_1);
                            s2           =  ln(1.0 + Vdsx * inv_VP);
                            dL1          =  dL + ALP1_i * (qim1_1 * r1 * s1) + ALP2_i * (qbm * r2 * r2 * s2);
                            FdL          =  (1.0 + dL1 + dL1 * dL1) * GdL;
                        end

                        xg_dc        =  xg;
                        qeff1_dc     =  qeff1;
                        Voxm_dc      =  Voxm;
                        alpha_dc     =  alpha;
                        dps_dc       =  dps;
                        qim_dc       =  qim;
                        qim1_dc      =  qim1;
                        GdL_dc       =  GdL;
                        FdL_dc       =  FdL;
                        H_dc         =  H;
                        eta_p_dc     =  eta_p;
                        Gvsat_dc     =  Gvsat;
                        Gvsatinv_dc  =  Gvsatinv;
                        Gmob_dL_dc   =  Gmob_dL;
                        x_ds_dc      =  x_ds;
                        x_m_dc       =  x_m;
                        Gf_dc        =  Gf;
                        Vdsat_dc     =  Vdsat;
                        Udse_dc      =  Udse;
                        Gmob_dc      =  Gmob;
                        xitsb_dc     =  xitsb;
                        Vdse_dc      =  Vdse;
                        `ifdef NQSmodel
                        xgm_dc       =  xgm;
                        thesat1_dc   =  thesat1;
                        margin_dc    =  margin;
                        `endif // NQSmodel
                    end // SPcalc_dc

                    if (xg_dc <= 0) begin
                        Ids          =  0.0;
                    end else begin
                        // Drain-source current
                        Ids          =  BET_i * (FdL_dc * qim1_dc * dps_dc * Gvsatinv_dc);
                    end

                    // Surface potential in gate overlap regions
                    if (((SWIGATE_i != 0) && ((IGOV_i > 0.0) || (IGOVD_i > 0.0))) || ((SWGIDL_i != 0) && ((AGIDL_i > 0.0) || (AGIDLD_i > 0.0))) || (CGOV_i > 0.0) || (CGOVD_i > 0.0)) begin
                        SP_OV_xg     = 0.5 * (xgs_ov + sqrt(xgs_ov * xgs_ov + SP_OV_eps2_s));
                        xs_ov        = -SP_OV_xg - GOV2_s * 0.5 + GOV_s * sqrt(SP_OV_xg + GOV2_s * 0.25 + SP_OV_a_s) + SP_OV_delta1_s; 
                        SP_OV_xg     = 0.5 * (xgd_ov + sqrt(xgd_ov * xgd_ov + SP_OV_eps2_d));
                        xd_ov        = -SP_OV_xg - GOV2_d * 0.5 + GOV_d * sqrt(SP_OV_xg + GOV2_d * 0.25 + SP_OV_a_d) + SP_OV_delta1_d; 
                        Vovs         = -phita * (xgs_ov + xs_ov);
                        Vovd         = -phita * (xgd_ov + xd_ov);
                    end

                    // Gate current
                    Igsov        =  0.0;
                    Igdov        =  0.0;
                    Igc          =  0.0;
                    Igb          =  0.0;
                    Igcs         =  0.0;
                    Igcd         =  0.0;
                    if (SWIGATE_i != 0) begin
                        if (IGOV_i > 0.0) begin
                            // Gate-source overlap component of gate current
                            zg           =  sqrt(Vovs * Vovs + 1.0e-6) * inv_CHIB;
                            if (GC3_i < 0.0) begin
                                zg           = `MINA(zg, GCQ, 1.0e-6);
                            end
                            temp         =  BOV * (-1.5 + zg * (GC2_i + GC3_i * zg));
                            if (temp > 0.0) begin
                                TP           = `P3(temp);
                            end else begin
                                `expl_low(temp, TP)
                            end
                            Fs1          =  3.0 + xs_ov;
                            Fs2          = -3.0 - GCO_i;
                            Fs3          =  30.0 * VgsPrime;
                            `MNE(Fs1, Fs3, 0.9, temp)
                            `MXE(Fs2, temp, 0.3, Fs)
                            Igsov        =  IGOV_i * (TP * Fs);
                        end

                        if (IGOVD_i > 0.0) begin
                            // Gate-drain overlap component of gate current
                            zg           =  sqrt(Vovd * Vovd + 1.0e-6) * inv_CHIB;
                            if (GC3_i < 0.0) begin
                                zg           = `MINA(zg, GCQ, 1.0e-6);
                            end
                            temp         =  BOV_d * (-1.5 + zg * (GC2_i + GC3_i * zg));
                            if (temp > 0.0) begin
                                TP           = `P3(temp);
                            end else begin
                                `expl_low(temp, TP)
                            end
                            Fs1          =  3.0 + xd_ov;
                            Fs2          = -3.0 - GCO_i;
                            Fs3          =  30.0 * VgdPrime;
                            `MNE(Fs1, Fs3, 0.9, temp)
                            `MXE(Fs2, temp, 0.3, Fs)
                            Igdov        =  IGOVD_i * (TP * Fs);
                        end

                                // Gate-channel component of gate current
                        if (IGINV_i > 0.0) begin
                            if (xg_dc <= 0.0) begin
                                temp         =  pow(Vds / Vdsat_lim, AX_i);
                                Udse_dc      =  Vds * pow(1.0 + temp, -inv_AX) * inv_phit1;
                            end
                            `expl_low(x_ds_dc-Udse_dc, temp)
                            Vm           =  Vsbstar_dc + phit1 * (0.5 * x_ds_dc - ln(0.5 * (1.0 + temp)));
                            Dch          =  GCO_i * phit1;
                            arg2mina     =  Voxm_dc + Dch;
                            psi_t        = `MINA(0.0, arg2mina, 0.01);
                            zg           =  sqrt(Voxm_dc * Voxm_dc + 1.0e-6) * inv_CHIB;
                            if (GC3_i < 0.0) begin
                                zg           = `MINA(zg, GCQ, 1.0e-06);
                            end
                            arg1         =  (x_m_dc + (psi_t - alpha_b - Vm) * inv_phit1);
                            `expl(arg1,Dsi)
                            arg1         = -(Vgs + Vsbstar_dc - Vm) * inv_phit1;
                            `expl(arg1,temp)
                            Dgate        =  Dsi * temp;
                            temp         =  BCH * (-1.5 + zg * (GC2_i + GC3_i * zg));
                            if (temp > 0) begin
                                TP           = `P3(temp);
                            end else begin
                                `expl_low(temp, TP)
                            end
                            Igc0         =  IGINV_i * (TP * ln((1.0 + Dsi) / (1.0 + Dgate)));

                            // Source/drain partitioning of gate-channel current
                            if ((xg_dc <= 0.0) || ((GC2_i == 0.0) && (GC3_i == 0.0))) begin
                                igc          =  1.0;
                                igcd_h       =  0.5;
                            end else begin
                                temp         =  GC2_i + 2.0 * GC3_i * zg;
                                u0           =  CHIB_i / (temp * BCH);
                                x            =  0.5 * (dps_dc / u0);
                                u0_div_H     =  u0 / H_dc;
                                Bg           =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                                Ag           =  0.5 - 3.0 * Bg;
                                if (x < 1.0e-3) begin
                                    xsq          =  x * x;
                                    igc          =  1.0 + xsq * (`oneSixth + u0_div_H * `oneThird + `oneSixth * (xsq * (0.05 + 0.2 * u0_div_H)));
                                    igcd_h       =  0.5 * igc - `oneSixth * (x * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * (xsq * (0.125 + Bg)))));
                                end else begin
                                    inv_x        =  1.0 / x;
                                    `expl(x, ex)
                                    inv_ex       =  1.0 / ex;
                                    temp         =  ex - inv_ex;
                                    temp2        =  ex + inv_ex;
                                    igc          =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                                    igcd_h       =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                                end
                            end
                            Sg           =  0.5 * (1.0 + xg_dc / sqrt(xg_dc * xg_dc + 1.0e-6));
                            Igc          =  Igc0 * igc * Sg;
                            Igcd         =  Igc0 * igcd_h * Sg;
                            Igcs         =  Igc - Igcd;
                            Igb          =  Igc0 * igc * (1.0 - Sg);
                        end // (IGINV >0)
                    end // (SWIGATE != 0)

                    // GIDL/GISL current
                    Igidl        =  0.0;
                    Igisl        =  0.0;
                    if (SWGIDL_i != 0) begin
                        // GIDL current computation
                        if ((AGIDLD_i > 0) && (Vovd < 0)) begin
                            Vtovd        =  sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * (VdbPrime * VdbPrime) + 1.0e-6);
                            temp         = -BGIDLDs / Vtovd;
                            `expl_low(temp, temp2)
                            Igidl        = -AGIDLDs * (VdbPrime * Vovd * Vtovd * temp2);
                        end

                        // GISL current computation
                        if ((AGIDL_i > 0) && (Vovs < 0)) begin
                            Vtovs        =  sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * (VsbPrime * VsbPrime) + 1.0e-6);
                            temp         = -BGIDLs / Vtovs;
                            `expl_low(temp, temp2)
                            Igisl        = -AGIDLs * (VsbPrime * Vovs * Vtovs * temp2);
                        end
                    end // (SWGIDL != 0)

                    // Drain current of edge transistors: PSP 103.4
                    xgedge       =  0.0;
                    qdseffedge   =  0.0;
                    qmeffedge    =  0.0;
                    dsqredge     =  1.0e-40;
                    alphabmedge  =  1.0;
                    Idsedge      =  0.0;
                    if ((SWEDGE_i != 0.0) && (BETNEDGE_i > 0)) begin
                        temp         = `MINA(Vdb, Vsb, bphiedge) + phixedge;
                        Vsbstaredge  =  Vsb - `MINA(temp, 0, aphiedge) + phix1edge;
                        Vsbxedge     =  Vsbstaredge + 0.5 * (Vds - Vdsx);
                        dphit1edge   =  PSCEEDGE_i * (1 + PSCEDEDGE_i * Vdsx)* (1.0 + PSCEBEDGE_i * Vsbxedge); // SCE on subthreshold slope
                        phit1edge    =  phit0edge * (1.0 + dphit1edge);
                        inv_phit1edge =  1.0 / phit1edge;
                        if (CFDEDGE_i < 0.05) begin
                            Vdspedge     =  Vdsx;
                        end else begin
                            Vdspedge     =  2.0 * (sqrt(1.0 + CFDEDGE_i * Vdsx) - 1.0) / CFDEDGE_i;
                        end
                        delVgedge    =  CFEDGE_i * Vdspedge * (1 + CFBEDGE_i * Vsbxedge); // DIBL effect
                        xgedge       =  inv_phit1edge * (Vgs + Vsbstaredge + delVgedge - VFBEDGE_T);
                        xbedge       =  inv_phit1edge * phibedge;
                        dxthedge     =  2.0 * ln(xbedge / Gfedge + sqrt(xbedge));
                        xnedge_s     =  inv_phit1edge * Vsbstaredge;
                        `qi_edge(qseffedge,xgedge,xnedge_s)
                        xnedge_d     =  inv_phit1edge * (Vdse_dc + Vsbstaredge); 
                        if ((qseffedge < 1.0e-3)&(Vdse_dc < 1.0e-6)) begin
                            `expl_low((-xnedge_d + xnedge_s), temp)
                            qdseffedge   =  qseffedge * (temp - 1.0);
                            qdeffedge    =  qdseffedge + qseffedge;
                        end else begin
                            `qi_edge(qdeffedge,xgedge,xnedge_d)
                            qdseffedge   =  qdeffedge - qseffedge;
                        end
                        qmeffedge    =  0.5 * (qdeffedge + qseffedge);
                        dsqredge     =  max(xgedge - qmeffedge, 1.0e-40);
                        alphabmedge  =  1.0 - 0.5 * Gfedge / sqrt(dsqredge + 0.25 * Gfedge2);
                        Idsedge      = -BETEDGE_i * phit1edge * phit1edge * (alphabmedge * qmeffedge  + 1.0) * qdseffedge / Gmob_dc;
                    end

                    // Impact-Ionization
                    if ((xg_dc > 0) && (SWIMPACT_i != 0)) begin
                        delVsat      =  Vds - A3_i * dps_dc;
                        if (delVsat > 0) begin
                            temp2        =  A2_T * ((1.0 + A4_i * (sqrt(phib_dc + Vsbstar_dc) - sqrt_phib_dc)) / (delVsat + 1.0e-30));
                            `expl(-temp2, temp)
                            mavl         =  A1_i * (delVsat * temp);
                            Iimpact      =  mavl * (Ids + Idsedge);
                        end
                    end

                    // Threshold voltage calculation for .OP
                    P_D          =  1.0 + 0.25 * (Gf_dc * kp);
                    facvsb0      =  phib_dc + 2.0 * phit1;
                    facvsb       =  Vsbstar_dc + facvsb0;
                    vts_i        =  VFB_T + P_D * facvsb - Vsbstar_dc + Gf_dc * sqrt(phit1 * facvsb );
                    vth_i        =  vts_i - delVg;

                end // evaluateStatic

                //  --------------------------------------------------------------------------------------------------------------
                //  AC bias dependent quantities (calculations for charge contribs)
                //  --------------------------------------------------------------------------------------------------------------
                begin : evaluateDynamic
                
                    // Core's model calculation for AC
                    begin : SPcalc_ac

                        // Local variable declaration
                        `SPcalcLocalVarDecl

                        // SP calculations
                        if ((SWNUD_i == 1) || (SWDELVTAC_i != 0)) begin
                            if (SWDELVTAC_i != 0) begin
                                // Conditioning of terminal voltages
                                temp         = `MINA(Vdb, Vsb, bphi_ac) + phix_ac;
                                Vsbstar_ac   =  Vsb - `MINA(temp, 0.0, aphi_ac) + phix1_ac;
                                Vsbstar      =  Vsbstar_ac;
                                phib         =  phib_ac;
                                G_0          =  G_0_ac;
                            end else begin
                                Vsbstar      =  Vsbstar_dc_tmp;
                                phib         =  phib_dc;
                                G_0          =  G_0_dc;
                            end

                            `include "PSP103_SPCalculation.include"

                            xg_ac        =  xg;
                            qeff1_ac     =  qeff1;
                            Voxm_ac      =  Voxm;
                            alpha_ac     =  alpha;
                            dps_ac       =  dps;
                            qim_ac       =  qim;
                            GdL_ac       =  GdL;
                            H_ac         =  H;
                            eta_p_ac     =  eta_p;
                            Gvsat_ac     =  Gvsat;
                            Gmob_dL_ac   =  Gmob_dL;
                            `ifdef NQSmodel
                            Gf_ac        =  Gf;
                            x_m_ac       =  x_m;
                            xgm_ac       =  xgm;
                            thesat1_ac   =  thesat1;
                            margin_ac    =  margin;
                            `endif // NQSmodel
                        end else begin
                            xg_ac        =  xg_dc;
                            qeff1_ac     =  qeff1_dc;
                            Voxm_ac      =  Voxm_dc;
                            alpha_ac     =  alpha_dc;
                            dps_ac       =  dps_dc;
                            qim_ac       =  qim_dc;
                            GdL_ac       =  GdL_dc;
                            H_ac         =  H_dc;
                            eta_p_ac     =  eta_p_dc;
                            Gvsat_ac     =  Gvsat_dc;
                            Gmob_dL_ac   =  Gmob_dL_dc;
                            `ifdef NQSmodel
                            Gf_ac        =  Gf_dc;
                            x_m_ac       =  x_m_dc;
                            xgm_ac       =  xgm_dc;
                            thesat1_ac   =  thesat1_dc;
                            margin_ac    =  margin_dc;
                            `endif // NQSmodel
                        end
                    end // SPcalc_ac

                    // Quantum mechanical corrections
                    Vgb          =  Vgs + Vsb;
                    COX_qm       =  COX_i;
                    if (qq > 0.0) begin
                        COX_qm       =  COX_i / (1.0 + qq * pow(qeff1_ac * qeff1_ac + qlim2, -1.0 * `oneSixth));
                    end

                    // Intrinsic charge model
                    if (xg_ac <= 0.0) begin
                        QG           =  Voxm_ac;
                        QI           =  0.0;
                        QD           =  0.0;
                        QB           =  QG;
                    end else begin
                        Fj           =  0.5 * (dps_ac / H_ac);
                        Fj2          =  Fj * Fj;
                        QCLM         =  (1.0 - GdL_ac) * (qim_ac - 0.5 * (alpha_ac * dps_ac));
                        QG           =  Voxm_ac + 0.5 * (eta_p_ac * dps_ac * (Fj * GdL_ac * `oneThird - 1.0 + GdL_ac));
                        temp         =  alpha_ac * dps_ac * `oneSixth;
                        QI           =  GdL_ac * (qim_ac + temp * Fj) + QCLM;
                        QD           =  0.5 * (GdL_ac * GdL_ac * (qim_ac - temp * (1.0 - Fj - 0.2 * Fj2)) + QCLM * (1.0 + GdL_ac));
                        QB           =  QG - QI;
                    end
                    Qg           =  QG * COX_qm;
                    Qd           = -QD * COX_qm;
                    Qb           = -QB * COX_qm;

                    // Extrinsic charge model
                    Qgs_ov       =  CGOV_i * Vovs;
                    Qgd_ov       =  CGOVD_i * Vovd;
                    Qgb_ov       =  CGBOV_i * Vgb;

                    // Outer fringe charge
                    Qfgs         =  CFR_i * VgsPrime;
                    Qfgd         =  CFRD_i * VgdPrime;

                    // Variables for NQS model
                    `ifdef NQSmodel
                    Gp           =  0.0;
                    Gp2          =  0.0;
                    a_factrp     =  0.0;
                    marginp      =  0.0;
                    if (SWNQS_i != 0) begin
                        if (xg_ac <= 0.0) begin
                            ym           =  0.5;
                            pd           =  1.0;
                            Gp           =  Gf_ac;
                        end else begin
                            ym           =  0.5 * ( 1.0 + 0.25 * (dps_ac / H_ac));
                            pd           =  xgm_ac / (xg_ac - x_m_ac);
                            Gp           =  Gf_ac / pd;
                        end
                        Gp2          =  Gp * Gp;
                        a_factrp     =  1.0 + Gp * `invSqrt2;
                        marginp      =  1.0e-5 * a_factrp;
                    end
                    `endif // NQSmodel

                end // evaluateDynamic

                //  --------------------------------------------------------------------------------------------------------------
                //  JUNCAP2 contribs
                //  --------------------------------------------------------------------------------------------------------------
                begin : evaluateStaticDynamic
                    ijun_s       =  0.0;
                    ijunbot_s    =  0.0;
                    ijunsti_s    =  0.0;
                    ijungat_s    =  0.0;
                    ijun_d       =  0.0;
                    ijunbot_d    =  0.0;
                    ijunsti_d    =  0.0;
                    ijungat_d    =  0.0;
                    qjun_s       =  0.0;
                    qjunbot_s    =  0.0;
                    qjunsti_s    =  0.0;
                    qjungat_s    =  0.0;
                    qjun_d       =  0.0;
                    qjunbot_d    =  0.0;
                    qjunsti_d    =  0.0;
                    qjungat_d    =  0.0;
                    if (SWJUNCAP_i > 0) begin
                        if (SWJUNEXP_i == 1) begin
                            `JuncapExpressCurrent(Vjun_s, MFOR1_s, ISATFOR1_s, MFOR2_s, ISATFOR2_s, MREV_s, ISATREV_s, m0flag_s, xhighf1_s, expxhf1_s, xhighf2_s, expxhf2_s, xhighr_s, expxhr_s, ijun_s)
                            `JuncapExpressCurrent(Vjun_d, MFOR1_d, ISATFOR1_d, MFOR2_d, ISATFOR2_d, MREV_d, ISATREV_d, m0flag_d, xhighf1_d, expxhf1_d, xhighf2_d, expxhf2_d, xhighr_d, expxhr_d, ijun_d)
                            begin : evaluateDynamic
                                real tmpv, vjv;
                                `JuncapExpressCharge(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot,   qprefsti,   qprefgat,   qpref2bot,   qpref2sti,   qpref2gat,   vbiinvbot,   vbiinvsti,   vbiinvgat,   one_minus_PBOT,   one_minus_PSTI,   one_minus_PGAT,   vfmin_s, vch_s, zflagbot_s, zflagsti_s, zflaggat_s, qjunbot_s, qjunsti_s, qjungat_s)
                                `JuncapExpressCharge(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qprefsti_d, qprefgat_d, qpref2bot_d, qpref2sti_d, qpref2gat_d, vbiinvbot_d, vbiinvsti_d, vbiinvgat_d, one_minus_PBOT_d, one_minus_PSTI_d, one_minus_PGAT_d, vfmin_d, vch_d, zflagbot_d, zflagsti_d, zflaggat_d, qjunbot_d, qjunsti_d, qjungat_d)
                            end
                        end else begin
                                `juncapcommon(Vjun_s, ABSOURCE_i, LSSOURCE_i, LGSOURCE_i, qprefbot, qpref2bot, vbiinvbot, one_minus_PBOT, idsatbot, CSRHBOT_i, CTATBOT_i, vbibot, wdepnulrbot, VBIRBOTinv, PBOT_i, ftdbot, btatpartbot, atatbot, one_over_one_minus_PBOT, CBBTBOT_i, VBIRBOT_i, wdepnulrinvbot, fbbtbot, VBRBOT_i, VBRinvbot, PBRBOT_i, fstopbot, slopebot, qprefsti, qpref2sti, vbiinvsti, one_minus_PSTI, idsatsti, CSRHSTI_i, CTATSTI_i, vbisti, wdepnulrsti, VBIRSTIinv, PSTI_i, ftdsti, btatpartsti, atatsti, one_over_one_minus_PSTI, CBBTSTI_i, VBIRSTI_i, wdepnulrinvsti, fbbtsti, VBRSTI_i, VBRinvsti, PBRSTI_i, fstopsti, slopesti, qprefgat, qpref2gat, vbiinvgat, one_minus_PGAT, idsatgat, CSRHGAT_i, CTATGAT_i, vbigat, wdepnulrgat, VBIRGATinv, PGAT_i, ftdgat, btatpartgat, atatgat, one_over_one_minus_PGAT, CBBTGAT_i, VBIRGAT_i, wdepnulrinvgat, fbbtgat, VBRGAT_i, VBRinvgat, PBRGAT_i, fstopgat, slopegat, VMAX_s, exp_VMAX_over_phitd_s, vbimin_s, vch_s, vfmin_s, vbbtlim_s, ijunbot_s, qjunbot_s, ijunsti_s, qjunsti_s, ijungat_s, qjungat_s)
                                ijun_s = ABSOURCE_i * ijunbot_s + LSSOURCE_i * ijunsti_s + LGSOURCE_i * ijungat_s;
                                `juncapcommon(Vjun_d, ABDRAIN_i,  LSDRAIN_i,  LGDRAIN_i,  qprefbot_d, qpref2bot_d, vbiinvbot_d, one_minus_PBOT_d, idsatbot_d, CSRHBOTD_i, CTATBOTD_i, vbibot_d, wdepnulrbot_d, VBIRBOTinv_d, PBOTD_i, ftdbot_d, btatpartbot_d, atatbot_d, one_over_one_minus_PBOT_d, CBBTBOTD_i, VBIRBOTD_i, wdepnulrinvbot_d, fbbtbot_d, VBRBOTD_i, VBRinvbot_d, PBRBOTD_i, fstopbot_d, slopebot_d, qprefsti_d, qpref2sti_d, vbiinvsti_d, one_minus_PSTI_d, idsatsti_d, CSRHSTID_i, CTATSTID_i, vbisti_d, wdepnulrsti_d, VBIRSTIinv_d, PSTID_i, ftdsti_d, btatpartsti_d, atatsti_d, one_over_one_minus_PSTI_d, CBBTSTID_i, VBIRSTID_i, wdepnulrinvsti_d, fbbtsti_d, VBRSTID_i, VBRinvsti_d, PBRSTID_i, fstopsti_d, slopesti_d, qprefgat_d, qpref2gat_d, vbiinvgat_d, one_minus_PGAT_d, idsatgat_d, CSRHGATD_i, CTATGATD_i, vbigat_d, wdepnulrgat_d, VBIRGATinv_d, PGATD_i, ftdgat_d, btatpartgat_d, atatgat_d, one_over_one_minus_PGAT_d, CBBTGATD_i, VBIRGATD_i, wdepnulrinvgat_d, fbbtgat_d, VBRGATD_i, VBRinvgat_d, PBRGATD_i, fstopgat_d, slopegat_d, VMAX_d, exp_VMAX_over_phitd_d, vbimin_d, vch_d, vfmin_d, vbbtlim_d, ijunbot_d, qjunbot_d, ijunsti_d, qjunsti_d, ijungat_d, qjungat_d)
                                ijun_d = ABDRAIN_i * ijunbot_d + LSDRAIN_i * ijunsti_d + LGDRAIN_i * ijungat_d;
                        end
                    end

                //  --------------------------------------------------------------------------------------------------------------
                //  NQS and parasitic resistance contribs
                //  --------------------------------------------------------------------------------------------------------------
 
                    // Set initial conditions for NQS model
                    `ifdef NQSmodel
                    `include "PSP103_InitNQS.include"
                    `endif // NQSmodel

                    // Parasitic resistances (including noise)
                    rgatenoise   =  nt0 * ggate;
                    rsourcenoise =  nt0 * gsource;
                    rdrainnoise  =  nt0 * gdrain;
                    rbulknoise   =  nt0 * gbulk;
                    rjunsnoise   =  nt0 * gjuns;
                    rjundnoise   =  nt0 * gjund;
                    rwellnoise   =  nt0 * gwell;

                end // evaluateStaticDynamic

                //  --------------------------------------------------------------------------------------------------------------
                //  Current contribs
                //  --------------------------------------------------------------------------------------------------------------
                begin : loadStatic

                    // Convert back for NMOS-PMOS and Source-Drain interchange
                    if (sigVds > 0.0) begin
                        I(DI, BP)    <+  CHNL_TYPE * MULT_i * Iimpact;
                        I(DI, SI)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                        I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igcs;
                        I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igcd;
                    end else begin
                        I(SI, BP)    <+  CHNL_TYPE * MULT_i * Iimpact;
                        I(SI, DI)    <+  CHNL_TYPE * MULT_i * (Ids + Idsedge);
                        I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igcs;
                        I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igcd;
                    end
                    I(GP, BP)    <+  CHNL_TYPE * MULT_i * Igb;
                    I(GP, SI)    <+  CHNL_TYPE * MULT_i * Igsov;
                    I(GP, DI)    <+  CHNL_TYPE * MULT_i * Igdov;
                    I(SI, BP)    <+  CHNL_TYPE * MULT_i * Igisl;
                    I(DI, BP)    <+  CHNL_TYPE * MULT_i * Igidl;
                    I(BS, SI)    <+  CHNL_TYPE * MULT_i * ijun_s;
                    I(BD, DI)    <+  CHNL_TYPE * MULT_i * ijun_d;

                    `CollapsableR(ggate,   RG_i,    rgatenoise,   G,  GP, "rgate")
                    `CollapsableR(gsource, RSE_i,   rsourcenoise, S,  SI, "rsource")
                    `CollapsableR(gdrain,  RDE_i,   rdrainnoise,  D,  DI, "rdrain")
                    `CollapsableR(gbulk,   RBULK_i, rbulknoise,   BP, BI, "rbulk")
                    `CollapsableR(gjuns,   RJUNS_i, rjunsnoise,   BS, BI, "rjuns")
                    `CollapsableR(gjund,   RJUND_i, rjundnoise,   BD, BI, "rjund")
                    `CollapsableR(gwell,   RWELL_i, rwellnoise,   B,  BI, "rwell")

                    I(DI, SI)  <+  `GMIN * V(DI, SI);

                end // loadStatic

                //  --------------------------------------------------------------------------------------------------------------
                //  ddt() contribs from charges (Note: MULT is handled explicitly)
                //  --------------------------------------------------------------------------------------------------------------
                begin : loadStaticDynamic

                    // Implementation of NQS charges
                    `ifdef NQSmodel
                    `include "PSP103_ChargesNQS.include"
                    `endif // NQSmodel

                    // Implementation of Self heating effect
                    `ifdef SelfHeating
                    begin : self_heating
                        real Pdiss_s, Pdiss_d;
                        Pdiss        =  0.0;
                        Pdiss_s      =  0.0;
                        Pdiss_d      =  0.0;
                        if (RSE_i > 0.0) begin
                            Pdiss_s      =  gsource * V(S, SI) * V(S, SI);
                        end
                        if (RDE_i > 0.0) begin
                            Pdiss_d      =  gdrain * V(D, DI) * V(D, DI);
                        end
                        if (RTH_p > 1.0e-3) begin
                            Pdiss        =  ((Ids + Idsedge) * Vds + Iimpact * (Vds + Vsb) + Pdiss_s + Pdiss_d);
                        end
                        Pwr(br_ith)  <+ -MULT_i * Pdiss;
                        Pwr(br_rth)  <+  ddt(MULT_i * CTH_i * Temp(br_rth));
                        Pwr(br_rth)  <+  MULT_i * Temp(br_rth) / RTH_T;
                    end // self_heating
                    `endif // SelfHeating

                end // loadStaticDynamic

                begin : loadDynamic

                    // Local variable
                    real temp;

                    // Intrinsic MOSFET charges
                    Qs           =  -(Qg + Qb + Qd);

                    // Total outerFringe + overlap for gate-source and gate-drain.
                    Qfgs         =  Qfgs + Qgs_ov;
                    Qfgd         =  Qfgd + Qgd_ov;

                    // JUNCAP2
                    qjun_s       =  ABSOURCE_i * qjunbot_s + LSSOURCE_i * qjunsti_s + LGSOURCE_i * qjungat_s;
                    qjun_d       =  ABDRAIN_i * qjunbot_d + LSDRAIN_i * qjunsti_d + LGDRAIN_i * qjungat_d;

                    // Convert back (undo S-D interchange)
                    if (sigVds < 0.0) begin
                        temp         =  Qd;    // Qd <--> Qs
                        Qd           =  Qs;
                        Qs           =  temp;
                    end

                    I(GP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qg);
                    I(BP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qb);
                    I(DI, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qd);
                    I(GP, SI)    <+  ddt(CHNL_TYPE * MULT_i * Qfgs);
                    I(GP, DI)    <+  ddt(CHNL_TYPE * MULT_i * Qfgd);
                    I(GP, BP)    <+  ddt(CHNL_TYPE * MULT_i * Qgb_ov);
                    I(BS, SI)    <+  ddt(CHNL_TYPE * MULT_i * qjun_s);
                    I(BD, DI)    <+  ddt(CHNL_TYPE * MULT_i * qjun_d);

                end // loadDynamic

                //  --------------------------------------------------------------------------------------------------------------
                //  Noise
                //  --------------------------------------------------------------------------------------------------------------
                begin : noise
`ifdef _XYCE_HACK
                    real sf;
`endif                    
                    // Noise variable calculation
                    Sfl          =  0.0;
                    Sidexc       =  0.0;
                    mid          =  0.0;
                    mig          =  1.0e-40;
                    migid        =  0.0;
                    c_igid       =  0.0;
                    CGeff        =  COX_qm * eta_p_ac;
                    sqid         =  0.0;
                    sqig         =  0.0;
                    Sfledge      =  0.0;
                    midedge      =  0.0;
                    sqidedge     =  0.0;

                    // Channel noise contributions
                    if ((xg_dc > 0.0) && (MULT_i > 0.0) && (BET_i > 0.0)) begin
                        // Flicker noise
                        N1           =  Cox_over_q * alpha_dc * phit;
                        Nm1          =  Cox_over_q * qim1_dc;
                        Delta_N1     =  Cox_over_q * alpha_dc * dps_dc;
                        Sfl          =  (NFA_i - NFB_i * N1 + NFC_i * (N1 * N1)) * ln((Nm1 + 0.5 * Delta_N1) / (Nm1 - 0.5 * Delta_N1));
                        Sfl          =  Sfl + (NFB_i + NFC_i * (Nm1 - 2.0 * N1)) * Delta_N1;
                        Sfl          =  Sfl_prefac * Ids * Gvsatinv_dc * Sfl / N1;
                        Sfl          = `CLIP_LOW(Sfl, 0.0);

                        // Thermal channel noise
                        H0           =  qim1_dc / alpha_dc;
                        t1           =  qim_dc / qim1_dc;
                        sqt2         =  0.5 * `oneSixth * (dps_dc / H0);
                        t2           =  sqt2 * sqt2;
                        r            =  H0 / H_dc - 1.0;
                        lc           = `CLIP_LOW(1.0 - 12.0 * (r * t2), 1.0e-20);
                        lcinv2       =  1.0 / (lc * lc);
                        g_ideal      =  BET_i * (FdL_dc * qim1_dc * Gvsatinv_dc);
                        mid          =  t1 + 12.0 * t2 - 24.0 * ((1.0 + t1) * t2 * r);
                        mid          = `CLIP_LOW(mid, 1.0e-40);
                        mid          =  g_ideal * lcinv2 * mid;
                        if (FNTEXC_i > 0.0) begin
                            // recalculate Gvsat, excluding Gmob-effect
                            temp2_exc    =  qim_dc * xitsb_dc;
                            wsat_exc     =  100.0 * (temp2_exc / (100.0 + temp2_exc));
                            if (THESATG_i < 0) begin
                                temp_exc     = 1.0 / (1.0 - THESATG_i * wsat_exc);
                            end else begin
                                temp_exc     = 1.0 + THESATG_i * wsat_exc;
                            end
                            thesat1_exc  =  THESAT_T * (temp_exc / Gmob_dc);
                            zsat_exc     =  thesat1_exc * thesat1_exc * dps_dc * dps_dc;
                            if (CHNL_TYPE == `PMOS) begin
                                zsat_exc     =  zsat_exc / (1.0 + thesat1_exc * dps_dc);
                            end
                            Gvsat_exc    =  0.5 * (Gmob_dc * (1.0 + sqrt(1.0 + 2.0 * zsat_exc)));
                            gfac         =  Gmob_dc / (Gvsat_exc * lc);
                            Sidexc       =  fac_exc * Ids * Vdse_dc * gfac * gfac;
                            mid          =  mid + Sidexc / nt0;
                        end
                        sqid         =  sqrt(nt * mid);

                        // Induced gate noise
                        if (SWIGN_i == 1) begin
                            mig          =  t1 / 12.0 - t2 * (t1 + 0.2 - 12.0 * t2) - 1.6 * (t2 * (t1 + 1.0 - 12.0 * t2) * r);
                            mig          = `CLIP_LOW(mig, 1.0e-40);
                            mig          =  lcinv2 / g_ideal * mig;
                            migid        =  lcinv2 * sqt2 * (1.0 - 12.0 * t2 - (t1 + 19.2 * t2 - 12.0 * (t1 * t2)) * r);
                            CGeff        =  Gvsat_ac * Gvsat_ac * COX_qm * eta_p_ac / (Gmob_dL_ac * Gmob_dL_ac);
                            if (FNTEXC_i > 0.0) begin
                                mig          =  mig + Sidexc * (1.0 + 12.0 * t2) / (12.0 * g_ideal * g_ideal * nt0);
                                migid        =  migid - Sidexc * sqt2 * (1.0 + r) / (g_ideal * nt0);
                            end
                                sqig         =  sqrt(nt / mig);
                                if (sqid == 0) begin
                                    c_igid       =  0.0;
                                end else begin
                                    c_igid       =  migid * sqig / sqid; // = migid / sqrt(mig * mid);
                                end
                                c_igid       = `CLIP_BOTH(c_igid, 0.0, 1.0);
                        end
                    end

                    // Noise of gate leakage currents
                    shot_igcsx   =  2.0 * `QELE * abs(Igcs);
                    shot_igcdx   =  2.0 * `QELE * abs(Igcd);
                    shot_igsov   =  2.0 * `QELE * abs(Igsov);
                    shot_igdov   =  2.0 * `QELE * abs(Igdov);

                    // Noise of impact ionization currents
                    shot_iavl    =  2.0 * `QELE * ((mavl + 1) * abs(Iimpact));

                    // Noise of junctions (JUNCAP2)
                    jnoisex_s    =  2.0 * `QELE * abs(ijun_s);
                    jnoisex_d    =  2.0 * `QELE * abs(ijun_d);
                    if (sigVds > 0.0) begin
                        shot_igs     =  shot_igcsx + shot_igsov;
                        shot_igd     =  shot_igcdx + shot_igdov;
                        jnoise_s     =  jnoisex_s;
                        jnoise_d     =  jnoisex_d + shot_iavl;
                    end else begin
                        shot_igs     =  shot_igcdx + shot_igsov;
                        shot_igd     =  shot_igcsx + shot_igdov;
                        jnoise_s     =  jnoisex_s + shot_iavl;
                        jnoise_d     =  jnoisex_d;
                    end

                    // Noise of edge transistors: PSP 103.4
                    if ((SWEDGE_i != 0.0) && (BETNEDGE_i > 0) && (xgedge > 0)) begin
                        // Flicker noise of edge transistor
                        temp1        =  4.0 * dsqredge / Gfedge2;
                        anoisedge    =  sqrt(temp1 + 1.0) / (sqrt(temp1 + 1.1) - 1.0);
                        temp1        =  Cox_over_q * phit;
                        N1edge       =  temp1 * anoisedge;
                        Nm1edge      =  temp1 * (qmeffedge + anoisedge);
                        Delta_N1edge = -temp1 * anoisedge * alphabmedge * qdseffedge;
                        Sfledge      =  (NFAEDGE_i - (NFBEDGE_i - NFCEDGE_i * N1edge) * N1edge) * ln((Nm1edge + 0.5 * Delta_N1edge) / (Nm1edge - 0.5 * Delta_N1edge));
                        Sfledge      =  Sfledge + (NFBEDGE_i + NFCEDGE_i * (Nm1edge - 2.0 * N1edge)) * Delta_N1edge;
                        Sfledge      =  Sfl_prefac_edge * Idsedge * Gvsatinv_dc * Sfledge / N1edge;
                        Sfledge      = `CLIP_LOW(Sfledge, 0.0);

                        // Thermal channel noise of edge transistor
                        H0edge       =  phit * (qmeffedge + anoisedge) / anoisedge;
                        t1edge       =  phit1 / phit * qmeffedge / (qmeffedge + anoisedge);
                        sqt2edge     = -0.5 * `oneSixth * phit * alphabmedge * qdseffedge / H0edge;
                        t2edge       =  sqt2edge * sqt2edge;
                        redge        =  anoisedge / alpha_dc * H0edge / H_dc - 1.0;
                        lcedge       = `CLIP_LOW(1.0 - 12.0 * (redge * t2edge), 1.0e-20);
                        lcinv2edge   =  1.0 / (lcedge * lcedge);
                        g_idealedge  =  BETEDGE_i * phit * (qmeffedge + anoisedge) * FdL_dc * Gvsatinv_dc;
                        midedge      =  t1edge + 12.0 * t2edge - 24.0 * ((1.0 + t1edge) * t2edge * redge);
                        midedge      = `CLIP_LOW(midedge, 1.0e-40);
                        midedge      =  g_idealedge * lcinv2edge * midedge;
                        sqidedge     =  sqrt(ntedge * midedge);
                    end

                    // Noise contributions
`ifdef _XYCE_HACK
                    // Xyce/ADMS does not work with the way that PSP 103.4
                    // tries to do correlated noise with only 1 noise node.
                    // This hack basically reverts the PSP noise model back
                    // to the way it was done in PSP 103.3 and older

                    sf = 1.0e+6 * CGeff *mig;   // scale factor from PSP 103.3
                   
                    I(NOI2) <+ V(NOI2);
                    I(NOI2) <+  white_noise((nt / mig)*sf*sf, "igig");
                    I(NOII) <+  -V(NOI2)/sf;
                    I(NOIR)      <+  V(NOIR) / mig;
                    I(NOIC)      <+  ddt(CGeff * V(NOIC));
                    I(GP,SI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
                    I(GP,DI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
                    I(DI,SI)     <+  sigVds * sqrt(MULT_i) * migid * V(NOI2)/sf;
`else
                    I(NOII)      <+  white_noise((nt / mig), "igig");
                    I(NOIR)      <+  V(NOIR) / mig;
                    I(NOIC)      <+  ddt(CGeff * V(NOIC));
                    I(GP,SI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
                    I(GP,DI)     <+ -ddt(sqrt(MULT_i) * 0.5 * CGeff * V(NOIC));
                    I(DI,SI)     <+  sigVds * sqrt(MULT_i) * migid * I(NOII);
`endif // XYCE
                    I(DI,SI)     <+  white_noise(MULT_i * sqid * sqid * (1.0 - c_igid * c_igid), "idid");
                    I(DI,SI)     <+  flicker_noise(MULT_i * Sfl, EF_i, "flicker");
                    I(GP,SI)     <+  white_noise(MULT_i * shot_igs, "igs");
                    I(GP,DI)     <+  white_noise(MULT_i * shot_igd, "igd");
                    I(BS,SI)     <+  white_noise(MULT_i * jnoise_s, "ibs");
                    I(BD,DI)     <+  white_noise(MULT_i * jnoise_d, "ibd");
                    I(DI,SI)     <+  flicker_noise(MULT_i * Sfledge, EFEDGE_i, "flicker");
                    I(DI,SI)     <+  white_noise(MULT_i * sqidedge * sqidedge, "ididedge");

                end // noise

                //  --------------------------------------------------------------------------------------------------------------
                //  Operating point info
                //  --------------------------------------------------------------------------------------------------------------
                begin : OPinfo

                    // Auxiliary variables
                    id_op        =  Ids + Idsedge + Iimpact - Igcd;
                    is           = -Ids - Idsedge - Igcs;
                    ig           =  Igcs + Igcd + Igsov + Igdov + Igb;
                    ib           = -Iimpact - Igb - Igidl - Igisl;
                    sig1k        =  2.0e3 * `PI * CGeff;
                    sig1k        =  sig1k * sig1k * mig;

                    //  Actual operation point output variables
                    sdint        =  sigVds;
                    ctype        =  CHNL_TYPE;
                    if (sigVds < 0.0) begin
                        ise          =  MULT_i * (is - Igdov + Igidl - ijun_d);
                        ige          =  MULT_i * ig;
                        ide          =  MULT_i * (id_op - Igsov + Igisl - ijun_s);
                        ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                        ids          =  MULT_i * Ids;
                        idb          =  MULT_i * (Iimpact + Igisl - ijun_s);
                        isb          =  MULT_i * (Igidl - ijun_d);
                        igs          =  MULT_i * (Igcs + Igdov);
                        igd          =  MULT_i * (Igcd + Igsov);
                        igb          =  MULT_i * Igb;
                        idedge       =  MULT_i * Idsedge;
                        igcs         =  MULT_i * Igcs;
                        igcd         =  MULT_i * Igcd;
                        iavl         =  MULT_i * Iimpact;
                        igisl        =  MULT_i * Igidl;
                        igidl        =  MULT_i * Igisl;
                        if (SWJUNEXP_i == 1) begin
                            ijsbot       =  0.0;
                            ijsgat       =  0.0;
                            ijssti       =  0.0;
                            ijdbot       =  0.0;
                            ijdgat       =  0.0;
                            ijdsti       =  0.0;
                            idsatsbot    =  0.0;
                            idsatssti    =  0.0;
                            idsatsgat    =  0.0;
                            idsatsbotd   =  0.0;
                            idsatsstid   =  0.0;
                            idsatsgatd   =  0.0;
                        end else begin
                            ijsbot       =  MULT_i * ABDRAIN_i * ijunbot_d;
                            ijsgat       =  MULT_i * LGDRAIN_i * ijungat_d;
                            ijssti       =  MULT_i * LSDRAIN_i * ijunsti_d;
                            ijdbot       =  MULT_i * ABSOURCE_i * ijunbot_s;
                            ijdgat       =  MULT_i * LGSOURCE_i * ijungat_s;
                            ijdsti       =  MULT_i * LSSOURCE_i * ijunsti_s;
                            idsatsbot    =  MULT_i * ABSOURCE_i * idsatbot;
                            idsatssti    =  MULT_i * LSSOURCE_i * idsatsti;
                            idsatsgat    =  MULT_i * LGSOURCE_i * idsatgat;
                            idsatsbotd   =  MULT_i * ABDRAIN_i * idsatbot_d;
                            idsatsstid   =  MULT_i * LSDRAIN_i * idsatsti_d;
                            idsatsgatd   =  MULT_i * LGDRAIN_i * idsatgat_d;
                        end
                        ijs          =  MULT_i * ijun_d;
                        ijd          =  MULT_i * ijun_s;
                        vds          =  Vds;
                        vgs          =  Vgs;
                        vsb          =  Vsb;
                        vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                        vts          =  vts_i;
                        vth          =  vth_i;
                        vgt          =  vgs - vth;
                        vdss         =  Vdsat_dc;
                        vsat         =  Vds - vdss;
                        ids_i        =  Ids + Idsedge + Iimpact + Igisl - Igcd - Igsov - ijun_s; // Total drain-current
                        `ifdef OPderiv
                            gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(GP));
                            gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(BP));
                            gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(SI));
                            gjs          =  MULT_i * ddx(ijun_d, V(BD));
                            gjd          =  MULT_i * ddx(ijun_s, V(BS));
                            css          =  CHNL_TYPE * MULT_i * ddx(Qd, V(DI));
                            csg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(GP));
                            csb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(BP));
                            csd          =  css - csg - csb;
                            cgs          = -CHNL_TYPE * MULT_i * ddx(Qg, V(DI));
                            cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(GP));
                            cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(BP));
                            cgd          =  cgg - cgs - cgb;
                            cds          = -CHNL_TYPE * MULT_i * ddx(Qs, V(DI));
                            cdg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(GP));
                            cdb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(BP));
                            cdd          =  cdg + cds + cdb;
                            cbs          = -CHNL_TYPE * MULT_i * ddx(Qb, V(DI));
                            cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(GP));
                            cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(BP));
                            cbd          =  cbb - cbs - cbg;
                            cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(GP));
                            cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(GP));
                            cjsbot       = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                            cjsgat       = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                            cjssti       = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                            cjs          =  cjsbot + cjsgat + cjssti;
                            cjdbot       = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                            cjdgat       = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                            cjdsti       = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                            cjd          =  cjdbot + cjdgat + cjdsti;
                        `endif // OPderiv
                    end else begin
                        ise          =  MULT_i * (is - Igsov + Igisl - ijun_s);
                        ige          =  MULT_i * ig;
                        ide          =  MULT_i * (id_op - Igdov + Igidl - ijun_d);
                        ibe          =  MULT_i * (ib + ijun_s + ijun_d);
                        ids          =  MULT_i * Ids;
                        idb          =  MULT_i * (Iimpact + Igidl - ijun_d);
                        isb          =  MULT_i * (Igisl - ijun_s);
                        igs          =  MULT_i * (Igcs + Igsov);
                        igd          =  MULT_i * (Igcd + Igdov);
                        igb          =  MULT_i * Igb;
                        idedge       =  MULT_i * Idsedge;
                        igcs         =  MULT_i * Igcs;
                        igcd         =  MULT_i * Igcd;
                        iavl         =  MULT_i * Iimpact;
                        igisl        =  MULT_i * Igisl;
                        igidl        =  MULT_i * Igidl;
                        if (SWJUNEXP_i == 1) begin
                            ijsbot       =  0.0;
                            ijsgat       =  0.0;
                            ijssti       =  0.0;
                            ijdbot       =  0.0;
                            ijdgat       =  0.0;
                            ijdsti       =  0.0;
                            idsatsbot    =  0.0;
                            idsatssti    =  0.0;
                            idsatsgat    =  0.0;
                            idsatsbotd   =  0.0;
                            idsatsstid   =  0.0;
                            idsatsgatd   =  0.0;
                        end else begin
                            ijsbot       =  MULT_i * ABSOURCE_i * ijunbot_s;
                            ijsgat       =  MULT_i * LGSOURCE_i * ijungat_s;
                            ijssti       =  MULT_i * LSSOURCE_i * ijunsti_s;
                            ijdbot       =  MULT_i * ABDRAIN_i * ijunbot_d;
                            ijdgat       =  MULT_i * LGDRAIN_i * ijungat_d;
                            ijdsti       =  MULT_i * LSDRAIN_i * ijunsti_d;
                            idsatsbot    =  MULT_i * ABSOURCE_i * idsatbot;
                            idsatssti    =  MULT_i * LSSOURCE_i * idsatsti;
                            idsatsgat    =  MULT_i * LGSOURCE_i * idsatgat;
                            idsatsbotd   =  MULT_i * ABDRAIN_i * idsatbot_d;
                            idsatsstid   =  MULT_i * LSDRAIN_i * idsatsti_d;
                            idsatsgatd   =  MULT_i * LGDRAIN_i * idsatgat_d;
                        end
                        ijs          =  MULT_i * ijun_s;
                        ijd          =  MULT_i * ijun_d;
                        vds          =  Vds;
                        vgs          =  Vgs;
                        vsb          =  Vsb;
                        vto          =  VFB_T + P_D * facvsb0 + Gf_dc * sqrt(phit1 * facvsb0);
                        vts          =  vts_i;
                        vth          =  vth_i;
                        vgt          =  vgs - vth;
                        vdss         =  Vdsat_dc;
                        vsat         =  Vds - vdss;
                        ids_i        =  Ids + Idsedge + Iimpact + Igidl - Igcd - Igdov - ijun_d; // Total drain-current
                        `ifdef OPderiv
                            gm           =  CHNL_TYPE * MULT_i * ddx(ids_i, V(GP));
                            gmb          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(BP));
                            gds          =  CHNL_TYPE * MULT_i * ddx(ids_i, V(DI));
                            gjs          = -MULT_i * ddx(ijun_s, V(SI));
                            gjd          = -MULT_i * ddx(ijun_d, V(DI));
                            cdd          =  CHNL_TYPE * MULT_i * ddx(Qd, V(DI));
                            cdg          = -CHNL_TYPE * MULT_i * ddx(Qd, V(GP));
                            cdb          = -CHNL_TYPE * MULT_i * ddx(Qd, V(BP));
                            cds          =  cdd - cdg - cdb;
                            cgd          = -CHNL_TYPE * MULT_i * ddx(Qg, V(DI));
                            cgg          =  CHNL_TYPE * MULT_i * ddx(Qg, V(GP));
                            cgb          = -CHNL_TYPE * MULT_i * ddx(Qg, V(BP));
                            cgs          =  cgg - cgd - cgb;
                            csd          = -CHNL_TYPE * MULT_i * ddx(Qs, V(DI));
                            csg          = -CHNL_TYPE * MULT_i * ddx(Qs, V(GP));
                            csb          = -CHNL_TYPE * MULT_i * ddx(Qs, V(BP));
                            css          =  csg + csd + csb;
                            cbd          = -CHNL_TYPE * MULT_i * ddx(Qb, V(DI));
                            cbg          = -CHNL_TYPE * MULT_i * ddx(Qb, V(GP));
                            cbb          =  CHNL_TYPE * MULT_i * ddx(Qb, V(BP));
                            cbs          =  cbb - cbd - cbg;
                            cgsol        =  CHNL_TYPE * MULT_i * ddx(Qfgs, V(GP));
                            cgdol        =  CHNL_TYPE * MULT_i * ddx(Qfgd, V(GP));
                            cjsbot       = -MULT_i * CHNL_TYPE * ABSOURCE_i * ddx(qjunbot_s, V(SI));
                            cjsgat       = -MULT_i * CHNL_TYPE * LGSOURCE_i * ddx(qjungat_s, V(SI));
                            cjssti       = -MULT_i * CHNL_TYPE * LSSOURCE_i * ddx(qjunsti_s, V(SI));
                            cjs          =  cjsbot + cjsgat + cjssti;
                            cjdbot       = -MULT_i * CHNL_TYPE * ABDRAIN_i * ddx(qjunbot_d, V(DI));
                            cjdgat       = -MULT_i * CHNL_TYPE * LGDRAIN_i * ddx(qjungat_d, V(DI));
                            cjdsti       = -MULT_i * CHNL_TYPE * LSDRAIN_i * ddx(qjunsti_d, V(DI));
                            cjd          =  cjdbot + cjdgat + cjdsti;
                        `endif // OPderiv
                    end
                    weff         =  WE;
                    leff         =  LE;
                    `ifdef OPderiv
                        if (abs(gds) < 1.0e-18) begin
                            u            =  0.0;
                            rout         =  0.0;
                            vearly       =  0.0;
                        end else begin
                            u            =  gm / gds;
                            rout         =  1.0 / gds;
                            vearly       =  ide / gds;
                        end
                        if (abs(vgt) < 1.0e-12) begin
                            beff         =  0.0;
                        end else begin
                            beff         =  2.0 * abs(ide) / (vgt * vgt);
                        end
                        if (abs(cgg + cgsol + cgdol) < 1.0e-30) begin
                            fug          =  0.0;
                        end else begin
                            fug          =  gm / (2.0 * `PI * (cgg + cgsol + cgdol));
                        end
                        rg           =  RG_i / MULT_i;
                        sfl          =  MULT_i * Sfl;
                        if (abs(gm) < 1.0e-18) begin
                            sqrtsff      =  0.0;
                            sqrtsfw      =  0.0;
                        end else begin
                            sqrtsff      =  sqrt(MULT_i * Sfl / 1000.0) / gm;
                            sqrtsfw      =  sqrt(MULT_i) * sqid / gm;
                        end
                        sid          =  MULT_i * sqid * sqid;
                        sig          =  MULT_i * nt * sig1k / (1.0 + sig1k * mig);
                        cigid        =  c_igid;
                        if (sid == 0.0) begin
                            fknee        =  0.0;
                        end else begin
                            fknee        =  sfl / sid;
                        end
                        siavl        =  MULT_i * shot_iavl;
                        if (sigVds < 0.0) begin
                            sigs         =  MULT_i * (shot_igcsx + shot_igdov);
                            sigd         =  MULT_i * (shot_igcdx + shot_igsov);
                            ssi          =  MULT_i * jnoisex_d;
                            sdi          =  MULT_i * jnoisex_s;
                        end else begin
                            sigs         =  MULT_i * (shot_igcsx + shot_igsov);
                            sigd         =  MULT_i * (shot_igcdx + shot_igdov);
                            ssi          =  MULT_i * jnoisex_s;
                            sdi          =  MULT_i * jnoisex_d;
                        end
                        sfledge      =  MULT_i * Sfledge;
                        sidedge      =  MULT_i * sqidedge;
                    `endif // OPderiv

                    lp_vfb       =  VFB_T;
                    lp_stvfb     =  STVFB_i;
                    lp_tox       =  TOX_i;
                    lp_epsrox    =  EPSROX_i;
                    lp_neff      =  NEFF_i;
                    lp_facneffac =  FACNEFFAC_i;
                    lp_gfacnud   =  GFACNUD_i;
                    lp_vsbnud    =  VSBNUD_i;
                    lp_dvsbnud   =  DVSBNUD_i;
                    lp_vnsub     =  VNSUB_i;
                    lp_nslp      =  NSLP_i;
                    lp_dnsub     =  DNSUB_i;
                    lp_dphib     =  DPHIB_i;
                    lp_delvtac   =  DELVTAC_i;
                    lp_np        =  NP_i;
                    lp_ct        =  CT_i;
                    lp_toxov     =  TOXOV_i;
                    lp_toxovd    =  TOXOVD_i;
                    lp_nov       =  NOV_i;
                    lp_novd      =  NOVD_i;
                    lp_cf        =  CF_i;
                    lp_cfd       =  CFD_i;
                    lp_cfb       =  CFB_i;
                    lp_psce      =  PSCE_i;
                    lp_psceb     =  PSCEB_i;
                    lp_psced     =  PSCED_i;
                    lp_betn      =  BETN_T;
                    lp_stbet     =  STBET_i;
                    lp_mue       =  MUE_T;
                    lp_stmue     =  STMUE_i;
                    lp_themu     =  THEMU_T;
                    lp_stthemu   =  STTHEMU_i;
                    lp_cs        =  CS_T;
                    lp_stcs      =  STCS_i;
                    lp_xcor      =  XCOR_T;
                    lp_stxcor    =  STXCOR_i;
                    lp_feta      =  FETA_i;
                    lp_rs        =  RS_T;
                    lp_strs      =  STRS_i;
                    lp_rsb       =  RSB_i;
                    lp_rsg       =  RSG_i;
                    lp_thesat    =  THESAT_T;
                    lp_stthesat  =  STTHESAT_i;
                    lp_thesatb   =  THESATB_i;
                    lp_thesatg   =  THESATG_i;
                    lp_ax        =  AX_i;
                    lp_alp       =  ALP_i;
                    lp_alp1      =  ALP1_i;
                    lp_alp2      =  ALP2_i;
                    lp_vp        =  VP_i;
                    lp_a1        =  A1_i;
                    lp_a2        =  A2_T;
                    lp_sta2      =  STA2_i;
                    lp_a3        =  A3_i;
                    lp_a4        =  A4_i;
                    lp_gco       =  GCO_i;
                    lp_iginv     =  IGINV_i;
                    lp_igov      =  IGOV_i;
                    lp_igovd     =  IGOVD_i;
                    lp_stig      =  STIG_i;
                    lp_gc2       =  GC2_i;
                    lp_gc3       =  GC3_i;
                    lp_chib      =  CHIB_i;
                    lp_agidl     =  AGIDL_i;
                    lp_agidld    =  AGIDLD_i;
                    lp_bgidl     =  BGIDL_T;
                    lp_bgidld    =  BGIDLD_T;
                    lp_stbgidl   =  STBGIDL_i;
                    lp_stbgidld  =  STBGIDLD_i;
                    lp_cgidl     =  CGIDL_i;
                    lp_cgidld    =  CGIDLD_i;
                    lp_cox       =  COX_i;
                    lp_cgov      =  CGOV_i;
                    lp_cgovd     =  CGOVD_i;
                    lp_cgbov     =  CGBOV_i;
                    lp_cfr       =  CFR_i;
                    lp_cfrd      =  CFRD_i;
                    lp_fnt       =  FNT_i;
                    lp_fntexc    =  FNTEXC_i;
                    lp_nfa       =  NFA_i;
                    lp_nfb       =  NFB_i;
                    lp_nfc       =  NFC_i;
                    lp_ef        =  EF_i;
                    lp_vfbedge   =  VFBEDGE_T;
                    lp_stvfbedge =  STVFBEDGE_i;
                    lp_dphibedge =  DPHIBEDGE_i;
                    lp_neffedge  =  NEFFEDGE_i;
                    lp_ctedge    =  CTEDGE_i;
                    lp_betnedge  =  BETNEDGE_T;
                    lp_stbetedge =  STBETEDGE_i;
                    lp_psceedge  =  PSCEEDGE_i;
                    lp_pscebedge =  PSCEBEDGE_i;
                    lp_pscededge =  PSCEDEDGE_i;
                    lp_cfedge    =  CFEDGE_i;
                    lp_cfdedge   =  CFDEDGE_i;
                    lp_cfbedge   =  CFBEDGE_i;
                    lp_fntedge   =  FNTEDGE_i;
                    lp_nfaedge   =  NFAEDGE_i;
                    lp_nfbedge   =  NFBEDGE_i;
                    lp_nfcedge   =  NFCEDGE_i;
                    lp_efedge    =  EFEDGE_i;
                    lp_rg        =  RG_i;
                    lp_rse       =  RSE_i;
                    lp_rde       =  RDE_i;
                    lp_rbulk     =  RBULK_i;
                    lp_rwell     =  RWELL_i;
                    lp_rjuns     =  RJUNS_i;
                    lp_rjund     =  RJUND_i;
                    `ifdef SelfHeating
                        lp_rth       =  RTH_i;
                        lp_cth       =  CTH_i;
                        lp_strth     =  STRTH_i;
                        pdiss        =  MULT_i * Pdiss;
                        dtsh         =  TKD - TKA;
                    `endif // SelfHeating
                    tk           =  TKD;
                    cjosbot      =  MULT_i * ABSOURCE_i * cjobot;
                    cjossti      =  MULT_i * LSSOURCE_i * cjosti;
                    cjosgat      =  MULT_i * LGSOURCE_i * cjogat;
                    vbisbot      =  vbibot;
                    vbissti      =  vbisti;
                    vbisgat      =  vbigat;
                    cjosbotd     =  MULT_i * ABDRAIN_i * cjobot_d;
                    cjosstid     =  MULT_i * LSDRAIN_i * cjosti_d;
                    cjosgatd     =  MULT_i * LGDRAIN_i * cjogat_d;
                    vbisbotd     =  vbibot_d;
                    vbisstid     =  vbisti_d;
                    vbisgatd     =  vbigat_d;
                    `ifdef NQSmodel
                        lp_munqs     =  MUNQS_i;
                    `endif // NQSmodel

                end // OPinfo
            end // evaluateblock

        end // analogBlock
