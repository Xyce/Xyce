//********************************************************
// **** BSIM6.1.1 released by Sourabh Khandelwal on 07/30/2015 ****/
// ********************************************************
//
// ********************************************************
// * Copyright 2015 Regents of the University of California. 
// * All rights reserved.
// *
// * Project Director: Prof. Chenming Hu.
// * Authors: Yogesh Singh Chauhan, M. A. Karim
// *          Sriramkumar Venugopalan, Harshit Agarwal, Chetan Gupta, Darsen Lu,
// *          Sayeef Salahuddin, Chenming Hu
// ********************************************************
// ********************************************************
// *   NONDISCLOSURE STATEMENT
// Software is distributed as is, completely without warranty or service
// support. The University of California and its employees are not liable
// for the condition or performance of the software.
// The University of California owns the copyright and grants users a perpetual,
// irrevocable, worldwide, non-exclusive, royalty-free license with 
// respect to the software as set forth below.
// The University of California hereby disclaims all implied warranties.
// The University of California grants the users the right to modify, copy,
// and redistribute the software and documentation, both within the user's
// organization and externally, subject to the following restrictions
// 1. The users agree not to charge for the University of California code
// itself but may charge for additions, extensions, or support.
// 2. In any product based on the software, the users agree to acknowledge
// the University of California that developed the software. This
// acknowledgement shall appear in the product documentation.
// 3. The users agree to obey all U.S. Government restrictions governing
// redistribution or export of the software.
// 4. The users agree to reproduce any copyright notice which appears on
// the software on any copy or modification of such made available
// to others
// Agreed to on __July 25, 2015_________________
// By: ___University of California, Berkeley____ 
//     ___Chenming Hu_____________________ 
//     ___Professor in Graduate School _______
// ********************************************************



// ********************************************************
// *  BSIM Bulk MOSFET Model Equations (Verilog-A)
// ********************************************************
`include "constants.vams"
`include "disciplines.vams"

// Disable strobe for improved performance speed
`define DISABLE_STROBE	//To Use DISABLE_STROBE, Activate it here. Used Only at GEOMOD and RGEOMOD
`ifdef DISABLE_STROBE
	`define STROBE(X)
	`define STROBE2(X,Y)
`else
	`define STROBE(X) $strobe(X)
	`define STROBE2(X,Y) $strobe(X,Y)
`endif

// Not all Verilog-A compilers are able to properly collapse
// internal nodes  by shorting branches. To ensure minimal node
// count, comment out the following lines:
`define __RDSMOD__
`define __TNOISW__
`define __RGATEMOD__
`define __RBODYMOD__
`define __SHMOD__


// Normalized pinch-off voltage including PD

`define PO_psip(vg_vfb,gamma,DPD,phif,psip) \
	T1 = 1.0 + DPD; \
	vgfbPD = vg_vfb/T1; \
	gammaPD = gamma/T1; \
	T1 = 0.5*vgfbPD - 3.0*(1.0 + gammaPD/`M_SQRT2); \
	T2 = T1 + sqrt(T1*T1 + 6.0*vgfbPD); \
	if (vgfbPD < 0.0) begin \
		T3 = (vgfbPD - T2) / gammaPD; \
		psip = -ln(1.0 - T2 + T3*T3); \
	end else begin \
		T3 = exp(-T2); \
		T1 = 0.5 * gammaPD; \
		T2 = sqrt(vgfbPD - 1.0 + T3 + T1*T1) - T1; \
		psip = T2*T2 + 1.0 - T3; \
	end \
// BSIMv6's normalized charge-voltage relationship
`define BSIM_q(psip,phib,vch,gam,q) \
	T8 = 0.5*( psip+1.0 + sqrt((psip-1.0)*(psip-1.0) + 0.25*2*2 ) ); \
	sqrtpsip = sqrt(T8); \
	T9 = 1.0+ gam/(2.0*sqrtpsip); \
	T0 = ( 1.0+ (gam/(2.0*sqrtpsip)) )/gam; \
	T1 = psip - 2.0*phib -vch; \
	T2 = T1 - ln(4.0*T0*sqrtpsip); \
	T8 = 0.5*(T2 - 0.201491 - sqrt(T2 * (T2 + 0.402982) + 2.446562)); \
	sqrtpsisa = sqrtpsip; \
	if (T8 <= -68.0) begin \
		T4 = -100.0; \
		T5= 20.0; \
		if (T8 < T4 - 0.5 * T5) \
			T3 = exp(T4); \
		else begin \
			if (T8 > T4 + 0.5 * T5) \
				T3 = exp(T8); \
			else begin \
				T2 = (T8 - T4) / T5; \
				T6 = T2 * T2; \
				T3 = exp(T4 + T5 * ((5.0/64.0) + 0.5*T2 + T6*( (15.0/16.0) - T6*(1.25 - T6)))); \
			end \
		end \
		q = T3 * (1.0 + T1 - T8 -ln(2.0*T0*(T3*2.0*T0+2.0*sqrtpsisa))); \
	end else begin \
		T3 = exp(T8); \
		sqrtpsisainv = 1.0 / sqrtpsisa; \
		T4 = 2.0*T3 + ln(T3*2.0*T0*(T3*2.0*T0+2.0*sqrtpsisa)) - T1; \
		T5 = 2.0 + (1.0/T3) + (T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa); \
		T3 = T3 - T4/T5; \
		T4 = 2.0*T3 + ln(T3*2.0*T0*(T3*2.0*T0+2.0*sqrtpsisa)) - T1; \
		T5 = 2.0 + (1.0/T3) + (T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa); \
		T6 = ((T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa))*((T0 - sqrtpsisainv)/(T0*T3 + sqrtpsisa)); \
		T7 = -((1.0/T3)*(1.0/T3)) -(1.0/(sqrtpsisa*sqrtpsisa*sqrtpsisa*(T0*T3+sqrtpsisa))) - T6; \
		q = T3 - (T4/T5)*( 1.0 + T4*T7/(2.0*T5*T5)); \
	end \

// Smoothing function for (max of x, x0 with deltax)
`define Smooth(x,x0,deltax,xsmooth) \
	xsmooth = 0.5*( x+x0 + sqrt((x-x0)*(x-x0) + 0.25*deltax*deltax ) ); \
// Smoothing function for (max of x, x0 with deltax)
`define Smooth1(x,x0,deltax,xsmooth) \
	xsmooth = 0.5*( x+x0 + sqrt((x-x0)*(x-x0) + 0.25*deltax*deltax ) ) - 0.25*deltax; \
// Smoothing function for (min of x, x0 with deltax)
`define Smooth2(x,x0,deltax,xsmooth) \
	xsmooth = 0.5*( x+x0 - sqrt((x-x0)*(x-x0) + 0.25*deltax*deltax ) ) + 0.25*deltax; \

// Smoothing function for (min of x, x0 with deltax)
`define Min1(x,x0,deltax,xsmooth) \
	xsmooth = 0.5*( x+x0 - sqrt((x-x0)*(x-x0) + 0.25*deltax*deltax ) ) ; \

/*
 * These macros represent the subroutines to process the geometry dependent
 * parasitics for BSIM6, which calculates Ps, Pd, As, Ad, and Rs and Rd
 * for multi-fingers and various GEO and RGEO options.
 */
//Define GEOMOD and RGEOMOD in the Modelcard
`define BSIM6NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
	if ((nf%2) != 0) begin \
		nuEndD = 1.0; \
		nuEndS = 1.0; \
		nuIntD = 2.0 * max((nf - 1.0) / 2.0, 0.0); \
		nuIntS = nuIntD; \
	end else begin \
		if (minSD == 1) begin \
			nuEndD = 2.0; \
			nuIntD = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
			nuEndS = 0.0; \
			nuIntS = nf; \
		end else begin \
			nuEndD = 0.0; \
			nuIntD = nf; \
			nuEndS = 2.0; \
			nuIntS = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
		end \
	end


`define BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, TYPE, Rend) \
	if (TYPE == 1) begin \
		case(rgeo) \
		1, 2, 5: begin \
			if (nuEnd == 0.0) \
				Rend = 0.0; \
			else \
				Rend = Rsh * DMCG / (Weffcj * nuEnd); \
		end \
		3, 4, 6: begin \
			if ((DMCG + DMCI) == 0.0) \
				`STROBE("(DMCG + DMCI) can not be equal to zero"); \
			if (nuEnd == 0.0) \
				Rend = 0.0; \
			else \
				Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
		end \
		default: begin \
			`STROBE2("Warning: (instance %M) Specified RGEO = %d not matched (BSIM6RdsEndIso), \
			Rend is set to zero.", rgeo); \
			Rend = 0.0; \
		end \
		endcase \
	end \
	else begin \
		case(rgeo) \
		1, 3, 7: begin \
			if (nuEnd == 0.0) \
				Rend = 0.0; \
			else \
				Rend = Rsh * DMCG / (Weffcj * nuEnd); \
		end \
		2, 4, 8: begin \
			if ((DMCG + DMCI) == 0.0) \
				`STROBE("(DMCG + DMCI) can not be equal to zero"); \
			if (nuEnd == 0.0) \
				Rend = 0.0; \
			else \
				Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
		end \
		default: begin \
			`STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIM6RdsEndIso \
			type 2), Rend is set to zero.", rgeo); \
			Rend = 0.0; \
		end \
		endcase \
	end


`define BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, TYPE, Rend) \
	begin \
		if (TYPE == 1) begin \
			case(rgeo) \
			1, 2, 5: begin \
				if (nuEnd == 0.0) \
					Rend = 0.0; \
				else \
					Rend = Rsh * DMCG / (Weffcj * nuEnd); \
			end \
			3, 4, 6: begin \
				if (DMCG == 0.0) \
					`STROBE("DMCG can not be equal to zero"); \
				if (nuEnd == 0.0) \
					Rend = 0.0; \
				else \
					Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
			end \
			default: begin \
				`STROBE2("Warning: (instance %M) Specified RGEO = %d not matched (BSIM6RdsEndSha), \
				Rend is set to zero.", rgeo); \
				Rend = 0.0; \
			end \
			endcase \
		end \
		else begin \
			case(rgeo) \
			1, 3, 7: begin \
				if (nuEnd == 0.0) \
					Rend = 0.0; \
				else \
					Rend = Rsh * DMCG / (Weffcj * nuEnd); \
			end \
			2, 4, 8: begin \
				if (DMCG == 0.0) \
					`STROBE("DMCG can not be equal to zero"); \
				if (nuEnd == 0.0) \
					Rend = 0.0; \
				else \
					Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
			end \
			default: begin \
				`STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIM6RdsEndSha \
				type 2), Rend is set to zero.", rgeo); \
				Rend = 0.0; \
			end \
			endcase \
		end \
	end

`define BSIM6RdseffGeo(nf, geo, rgeo, minSD, Weffcj, Rsh, DMCG, DMCI, DMDG, TYPE, Rtot) \
	begin \
		if (geo < 9) begin \
			`BSIM6NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
			if (TYPE == 1) begin \
				if (nuIntS == 0.0) \
					Rint = 0.0; \
				else \
					Rint = Rsh * DMCG / ( Weffcj * nuIntS); \
				end \
			else begin \
				if (nuIntD == 0.0) \
					Rint = 0.0; \
				else \
					Rint = Rsh * DMCG / ( Weffcj * nuIntD); \
			end \
		end \
		case(geo) \
		0: begin \
			if (TYPE == 1) \
				`BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
				rgeo, 1, Rend) \
			else \
				`BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
				rgeo, 0, Rend) \
		end \
		1: begin \
			if (TYPE == 1) \
				`BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
				rgeo, 1, Rend) \
			else\
				`BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
				rgeo, 0, Rend) \
		end \
		2: begin \
			if (TYPE == 1) \
				`BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
				rgeo, 1, Rend) \
			else \
				`BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
				rgeo, 0, Rend) \
		end \
		3: begin \
			if (TYPE == 1) \
				`BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
				rgeo, 1, Rend) \
			else \
				`BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
				rgeo, 0, Rend) \
		end \
		4: begin \
			if (TYPE == 1) \
				`BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
				rgeo, 1, Rend) \
			else \
				Rend = Rsh * DMDG / Weffcj; \
		end \
		5: begin \
			if (TYPE == 1) \
				`BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
				rgeo, 1, Rend) \
			else begin \
					if (nuEndD==0)\
						Rend = 0;\
					else\
					Rend = Rsh * DMDG / (Weffcj * nuEndD); \
				end\
		end \
		6: begin \
			if (TYPE == 1) \
				Rend = Rsh * DMDG / Weffcj; \
			else \
				`BSIM6RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
				rgeo, 0, Rend) \
		end \
		7:begin \
			if (TYPE == 1) begin \
					if (nuEndS==0) \
						Rend = 0; \
					else \
						Rend = Rsh * DMDG / (Weffcj * nuEndS); \
			end else \
				`BSIM6RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
				rgeo, 0, Rend) \
		end \
		8: begin \
			Rend = Rsh * DMDG / Weffcj; \
		end \
		9: begin /* all wide contacts assumed for geo = 9 and 10 */\
			if (TYPE == 1) begin \
				Rend = 0.5 * Rsh * DMCG / Weffcj; \
				if (nf == 2.0) \
					Rint = 0.0; \
				else \
					Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
			end \
			else begin \
				Rend = 0.0; \
				Rint = Rsh * DMCG / (Weffcj * nf); \
			end \
		end \
		10: begin \
			if (TYPE == 1) begin \
				Rend = 0.0; \
				Rint = Rsh * DMCG / (Weffcj * nf); \
			end \
			else begin \
				Rend = 0.5 * Rsh * DMCG / Weffcj; \
				if (nf == 2.0) \
					Rint = 0.0; \
				else \
					Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
			end \
		end \
		default: begin \
			`STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIM6RdseffGeo \
			), Rint is set to zero.", rgeo); \
			Rint = 0.0; \
		end \
		endcase \
		if (Rint <= 0.0) \
			Rtot = Rend; \
		else if (Rend <= 0.0) \
			Rtot = Rint; \
		else \
			Rtot = Rint * Rend / (Rint + Rend); \
		if (Rtot==0.0) \
			`STROBE("Warning: (instance %M) Zero resistance returned from RdseffGeo"); \
	end

//****************** Effective PS,PD,AS,AD Calculation. Ref: BSIM4 ****************************

`define BSIM6PAeffGeo(nf, geo, minSD,Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad) \
	begin if (geo < 9) \
			`BSIM6NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
	T0 = DMCG + DMCI;\
	T1 = DMCG + DMCG;\
	T2 = DMDG + DMDG;\
	PSiso = T0 + T0 + Weffcj;\
	PDiso = T0 + T0 + Weffcj;\
	PSsha = T1;\
	PDsha = T1;\
	PSmer = T2;\
	PDmer = T2;\
	ASiso = T0 * Weffcj;\
	ADiso = T0 * Weffcj;\
	ASsha = DMCG * Weffcj;\
	ADsha = DMCG * Weffcj;\
	ASmer = DMDG * Weffcj;	\
	ADmer = DMDG * Weffcj;	\
		case(geo) \
		0: begin \
			Ps = nuEndS * PSiso + nuIntS * PSsha;\
			Pd = nuEndD * PDiso + nuIntD * PDsha;\
			As = nuEndS * ASiso + nuIntS * ASsha;\
			Ad = nuEndD * ADiso + nuIntD * ADsha;\
		end \
		1: begin \
			Ps = nuEndS * PSiso + nuIntS * PSsha;\
                	Pd = (nuEndD + nuIntD) * PDsha;\
                	As = nuEndS * ASiso + nuIntS * ASsha;\
                	Ad = (nuEndD + nuIntD) * ADsha;\
		end \
		2: begin \
			Ps = (nuEndS + nuIntS) * PSsha;\
                	Pd = nuEndD * PDiso + nuIntD * PDsha;\
                	As = (nuEndS + nuIntS) * ASsha;\
                	Ad = nuEndD * ADiso + nuIntD * ADsha;\
		end \
		3: begin \
			Ps = (nuEndS + nuIntS) * PSsha;\
                	Pd = (nuEndD + nuIntD) * PDsha;\
                	As = (nuEndS + nuIntS) * ASsha;\
                	Ad = (nuEndD + nuIntD) * ADsha;\
		end \
		4: begin \
			Ps = nuEndS * PSiso + nuIntS * PSsha;\
                	Pd = nuEndD * PDmer + nuIntD * PDsha;\
                	As = nuEndS * ASiso + nuIntS * ASsha;\
                	Ad = nuEndD * ADmer + nuIntD * ADsha;\
		end \
		5: begin \
			Ps = (nuEndS + nuIntS) * PSsha;\
                	Pd = nuEndD * PDmer + nuIntD * PDsha;\
                	As = (nuEndS + nuIntS) * ASsha;\
                	Ad = nuEndD * ADmer + nuIntD * ADsha;\
		end \
		6: begin \
			Ps = nuEndS * PSmer + nuIntS * PSsha;\
                	Pd = nuEndD * PDiso + nuIntD * PDsha;\
                	As = nuEndS * ASmer + nuIntS * ASsha;\
                	Ad = nuEndD * ADiso + nuIntD * ADsha;\
		end \
		7: begin \
			Ps = nuEndS * PSmer + nuIntS * PSsha;\
                	Pd = (nuEndD + nuIntD) * PDsha;\
                	As = nuEndS * ASmer + nuIntS * ASsha;\
                	Ad = (nuEndD + nuIntD) * ADsha;\
		end \
		8: begin \
			Ps = nuEndS * PSmer + nuIntS * PSsha;\
                	Pd = nuEndD * PDmer + nuIntD * PDsha;\
                	As = nuEndS * ASmer + nuIntS * ASsha;\
                	Ad = nuEndD * ADmer + nuIntD * ADsha;\
		end \
		9: begin \
			Ps = PSiso + (nf - 1.0) * PSsha;\
                	Pd = nf * PDsha;\
                	As = ASiso + (nf - 1.0) * ASsha;\
                	Ad = nf * ADsha;\
		end \
		10: begin \
			Ps = nf * PSsha;\
                	Pd = PDiso + (nf - 1.0) * PDsha;\
                	As = nf * ASsha;\
                	Ad = ADiso + (nf - 1.0) * ADsha;\
		end \
		default: begin \
			`STROBE2("Warning: (instance %M) Specified GEO=%d not matched (BSIM6RdseffGeo \
			), PS,PD,AS,AD set to zero.", geo); \
			Ps = 0;\
                	Pd = 0;\
                	As = 0;\
                	Ad = 0;\
		end \
		endcase \
	end \

//******************************************************




// Numerical Constants
`define EXPL_THRESHOLD 80.0
`define MAX_EXPL 5.540622384e+34
`define MIN_EXPL 1.804851387e-35
`define N_MINLOG 	1.0e-38
`define DELTA_1 0.02
`define Oneby3		0.33333333333333333
`define REFTEMP (300.15) /* 27 degrees C */

//Physical Constants
`define ntype 1
`define ptype -1
`define q    1.60219e-19
`define EPS0 8.85418e-12
`define KboQ 8.617087e-5 // Joule / degree

//  Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     || 
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     cz    closed lower bound=0, open upper bound=inf
//     oz    open   lower bound=0, open upper bound=inf
//     nb    no bounds
//     ex    no bounds with exclude
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  IPM   instance parameter mFactor(multiplicity, implicit for LRM2.2)
//  OPP   operating point parameter, includes units and description for printing
//
`define OPP(nam,uni,des)               (*units=uni,                   desc=des*)           real    nam ;

`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def ; 
`define MPRex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter real    nam=def exclude exc ;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr] ; 
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr) ; 
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr) ; 
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr] ; 
`define MPRcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from(  0:inf);

`define MPInb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def ;
`define MPIex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter integer nam=def exclude exc ;
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr] ;
`define MPIoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr) ; 
`define MPIco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr) ; 
`define MPIoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr] ; 
`define MPIcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:inf);
`define MPIoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from(  0:inf);

`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1] ;
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0 ;

`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def ; 
`define IPRex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def exclude exc ;
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr] ; 
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr) ; 
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr) ; 
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr] ; 
`define IPRcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[  0:inf);
`define IPRoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(  0:inf);

`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def ;
`define IPIex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def exclude exc ;
`define IPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr] ; 
`define IPIoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr) ; 
`define IPIco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr) ; 
`define IPIoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr] ; 
`define IPIcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[  0:inf);
`define IPIoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(  0:inf);

`ifdef __XYCE__
// Xyce requires an extra parameter attribute to flag a parameter as both model and instance, and this is needed for a few cases.
`define IPRoz_BOTH(nam,def,uni,        des) (*units=uni, type="instance", xyceAlsoModel="yes",  desc=des*) parameter real    nam=def from(  0:inf);
`define IPRcz_BOTH(nam,def,uni,        des) (*units=uni, type="instance", xyceAlsoModel="yes",  desc=des*) parameter real    nam=def from[  0:inf);
`define IPRnb_BOTH(nam,def,uni,        des) (*units=uni, type="instance", xyceAlsoModel="yes",  desc=des*) parameter real    nam=def ; 
`define IPIcc_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance", xyceAlsoModel="yes",  desc=des*) parameter integer nam=def from[lwr:upr] ; 
`define IPIoo_BOTH(nam,def,uni,lwr,upr,des) (*units=uni, type="instance", xyceAlsoModel="yes",  desc=des*) parameter integer nam=def from(lwr:upr) ; 
`else
`define IPRoz_BOTH(nam,def,uni,        des) `IPRoz(nam,def,uni,des);
`define IPRcz_BOTH(nam,def,uni,        des) `IPRcz(nam,def,uni,des);
`define IPRnb_BOTH(nam,def,uni,        des) `IPRnb(nam,def,uni,des);
`define IPIcc_BOTH(nam,def,uni,lwr,upr,des) `IPIcc(nam,def,uni,lwr,upr,des);
`define IPIoo_BOTH(nam,def,uni,lwr,upr,des) `IPIoo(nam,def,uni,lwr,upr,des);
`endif // __XYCE__

// Implicit mfactor is often assumed by models, but Xyce requires it explicit.
// Define and use the standard CMC macros to do this.
`ifdef __XYCE__
   `define IPM                         (*units="" , type="instance",  desc="multiplicity factor"*) parameter real m=1.0 from(0.0:inf) ;
   `define MFACTOR_USE m
`else
   `define IPM
   `define MFACTOR_USE 1.0
`endif

`define __THERMAL_NODE__
`ifdef __THERMAL_NODE__
	module bsim6(d, g, s, b, t) (* xyceModelGroup="MOSFET" xyceLevelNumber="77" xyceDeviceName="BSIM6" xyceTypeVariable="TYPE" *);
	inout      d, g, s, b, t;
`else

	module bsim6(d, g, s, b) (* xyceModelGroup="MOSFET" xyceLevelNumber="77" xyceDeviceName="BSIM6" xyceTypeVariable="TYPE" *);
	inout      d, g, s, b;
`endif
electrical d, g, s, b;


`ifdef __RDSMOD__
	electrical di, si;
`endif

`ifdef __RGATEMOD__
	electrical gi, gm;
`endif
`ifdef __RBODYMOD__
	electrical bi, sbulk, dbulk;
`endif

// Node definitions
`ifdef __RDSMOD__
	`define IntrinsicDrain di
	`define IntrinsicSource si
`else
	`define IntrinsicDrain d
	`define IntrinsicSource s
`endif

`ifdef __RGATEMOD__
	`define IntrinsicGate gi
	`define GateEdgeNode gm
`else
	`define IntrinsicGate g
	`define GateEdgeNode g
`endif

`ifdef __RBODYMOD__
	`define IntrinsicBody bi
`else
	`define IntrinsicBody b
`endif

// Extra internal nodes and branches (TNOIMOD=1) for correlated drain and gate noise
`ifdef __TNOISW__
	electrical N1, N2;
	branch (N1) NI;
	branch (N1) NR;
	branch (N1) NC;
`endif

// Clamped exponential function
analog function real lexp;
	input x;
	real x;
	begin
		if(x > `EXPL_THRESHOLD) begin
			lexp = `MAX_EXPL * (1.0+(x)-`EXPL_THRESHOLD);
		end else if(x < -`EXPL_THRESHOLD) begin
			lexp = `MIN_EXPL;
		end else begin
			lexp = exp(x);
		end
	end
endfunction

// Clamped log function
analog function real lln;
	input x;
	real x;
	begin
		lln = ln(max(x , `N_MINLOG));
	end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
	input x , c;
	real x , c;
	begin
		hypsmooth = 0.5 * (x + sqrt(x*x + 4.0*c*c));
	end
endfunction
/***************************/
/*  Instance Parameters    */
/***************************/

/* Note: Some instance parameters are also model parameters.  */
/*       Please refer to the technical note for details.      */

// XYCE MOD:  The instance parameter "L" is used in an expression for the default value of the model parameter XGL, a usage that is illegal in Xyce ---
//  the instance parameter, being local to a single instance of the device, is not available to the model, which is shared by multiple instances.
//  A simple hack is to make L both model and instance variable, and to use the model's copy of the value of L to compute the default value of XGL.
`IPRoz_BOTH( L              ,10u            ,"m"                                  	,"" ) 
`IPRoz( W              ,10u            ,"m"           							,"Total width including fingers" ) 
`IPIco( NF             ,1              ,""            ,1           ,inf         ,"Number of fingers" ) 
`IPRcz( NRS            ,1.0            ,""            							,"Number of squares in source" ) 
`IPRcz( NRD            ,1.0            ,""            							,"Number of squares in drain" ) 
`IPRnb_BOTH( VFBSDOFF       ,0.0            ,""            							,"" ) 
`IPIcc( MINZ           ,0              ,""            ,0           ,1           ,"Minimize either D or S" ) 
`IPRnb_BOTH( XGW            ,0.0            ,"m"           							,"Dist from gate contact center to dev edge [m]" ) 
`IPIcc_BOTH( NGCON          ,1              ,""            ,1           ,2           ,"Number of gate contacts" ) 
`IPIcc_BOTH( RGATEMOD       ,0              ,""            ,0           ,3           ,"Gate resistance model selector" ) 
`IPIcc_BOTH( RBODYMOD       ,0              ,""            ,0           ,2           ,"Distributed body R model" ) 
`IPIcc_BOTH( GEOMOD         ,0              ,""            ,0           ,10          ,"Geo dependent parasitics model" ) 
`IPIcc_BOTH( RGEOMOD        ,0              ,""            ,0           ,8           ,"Geometry-dependent source/drain resistance,  0: RSH-based, 1: Holistic" ) 

`IPRcz_BOTH( RBPB           ,50.0           ,"ohm"         							,"Resistance between bNodePrime and bNode" ) 
`IPRcz_BOTH( RBPD           ,50.0           ,"ohm"         							,"Resistance between bNodePrime and bNode " ) 
`IPRcz_BOTH( RBPS           ,50.0           ,"ohm"         							,"Resistance between bNodePrime and sbNode " ) 
`IPRcz_BOTH( RBDB           ,50.0           ,"ohm"         							,"Resistance between bNode and dbNode " ) 
`IPRcz_BOTH( RBSB           ,50.0           ,"ohm"         							,"Resistance between bNode and sbNode" ) 
`IPRnb_BOTH( SA             ,0.0            ,""            							,"Distance between OD edge from Poly from one side" ) 
`IPRnb_BOTH( SB             ,0.0            ,""            							,"Distance between OD edge from Poly from other side" ) 
`IPRnb_BOTH( SD             ,0.0            ,""            							,"Distance between neighboring fingers" ) 
`IPIoo_BOTH( SCA            ,0.0            ,""           ,-inf		  ,inf 			,"" ) 
`IPIoo_BOTH( SCB            ,0.0            ,""           ,-inf		  ,inf 			,"" ) 
`IPIoo_BOTH( SCC            ,0.0            ,""           ,-inf		  ,inf 			,"" ) 
`IPIoo_BOTH( SC             ,0.0            ,""           ,-inf		  ,inf 			,"Distance to a single well edge if <=0.0, turn off WPE" ) 
`IPRcz( AS             ,0.0            ,""            							,"Source to Substrate Junction Area" ) 
`IPRcz( AD             ,0.0            ,""            							,"Drain to Substrate Junction Area" ) 
`IPRcz( PS             ,0.0            ,""            							,"Source to Substrate Junction Perimeter" ) 
`IPRcz( PD             ,0.0            ,""            							,"Drain to Substrate Junction Perimeter" ) 
/************************/
/*  Model Parameters    */
/************************/
`MPIty( TYPE           ,`ntype         ,""            							,"" ) 
`MPIcc( CVMOD          ,0              ,""            ,0           ,1           ,"0: Consistent IV-CV, 1: Different IV-CV" ) 
`MPIcc( COVMOD         ,0              ,""            ,0           ,1           ,"0: Use Bias-independent Overlap Capacitances,  1: Use Bias-dependent Overlap Capacitances" ) 
														
`MPIcc( RDSMOD         ,0              ,""            ,0           ,2           ,"0: Internal bias dependent and external bias independent s/d resistance model,  1: External s/d resistance model,  2: Internal s/d resistance model" ) 

`MPIcc( WPEMOD         ,0              ,""            ,0           ,1           ,"Model flag" ) 														
														
`MPIcc( ASYMMOD        ,0              ,""            ,0           ,1           ,"0: Asymmetry Model turned off - forward mode parameters used,  1: Asymmetry Model turned on" ) 
														

`MPIcc( GIDLMOD        ,0              ,""            ,0           ,1           ,"0: Turn off GIDL Current,  1: Turn on GIDL Current" ) 
														
`MPIcc( IGCMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd,  1: Turn on Igc, Igs and Igd" ) 
														
`MPIcc( IGBMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igb,  1: Turn on Igb" ) 
														
`MPIcc( TNOIMOD        ,0              ,""            ,0           ,1           ,"Thermal noise model selector" ) 
`MPIcc( SHMOD          ,0              ,""            ,0           ,1           ,"0 : Self heating model OFF,  1 : Self heating model ON" ) 
														
`MPIcc( MOBSCALE       ,0              ,""            ,0           ,1           ,"Mobility scaling model, 0: Old Model,  1: New Model" ) 
																						  
// *************************
//   Device Parameters
// *************************

`MPRoz( LLONG          ,10u            ,"m"           							,"L of extracted Long channel device" ) 
`MPRoz( LMLT           ,1.0            ,""            							,"Length Shrinking Parameter" ) 
`MPRoz( WMLT           ,1.0            ,""            							,"Width Shrinking Parameter" ) 
`MPRnb( XL             ,0.0            ,""            							,"L offset for channel length due to mask/etch effect" ) 
`MPRoz( WWIDE          ,10u            ,"m"           							,"W of extracted Wide channel device" ) 
`MPRnb( XW             ,0.0            ,""            							,"W offset for channel width due to mask/etch effect" ) 
`MPRnb( LINT           ,0.0            ,""            							,"delta L for IV" ) 
`MPRnb( LL             ,0.0            ,""            							,"" ) 
`MPRnb( LW             ,0.0            ,""            							,"" ) 
`MPRnb( LWL            ,0.0            ,""            							,"" ) 
`MPRnb( LLN            ,1.0            ,""            							,"" ) 
`MPRnb( LWN            ,1.0            ,""            							,"" ) 
`MPRnb( WINT           ,0.0            ,""            							,"delta W for IV" ) 
`MPRnb( WL             ,0.0            ,""            							,"" ) 
`MPRnb( WW             ,0.0            ,""            							,"" ) 
`MPRnb( WWL            ,0.0            ,""            							,"" ) 
`MPRnb( WLN            ,1.0            ,""            							,"" ) 
`MPRnb( WWN            ,1.0            ,""            							,"" ) 
`MPRnb( DLC            ,0.0            ,""            							,"delta L for CV" ) 
`MPRnb( LLC            ,0.0            ,""            							,"" ) 
`MPRnb( LWC            ,0.0            ,""            							,"" ) 
`MPRnb( LWLC           ,0.0            ,""            							,"" ) 
`MPRnb( DWC            ,0.0            ,""            							,"delta W for CV" ) 
`MPRnb( WLC            ,0.0            ,""            							,"" ) 
`MPRnb( WWC            ,0.0            ,""            							,"" ) 
`MPRnb( WWLC           ,0.0            ,""            							,"" ) 
`MPRnb( TOXE           ,3.0e-9         ,"m"           							,"Effective gate dielectric thickness relative to SiO2, m" ) 
`MPRnb( TOXP           ,TOXE           ,"m"           							,"Physical gate dielectric thickness,If not given, TOXP is calculated from TOXE and DTOX" ) 
													
`MPRnb( DTOX           ,0.0            ,""            							,"Difference between effective dielectric thickness" ) 
														
`MPRnb( NDEP           ,1e24           ,"m^-3"        							,"Channel Doping Concentration for IV" ) 
`MPRnb( NDEPL1         ,0.0            ,""            							,"Length dependence coefficient of NDEP" ) 
`MPRoz( NDEPLEXP1      ,1.0            ,""            							,"Length dependence exponent coefficient of NDEP" ) 
`MPRnb( NDEPL2         ,0.0            ,""            							,"Length dependence of NDEP - For Short Channel Devices" ) 
`MPRoz( NDEPLEXP2      ,2.0            ,""            							,"Length dependence exponent coefficient of NDEP" ) 
`MPRnb( NDEPW          ,0.0            ,""            							,"Width dependence coefficient of NDEP" ) 
`MPRoz( NDEPWEXP       ,1.0            ,""            							,"Width dependence exponent coefficient of NDEP" ) 
`MPRnb( NDEPWL         ,0.0            ,""            							,"Width-Length dependence coefficient of NDEP" ) 
`MPRoz( NDEPWLEXP      ,1.0            ,""            							,"Width-Length dependence exponent coefficient of NDEP" ) 
`MPRnb( LNDEP          ,0.0            ,""            							,"" ) 
`MPRnb( WNDEP          ,0.0            ,""            							,"" ) 
`MPRnb( PNDEP          ,0.0            ,""            							,"" ) 

`MPRnb( NDEPCV         ,NDEP           ,"m^-3"        							,"Channel Doping Concentration for CV" ) 
`MPRnb( NDEPCVL1       ,NDEPL1         ,""            							,"Length dependence coefficient of NDEPCV" ) 
`MPRoz( NDEPCVLEXP1    ,NDEPLEXP1      ,""            							,"Length dependence exponent coefficient of NDEPCV" ) 
`MPRnb( NDEPCVL2       ,NDEPL2         ,""            							,"Length dependence coefficient of NDEPCV - For Short Channel Devices" ) 
`MPRoz( NDEPCVLEXP2    ,NDEPLEXP2      ,""            							,"Length dependence exponent coefficient of NDEPCV" ) 
`MPRnb( NDEPCVW        ,NDEPW          ,""            							,"Width dependence coefficient of NDEPCV" ) 
`MPRoz( NDEPCVWEXP     ,NDEPWEXP       ,""            							,"Width dependence exponent coefficient of NDEPCV" ) 
`MPRnb( NDEPCVWL       ,NDEPWL         ,""            							,"Width-Length dependence coefficient of NDEPCV" ) 
`MPRoz( NDEPCVWLEXP    ,NDEPWLEXP      ,""            							,"Width-Length dependence exponent coefficient of NDEPCV" ) 
`MPRnb( LNDEPCV        ,LNDEP          ,""            							,"" ) 
`MPRnb( WNDEPCV        ,WNDEP          ,""            							,"" ) 
`MPRnb( PNDEPCV        ,PNDEP          ,""            							,"" ) 

`MPRnb( NGATE          ,5e25           ,"m^-3"        							,"Gate Doping Concentration" ) 
`MPRnb( LNGATE         ,0.0            ,""            							,"" ) 
`MPRnb( WNGATE         ,0.0            ,""            							,"" ) 
`MPRnb( PNGATE         ,0.0            ,""            							,"" ) 

`MPRnb( EASUB          ,4.05           ,"eV"          							,"Electron affinity of substrate" ) 
`MPRnb( NI0SUB         ,1.1e16         ,"m^-3"        							,"Intrinsic carrier concentration of the substrate at 300.15K" ) 
`MPRnb( BG0SUB         ,1.17           ,"eV"          							,"Band gap of substrate at 300.15K" ) 
`MPRnb( EPSRSUB        ,11.9           ,""            							,"Relative dielectric constant of the channel material" ) 
`MPRnb( EPSROX         ,3.9            ,""            							,"Relative dielectric constant of the gate dielectric" ) 
`MPRnb( XJ             ,1.5e-7         ,""            							,"S/D junction depth" ) 
`MPRnb( LXJ            ,0.0            ,""            							,"" ) 
`MPRnb( WXJ            ,0.0            ,""            							,"" ) 
`MPRnb( PXJ            ,0.0            ,""            							,"" ) 
`MPRnb( LVFB           ,0.0            ,""            							,"" ) 
`MPRnb( WVFB           ,0.0            ,""            							,"" ) 
`MPRnb( PVFB           ,0.0            ,""            							,"" ) 
`MPRnb( VFB            ,-0.5           ,"V"            							,"Flat band voltage " )
`MPRnb( VFBCV          ,VFB            ,""            							,"Flat band voltage for CV" ) 
`MPRnb( LVFBCV         ,LVFB           ,""            							,"" ) 
`MPRnb( WVFBCV         ,WVFB           ,""            							,"" ) 
`MPRnb( PVFBCV         ,PVFB           ,""            							,"" ) 
`MPRnb( VFBCVL         ,0.0            ,""            							,"Length dependence coefficient of VFBCV" ) 
`MPRoz( VFBCVLEXP      ,1.0            ,""            							,"Length dependence exponent coefficient of VFBCV" ) 
`MPRnb( VFBCVW         ,0.0            ,""            							,"Width dependence coefficient of VFBCV" ) 
`MPRoz( VFBCVWEXP      ,1.0            ,""            							,"Width dependence exponent coefficient of VFBCV" ) 
`MPRnb( VFBCVWL        ,0.0            ,""            							,"Width-Length dependence coefficient of VFBCV" ) 
`MPRoz( VFBCVWLEXP     ,1.0            ,""           							,"Width-Length dependence coefficient of VFBCV" ) 

//Diode parameters
`MPIcc( PERMOD         ,1              ,""            ,0           ,1           ,"Whether PS/PD (when given) include gate-edge perimeter" ) 
`MPRnb( DWJ            ,DWC            ,""            							,"delta W for S/D junctions" ) 

// Short Channel Effects
`MPRnb( NSD            ,1e26           ,"m^-3"        							,"S/D Doping Concentration" ) 
`MPRnb( LNSD           ,0.0            ,""            							,"" ) 
`MPRnb( WNSD           ,0.0            ,""            							,"" ) 
`MPRnb( PNSD           ,0.0            ,""            							,"" ) 

`MPRnb( DELVT0         ,0.0            ,""            							,"" ) 
`MPRnb( DVTP0          ,0.0            ,""            							,"DITS" ) 
`MPRnb( LDVTP0         ,0              ,""            							,"" ) 
`MPRnb( WDVTP0         ,0              ,""            							,"" ) 
`MPRnb( PDVTP0         ,0              ,""            							,"" ) 
`MPRnb( DVTP1          ,0.0            ,""            							,"DITS" ) 
`MPRnb( LDVTP1         ,0              ,""            							,"" ) 
`MPRnb( WDVTP1         ,0              ,""            							,"" ) 
`MPRnb( PDVTP1         ,0              ,""            							,"" ) 
`MPRnb( DVTP2          ,0.0            ,""            							,"DITS" ) 
`MPRnb( LDVTP2         ,0              ,""            							,"" ) 
`MPRnb( WDVTP2         ,0              ,""            							,"" ) 
`MPRnb( PDVTP2         ,0              ,""            							,"" ) 
`MPRnb( DVTP3          ,0.0            ,""            							,"DITS" ) 
`MPRnb( LDVTP3         ,0              ,""            							,"" ) 
`MPRnb( WDVTP3         ,0              ,""            							,"" ) 
`MPRnb( PDVTP3         ,0              ,""            							,"" ) 
`MPRnb( DVTP4          ,0.0            ,""            							,"DITS" ) 
`MPRnb( LDVTP4         ,0              ,""            							,"" ) 
`MPRnb( WDVTP4         ,0              ,""            							,"" ) 
`MPRnb( PDVTP4         ,0              ,""            							,"" ) 
`MPRnb( DVTP5          ,0.0            ,""            							,"DITS" ) 
`MPRnb( LDVTP5         ,0              ,""            							,"" ) 
`MPRnb( WDVTP5         ,0              ,""            							,"" ) 
`MPRnb( PDVTP5         ,0              ,""            							,"" ) 

`MPRnb( PHIN           ,0.045          ,"V"           							,"Nonuniform vertical doping effect on surface potential, V" ) 
`MPRnb( LPHIN          ,0.0            ,""            							,"" ) 
`MPRnb( WPHIN          ,0.0            ,""            							,"" ) 
`MPRnb( PPHIN          ,0.0            ,""            							,"" ) 

`MPRnb( ETA0           ,0.08           ,""            							,"DIBL coefficient" ) 
`MPRnb( LETA0          ,0.0            ,""            							,"" ) 
`MPRnb( WETA0          ,0.0            ,""            							,"" ) 
`MPRnb( PETA0          ,0.0            ,""            							,"" ) 
`MPRnb( ETA0R          ,ETA0           ,""            							,"DIBL coefficient" ) 
`MPRnb( LETA0R         ,LETA0          ,""            							,"" ) 
`MPRnb( WETA0R         ,WETA0          ,""            							,"" ) 
`MPRnb( PETA0R         ,PETA0          ,""            							,"" ) 
`MPRnb( DSUB           ,1.0            ,""            							,"Length scaling exponent for DIBL" ) 
`MPRnb( ETAB           ,-0.07          ,""            							,"Body bias coefficient for subthreshold DIBL effect" ) 
`MPRoz( ETABEXP        ,1.0            ,""            							,"Exponent coefficient of ETAB" ) 
`MPRnb( LETAB          ,0.0            ,""            							,"" ) 
`MPRnb( WETAB          ,0.0            ,""            							,"" ) 
`MPRnb( PETAB          ,0.0            ,""            							,"" ) 

`MPRnb( K1             ,0.0            ,""            							,"First-order body-bias Vth shift due to Vertical Non-uniform doping" ) 
`MPRnb( K1L            ,0.0            ,""            							,"Length dependence coefficient of K1" ) 
`MPRoz( K1LEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of K1" ) 
`MPRnb( K1W            ,0.0            ,""            							,"Width dependence coefficient of K1" ) 
`MPRoz( K1WEXP         ,1.0            ,""            							,"Width dependence exponent coefficient of K1" ) 
`MPRnb( K1WL           ,0.0            ,""            							,"Width-Length dependence coefficient of K1" ) 
`MPRoz( K1WLEXP        ,1.0            ,""           							,"Width-Length dependence exponent coefficient of K1" ) 
`MPRnb( LK1            ,0.0            ,""            							,"" ) 
`MPRnb( WK1            ,0.0            ,""            							,"" ) 
`MPRnb( PK1            ,0.0            ,""            							,"" ) 
`MPRnb( K2             ,0.0            ,""            							,"Vth shift due to Vertical Non-uniform doping" ) 
`MPRnb( K2L            ,0.0            ,""            							,"Length dependence coefficient of K2" ) 
`MPRoz( K2LEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of K2" ) 
`MPRnb( K2W            ,0.0            ,""            							,"Width dependence coefficient of K2" ) 
`MPRoz( K2WEXP         ,1.0            ,""            							,"Width dependence exponent coefficient of K2" ) 
`MPRnb( K2WL           ,0.0            ,""            							,"Width-Length dependence coefficient of K2" ) 
`MPRoz( K2WLEXP        ,1.0            ,""            							,"Width-Length dependence exponent coefficient of K2" ) 
`MPRnb( LK2            ,0.0            ,""            							,"" ) 
`MPRnb( WK2            ,0.0            ,""            							,"" ) 
`MPRnb( PK2            ,0.0            ,""            							,"" ) 

// Quantum Mechanical Effects
`MPRcz( ADOS           ,0.0            ,""            							,"Quantum mechanical effect prefactor cum switch in inversion" ) 
`MPRcz( BDOS           ,1.0            ,""            							,"Charge centroid parameter - slope of CV curve under QME in inversion" ) 
`MPRoz( QM0            ,1.0e-3         ,""            							,"Charge centroid parameter - starting point for QME in inversion" ) 
`MPRcz( ETAQM          ,0.54           ,""            							,"Bulk charge coefficient for charge centroid in inversion" ) 

//Subthreshold Swing Factor
`MPRnb( CIT            ,0.0            ,""            							,"parameter for interface trap" ) 
`MPRnb( LCIT           ,0.0            ,""            							,"" ) 
`MPRnb( WCIT           ,0.0            ,""            							,"" ) 
`MPRnb( PCIT           ,0.0            ,""            							,"" ) 


`MPRnb( NFACTOR        ,0.0            ,""            							,"Sub-threshold slope factor" ) 
`MPRnb( NFACTORL       ,0.0            ,""            							,"Length dependence coefficient of NFACTOR" ) 
`MPRoz( NFACTORLEXP    ,1.0            ,""            							,"Length dependence exponent coefficient of NFACTOR" ) 
`MPRnb( NFACTORW       ,0.0            ,""            							,"Width dependence coefficient of NFACTOR" ) 
`MPRoz( NFACTORWEXP    ,1.0            ,""            							,"Width dependence exponent coefficient of NFACTOR" ) 
`MPRnb( NFACTORWL      ,0.0            ,""           						 	,"Width-Length dependence coefficient of NFACTOR" ) 
`MPRoz( NFACTORWLEXP   ,1.0            ,""            							,"Width-Length dependence exponent coefficient of NFACTOR" ) 
`MPRnb( LNFACTOR       ,0.0            ,""            							,"" ) 
`MPRnb( WNFACTOR       ,0.0            ,""            							,"" ) 
`MPRnb( PNFACTOR       ,0.0            ,""            							,"" ) 

`MPRnb( CDSCD          ,1e-9           ,""            							,"drain-bias sensitivity of sub-threshold slope" ) 
`MPRnb( CDSCDL         ,0.0            ,""            							,"Length dependence coefficient of CDSCD" ) 
`MPRoz( CDSCDLEXP      ,1.0            ,""            							,"Length dependence exponent coefficient of CDSCD" ) 
`MPRnb( LCDSCD         ,0.0            ,""            							,"" ) 
`MPRnb( WCDSCD         ,0.0            ,""            							,"" ) 
`MPRnb( PCDSCD         ,0.0            ,""            							,"" ) 
`MPRnb( CDSCDR         ,CDSCD          ,""            							,"drain-bias sensitivity of sub-threshold slope" ) 
`MPRnb( CDSCDLR        ,CDSCDL         ,""            							,"Length dependence coefficient of CDSCD" ) 
`MPRnb( LCDSCDR        ,LCDSCD         ,""            							,"" ) 
`MPRnb( WCDSCDR        ,WCDSCD         ,""            							,"" ) 
`MPRnb( PCDSCDR        ,PCDSCD         ,""            							,"" ) 
`MPRnb( CDSCB          ,0.0            ,""            							,"body-bias sensitivity of sub-threshold slope" ) 
`MPRnb( CDSCBL         ,0.0            ,""            							,"Length dependence coefficient of CDSCB" ) 
`MPRoz( CDSCBLEXP      ,1.0            ,""            							,"Length dependence exponent coefficient of CDSCB" ) 
`MPRnb( LCDSCB         ,0.0            ,""            							,"" ) 
`MPRnb( WCDSCB         ,0.0            ,""            							,"" ) 
`MPRnb( PCDSCB         ,0.0            ,""            							,"" ) 

//Drain Saturation Voltage
`MPRnb( VSAT           ,1e5            ,"m/s"         							,"Saturation Velocity" ) 
`MPRnb( LVSAT          ,0.0            ,""            							,"" ) 
`MPRnb( WVSAT          ,0.0            ,""            							,"" ) 
`MPRnb( PVSAT          ,0.0            ,""            							,"" ) 
`MPRnb( VSATL          ,0.0            ,""            							,"Length dependence coefficient of of VSAT" ) 
`MPRoz( VSATLEXP       ,1.0            ,""            							,"Length dependence exponent coefficient of VSAT" ) 
`MPRnb( VSATW          ,0.0            ,""            							,"Width dependence coefficient of of VSAT" ) 
`MPRoz( VSATWEXP       ,1.0            ,""            							,"Width dependence exponent coefficient of of VSAT" ) 
`MPRnb( VSATWL         ,0.0            ,""            							,"Width-Length dependence coefficient of of VSAT" ) 
`MPRoz( VSATWLEXP      ,1.0            ,""            							,"Width-Length dependence exponent coefficient of of VSAT" ) 
`MPRnb( VSATR          ,VSAT           ,"m/s"         							,"Saturation Velocity" ) 
`MPRnb( LVSATR         ,LVSAT          ,""            							,"" ) 
`MPRnb( WVSATR         ,WVSAT          ,""            							,"" ) 
`MPRnb( PVSATR         ,PVSAT          ,""            							,"" ) 

`MPRnb( DELTA          ,0.125          ,""            							,"Smoothing function factor for Vdsat" ) 
`MPRnb( LDELTA         ,0.0            ,""            							,"" ) 
`MPRnb( WDELTA         ,0.0            ,""            							,"" ) 
`MPRnb( PDELTA         ,0.0            ,""            							,"" ) 
`MPRnb( DELTAL         ,0.0            ,""            							,"Length dependence coefficient of DELTA" ) 
`MPRoz( DELTALEXP      ,1.0            ,""            							,"Length dependence exponent coefficient of DELTA" ) 

`MPRnb( VSATCV         ,VSAT           ,""            							,"VSAT parameter for CV" ) 
`MPRnb( LVSATCV        ,LVSAT          ,""            							,"" ) 
`MPRnb( WVSATCV        ,WVSAT          ,""            							,"" ) 
`MPRnb( PVSATCV        ,PVSAT          ,""            							,"" ) 
`MPRnb( VSATCVL        ,VSATL          ,""            							,"" ) 
`MPRoz( VSATCVLEXP     ,VSATLEXP       ,""            							,"" ) 
`MPRnb( VSATCVW        ,VSATW          ,""            							,"" ) 
`MPRoz( VSATCVWEXP     ,VSATWEXP       ,""            							,"" ) 
`MPRnb( VSATCVWL       ,VSATWL         ,""            							,"" ) 
`MPRoz( VSATCVWLEXP    ,VSATWLEXP      ,""            							,"" ) 

// Mobility Degradation

`MPRoo( UP1            ,0.0            ,""            ,-inf        ,inf         ,"Mobility channel length coefficent" ) 
`MPRoo( LP1            ,1.0e-8         ,""            ,-inf        ,inf         ,"Mobility channel length exponential coefficent" ) 
`MPRoo( UP2            ,0.0            ,""            ,-inf        ,inf         ,"Mobility channel length coefficent" ) 
`MPRoo( LP2            ,1.0e-8         ,""            ,-inf        ,inf         ,"Mobility channel length exponential coefficent" ) 
`MPRnb( MULU0          ,1.0            ,""            							,"" ) 
`MPRnb( U0             ,67.0e-3        ,"m2/Vs"       							,"" ) 
`MPRnb( U0L            ,0.0            ,""            							,"Length dependence coefficient of U0L" ) 
`MPRoz( U0LEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of U0L" ) 
`MPRnb( LU0            ,0.0            ,""            							,"" ) 
`MPRnb( WU0            ,0.0            ,""            							,"" ) 
`MPRnb( PU0            ,0.0            ,""            							,"" ) 
`MPRnb( U0R            ,U0             ,"m2/Vs"       							,"" ) 
`MPRnb( LU0R           ,LU0            ,""            							,"" ) 
`MPRnb( WU0R           ,WU0            ,""            							,"" ) 
`MPRnb( PU0R           ,PU0            ,""            							,"" ) 

`MPRnb( ETAMOB         ,1.0            ,""            							,"Effective field parameter (should be kept close to 1)" ) 

`MPRnb( UA             ,0.001          ,""            							,"Mobility reduction coefficient" ) 
`MPRnb( UAL            ,0.0            ,""            							,"Length dependence coefficient of  UA" ) 
`MPRoz( UALEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of  UA" ) 
`MPRnb( UAW            ,0.0            ,""            							,"Width dependence coefficient of UA" ) 
`MPRoz( UAWEXP         ,1.0            ,""            							,"Width dependence exponent coefficient of UA" ) 
`MPRnb( UAWL           ,0.0            ,""            							,"Width-Length dependence coefficient of UA" ) 
`MPRoz( UAWLEXP        ,1.0            ,""            							,"Width-Length dependence coefficient of UA" ) 
`MPRnb( LUA            ,0.0            ,""           		 					,"" ) 
`MPRnb( WUA            ,0.0            ,""            							,"" ) 
`MPRnb( PUA            ,0.0            ,""            							,"" ) 
`MPRnb( UAR            ,UA             ,""            							,"Mobility reduction coefficient" ) 
`MPRnb( LUAR           ,LUA            ,""            							,"" ) 
`MPRnb( WUAR           ,WUA            ,""            							,"" ) 
`MPRnb( PUAR           ,PUA            ,""            							,"" ) 

`MPRnb( EU             ,1.5            ,""            							,"Mobility reduction exponent" ) 
`MPRnb( LEU            ,0.0            ,""            							,"" ) 
`MPRnb( WEU            ,0.0            ,""            							,"" ) 
`MPRnb( PEU            ,0.0            ,""            							,"" ) 
`MPRnb( EUL            ,0.0            ,""            							,"Length dependence coefficient of EU" ) 
`MPRoz( EULEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of EU" ) 
`MPRnb( EUW            ,0.0            ,""            							,"Width dependence coefficient of EU" ) 
`MPRoz( EUWEXP         ,1.0            ,""            							,"Width dependence exponent coefficient of EU" ) 
`MPRnb( EUWL           ,0.0            ,""            							,"Width-Length dependence coefficient of EU" ) 
`MPRoz( EUWLEXP        ,1.0            ,""            							,"Width-Length dependence coefficient of EU" ) 

`MPRnb( UD             ,0.001          ,""            							,"Coulombic scattering parameter" ) 
`MPRnb( UDL            ,0.0            ,""            							,"Length dependence coefficient of UD" ) 
`MPRoz( UDLEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of UD" ) 
`MPRnb( LUD            ,0.0            ,""            							,"" ) 
`MPRnb( WUD            ,0.0            ,""            							,"" ) 
`MPRnb( PUD            ,0.0            ,""            							,"" ) 
`MPRnb( UDR            ,UD             ,""            							,"Coulombic scattering parameter" ) 
`MPRnb( LUDR           ,LUD            ,""            							,"" ) 
`MPRnb( WUDR           ,WUD            ,""            							,"" ) 
`MPRnb( PUDR           ,PUD            ,""            							,"" ) 

`MPRnb( UCS            ,2.0            ,""            							,"Coulombic scattering parameter" ) 
`MPRnb( LUCS           ,0.0            ,""            							,"" ) 
`MPRnb( WUCS           ,0.0            ,""            							,"" ) 
`MPRnb( PUCS           ,0.0            ,""            							,"" ) 
`MPRnb( UCSR           ,UCS            ,""            							,"Coulombic scattering parameter" ) 
`MPRnb( LUCSR          ,LUCS           ,""            							,"" ) 
`MPRnb( WUCSR          ,WUCS           ,""            							,"" ) 
`MPRnb( PUCSR          ,PUCS           ,""            							,"" ) 

`MPRnb( UC             ,0.0            ,""            							,"Mobility reduction with body bias" ) 
`MPRnb( UCL            ,0.0            ,""            							,"Length dependence coefficient of UC" ) 
`MPRoz( UCLEXP         ,1.0            ,""            							,"Length dependence exponent coefficient of UC" ) 
`MPRnb( UCW            ,0.0            ,""            							,"Width dependence coefficient of UC" ) 
`MPRoz( UCWEXP         ,1.0            ,""            							,"Width dependence exponent coefficient of UC" ) 
`MPRnb( UCWL           ,0.0            ,""            							,"Width-Length dependence coefficient of UC" ) 
`MPRoz( UCWLEXP        ,1.0            ,""            							,"Width-Length dependence exponent coefficient of UC" ) 
`MPRnb( LUC            ,0.0            ,""           							,"" ) 
`MPRnb( WUC            ,0.0            ,""            							,"" ) 
`MPRnb( PUC            ,0.0            ,""            							,"" ) 
`MPRnb( UCR            ,UC             ,""            							,"Mobility reduction with body bias" ) 
`MPRnb( LUCR           ,LUC            ,""            							,"" ) 
`MPRnb( WUCR           ,WUC            ,""            							,"" ) 
`MPRnb( PUCR           ,PUC            ,""            							,"" ) 

// Channel Length Modulation
`MPRnb( PCLM           ,0.0            ,""            							,"CLM prefactor" ) 
`MPRnb( PCLML          ,0.0            ,""            							,"Length dependence coefficient of PCLM" ) 
`MPRoz( PCLMLEXP       ,1.0            ,""            							,"Length dependence exponent coefficient of PCLM" ) 
`MPRnb( LPCLM          ,0.0            ,""            							,"" ) 
`MPRnb( WPCLM          ,0.0            ,""            							,"" ) 
`MPRnb( PPCLM          ,0.0            ,""            							,"" ) 
`MPRnb( PCLMR          ,PCLM           ,""            							,"CLM prefactor" ) 
`MPRnb( LPCLMR         ,LPCLM          ,""            							,"" ) 
`MPRnb( WPCLMR         ,WPCLM          ,""            							,"" ) 
`MPRnb( PPCLMR         ,PPCLM          ,""            							,"" ) 

`MPRnb( PCLMG          ,0.0            ,""            							,"CLM prefactor gate voltage dependence" ) 

`MPRnb( PCLMCV         ,PCLM           ,""            							,"CLM parameter for CV" ) 
`MPRnb( PCLMCVL        ,PCLML          ,""            							,"" ) 
`MPRoz( PCLMCVLEXP     ,PCLMLEXP       ,""            							,"" ) 
`MPRnb( LPCLMCV        ,LPCLM          ,""            							,"" ) 
`MPRnb( WPCLMCV        ,WPCLM          ,""            							,"" ) 
`MPRnb( PPCLMCV        ,PPCLM          ,""            							,"" ) 

`MPRnb( PSCBE1         ,4.24e8         ,""            							,"Substrate current body-effect coeff" ) 
`MPRnb( LPSCBE1        ,0.0            ,""            							,"" ) 
`MPRnb( WPSCBE1        ,0.0            ,""            							,"" ) 
`MPRnb( PPSCBE1        ,0.0            ,""            							,"" ) 
`MPRnb( PSCBE2         ,1.0e-8         ,""            							,"Substrate current body-effect coeff" ) 
`MPRnb( LPSCBE2        ,0.0            ,""            							,"" ) 
`MPRnb( WPSCBE2        ,0.0            ,""            							,"" ) 
`MPRnb( PPSCBE2        ,0.0            ,""            							,"" ) 

`MPRnb( PDITS          ,0.0            ,""            							,"Coefficient for drain-induced Vth shifts" ) 
`MPRnb( LPDITS         ,0.0            ,""            							,"" ) 
`MPRnb( WPDITS         ,0.0            ,""            							,"" ) 
`MPRnb( PPDITS         ,0.0            ,""            							,"" ) 
`MPRcz( PDITSL         ,0.0            ,""            							,"L dep of drain-induced Vth shifts" ) 
`MPRnb( PDITSD         ,0.0            ,""            							,"Vds dep of drain-induced Vth shifts" ) 
`MPRnb( LPDITSD        ,0.0            ,""            							,"" ) 
`MPRnb( WPDITSD        ,0.0            ,""            							,"" ) 
`MPRnb( PPDITSD        ,0.0            ,""            							,"" ) 

// S/D Series Resistance
`MPRcz( RSH            ,0.0            ,""            							,"Source-drain sheet resistance" ) 
`MPRnb( PRWG           ,1.0            ,""            							,"gate bias dependence of S/D extension resistance" ) 
`MPRnb( LPRWG          ,0.0            ,""            							,"" ) 
`MPRnb( WPRWG          ,0.0            ,""            							,"" ) 
`MPRnb( PPRWG          ,0.0            ,""            							,"" ) 
`MPRnb( PRWB           ,0.0            ,""            							,"Body bias dependence of resistance" ) 
`MPRnb( LPRWB          ,0.0            ,""            							,"" ) 
`MPRnb( WPRWB          ,0.0            ,""            							,"" ) 
`MPRnb( PPRWB          ,0.0            ,""            							,"" ) 
`MPRnb( PRWBL          ,0.0            ,""            							,"Length dependence coefficient of PPRWB" ) 
`MPRoz( PRWBLEXP       ,1.0            ,""            							,"Length dependence exponent coefficient of PPRWB" ) 
`MPRnb( WR             ,1.0            ,""            							,"W dependence parameter of S/D extension resistance" ) 
`MPRnb( LWR            ,0.0            ,""            							,"" ) 
`MPRnb( WWR            ,0.0            ,""            							,"" ) 
`MPRnb( PWR            ,0.0            ,""            							,"" ) 

`MPRnb( RSWMIN         ,0.0            ,""            							,"Source Resistance per unit width at high Vgs (RDSMOD=1)" ) 
`MPRnb( LRSWMIN        ,0.0            ,""            							,"" ) 
`MPRnb( WRSWMIN        ,0.0            ,""            							,"" ) 
`MPRnb( PRSWMIN        ,0.0            ,""            							,"" ) 
`MPRnb( RSW            ,10.0           ,""            							,"zero bias Source Resistance (RDSMOD=1)" ) 
`MPRnb( LRSW           ,0.0            ,""            							,"" ) 
`MPRnb( WRSW           ,0.0            ,""            							,"" ) 
`MPRnb( PRSW           ,0.0            ,""            							,"" ) 
`MPRnb( RSWL           ,0.0            ,""            							,"Geometrical scaling of RSW (RDSMOD=1)" ) 
`MPRoz( RSWLEXP        ,1.0            ,""            							,"Geometrical scaling of RSW (RDSMOD=1)" ) 

`MPRnb( RDWMIN         ,RSWMIN         ,""            							,"Drain Resistance per unit width at high Vgs (RDSMOD=1)" ) 
`MPRnb( LRDWMIN        ,LRSWMIN        ,""            							,"" ) 
`MPRnb( WRDWMIN        ,WRSWMIN        ,""            							,"" ) 
`MPRnb( PRDWMIN        ,PRSWMIN        ,""            							,"" ) 
`MPRnb( RDW            ,RSW            ,""            							,"zero bias Drain Resistance (RDSMOD=1)" ) 
`MPRnb( LRDW           ,LRSW           ,""            							,"" ) 
`MPRnb( WRDW           ,WRSW           ,""            							,"" ) 
`MPRnb( PRDW           ,PRSW           ,""            							,"" ) 
`MPRnb( RDWL           ,RSWL           ,""            							,"Geometrical scaling of RDW (RDSMOD=1)" ) 
`MPRoz( RDWLEXP        ,RSWLEXP        ,""            							,"Geometrical scaling of RDW (RDSMOD=1)" ) 

`MPRnb( RDSWMIN        ,0.0            ,""            							,"S/D Resistance per unit width at high Vgs (RDSMOD=0 and RDSMOD=2)" ) 
`MPRnb( LRDSWMIN       ,0.0            ,""            							,"" ) 
`MPRnb( WRDSWMIN       ,0.0            ,""            							,"" ) 
`MPRnb( PRDSWMIN       ,0.0            ,""            							,"" ) 
`MPRnb( RDSW           ,20.0           ,""            							,"zero bias Resistance (RDSMOD=0 and RDSMOD=2)" ) 
`MPRnb( RDSWL          ,0.0            ,""            							,"Geometrical scaling of RDSW (RDSMOD=0 and RDSMOD=2)" ) 
`MPRoz( RDSWLEXP       ,1.0            ,""            							,"Geometrical scaling of RDSW (RDSMOD=0 and RDSMOD=2)" ) 
`MPRnb( LRDSW          ,0.0            ,""            							,"" ) 
`MPRnb( WRDSW          ,0.0            ,""            							,"" ) 
`MPRnb( PRDSW          ,0.0            ,""            							,"" ) 

// Velocity Saturation

`MPRnb( PSAT           ,1.0            ,""            							,"Gmsat variation with gate bias" ) 
`MPRnb( LPSAT          ,0.0            ,""            							,"" ) 
`MPRnb( WPSAT          ,0.0            ,""            							,"" ) 
`MPRnb( PPSAT          ,0.0            ,""            							,"" ) 
`MPRnb( PSATL          ,0.0            ,""            							,"" ) 
`MPRoz( PSATLEXP       ,1.0            ,""            							,"" ) 
`MPRnb( PSATB          ,0.0            ,""            							,"Body bias effect on Idsat" ) 
`MPRnb( PSATR          ,PSAT           ,""            							,"Gmsat variation with gate bias" ) 
`MPRnb( LPSATR         ,LPSAT          ,""            							,"" ) 
`MPRnb( WPSATR         ,WPSAT          ,""            							,"" ) 
`MPRnb( PPSATR         ,PPSAT          ,""            							,"" ) 

`MPRnb( LPSATB         ,0.0            ,""            							,"" ) 
`MPRnb( WPSATB         ,0.0            ,""            							,"" ) 
`MPRnb( PPSATB         ,0.0            ,""            							,"" ) 

`MPRoz( PSATX          ,1.0            ,""            							,"" ) 
`MPRnb( PTWG           ,0.0            ,""            							,"Idsat variation with gate bias" ) 
`MPRnb( LPTWG          ,0.0            ,""            							,"" ) 
`MPRnb( WPTWG          ,0.0            ,""            							,"" ) 
`MPRnb( PPTWG          ,0.0            ,""            							,"" ) 
`MPRnb( PTWGL          ,0.0            ,""            							,"Length dependence coefficient of PTWG" ) 
`MPRoz( PTWGLEXP       ,1.0            ,""            							,"Length dependence exponent coefficient of PTWG" ) 
`MPRnb( PTWGR          ,PTWG           ,""            							,"Idsat variation with gate bias" ) 
`MPRnb( LPTWGR         ,LPTWG          ,""            							,"" ) 
`MPRnb( WPTWGR         ,WPTWG          ,""            							,"" ) 
`MPRnb( PPTWGR         ,PPTWG          ,""            							,"" ) 
`MPRnb( PTWGLR         ,PTWGL          ,""            							,"Length dependence coefficient of PTWG" ) 
`MPRoz( PTWGLEXPR      ,PTWGLEXP       ,""            							,"Length dependence exponent coefficient of PTWG" ) 

// ******Velocity Non Saturation Effect
`MPRnb( A1             ,0.0            ,""            							,"Non-saturation effect parameter for strong inversion region" ) 
`MPRnb( LA1            ,0.0            ,""            							,"" ) 
`MPRnb( WA1            ,0.0            ,""            							,"" ) 
`MPRnb( PA1            ,0.0            ,""            							,"" ) 
`MPRnb( A11            ,0.0            ,""            							,"Temperature dependence of A1" ) 
`MPRnb( LA11           ,0.0            ,""            							,"" ) 
`MPRnb( WA11           ,0.0            ,""            							,"" ) 
`MPRnb( PA11           ,0.0            ,""            							,"" ) 

`MPRnb( A2             ,0.0            ,""            							,"Non-saturation effect parameter for moderate inversion region" ) 
`MPRnb( LA2            ,0.0            ,""           							,"" ) 
`MPRnb( WA2            ,0.0            ,""            							,"" ) 
`MPRnb( PA2            ,0.0            ,""            							,"" ) 
`MPRnb( A21            ,0.0            ,""            							,"Temperature dependence of A2" ) 
`MPRnb( LA21           ,0.0            ,""            							,"" ) 
`MPRnb( WA21           ,0.0            ,""            							,"" ) 
`MPRnb( PA21           ,0.0            ,""            							,"" ) 
				
// Output Conductance
`MPRnb( PDIBLC         ,0.0            ,""            							,"parameter for DIBL effect on Rout" ) 
`MPRnb( PDIBLCL        ,0.0            ,""            							,"Length dependence coefficient of PDIBLC" ) 
`MPRoz( PDIBLCLEXP     ,1.0            ,""            							,"Length dependence exponent coefficient of PDIBLC" ) 
`MPRnb( LPDIBLC        ,0.0            ,""            							,"" ) 
`MPRnb( WPDIBLC        ,0.0            ,""            							,"" ) 
`MPRnb( PPDIBLC        ,0.0            ,""            							,"" ) 
`MPRnb( PDIBLCR        ,0.0            ,""            							,"parameter for DIBL effect on Rout" ) 
`MPRnb( PDIBLCLR       ,PDIBLCL        ,""            							,"Length dependence coefficient of PDIBLC" ) 
`MPRoz( PDIBLCLEXPR    ,PDIBLCLEXP     ,""            							,"Length dependence exponent coefficient of PDIBLC" ) 
`MPRnb( LPDIBLCR       ,LPDIBLC        ,""            							,"" ) 
`MPRnb( WPDIBLCR       ,WPDIBLC        ,""            							,"" ) 
`MPRnb( PPDIBLCR       ,PPDIBLC        ,""            							,"" ) 

`MPRnb( PDIBLCB        ,0.0            ,""            							,"parameter for DIBL effect on Rout" ) 
`MPRnb( LPDIBLCB       ,0.0            ,""            							,"" ) 
`MPRnb( WPDIBLCB       ,0.0            ,""            							,"" ) 
`MPRnb( PPDIBLCB       ,0.0            ,""            							,"" ) 

`MPRnb( PVAG           ,1.0            ,""            							,"Vg dependence of early voltage" ) 
`MPRnb( LPVAG          ,0.0            ,""            							,"" ) 
`MPRnb( WPVAG          ,0.0            ,""            							,"" ) 
`MPRnb( PPVAG          ,0.0            ,""            							,"" ) 

`MPRnb( FPROUT         ,0.0            ,""            							,"" ) 
`MPRnb( FPROUTL        ,0.0            ,""            							,"Length dependence coefficient of FPROUT" ) 
`MPRoz( FPROUTLEXP     ,1.0            ,""            							,"Length dependence exponent coefficient of FPROUT" ) 
`MPRnb( LFPROUT        ,0.0            ,""            							,"" ) 
`MPRnb( WFPROUT        ,0.0            ,""            							,"" ) 
`MPRnb( PFPROUT        ,0.0            ,""            							,"" ) 

// Impact Ionization Current
`MPRnb( ALPHA0         ,0.0            ,""            							,"first parameter of Iii, m/V" ) 
`MPRnb( ALPHA0L        ,0.0            ,""           	 						,"Length dependence coefficient of ALPHA0" ) 
`MPRoz( ALPHA0LEXP     ,1.0            ,""            							,"Length dependence exponent coefficient of ALPHA0" ) 
`MPRnb( LALPHA0        ,0.0            ,""            							,"" ) 
`MPRnb( WALPHA0        ,0.0            ,""            							,"" ) 
`MPRnb( PALPHA0        ,0.0            ,""            							,"" ) 

`MPRnb( BETA0          ,0.0            ,""            							,"Vds dependent parameter of Iii, 1/V" ) 
`MPRnb( LBETA0         ,0.0            ,""            							,"" ) 
`MPRnb( WBETA0         ,0.0            ,""            							,"" ) 
`MPRnb( PBETA0         ,0.0            ,""            							,"" ) 

//Gate Dielectric Tunneling Current Model Parameters
`MPRnb( AIGBACC        ,1.36e-2        ,""            							,"Parameter for Igb" ) 
`MPRnb( BIGBACC        ,1.71e-3        ,""            							,"Parameter for Igb" ) 
`MPRnb( CIGBACC        ,0.075          ,""            							,"Parameter for Igb" ) 
`MPRnb( NIGBACC        ,1.0            ,""            							,"Parameter for Igbacc slope" ) 
`MPRnb( AIGBINV        ,1.11e-2        ,""            							,"Parameter for Igb" ) 
`MPRnb( BIGBINV        ,9.49e-4        ,""            							,"Parameter for Igb" ) 
`MPRnb( CIGBINV        ,0.006          ,""            							,"Parameter for Igb" ) 
`MPRnb( EIGBINV        ,1.1            ,""            							,"Parm for the Si bandgap for Igbinv" ) 
`MPRnb( NIGBINV        ,3.0            ,""            							,"Parameter for Igbinv slope" ) 
`MPRnb( AIGC           ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    	,""         ,"Parameter for Igc" ) 
`MPRnb( BIGC           ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)		,""         ,"Parameter for Igc" ) 
`MPRnb( CIGC           ,((TYPE == `ntype) ? 0.075 : 0.03)			,""         ,"Parameter for Igc" ) 
`MPRnb( AIGS           ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)		,""         ,"Parameter for Igs d" ) 
`MPRnb( BIGS           ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)		,""         ,"Parameter for Igs d" ) 
`MPRnb( CIGS           ,((TYPE == `ntype) ? 0.075 : 0.03)			,""         ,"Parameter for Igs d" ) 
`MPRnb( AIGD           ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)		,""         ,"Parameter for Igs d" ) 
`MPRnb( BIGD           ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)		,""         ,"Parameter for Igs d" ) 
`MPRnb( CIGD           ,((TYPE == `ntype) ? 0.075 : 0.03)			,""         ,"Parameter for Igs d" ) 
`MPRnb( DLCIG          ,LINT           ,"m"           							,"Delta L for Ig model [m]" ) 
`MPRnb( DLCIGD         ,DLCIG          ,"m"           							,"Delta L for Ig model [m]" ) 
`MPRnb( POXEDGE        ,1.0            ,""            							,"Factor for the gate edge Tox" ) 
`MPRnb( NTOX           ,1.0            ,""            							,"Exponent for Tox ratio" ) 
`MPRoz( TOXREF         ,3.0e-9         ,"m"           							,"Target tox value" ) 
`MPRcc( PIGCD          ,1.0            ,""            ,-50         ,50          ,"Igc, S/D partition parameter" ) 

`MPRnb( AIGCL          ,0.0            ,""            							,"Length dependence coefficient of AIGC" ) 
`MPRnb( AIGCW          ,0.0            ,""            							,"Width dependence coefficient of AIGC" ) 
`MPRnb( AIGSL          ,0.0            ,""            							,"Length dependence coefficient of AIGS" ) 
`MPRnb( AIGSW          ,0.0            ,""            							,"Width dependence coefficient of AIGS" ) 
`MPRnb( AIGDL          ,0.0            ,""            							,"Length dependence coefficient of AIGD" ) 
`MPRnb( AIGDW          ,0.0            ,""            							,"Width dependence coefficient of AIGD" ) 
`MPRnb( PIGCDL         ,0.0            ,""            							,"Length dependence coefficient of PIGCD" ) 

`MPRnb( LAIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( WAIGBINV       ,0.0            ,""           					 		,"" ) 
`MPRnb( PAIGBINV       ,0.0            ,""            							,"" ) 

`MPRnb( LBIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( WBIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( PBIGBINV       ,0.0            ,""            							,"" ) 

`MPRnb( LCIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( WCIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( PCIGBINV       ,0.0            ,""            							,"" ) 

`MPRnb( LEIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( WEIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( PEIGBINV       ,0.0            ,""            							,"" ) 

`MPRnb( LNIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( WNIGBINV       ,0.0            ,""            							,"" ) 
`MPRnb( PNIGBINV       ,0.0            ,""            							,"" ) 

`MPRnb( LAIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( WAIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( PAIGBACC       ,0.0            ,""            							,"" ) 

`MPRnb( LBIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( WBIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( PBIGBACC       ,0.0            ,""            							,"" ) 

`MPRnb( LCIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( WCIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( PCIGBACC       ,0.0            ,""            							,"" ) 

`MPRnb( LNIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( WNIGBACC       ,0.0            ,""            							,"" ) 
`MPRnb( PNIGBACC       ,0.0            ,""            							,"" ) 

`MPRnb( LAIGC          ,0.0            ,""            							,"" ) 
`MPRnb( WAIGC          ,0.0            ,""            							,"" ) 
`MPRnb( PAIGC          ,0.0            ,""            							,"" ) 

`MPRnb( LBIGC          ,0.0            ,""            							,"" ) 
`MPRnb( WBIGC          ,0.0            ,""            							,"" ) 
`MPRnb( PBIGC          ,0.0            ,""            							,"" ) 

`MPRnb( LCIGC          ,0.0            ,""            							,"" ) 
`MPRnb( WCIGC          ,0.0            ,""            							,"" ) 
`MPRnb( PCIGC          ,0.0            ,""            							,"" ) 

`MPRnb( LAIGS          ,0.0            ,""            							,"" ) 
`MPRnb( WAIGS          ,0.0            ,""            							,"" ) 
`MPRnb( PAIGS          ,0.0            ,""            							,"" ) 

`MPRnb( LBIGS          ,0.0            ,""            							,"" ) 
`MPRnb( WBIGS          ,0.0            ,""            							,"" ) 
`MPRnb( PBIGS          ,0.0            ,""            							,"" ) 

`MPRnb( LCIGS          ,0.0            ,""            							,"" ) 
`MPRnb( WCIGS          ,0.0            ,""            							,"" ) 
`MPRnb( PCIGS          ,0.0            ,""            							,"" ) 

`MPRnb( LAIGD          ,0.0            ,""            							,"" ) 
`MPRnb( WAIGD          ,0.0            ,""           					 		,"" ) 
`MPRnb( PAIGD          ,0.0            ,""            							,"" ) 

`MPRnb( LBIGD          ,0.0            ,""            							,"" ) 
`MPRnb( WBIGD          ,0.0            ,""            							,"" ) 
`MPRnb( PBIGD          ,0.0            ,""            							,"" ) 

`MPRnb( LCIGD          ,0.0            ,""            							,"" ) 
`MPRnb( WCIGD          ,0.0            ,""            							,"" ) 
`MPRnb( PCIGD          ,0.0            ,""            							,"" ) 

`MPRnb( LPOXEDGE       ,0.0            ,""            							,"" ) 
`MPRnb( WPOXEDGE       ,0.0            ,""            							,"" ) 
`MPRnb( PPOXEDGE       ,0.0            ,""            							,"" ) 

`MPRnb( LDLCIG         ,0.0            ,""            							,"" ) 
`MPRnb( WDLCIG         ,0.0            ,""            							,"" ) 
`MPRnb( PDLCIG         ,0.0            ,""            							,"" ) 

`MPRnb( LDLCIGD        ,0.0            ,""            							,"" ) 
`MPRnb( WDLCIGD        ,0.0            ,""            							,"" ) 
`MPRnb( PDLCIGD        ,0.0            ,""            							,"" ) 

`MPRnb( LNTOX          ,0.0            ,""            							,"" ) 
`MPRnb( WNTOX          ,0.0            ,""            							,"" ) 
`MPRnb( PNTOX          ,0.0            ,""            							,"" ) 

//GIDL/GISL Current
`MPRnb( AGIDL          ,0.0            ,"V/m"         							,"pre-exponential coeff. for GIDL in mho" ) 
`MPRnb( AGIDLL         ,0.0            ,""            							,"Length dependence coefficient of AGIDL" ) 
`MPRnb( AGIDLW         ,0.0            ,""            							,"Width dependence coefficient of AGIDL" ) 
`MPRnb( LAGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( WAGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( PAGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( BGIDL          ,2.3e9          ,"V/m"         							,"exponential coeff. for GIDL in" ) 
`MPRnb( LBGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( WBGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( PBGIDL         ,0.0            ,""            							,"" ) 

`MPRnb( CGIDL          ,0.5            ,"V/m"         							,"exponential coeff. for GIDL in V/m" ) 
`MPRnb( LCGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( WCGIDL         ,0.0            ,""           				 			,"" ) 
`MPRnb( PCGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( EGIDL          ,0.8            ,""            							,"band bending parameter for GIDL" ) 
`MPRnb( LEGIDL         ,0.0            ,""           	 						,"" ) 
`MPRnb( WEGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( PEGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( AGISL          ,AGIDL          ,"V/m"         							,"pre-exponential coeff. for GISL" ) 
`MPRnb( AGISLL         ,AGIDLL         ,""            							,"Length dependence coefficient of AGISL" ) 
`MPRnb( AGISLW         ,AGIDLW         ,""            							,"Width dependence coefficient of AGISL" ) 
`MPRnb( LAGISL         ,LAGIDL         ,""            							,"" ) 
`MPRnb( WAGISL         ,WAGIDL         ,""            							,"" ) 
`MPRnb( PAGISL         ,PAGIDL         ,""            							,"" ) 
`MPRnb( BGISL          ,BGIDL          ,"V/m"         							,"exponential coeff. for GISL" ) 
`MPRnb( LBGISL         ,LBGIDL         ,""            							,"" ) 
`MPRnb( WBGISL         ,WBGIDL         ,""            							,"" ) 
`MPRnb( PBGISL         ,PBGIDL         ,""            							,"" ) 
`MPRnb( CGISL          ,CGIDL          ,"V/m"         							,"exponential coeff. for GISL" ) 
`MPRnb( LCGISL         ,LCGIDL         ,""            							,"" ) 
`MPRnb( WCGISL         ,WCGIDL         ,""            							,"" ) 
`MPRnb( PCGISL         ,PCGIDL         ,""            							,"" ) 
`MPRnb( EGISL          ,EGIDL          ,""            							,"band bending parameter for GISL" ) 
`MPRnb( LEGISL         ,LEGIDL         ,""            							,"" ) 
`MPRnb( WEGISL         ,WEGIDL         ,""            							,"" ) 
`MPRnb( PEGISL         ,PEGIDL         ,""            							,"" ) 

// Overlap Cap and Fringing Cap
`MPRnb( CF             ,0.0            ,"F"           							,"Outer Fringe Cap" ) 
`MPRnb( LCF            ,0.0            ,"F"           							,"" ) 
`MPRnb( WCF            ,0.0            ,"F"           							,"" ) 
`MPRnb( PCF            ,0.0            ,"F"           							,"" ) 
`MPRco( CFRCOEFF       ,1.0            ,""            ,1.0         ,inf         ,"Coefficient for Outer Fringe Cap" ) 
`MPRnb( CGSO           ,0.0            ,""            							,"Gate - Source overlap capacitance" ) 
`MPRnb( CGDO           ,0.0            ,""            							,"Gate - Drain overlap capacitance" ) 
`MPRnb( CGBO           ,0.0            ,""            							,"Gate - Body overlap capacitance" ) 
`MPRnb( CGSL           ,0.0            ,""            							,"" ) 
`MPRnb( LCGSL          ,0.0            ,""            							,"" ) 
`MPRnb( WCGSL          ,0.0            ,""            							,"" ) 
`MPRnb( PCGSL          ,0.0            ,""           				 			,"" ) 
`MPRnb( CGDL           ,0.0            ,""            							,"" ) 
`MPRnb( LCGDL          ,0.0            ,""            							,"" ) 
`MPRnb( WCGDL          ,0.0            ,""            							,"" ) 
`MPRnb( PCGDL          ,0.0            ,""            							,"" ) 
`MPRnb( CKAPPAS        ,0.6            ,""            							,"" ) 
`MPRnb( LCKAPPAS       ,0.0            ,""            							,"" ) 
`MPRnb( WCKAPPAS       ,0.0            ,""            							,"" ) 
`MPRnb( PCKAPPAS       ,0.0            ,""            							,"" ) 
`MPRnb( CKAPPAD        ,0.6            ,""            							,"" ) 
`MPRnb( LCKAPPAD       ,0.0            ,""            							,"" ) 
`MPRnb( WCKAPPAD       ,0.0            ,""            							,"" ) 
`MPRnb( PCKAPPAD       ,0.0            ,""            							,"" ) 


// Layout-Dependent Parasitics Model Parameters ....Resistance only
`MPRnb( DMCG           ,0.0            ,"m"           							,"Distance of Mid-Contact to Gate edge" ) 
`MPRnb( DMCI           ,DMCG           ,"m"           							,"Distance of Mid-Contact to Isolation" ) 
`MPRnb( DMDG           ,0.0            ,"m"           							,"Distance of Mid-Diffusion to Gate edge" ) 
`MPRnb( DMCGT          ,0.0            ,"m"           							,"Dist of Mid-Contact to Gate edge in Test" ) 

`ifdef __RGATEMOD__
`MPRoo( XGL            ,0.0            ,"m"           ,-inf        ,L*LMLT+XL   ,"Variation in Ldrawn" ) 
`MPRcz( RSHG           ,0.1            ,"ohm"         							,"Gate sheet resistance" ) 
`endif

// Junction current and capacitance
// Junction Capacitance
`MPRnb( CJS            ,5.0e-4         ,""            							,"Unit area source-side junction capacitance at zero bias" ) 
`MPRnb( CJD            ,CJS            ,""            							,"Unit area drain-side junction capacitance at zero bias" ) 
`MPRnb( CJSWS          ,5.0e-10        ,""            							,"Unit length source-side sidewall junction capacitance at zero bias" ) 
`MPRnb( CJSWD          ,CJSWS          ,""            							,"Unit length drain-side sidewall junction capacitance at zero bias" ) 
`MPRnb( CJSWGS         ,0.0            ,""            							,"Unit length source-side gate sidewall junction capacitance at zero bias" ) 
`MPRnb( CJSWGD         ,CJSWGS         ,""            							,"Unit length drain-side gate sidewall junction capacitance at zero bias" ) 
`MPRnb( PBS            ,1.0            ,""            							,"Source-side bulk junction built-in potential" ) 
`MPRnb( PBD            ,PBS            ,""            							,"Drain-side bulk junction built-in potential" ) 
`MPRnb( PBSWS          ,1.0            ,""            							,"Built-in potential for Source-side sidewall junction capacitance" ) 
`MPRnb( PBSWD          ,PBSWS          ,""            							,"Built-in potential for Drain-side sidewall junction capacitance" ) 
`MPRnb( PBSWGS         ,PBSWS          ,""            							,"Built-in potential for Source-side gate sidewall junction capacitance" ) 
`MPRnb( PBSWGD         ,PBSWGS         ,""            							,"Built-in potential for Drain-side gate sidewall junction capacitance" ) 
`MPRnb( MJS            ,0.5            ,""            							,"Source bottom junction capacitance grading coefficient" ) 
`MPRnb( MJD            ,MJS            ,""            							,"Drain bottom junction capacitance grading coefficient" ) 
`MPRnb( MJSWS          ,0.33           ,""            							,"Source sidewall junction capacitance grading coefficient" ) 
`MPRnb( MJSWD          ,MJSWS          ,""            							,"Drain sidewall junction capacitance grading coefficient" ) 
`MPRnb( MJSWGS         ,MJSWS          ,""            							,"Source-side gate sidewall junction capacitance grading coefficient" ) 
`MPRnb( MJSWGD         ,MJSWGS         ,""            							,"Drain-side gate sidewall junction capacitance grading coefficient" ) 

// Junction Current
`MPRnb( JSS            ,1.0e-4         ,""            							,"Bottom source junction reverse saturation current density" ) 
`MPRnb( JSD            ,JSS            ,""            							,"Bottom drain junction reverse saturation current density" ) 
`MPRnb( JSWS           ,0.0            ,""            							,"Unit length reverse saturation current for sidewall source junction" ) 
`MPRnb( JSWD           ,JSWS           ,""            							,"Unit length reverse saturation current for sidewall drain junction" ) 
`MPRnb( JSWGS          ,0.0            ,""            							,"Unit length reverse saturation current for gate-edge sidewall source junction" ) 
`MPRnb( JSWGD          ,JSWGS          ,""            							,"Unit length reverse saturation current for gate-edge sidewall drain junction" ) 
`MPRnb( NJS            ,1.0            ,""            							,"Source junction emission coefficient" ) 
`MPRnb( NJD            ,NJS            ,""            							,"Drain junction emission coefficient" ) 
`MPRnb( IJTHSFWD       ,0.1            ,""            							,"Forward source diode breakdown limiting current" ) 
`MPRnb( IJTHDFWD       ,IJTHSFWD       ,""            							,"Forward drain diode breakdown limiting current" ) 
`MPRnb( IJTHSREV       ,0.1            ,""           					 		,"Reverse source diode breakdown limiting current" ) 
`MPRnb( IJTHDREV       ,IJTHSREV       ,""            							,"Reverse drain diode breakdown limiting current" ) 
`MPRnb( BVS            ,10.0           ,""            							,"Source diode breakdown voltage" ) 
`MPRnb( BVD            ,BVS            ,""            							,"Drain diode breakdown voltage" ) 
`MPRnb( XJBVS          ,1.0            ,""            							,"Fitting parameter for source diode breakdown current" ) 
`MPRnb( XJBVD          ,XJBVS          ,""            							,"Fitting parameter for drain diode breakdown current" ) 

// Tunneling Component of Junction Current
`MPRnb( JTSS           ,0.0            ,""            							,"Bottom source junction trap-assisted saturation current density" ) 
`MPRnb( JTSD           ,JTSS           ,""            							,"Bottom drain junction trap-assisted saturation current density" ) 
`MPRnb( JTSSWS         ,0.0            ,""            							,"Unit length trap-assisted saturation current for sidewall source junction" ) 
`MPRnb( JTSSWD         ,JTSSWS         ,""            							,"Unit length trap-assisted saturation current for sidewall drain junction" ) 
`MPRnb( JTSSWGS        ,0.0            ,""            							,"Unit length trap-assisted saturation current for gate-edge sidewall source junction" ) 
`MPRnb( JTSSWGD        ,JTSSWGS        ,""            							,"Unit length trap-assisted saturation current for gate-edge sidewall drain junction" ) 
`MPRnb( JTWEFF         ,0.0            ,""            							,"Trap assisted tunneling current width dependence" ) 
`MPRnb( NJTS           ,20.0           ,""            							,"Non-ideality factor for JTSS" ) 
`MPRnb( NJTSD          ,NJTS           ,""            							,"Non-ideality factor for JTSD" ) 
`MPRnb( NJTSSW         ,20.0           ,""            							,"Non-ideality factor for JTSSWS" ) 
`MPRnb( NJTSSWD        ,NJTSSW         ,""            							,"Non-ideality factor for JTSSWD" ) 
`MPRnb( NJTSSWG        ,20.0           ,""            							,"Non-ideality factor for JTSSWGS" ) 
`MPRnb( NJTSSWGD       ,NJTSSWG        ,""            							,"Non-ideality factor for JTSSWGD" ) 
`MPRnb( VTSS           ,10.0           ,""            							,"Bottom source junction trap-assisted current voltage dependent parameter" ) 
`MPRnb( VTSD           ,VTSS           ,""            							,"Bottom drain junction trap-assisted current voltage dependent parameter" ) 
`MPRnb( VTSSWS         ,10.0           ,""            							,"Unit length trap-assisted current voltage dependent parameter for sidewall source junction" ) 
												
`MPRnb( VTSSWD         ,VTSSWS         ,""            							,"Unit length trap-assisted current voltage dependent parameter for sidewall drain junction" ) 
												
`MPRnb( VTSSWGS        ,10.0           ,""            							,"Unit length trap-assisted current voltage dependent parameter for gate-edge sidewall source junction" ) 
												
`MPRnb( VTSSWGD        ,VTSSWGS        ,""            							,"Unit length trap-assisted current voltage dependent parameter for gate-edge sidewall drain junction" ) 
												

// High-Speed/RF Model Parameters
`ifdef __RGATEMOD__
`MPRnb( XRCRG1         ,12.0           ,""            							,"1st fitting parm the bias-dependent Rg //make it binnable" ) 
`MPRnb( XRCRG2         ,1.0            ,""           	 						,"2nd fitting parm the bias-dependent Rg  //make it binnable" ) 
`endif
`ifdef __RBODYMOD__
`MPRcz( GBMIN          ,1.0e-12        ,""            							,"Minimum body conductance" ) 
`MPRoz( RBPS0          ,50.0           ,""            							,"Scaling prefactor for RBPS 50 Ohms" ) 
`MPRcz( RBPSL          ,0.0            ,""            							,"" ) 
`MPRcz( RBPSW          ,0.0            ,""            							,"" ) 
`MPRcz( RBPSNF         ,0.0            ,""            							,"" ) 
`MPRoz( RBPD0          ,50.0           ,""            							,"" ) 
`MPRcz( RBPDL          ,0.0            ,""            							,"Length Scaling parameter for RBPD" ) 
`MPRcz( RBPDW          ,0.0            ,""            							,"Width Scaling parameter for RBPD" ) 
`MPRcz( RBPDNF         ,0.0            ,""            							,"Number of fingers Scaling parameter for RBPD" ) 
`MPRoz( RBPBX0         ,100.0          ,""            							,"" ) 
`MPRcz( RBPBXL         ,0.0            ,""            							,"Length Scaling parameter for RBPBX" ) 
`MPRcz( RBPBXW         ,0.0            ,""            							,"Width Scaling parameter for RBPBX" ) 
`MPRcz( RBPBXNF        ,0.0            ,""            							,"Number of fingers Scaling parameter for RBPBX" ) 
`MPRoz( RBPBY0         ,100.0          ,""            							,"Scaling prefactor for RBPBY" ) 
`MPRcz( RBPBYL         ,0.0            ,""            							,"Length Scaling parameter for RBPBY" ) 
`MPRcz( RBPBYW         ,0.0            ,""            							,"Width Scaling parameter for RBPBY" ) 
`MPRcz( RBPBYNF        ,0.0            ,""            							,"Number of fingers Scaling parameter for RBPBY" ) 
`MPRoz( RBSBX0         ,100.0          ,""            							,"Scaling prefactor for RBSBX" ) 
`MPRoz( RBSBY0         ,100.0          ,""            							,"Scaling prefactor for RBSBY" ) 
`MPRoz( RBDBX0         ,100.0          ,""            							,"Scaling prefactor for RBDBX" ) 
`MPRoz( RBDBY0         ,100.0          ,""            							,"Scaling prefactor for RBDBY" ) 
`MPRcz( RBSDBXL        ,0.0            ,""            							,"Length Scaling parameter for RBSBX and RBDBX" ) 
`MPRcz( RBSDBXW        ,0.0            ,""            							,"Width Scaling parameter for RBSBX and RBDBX" ) 
`MPRcz( RBSDBXNF       ,0.0            ,""            							,"Number of fingers Scaling parameter for RBSBX and RBDBX" ) 
`MPRcz( RBSDBYL        ,0.0            ,""            							,"Length Scaling parameter for RBSBY and RBDBY" ) 
`MPRcz( RBSDBYW        ,0.0            ,""            							,"Width Scaling parameter for RBSBY and RBDBY" ) 
`MPRcz( RBSDBYNF       ,0.0            ,""            							,"Number of fingers Scaling parameter for RBSBY and RBDBY" ) 
`endif

// Flicker Noise
`MPRoc( EF             ,1.0            ,""            ,0           ,2           ,"Flicker Noise frequency exponent" ) 
`MPRnb( EM             ,4.1e7          ,""            							,"" ) 
`MPRnb( NOIA           ,6.250e+40      ,""            							,"" ) 
`MPRnb( NOIB           ,3.125e+25      ,""            							,"" ) 
`MPRnb( NOIC           ,8.750e+8       ,""            							,"" ) 
`MPRnb( LINTNOI        ,0.0            ,""            							,"" ) 

// Thermal Noise
`MPRcz( NTNOI          ,1.0            ,""            							,"" ) 
`ifdef __TNOISW__
`MPRnb( RNOIA          ,0.577          ,""            							,"TNOIMOD = 1" ) 
`MPRnb( RNOIB          ,0.5164         ,""            							,"TNOIMOD = 1" ) 
`MPRnb( RNOIC          ,0.395          ,""            							,"TNOIMOD = 1" ) 
`MPRoo( TNOIA          ,0.0            ,""           ,-inf 		   ,inf			,"TNOIMOD = 1" ) 
`MPRoo( TNOIB          ,0.0            ,""           ,-inf 		   ,inf 		,"TNOIMOD = 1" ) 
`MPRoo( TNOIC          ,0.0            ,""           ,-inf 		   ,inf 		,"Correlation coefficient" ) 
`endif


// Binning Parameters
`MPIcc( BINUNIT        ,1              ,""            ,0           ,1           ,"Unit of L and W for Binning, 1 : micro-meter, 0 : default" ) 
													
`MPRnb( DLBIN          ,0.0            ,""            							,"" ) 
`MPRnb( DWBIN          ,0.0            ,""            							,"" ) 



// Temperature Dependence Parameters
`MPRnb( TNOM           ,27.0           ,"degrees"     							,"Temperature at which the model was extracted" ) 
`MPRnb( DTEMP          ,0.0            ,""            							,"Offset of Device Temperature" ) 

`MPRnb( TBGASUB        ,4.73e-4        ,"eV / degrees"							,"Bandgap Temperature Coefficient" ) 
`MPRnb( TBGBSUB        ,636.0          ,"degrees"     							,"Bandgap Temperature Coefficient" ) 

`MPRnb( TNFACTOR       ,0.0            ,""            							,"Temperature exponent for NFACTOR" ) 

`MPRnb( UTE            ,-1.5           ,""            							,"Mobility temperature exponent" ) 
`MPRnb( LUTE           ,0.0            ,""            							,"" ) 
`MPRnb( WUTE           ,0.0            ,""            							,"" ) 
`MPRnb( PUTE           ,0.0            ,""            							,"" ) 
`MPRnb( UTEL           ,0.0            ,""            							,"Length Scaling parameter for UTE" ) 

`MPRnb( UA1            ,1.0e-3         ,""            							,"Temperature coefficient for UA" ) 
`MPRnb( LUA1           ,0.0            ,""            							,"" ) 
`MPRnb( WUA1           ,0.0            ,""            							,"" ) 
`MPRnb( PUA1           ,0.0            ,""            							,"" ) 
`MPRnb( UA1L           ,0.0            ,""            							,"Length Scaling parameter for UA1" ) 

`MPRnb( UC1            ,0.056e-9       ,""            							,"Temperature coefficient for UC" ) 
`MPRnb( LUC1           ,0.0            ,""            							,"" ) 
`MPRnb( WUC1           ,0.0            ,""            							,"" ) 
`MPRnb( PUC1           ,0.0            ,""            							,"" ) 
`MPRnb( UD1            ,0.0            ,""            							,"Temperature coefficient for UD" ) 
`MPRnb( LUD1           ,0.0            ,""            							,"" ) 
`MPRnb( WUD1           ,0.0            ,""            							,"" ) 
`MPRnb( PUD1           ,0.0            ,""            							,"" ) 
`MPRnb( UD1L           ,0.0            ,""            							,"Length Scaling parameter for UD1" ) 

`MPRnb( UCSTE          ,-4.775e-3      ,""            							,"Temperature coefficient for UCS" ) 
`MPRnb( LUCSTE         ,0.0            ,""            							,"" ) 
`MPRnb( WUCSTE         ,0.0            ,""            							,"" ) 
`MPRnb( PUCSTE         ,0.0            ,""            							,"" ) 

`MPRnb( TETA0          ,0.0            ,""            							,"Temperature coefficient for ETA0" ) 

`MPRnb( PRT            ,0.0            ,""            							,"Temperature coefficient for resistance" ) 
`MPRnb( LPRT           ,0.0            ,""            							,"" ) 
`MPRnb( WPRT           ,0.0            ,""            							,"" ) 
`MPRnb( PPRT           ,0.0            ,""            							,"" ) 

`MPRnb( AT             ,-1.56e-3       ,""            							,"Temperature coefficient for saturation velocity" ) 
`MPRnb( LAT            ,0.0            ,""            							,"" ) 
`MPRnb( WAT            ,0.0            ,""            							,"" ) 
`MPRnb( PAT            ,0.0            ,""            							,"" ) 
`MPRnb( ATL            ,0.0            ,""            							,"Length Scaling parameter for AT" ) 

`MPRnb( TDELTA         ,0.0            ,""            							,"Temperature coefficient for DELTA" ) 

`MPRnb( PTWGT          ,0.0            ,""            							,"Temperature coefficient for PTWG" ) 
`MPRnb( LPTWGT         ,0.0            ,""            							,"" ) 
`MPRnb( WPTWGT         ,0.0            ,""            							,"" ) 
`MPRnb( PPTWGT         ,0.0            ,""            							,"" ) 
`MPRnb( PTWGTL         ,0.0            ,""            							,"Length Scaling parameter for PTWGT" ) 

`MPRnb( KT1            ,-0.11          ,""            							,"Temperature coefficient for Vth" ) 
`MPRoz( KT1EXP         ,1.0            ,""            							,"Temperature coefficient for Vth" ) 
`MPRnb( KT1L           ,0.0            ,""            							,"Temperature coefficient for Vth" ) 
`MPRnb( LKT1           ,0.0            ,""            							,"" ) 
`MPRnb( WKT1           ,0.0            ,""            							,"" ) 
`MPRnb( PKT1           ,0.0            ,""            							,"" ) 

`MPRnb( KT2            ,0.022          ,""            							,"Temperature coefficient for Vth" ) 
`MPRnb( LKT2           ,0.0            ,""            							,"" ) 
`MPRnb( WKT2           ,0.0            ,""            							,"" ) 
`MPRnb( PKT2           ,0.0            ,""            							,"" ) 

`MPRnb( IIT            ,0.0            ,""            							,"Temperature coefficient for BETA0" ) 
`MPRnb( LIIT           ,0.0            ,""            							,"" ) 
`MPRnb( WIIT           ,0.0            ,""            							,"" ) 
`MPRnb( PIIT           ,0.0            ,""            							,"" ) 

`MPRnb( IGT            ,2.5            ,""            							,"Gate Current Temperature Dependence" ) 
`MPRnb( LIGT           ,0.0            ,""            							,"" ) 
`MPRnb( WIGT           ,0.0            ,""            							,"" ) 
`MPRnb( PIGT           ,0.0            ,""            							,"" ) 

`MPRnb( TGIDL          ,0.0            ,""           	 						,"Temperature coefficient for GIDL/GISL" ) 
`MPRnb( LTGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( WTGIDL         ,0.0            ,""            							,"" ) 
`MPRnb( PTGIDL         ,0.0            ,""            							,"" ) 

`MPRnb( TCJ            ,0.0            ,""            							,"Temperature coefficient for CJS/CJD" ) 
`MPRnb( TCJSW          ,0.0            ,""            							,"Temperature coefficient for CJSWS/CJSWD" ) 
`MPRnb( TCJSWG         ,0.0            ,""            							,"Temperature coefficient for CJSWGS/CJSWGD" ) 
`MPRnb( TPB            ,0.0            ,""            							,"Temperature coefficient for PBS/PBD" ) 
`MPRnb( TPBSW          ,0.0            ,""            							,"Temperature coefficient for PBSWS/PBSWD" ) 
`MPRnb( TPBSWG         ,0.0            ,""            							,"Temperature coefficient for PBSWGS/PBSWGD" ) 
`MPRnb( XTIS           ,3.0            ,""            							,"Source junction current temperature exponent" ) 
`MPRnb( XTID           ,XTIS           ,""            							,"Drain junction current temperature exponent" ) 
`MPRnb( XTSS           ,0.02           ,""            							,"Power dependence of JTSS on temperature" ) 
`MPRnb( XTSD           ,XTSS           ,""            							,"Power dependence of JTSD on temperature" ) 
`MPRnb( XTSSWS         ,0.02           ,""            							,"Power dependence of JTSSWS on temperature" ) 
`MPRnb( XTSSWD         ,XTSSWS         ,""            							,"Power dependence of JTSSWD on temperature" ) 
`MPRnb( XTSSWGS        ,0.02           ,""            							,"Power dependence of JTSSWGS on temperature" ) 
`MPRnb( XTSSWGD        ,XTSSWGS        ,""            							,"Power dependence of JTSSWGD on temperature" ) 
`MPRnb( TNJTS          ,0.0            ,""            							,"Temperature coefficient for NJTS" ) 
`MPRnb( TNJTSD         ,TNJTS          ,""            							,"Temperature coefficient for NJTSD" ) 
`MPRnb( TNJTSSW        ,0.0            ,""            							,"Temperature coefficient for NJTSSW" ) 
`MPRnb( TNJTSSWD       ,TNJTSSW        ,""            							,"Temperature coefficient for NJTSSWD" ) 
`MPRnb( TNJTSSWG       ,0.0            ,""            							,"Temperature coefficient for NJTSSWG" ) 
`MPRnb( TNJTSSWGD      ,TNJTSSWG       ,""            							,"Temperature coefficient for NJTSSWGD" ) 

// Self Heating Parameter
`MPRnb( RTH0           ,0.0            ,""            							,"Thermal resistance" ) 
`MPRnb( CTH0           ,1.0E-05        ,""            							,"Thermal capacitance" ) 
`MPRnb( WTH0           ,0.0            ,""            							,"Width dependence coefficient for Rth and Cth" ) 

//Stress related Parameter
`MPRoz( SAREF          ,1.0e-6         ,""            							,"Reference distance between OD edge from Poly from one side" ) 
`MPRoz( SBREF          ,1.0e-6         ,""            							,"Reference distance between OD edge from Poly from other side" ) 
`MPRcz( WLOD           ,0.0            ,""            							,"Width Parameter for Stress Effect" ) 
`MPRnb( KU0            ,0.0            ,""            							,"Mobility degradation/enhancement Parameter for Stress Effect" ) 
`MPRnb( KVSAT          ,0.0            ,""            							,"Saturation Velocity degradation/enhancement Parameter for Stress Effect" ) 
`MPRnb( TKU0           ,0.0            ,""            							,"Temperature Coefficient for KU0" ) 
`MPRnb( LKU0           ,0.0            ,""            							,"Length Dependence of KU0" ) 
`MPRnb( WKU0           ,0.0            ,""            							,"Width Dependence of KU0" ) 
`MPRnb( PKU0           ,0.0            ,""            							,"Cross Term Dependence of KU0" ) 
`MPRnb( LLODKU0        ,0.0            ,""            							,"Length Parameter for u0 stress effect" ) 
`MPRnb( WLODKU0        ,0.0            ,""            							,"Width Parameter for u0 stress effect" ) 
`MPRnb( KVTH0          ,0.0            ,""            							,"Threshold Shift parameter for stress effect" ) 
`MPRnb( LKVTH0         ,0.0            ,""            							,"Length dependence of KVTH0" ) 
`MPRnb( WKVTH0         ,0.0            ,""            							,"Width dependence of KVTH0" ) 
`MPRnb( PKVTH0         ,0.0            ,""            							,"Cross-term dependence of KVTH0" ) 
`MPRnb( LLODVTH        ,0.0            ,""            							,"Length Parameter for Vth stress effect" ) 
`MPRnb( WLODVTH        ,0.0            ,""            							,"Width Parameter for Vth stress effect" ) 
`MPRnb( STK2           ,0.0            ,""            							,"K2 shift factor related to Vth change" ) 
`MPRnb( LODK2          ,0.0            ,""            							,"K2 shift modification factor for stress effect" ) 
`MPRnb( STETA0         ,0.0            ,""            							,"eta0 shift related to Vth0 change" ) 
`MPRnb( LODETA0        ,0.0            ,""            							,"eta0 modification foator for stress effect" ) 
//Well Proximity Parameters
`MPRnb( WEB            ,0.0            ,""            							,"" ) 
`MPRnb( WEC            ,0.0            ,""            							,"" ) 
`MPRnb( KVTH0WE        ,0.0            ,""            							,"" ) 
`MPRnb( LKVTH0WE       ,0.0            ,""            							,"" ) 
`MPRnb( WKVTH0WE       ,0.0            ,""            							,"" ) 
`MPRnb( PKVTH0WE       ,0.0            ,""            							,"" ) 
`MPRnb( K2WE           ,0.0            ,""            							,"" ) 
`MPRnb( LK2WE          ,0.0            ,""            							,"" ) 
`MPRnb( WK2WE          ,0.0            ,""            							,"" ) 
`MPRnb( PK2WE          ,0.0            ,""            							,"" ) 
`MPRnb( KU0WE          ,0.0            ,""            							,"" ) 
`MPRnb( LKU0WE         ,0.0            ,""            							,"" ) 
`MPRnb( WKU0WE         ,0.0            ,""            							,"" ) 
`MPRnb( PKU0WE         ,0.0            ,""            							,"" ) 
`MPRoo( SCREF          ,1.0e-6         ,""            ,0		   ,inf			,"" ) 

// STI Edge FET Device Parameters
`MPIcc( EDGEFET        ,1              ,""            ,0           ,1           ,"0: Edge FET Model Off, 1: Edge FET Model ON" ) 
`MPRco( WEDGE          ,10.0e-9        ,""            ,1.0e-9      ,inf         ,"" ) 
`MPRoo( DGAMMAEDGE         ,0.0            ,""            ,-inf        ,inf         ,"" ) 
`MPRoo( DGAMMAEDGEL        ,0.0            ,""            ,-inf        ,inf         ,"" ) 
`MPRoo( DGAMMAEDGELEXP     ,1.0            ,""            ,-inf        ,inf         ,"" ) 
`MPRoo( DVTEDGE        ,0.0            ,""            ,-inf        ,inf         ,"Vth shift for Edge FET" ) 
`MPRnb( NFACTOREDGE    ,NFACTOR        ,""            							,"" ) 
`MPRnb( CITEDGE        ,CIT            ,""            							,"" ) 
`MPRnb( CDSCDEDGE      ,CDSCD          ,""            							,"" ) 
`MPRnb( CDSCBEDGE      ,CDSCB          ,""            							,"" ) 
`MPRnb( ETA0EDGE       ,ETA0           ,""           				 			,"" ) 
`MPRnb( ETABEDGE       ,ETAB           ,""            							,"" ) 
`MPRnb( KT1EDGE        ,KT1            ,""            							,"" ) 
`MPRnb( KT1LEDGE       ,KT1L           ,""            							,"" ) 
`MPRnb( KT2EDGE        ,KT2            ,""            							,"" ) 
`MPRnb( KT1EXPEDGE     ,KT1EXP         ,""            							,"" ) 
`MPRnb( TNFACTOREDGE   ,TNFACTOR       ,""            							,"" ) 
`MPRnb( TETA0EDGE      ,TETA0          ,""            							,"" ) 
`MPRnb( DVT0EDGE       ,2.2            ,""            							,"" ) 
`MPRnb( DVT1EDGE       ,0.53           ,""            							,"" ) 
`MPRnb( DVT2EDGE       ,0.0            ,""            							,"Body-bias coefficient for SCE effect for Edge FET" )

`ifdef __XYCE__
`MPRnb( LMIN           ,0.0            ,"m"                                                             ,"Minimum length for which this model should be used")
`MPRnb( WMIN           ,0.0            ,"m"                                                             ,"Minimum width for which this model should be used")
`MPRnb( LMAX           ,100.0            ,"m"                                                           ,"Maximum length for which this model should be used")
`MPRnb( WMAX           ,0.0            ,"m"                                                             ,"Maximum width for which this model should be used")
`endif

// XYCE MOD:  add multiplicity factor declaration
// It is not OK to assume implicit mfactor
// NOTE:  Every contribution has also been modified to use the multiplicity factor!
`IPM

// ***********************************
//   Variables
// ***********************************

// Common Variables
real PSiso,PDiso,PSsha,PDsha,PSmer,PDmer,ASiso,ADiso,ASsha,ADsha,ASmer,ADmer;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
real Tb;
real epssi, epsox, ni, Weff, Leff, Weff1, Leff1, Wact, Lact, Weffcj, Eg, Eg0;
real dLIV, dWIV, dLB, dWB, dLCV, dWCV, dWJ, Cox, epsratio;
real Vdb_noswap, Vsb_noswap, Vgs_noswap, Vgd_noswap, Vds_noswap;
real sigvds, vfb, vgfb, vgfbCV, Vbsx, Vfbsdr;
real Vg, vg, Vd, Vs, vs, Vds, Vdsx, Vgs_eff, Vgd_eff;
real Vth_shift;
real qia, qba, qiaCV, qbaCV, qbs, qbd, qb, dps, phib, phib_n;
real nq, psip, psiavg, psipclamp, sqrtpsisa, sqrtpsisainv, sqrtpsip;
real Cdep, Lnew, L_mult, Wnew, W_mult;
real wf, wr;
// Short Channel Effects
real n, Fp, nVt, inv_nVt, Vt, inv_Vt;
real PhistVbs, sqrtPhistVbs, Xdep, cdsc;
real T1DEP;
real dVth_ldop, DVTP0_i, DVTP1_i, DVTP2_i, DVTP3_i, DVTP4_i, DVTP5_i;
real dVth_VNUD, dVth_dibl, dvth_temp;
real gam, inv_gam, Phist, sqrtPhist, litl;

// Drain Saturation Voltage
real qis, qdsat, Eeffs, Dmobs, Esat, EsatL, Vdsat, LambdaC_by2, LambdaC;
real Vdseff, Vdssat, VdssatCV, vdeff, vdsat, qdeff, vdsatcv, VdsatCV;
real ln_T1_T2;
real A1_i, A11_i, A1_t, A2_i, A21_i, A2_t, Nsat;
// Mobility Degradation
real EeffFactor, Eeffm, ueff, eta_mu, Dmob, Dtot;

// Velocity Saturation
real zsat, Dvsat, Dptwg, PSAT_i, PSATR_i, PSAT_a;

// Output Conductance
real diffVds, VaDITS, VaSCBE, Vasat;
real DIBLfactor, PVAGfactor, VaDIBL, Vgst2Vtm, Moc, MdL, Mscbe;

//Impact Ionization and GIDL
real Iii, igidl, igisl;

// IV Variables
integer devsign;
real ids;

// CV Variables
real Qb, Qs, Qd1, Qd2, Qd, Qi, QBi, QSi, QDi, QGi, WLCOXVtinv;
real qs, qbeff, dqgeff;
real DPD, vgfbPD, gammaPD, gamg2;
real MdL_2, inv_MdL, inv_MdL_2, MdL_less_1;
real sis, sid, vgpqm, Temps, Tempd, DQSD, DQSD2, invgamg2;
real Vgsov, Vgdov, Qovb, Qovg, Qovs, Qovd, Cgsof, Cgdof;
real XDCinv, Coxeffinv, BSIM6TOXP;
real Vgd_ov_noswap, Vgs_ov_noswap;

// S/D Series Resistance
real WeffWRFactor, Rtot, DMCGeff, DMDGeff, DMCIeff;
real RSourceGeo, RDrainGeo, Rsource, Rdrain, Rdss, Rdsi, Dr;

// S/D Junction Area and Perimeter
real temp_ASeff, temp_ADeff,temp_PSeff,temp_PDeff;
real ASeff, ADeff;

//Gate Resistances
`ifdef __RGATEMOD__
	real Grgeltd, Gcrg, idsovvds;
`endif

//Body Resistance
`ifdef __RBODYMOD__
	real Lnl, Lnw, Lnnf, Bodymode, Rbpbx, Rbpby, Rbsbx, Rbsby, Rbdbx, Rbdby;
	real Rbdb, Rbsb, Rbpb, Rbps, Rbpd;
	real Grbsb, Grbdb, Grbpb, Grbps, Grbpd;
`endif

// Gate Current
real Voxm, Voxminv, Voxmacc, Vdseffx;
real Vaux_Igbinv, Vaux_Igbacc, igbinv, igbacc, igb;
real igcs, igcd, igc0, T1_exp;
real igs, igd, igs_mult, igd_mult;
real Aechvb, Bechvb, AechvbEdge, BechvbEdge, ToxRatio, ToxRatioEdge;

// Junction Current and Capacitance
real PSeff, PDeff;
real Ibs, Ibd, Vbs_jct, Vbd_jct;
real Czbs, Czbssw, Czbsswg, Czbd, Czbdsw, Czbdswg;
real arg, sarg, Qbs, Qbd;
real Isbs, Isbd, Nvtms, Nvtmd;
real SslpRev, IVjsmRev, VjsmRev, SslpFwd, IVjsmFwd, VjsmFwd, XExpBVS;
real DslpRev, IVjdmRev, VjdmRev, DslpFwd, IVjdmFwd, VjdmFwd, XExpBVD;

// Flicker Noise
real LINTNOI_i;
real Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real gspr, gdpr;
real Gtnoi, sidn, Nt;
`ifdef __TNOISW__
	real mig, migid, mid, Lvsat, Vtn;
	real cm_igid, sqid, sqig, ctnoi, betanoisq, thetanoisq;
`endif

// Temperature Effects
real delTemp1;
real DevTemp, Tnom, Vtm, Vtm0;
real TRatio, delTemp;
real U0_t, U0R_t, UA_t, UAR_t, UC_t, UCR_t, UD_t, UDR_t, UCS_t, UCSR_t, rdstemp, VSAT_t, VSATR_t, VSATCV_t;
real DELTA_t, PTWG_t, PTWGR_t, BETA0_t, BGIDL_t, BGISL_t;
real igtemp;
real ETA0_t, ETA0R_t, NFACTOR_t;

//Diode temperature effects
real CJS_t, CJSWS_t, CJSWGD_t, CJD_t, CJSWD_t, CJSWGS_t;
real PBS_t, PBSWS_t, PBSWGS_t, PBD_t, PBSWD_t, PBSWGD_t;
real JSS_t, JSWS_t, JSWGS_t, JSD_t, JSWD_t, JSWGD_t;
real JTSS_t, JTSD_t, JTSSWS_t, JTSSWD_t, JTSSWGS_t, JTSSWGD_t;
real NJTS_t, NJTSD_t, NJTSSW_t, NJTSSWD_t, NJTSSWG_t, NJTSSWGD_t;

// Binning
real PSATB_i;
real KT1_i, KT2_i;
real W_by_NF;
real L_LLN, W_LWN, LW_LLN_LWN, L_LLN1, W_LWN1, LW_LLN_LWN1;
real L_WLN, W_WWN, LW_WLN_WWN, L_WLN1, W_WWN1, LW_WLN_WWN1;
real Inv_L, Inv_W, Inv_WL, Inv_Lact, Inv_Wact, Inv_Llong, Inv_Wwide;
real BIN_L, BIN_W, BIN_WL;
real NGATE_i, NSD_i, NDEP_i, VFB_i;
real CIT_i, CDSCD_i, CDSCDR_i, CDSCD_a, CDSCB_i, NFACTOR_i;
real PHIN_i, ETA0_i, ETA0R_i, ETA0_a, ETAB_i, K2_i, K1_i;
real DELTA_i;
real U0_i, U0R_i, U0_a, VSAT_i, VSATR_i, VSAT_a, VSATCV_i, UA_i, UAR_i, UA_a, EU_i, UD_i, UDR_i, UD_a, UCS_i, UCSR_i, UCS_a, UC_i, UCR_i, UC_a;
real PDIBLC_i, PDIBLCR_i, PDIBLC_a, PDIBLCB_i, PSCBE1_i, PSCBE2_i, PDITS_i, PDITSD_i, FPROUT_i;
real PRWG_i, WR_i, RDWMIN_i, RSWMIN_i, RDW_i, RSW_i, RDSW_i, RDSWMIN_i;
real PTWG_i, PTWGR_i, PTWG_a, PVAG_i, XJ_i;
real PCLM_i, PCLMR_i, PCLM_a, PCLMCV_i, PRWB_i;
real CF_i, CGSL_i, CGDL_i, CKAPPAS_i, CKAPPAD_i;
real VFBCV_i, NDEPCV_i;
real ALPHA0_i, BETA0_i;
real AGIDL_i, BGIDL_i, CGIDL_i, EGIDL_i;
real AGISL_i, BGISL_i, CGISL_i, EGISL_i;
real UTE_i, UA1_i, UC1_i, UD1_i, UCSTE_i, PRT_i, AT_i, PTWGT_i, IIT_i, TGIDL_i;
real KVTH0WE_i, K2WE_i, KU0WE_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real AIGC_i, BIGC_i, CIGC_i;
real AIGS_i, BIGS_i, CIGS_i, AIGD_i, BIGD_i, CIGD_i, POXEDGE_i, PIGCD_i;
real DLCIG_i, DLCIGD_i, NTOX_i;
real IGT_i;

//stress effect
real W_tmp_stress, tmp1_stress, kstress_u0, tmp1_stress_vth, kstress_vth0, ku0_temp;
real Inv_sa, Inv_sb, Inv_saref, Inv_sbref, Inv_odref, rho_ref, Inv_od,rho;
real mu0_mult, vsat_mult, vth0_stress, k2_stress, eta_stress;
integer i;

//Well Proximity effect
real vth0_well, k2_well, mu_well, Wdrn, local_sca, local_scb, local_scc;

//Edge FET Model Variables
real ids_edge, ETA0EDGE_t, NFACTOREDGE_t, Vbi, theta_sce_edge, dvth_dibl, dvth_sce, litl_edge, DGAMMAEDGE_i, vdsatedge, Vdsatedge, Vdssate ; 

// The following are used by the macro definitions (GEOMOD and RGEOMOD )
real nuIntD, nuEndD, nuIntS, nuEndS;
real Rint, Rend;


//VTH variables
real q_vth, psip_th;


// Self Heating
`ifdef __SHMOD__
	real gth, cth;
`endif

// ---- OPERATING POINT VARIABLES ----
`OPP( QBI      , "C"   , "Intrinsic Body Charge")
`OPP( QSI      , "C"   , "Intrinsic Source Charge")
`OPP( QDI      , "C"   , "Intrinsic Drain Charge")
`OPP( QGI      , "C"   , "Intrinsic Gate Charge")
`OPP( CGGI     , "F"   , " Intrinsic g-g MOSFET capacitance")
`OPP( CGBI     , "F"   , " Intrinsic g-b MOSFET capacitance")
`OPP( CGSI     , "F"   , " Intrinsic g-s MOSFET capacitance")
`OPP( CGDI     , "F"   , " Intrinsic g-d MOSFET capacitance")
`OPP( CSGI     , "F"   , " Intrinsic s-g MOSFET capacitance")
`OPP( CSBI     , "F"   , " Intrinsic s-b MOSFET capacitance")
`OPP( CSSI     , "F"   , " Intrinsic s-s MOSFET capacitance")
`OPP( CSDI     , "F"   , " Intrinsic s-d MOSFET capacitance")
`OPP( CDGI     , "F"   , " Intrinsic d-g MOSFET capacitance")
`OPP( CDBI     , "F"   , " Intrinsic d-b MOSFET capacitance")
`OPP( CDSI     , "F"   , " Intrinsic d-s MOSFET capacitance")
`OPP( CDDI     , "F"   , " Intrinsic d-d MOSFET capacitance")
`OPP( CBGI     , "F"   , " Intrinsic b-g MOSFET capacitance")
`OPP( CBBI     , "F"   , " Intrinsic b-b MOSFET capacitance")
`OPP( CBSI     , "F"   , " Intrinsic b-s MOSFET capacitance")
`OPP( CBDI     , "F"   , " Intrinsic b-d MOSFET capacitance")
`OPP( QB       , "C"   , "Body Charge")
`OPP( QS       , "C"   , "Source Charge")
`OPP( QD       , "C"   , "Drain Charge")
`OPP( QG       , "C"   , "Gate Charge")
`OPP( CGG      , "F"   , "g-g MOSFET capacitance")
`OPP( CGB      , "F"   , "g-b MOSFET capacitance")
`OPP( CGS      , "F"   , "g-s MOSFET capacitance")
`OPP( CGD      , "F"   , "g-d MOSFET capacitance")
`OPP( CSG      , "F"   , "s-g MOSFET capacitance")
`OPP( CSB      , "F"   , "s-b MOSFET capacitance")
`OPP( CSS      , "F"   , "s-s MOSFET capacitance")
`OPP( CSD      , "F"   , "s-d MOSFET capacitance")
`OPP( CDG      , "F"   , "d-g MOSFET capacitance")
`OPP( CDB      , "F"   , "d-b MOSFET capacitance")
`OPP( CDS      , "F"   , "d-s MOSFET capacitance")
`OPP( CDD      , "F"   , "d-d MOSFET capacitance")
`OPP( CBG      , "F"   , "b-g MOSFET capacitance")
`OPP( CBB      , "F"   , "b-b MOSFET capacitance")
`OPP( CBS      , "F"   , "b-s MOSFET capacitance")
`OPP( CBD      , "F"   , "b-d MOSFET capacitance")
`OPP( ISUB     , "A"   , "Substrate Current")
`OPP( IGIDL    , "A"   , "")
`OPP( IGISL    , "A"   , "")
`OPP( IGS      , "A"   , "")
`OPP( IGD      , "A"   , "")
`OPP( IGCS     , "A"   , "")
`OPP( IGCD     , "A"   , "")
`OPP( IGB      , "A"   , "")
`OPP( CGSEXT   , "F"   , "")
`OPP( CGDEXT   , "F"   , "")
`OPP( CGBOV    , "F"   , "Front Gate Charge")
`OPP( CAPBS    , "F"   , "")
`OPP( CAPBD    , "F"   , "")
`OPP( WEFF     , "m"   , "")
`OPP( LEFF     , "m"   , "")
`OPP( WEFFCV   , "m"   , "")
`OPP( LEFFCV   , "m"   , "")
`OPP( IDS      , "A"   , "Drain-Source current")
`OPP( IDEFF    , "A"   , "Effective drain Current")
`OPP( ISEFF    , "A"   , "Effective Source Current")
`OPP( IGEFF    , "A"   , "Effective Gate Current")
`OPP( IBS      , "A"   , "")
`OPP( IBD      , "A"   , "")
`OPP( VDS      , "V"   , "Drain to Source Voltage")
`OPP( VGS      , "V"   , "Gate to Source Voltage")
`OPP( VBS      , "V"   , "Body to Source Voltage")
`OPP( VDSAT    , "V"   , "")
`OPP( GM       , "mho" , "")
`OPP( GMBS     , "mho" , "")
`OPP( GDS      , "mho" , "")
`OPP( TK       , "m"   , "")
`OPP( VTH      , "V"   , "Threshold Voltage")


    `ifdef __SHMOD__
        thermal t;
    `else
       `ifdef __THERMAL_NODE__
          thermal t;
       `endif
    `endif    

analog begin

`ifdef __XYCE__
       // Xyce/ADMS cannot automatically detect and isolate bias-independent variables
       // yet.  It has become common for Verilog-A experts to state that all compilers should
       // do this and that model developers should not worry about giving the compilers any help
       // doing the isolation.  This is unfortunate, as ADMS makes this identification pretty
       // difficult
`ifdef insideADMS
       @(initial_instance)
`endif
       begin : initializeInstance
`endif  // __XYCE__
	// Variable initialization to prevent hidden states
	CDSCDR_i = 0; ETA0R_i   = 0; ETA0R_t = 0; L_LLN1  = 0; L_WLN1  = 0; 
	PCLMR_i  = 0; PDIBLCR_i = 0; PSATR_i = 0; PTWGR_i = 0; PTWGR_t = 0;
	U0R_i    = 0; U0R_t     = 0; UAR_i   = 0; UAR_t   = 0; UCR_i   = 0; UCR_t   = 0; 
	UCSR_i   = 0; UCSR_t    = 0; UDR_i   = 0; UDR_t   = 0; UD_a    = 0; VSATR_i = 0; 
	VSATR_t  = 0; W_LWN1    = 0; W_WWN1  = 0;

	// Bias independent calculations
	if( TYPE == `ntype ) devsign = 1;
	else devsign = -1;

	// Constants
	//ni 		= NI0SUB;
	epssi 	= EPSRSUB * `EPS0;
	epsox 	= EPSROX * `EPS0;
	Cox 	= EPSROX * `EPS0 / TOXE;
	epsratio = EPSRSUB / EPSROX;

	//Physical Oxide Thickness
	if (!$param_given(TOXP))
		BSIM6TOXP = (TOXE*EPSROX/3.9) - DTOX; // valid for any dielectric
	else
		BSIM6TOXP = TOXP;

	L_mult = L*LMLT ;
	W_mult = W*WMLT ;

	Lnew = L_mult + XL;
	if (Lnew <= 0) begin					
		$strobe("Fatal: Ldrawn*LMLT+XL = %e for  %M is non-positive", Lnew); 
		$finish(0);
	end
	W_by_NF = W_mult/NF ;
	Wnew 	= W_by_NF +XW;
	if (Wnew <= 0) begin					
		$strobe("Fatal: W/NF*WMLT+XW = %e for  %M is non-positive", Wnew); 
		$finish(0);
	end		
	// Binning
	
	//Leff and Weff for IV
	L_LLN		= pow(Lnew, -LLN);
	W_LWN		= pow(Wnew, -LWN);
	LW_LLN_LWN	= L_LLN*W_LWN;
	dLIV		= LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;
	L_WLN		= pow(Lnew, -WLN);
	W_WWN		= pow(Wnew, -WWN);
	LW_WLN_WWN	= L_WLN*W_WWN;
	dWIV		= WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;
	Leff		= Lnew - 2.0*dLIV;
	if (Leff <= 0) begin
		$strobe("Fatal: Effective channel length = %e for  %M is non-positive", Leff);
		$finish(0);
	end else if (Leff<=1.0e-9)
	$strobe("Warning: Effective channel length = %e for  %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);

	Weff		= Wnew - 2.0*dWIV;
	if (Weff <= 0) begin
		$strobe("Fatal: Effective channel Width = %e for  %M is non-positive", Weff);
		$finish(0);
	end else if (Weff<=1.0e-9)
	$strobe("Warning: Effective channel width = %e for  %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);

	//Leff and Weff for CV
	dLCV		= DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
	dWCV		= DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
	Lact		= Lnew - 2.0*dLCV;
	if (Lact <= 0) begin
		$strobe("Fatal: Effective channel length for CV = %e for  %M is non-positive", Lact);
		$finish(0);
	end else if (Lact<=1.0e-9)
	$strobe("Warning: Effective channel length for CV = %e for  %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);

	Wact		= Wnew - 2.0*dWCV;
	if (Wact <= 0) begin
		$strobe("Fatal: Effective channel width for CV = %e for  %M is non-positive", Wact);
		$finish(0);
	end else if (Wact<=1.0e-9)
	$strobe("Warning: Effective channel width for CV = %e for  %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);


	//Weffcj for Diode, GIDL etc.
	dWJ		= DWJ + WLC / pow(Lnew,WLN) + WWC / pow(Wnew,WWN) + WWLC / pow(Lnew,WLN) / pow(Wnew,WWN);
	Weffcj		= Wnew - 2.0*dWJ;
	if (Weffcj <= 0) begin
		$strobe("Fatal: Effective channel width for S/D junctions = %e for  %M is non-positive", Weffcj);
		$finish(0);
	end

	Inv_L		= 1.0e-6 / Leff;
	Inv_W		= 1.0e-6 / Weff;
	Inv_Lact	= 1.0e-6 / Lact;
	Inv_Wact	= 1.0e-6 / Wact;
	Inv_Llong	= 1.0e-6 / LLONG;
	Inv_Wwide	= 1.0e-6 / WWIDE;
	Inv_WL		= Inv_L * Inv_W;

	// Effective Length and Width for Binning
	L_LLN1		= L_LLN;
	L_WLN1		= L_WLN;
	if (DLBIN != 0) begin
			if(DLBIN<=-Lnew) begin
				$strobe("Fatal: DLBIN for  %M = %e is <= -Ldrawn*LMLT", DLBIN);
				$finish(0);
			end else begin
				L_LLN1		= pow(Lnew+DLBIN, -LLN);
				L_WLN1		= pow(Lnew+DLBIN, -WLN);
			end
	end
		
	W_LWN1      = W_LWN;
	W_WWN1		= W_WWN;
	if (DWBIN != 0) begin
			if(DWBIN<=-Wnew) begin
				$strobe("Fatal: DWBIN for  %M = %e is <= -Wdrawn*WMLT", DWBIN);
				$finish(0);
			end else begin
				W_LWN1		= pow(Wnew+DWBIN, -LWN);	
				W_WWN1		= pow(Wnew+DWBIN, -WWN);
			end
	end

	LW_LLN_LWN1	= L_LLN1*W_LWN1;
	dLB		= LINT + LL * L_LLN1 + LW * W_LWN1 + LWL * LW_LLN_LWN1;
	LW_WLN_WWN1	= L_WLN1*W_WWN1;
	dWB 		= WINT + WL * L_WLN1 + WW * W_WWN1 + WWL * LW_WLN_WWN1;

	Leff1		= Lnew - 2.0*dLB + DLBIN;
	if (Leff1 <= 0) begin
		$strobe("Fatal: Effective channel length for binning = %e for  %M is non-positive", Leff1);
		$finish(0);
	end
	Weff1		= Wnew - 2.0*dWB + DWBIN;
	if (Weff1 <= 0) begin
		$strobe("Fatal: Effective channel width for binning = %e for  %M is non-positive", Weff1);
		$finish(0);
	end

	if (BINUNIT==1) begin
		BIN_L		= 1.0e-6 / Leff1;
		BIN_W		= 1.0e-6 / Weff1;
	end else begin
		BIN_L		= 1.0 / Leff1;
		BIN_W		= 1.0 / Weff1;
	end

	BIN_WL		= BIN_L * BIN_W;

	VFB_i		= VFB		+ BIN_L * LVFB 		+ BIN_W * WVFB 		+ BIN_WL * PVFB ;
	VFBCV_i		= VFBCV		+ BIN_L * LVFBCV 	+ BIN_W * WVFBCV 	+ BIN_WL * PVFBCV ;
	NSD_i		= NSD 		+ BIN_L * LNSD 		+ BIN_W * WNSD 		+ BIN_WL * PNSD ;
	NDEP_i		= NDEP		+ BIN_L * LNDEP 	+ BIN_W * WNDEP 	+ BIN_WL * PNDEP ;
	NDEPCV_i	= NDEPCV	+ BIN_L * LNDEPCV 	+ BIN_W * WNDEPCV 	+ BIN_WL * PNDEPCV ;
	NGATE_i		= NGATE		+ BIN_L * LNGATE	+ BIN_W * WNGATE 	+ BIN_WL * PNGATE;
	CIT_i		= CIT		+ BIN_L * LCIT  	+ BIN_W * WCIT  	+ BIN_WL * PCIT ;
	NFACTOR_i	= NFACTOR 	+ BIN_L * LNFACTOR	+ BIN_W * WNFACTOR 	+ BIN_WL * PNFACTOR ;
	CDSCD_i		= CDSCD 	+ BIN_L * LCDSCD  	+ BIN_W * WCDSCD  	+ BIN_WL * PCDSCD ;
	CDSCB_i		= CDSCB 	+ BIN_L * LCDSCB  	+ BIN_W * WCDSCB  	+ BIN_WL * PCDSCB ;
	DVTP0_i		= DVTP0 	+ BIN_L * LDVTP0  	+ BIN_W * WDVTP0  	+ BIN_WL * PDVTP0 ;
	DVTP1_i		= DVTP1 	+ BIN_L * LDVTP1  	+ BIN_W * WDVTP1  	+ BIN_WL * PDVTP1 ;
	DVTP2_i		= DVTP2 	+ BIN_L * LDVTP2  	+ BIN_W * WDVTP2  	+ BIN_WL * PDVTP2 ;
	DVTP3_i		= DVTP3 	+ BIN_L * LDVTP3  	+ BIN_W * WDVTP3  	+ BIN_WL * PDVTP3 ;
	DVTP4_i		= DVTP4 	+ BIN_L * LDVTP4  	+ BIN_W * WDVTP4 	+ BIN_WL * PDVTP4 ;
	DVTP5_i		= DVTP5 	+ BIN_L * LDVTP5  	+ BIN_W * WDVTP5  	+ BIN_WL * PDVTP5 ;
	K2_i		= K2 		+ BIN_L * LK2  		+ BIN_W * WK2  		+ BIN_WL * PK2 ;
	K1_i		= K1 		+ BIN_L * LK1  		+ BIN_W * WK1  		+ BIN_WL * PK1 ;
	XJ_i		= XJ 		+ BIN_L * LXJ  		+ BIN_W * WXJ  		+ BIN_WL * PXJ ;
	PHIN_i		= PHIN 		+ BIN_L * LPHIN  	+ BIN_W * WPHIN  	+ BIN_WL * PPHIN ;
	ETA0_i		= ETA0 		+ BIN_L * LETA0  	+ BIN_W * WETA0  	+ BIN_WL * PETA0 ;
	
	ETAB_i		= ETAB 		+ BIN_L * LETAB  	+ BIN_W * WETAB  	+ BIN_WL * PETAB ;
	DELTA_i		= DELTA 	+ BIN_L * LDELTA  	+ BIN_W * WDELTA 	+ BIN_WL * PDELTA ;
	U0_i		= U0 		+ BIN_L * LU0  		+ BIN_W * WU0  		+ BIN_WL * PU0 ;
	UA_i		= UA 		+ BIN_L * LUA  		+ BIN_W * WUA  		+ BIN_WL * PUA ;
	UD_i		= UD 		+ BIN_L * LUD  		+ BIN_W * WUD  		+ BIN_WL * PUD ;
	EU_i		= EU 		+ BIN_L * LEU 		+ BIN_W * WEU 		+ BIN_WL * PEU;
	UCS_i		= UCS 		+ BIN_L * LUCS 		+ BIN_W * WUCS 		+ BIN_WL * PUCS;
	UC_i		= UC 		+ BIN_L * LUC 		+ BIN_W * WUC 		+ BIN_WL * PUC;
	PCLM_i		= PCLM 		+ BIN_L * LPCLM  	+ BIN_W * WPCLM  	+ BIN_WL * PPCLM ;
	PCLMCV_i	= PCLMCV	+ BIN_L * LPCLMCV	+ BIN_W * WPCLMCV  	+ BIN_WL * PPCLMCV ;

	RSW_i		= RSW 		+ BIN_L * LRSW  	+ BIN_W * WRSW  	+ BIN_WL * PRSW ;
	RDW_i		= RDW 		+ BIN_L * LRDW  	+ BIN_W * WRDW  	+ BIN_WL * PRDW ;
	PRWG_i		= PRWG 		+ BIN_L * LPRWG  	+ BIN_W * WPRWG  	+ BIN_WL * PPRWG ;
	PRWB_i		= PRWB 		+ BIN_L * LPRWB  	+ BIN_W * WPRWB  	+ BIN_WL * PPRWB ;
	WR_i		= WR 		+ BIN_L * LWR  		+ BIN_W * WWR 		+ BIN_WL * PWR ;
	RSWMIN_i	= RSWMIN 	+ BIN_L * LRSWMIN  	+ BIN_W * WRSWMIN  	+ BIN_WL * PRSWMIN ;
	RDWMIN_i	= RDWMIN 	+ BIN_L * LRDWMIN  	+ BIN_W * WRDWMIN  	+ BIN_WL * PRDWMIN ;
	RDSW_i		= RDSW 		+ BIN_L * LRDSW  	+ BIN_W * WRDSW  	+ BIN_WL * PRDSW ;
	RDSWMIN_i	= RDSWMIN 	+ BIN_L * LRDSWMIN	+ BIN_W * WRDSWMIN	+ BIN_WL * PRDSWMIN ;

	PTWG_i		= PTWG 		+ BIN_L * LPTWG  	+ BIN_W * WPTWG  	+ BIN_WL * PPTWG ;
	PDIBLC_i	= PDIBLC 	+ BIN_L * LPDIBLC  	+ BIN_W * WPDIBLC  	+ BIN_WL * PPDIBLC ;
	PDIBLCB_i	= PDIBLCB 	+ BIN_L * LPDIBLCB	+ BIN_W * WPDIBLCB 	+ BIN_WL * PPDIBLCB ;
	PSCBE1_i	= PSCBE1 	+ BIN_L * LPSCBE1  	+ BIN_W * WPSCBE1  	+ BIN_WL * PPSCBE1 ;
	PSCBE2_i	= PSCBE2 	+ BIN_L * LPSCBE2  	+ BIN_W * WPSCBE2  	+ BIN_WL * PPSCBE2 ;
	PDITS_i		= PDITS 	+ BIN_L * LPDITS 	+ BIN_W * WPDITS  	+ BIN_WL * PPDITS ;
	PDITSD_i	= PDITSD 	+ BIN_L * LPDITSD 	+ BIN_W * WPDITSD  	+ BIN_WL * PPDITSD ;
	FPROUT_i	= FPROUT 	+ BIN_L * LFPROUT 	+ BIN_W * WFPROUT  	+ BIN_WL * PFPROUT ;
	PVAG_i		= PVAG 		+ BIN_L * LPVAG  	+ BIN_W * WPVAG  	+ BIN_WL * PPVAG ;
	VSAT_i		= VSAT 		+ BIN_L * LVSAT		+ BIN_W * WVSAT  	+ BIN_WL * PVSAT ;
	PSAT_i		= PSAT 		+ BIN_L * LPSAT 	+ BIN_W * WPSAT  	+ BIN_WL * PPSAT ;
	VSATCV_i	= VSATCV 	+ BIN_L * LVSATCV  	+ BIN_W * WVSATCV  	+ BIN_WL * PVSATCV ;
	CF_i		= CF 		+ BIN_L * LCF 		+ BIN_W * WCF  		+ BIN_WL * PCF ;
	CGSL_i		= CGSL 		+ BIN_L * LCGSL 	+ BIN_W * WCGSL  	+ BIN_WL * PCGSL  ;
	CGDL_i		= CGDL 		+ BIN_L * LCGDL 	+ BIN_W * WCGDL  	+ BIN_WL * PCGDL ;
	CKAPPAS_i	= CKAPPAS 	+ BIN_L * LCKAPPAS	+ BIN_W * WCKAPPAS	+ BIN_WL * PCKAPPAS ;
	CKAPPAD_i	= CKAPPAD 	+ BIN_L * LCKAPPAD	+ BIN_W * WCKAPPAD	+ BIN_WL * PCKAPPAD ;

	ALPHA0_i 	= ALPHA0	+ BIN_L * LALPHA0	+ BIN_W * WALPHA0	+ BIN_WL * PALPHA0;
	BETA0_i 	= BETA0		+ BIN_L * LBETA0	+ BIN_W * WBETA0	+ BIN_WL * PBETA0;

	KVTH0WE_i 	= KVTH0WE	+ BIN_L * LKVTH0WE	+ BIN_W * WKVTH0WE	+ BIN_WL * PKVTH0WE;
	K2WE_i 		= K2WE		+ BIN_L * LK2WE		+ BIN_W * WK2WE		+ BIN_WL * PK2WE;
	KU0WE_i 	= KU0WE		+ BIN_L * LKU0WE	+ BIN_W * WKU0WE	+ BIN_WL * PKU0WE;

	AGIDL_i 	= AGIDL		+ BIN_L * LAGIDL	+ BIN_W  * WAGIDL	+ BIN_WL * PAGIDL;
	BGIDL_i 	= BGIDL		+ BIN_L * LBGIDL	+ BIN_W  * WBGIDL	+ BIN_WL * PBGIDL;
	CGIDL_i 	= CGIDL		+ BIN_L * LCGIDL	+ BIN_W  * WCGIDL	+ BIN_WL * PCGIDL;
	EGIDL_i 	= EGIDL		+ BIN_L * LEGIDL	+ BIN_W  * WEGIDL	+ BIN_WL * PEGIDL;
	AGISL_i 	= AGISL		+ BIN_L * LAGISL	+ BIN_W  * WAGISL	+ BIN_WL * PAGISL;
	BGISL_i 	= BGISL		+ BIN_L * LBGISL	+ BIN_W  * WBGISL	+ BIN_WL * PBGISL;
	CGISL_i 	= CGISL		+ BIN_L * LCGISL	+ BIN_W  * WCGISL	+ BIN_WL * PCGISL;
	EGISL_i 	= EGISL		+ BIN_L * LEGISL	+ BIN_W  * WEGISL	+ BIN_WL * PEGISL;

	UTE_i		= UTE 		+ BIN_L * LUTE		+ BIN_W  * WUTE		+ BIN_WL * PUTE;
	UA1_i		= UA1 		+ BIN_L * LUA1		+ BIN_W  * WUA1		+ BIN_WL * PUA1;
	UC1_i		= UC1 		+ BIN_L * LUC1		+ BIN_W  * WUC1		+ BIN_WL * PUC1;
	UD1_i		= UD1 		+ BIN_L * LUD1		+ BIN_W  * WUD1		+ BIN_WL * PUD1;
	UCSTE_i		= UCSTE		+ BIN_L * LUCSTE	+ BIN_W  * WUCSTE	+ BIN_WL * PUCSTE;
	PRT_i		= PRT 		+ BIN_L * LPRT		+ BIN_W  * WPRT		+ BIN_WL * PPRT;
	AT_i		= AT 		+ BIN_L * LAT		+ BIN_W  * WAT		+ BIN_WL * PAT;
	PTWGT_i		= PTWGT		+ BIN_L * LPTWGT	+ BIN_W  * WPTWGT	+ BIN_WL * PPTWGT;
	IIT_i		= IIT		+ BIN_L * LIIT		+ BIN_W  * WIIT		+ BIN_WL * PIIT;
	TGIDL_i		= TGIDL		+ BIN_L * LTGIDL	+ BIN_W  * WTGIDL	+ BIN_WL * PTGIDL;
	IGT_i		= IGT		+ BIN_L * LIGT		+ BIN_W  * WIGT		+ BIN_WL * PIGT;

	AIGBINV_i 	= AIGBINV 	+ BIN_L * LAIGBINV 	+ BIN_W * WAIGBINV 	+ BIN_WL * PAIGBINV;
	BIGBINV_i 	= BIGBINV 	+ BIN_L * LBIGBINV 	+ BIN_W * WBIGBINV 	+ BIN_WL * PBIGBINV;
	CIGBINV_i 	= CIGBINV 	+ BIN_L * LCIGBINV 	+ BIN_W * WCIGBINV 	+ BIN_WL * PCIGBINV;
	EIGBINV_i 	= EIGBINV 	+ BIN_L * LEIGBINV 	+ BIN_W * WEIGBINV 	+ BIN_WL * PEIGBINV;
	NIGBINV_i 	= NIGBINV 	+ BIN_L * LNIGBINV 	+ BIN_W * WNIGBINV 	+ BIN_WL * PNIGBINV;
	AIGBACC_i 	= AIGBACC 	+ BIN_L * LAIGBACC 	+ BIN_W * WAIGBACC 	+ BIN_WL * PAIGBACC;
	BIGBACC_i 	= BIGBACC 	+ BIN_L * LBIGBACC 	+ BIN_W * WBIGBACC 	+ BIN_WL * PBIGBACC;
	CIGBACC_i 	= CIGBACC 	+ BIN_L * LCIGBACC 	+ BIN_W * WCIGBACC 	+ BIN_WL * PCIGBACC;
 	NIGBACC_i 	= NIGBACC 	+ BIN_L * LNIGBACC 	+ BIN_W * WNIGBACC 	+ BIN_WL * PNIGBACC;
	AIGC_i 		= AIGC 		+ BIN_L * LAIGC 	+ BIN_W * WAIGC 	+ BIN_WL * PAIGC;
	BIGC_i 		= BIGC 		+ BIN_L * LBIGC 	+ BIN_W * WBIGC 	+ BIN_WL * PBIGC;
	CIGC_i 		= CIGC 		+ BIN_L * LCIGC 	+ BIN_W * WCIGC 	+ BIN_WL * PCIGC;
	AIGS_i 		= AIGS 		+ BIN_L * LAIGS 	+ BIN_W * WAIGS 	+ BIN_WL * PAIGS;
	BIGS_i 		= BIGS 		+ BIN_L * LBIGS 	+ BIN_W * WBIGS 	+ BIN_WL * PBIGS;
	CIGS_i 		= CIGS 		+ BIN_L * LCIGS 	+ BIN_W * WCIGS 	+ BIN_WL * PCIGS;
	AIGD_i 		= AIGD 		+ BIN_L * LAIGD 	+ BIN_W * WAIGD 	+ BIN_WL * PAIGD;
	BIGD_i 		= BIGD 		+ BIN_L * LBIGD 	+ BIN_W * WBIGD 	+ BIN_WL * PBIGD;
	CIGD_i 		= CIGD 		+ BIN_L * LCIGD 	+ BIN_W * WCIGD 	+ BIN_WL * PCIGD;
	POXEDGE_i 	= POXEDGE 	+ BIN_L * LPOXEDGE 	+ BIN_W * WPOXEDGE 	+ BIN_WL * PPOXEDGE;
	DLCIG_i 	= DLCIG 	+ BIN_L * LDLCIG 	+ BIN_W * WDLCIG 	+ BIN_WL * PDLCIG;
	DLCIGD_i 	= DLCIGD 	+ BIN_L * LDLCIGD 	+ BIN_W * WDLCIGD 	+ BIN_WL * PDLCIGD;
	NTOX_i 		= NTOX 		+ BIN_L * LNTOX 	+ BIN_W * WNTOX 	+ BIN_WL * PNTOX;

	KT1_i 		= KT1 		+ BIN_L * LKT1 		+ BIN_W * WKT1 		+ BIN_WL * PKT1;
	KT2_i 		= KT2 		+ BIN_L * LKT2 		+ BIN_W * WKT2 		+ BIN_WL * PKT2;
	PSATB_i		= PSATB 	+ BIN_L * LPSATB 	+ BIN_W * WPSATB	+ BIN_WL * PPSATB;

	A1_i		= A1		+ BIN_L * LA1 		+ BIN_W * WA1		+ BIN_WL * PA1;
	A11_i		= A11		+ BIN_L * LA11 		+ BIN_W * WA11		+ BIN_WL * PA11;
	A2_i		= A2		+ BIN_L * LA2 		+ BIN_W * WA2		+ BIN_WL * PA2;
	A21_i		= A21		+ BIN_L * LA21 		+ BIN_W * WA21		+ BIN_WL * PA21;

	if(ASYMMOD != 0) begin
		CDSCDR_i	= CDSCDR 	+ BIN_L * LCDSCDR  	+ BIN_W * WCDSCDR  	+ BIN_WL * PCDSCDR ;
		ETA0R_i		= ETA0R		+ BIN_L * LETA0R  	+ BIN_W * WETA0R  	+ BIN_WL * PETA0R ;
		U0R_i		= U0R 		+ BIN_L * LU0R  	+ BIN_W * WU0R 		+ BIN_WL * PU0R ;
		UAR_i		= UAR 		+ BIN_L * LUAR 		+ BIN_W * WUAR  	+ BIN_WL * PUAR ;
		UDR_i		= UDR 		+ BIN_L * LUDR  	+ BIN_W * WUDR		+ BIN_WL * PUDR ;
		UCSR_i		= UCSR 		+ BIN_L * LUCSR 	+ BIN_W * WUCSR 	+ BIN_WL * PUCSR;
		UCR_i		= UCR 		+ BIN_L * LUCR 		+ BIN_W * WUCR 		+ BIN_WL * PUCR;
		PCLMR_i		= PCLMR 	+ BIN_L * LPCLMR  	+ BIN_W * WPCLMR  	+ BIN_WL * PPCLMR ;	
		PDIBLCR_i	= PDIBLCR 	+ BIN_L * LPDIBLCR  	+ BIN_W * WPDIBLCR  	+ BIN_WL * PPDIBLCR ;	
		VSATR_i		= VSATR 	+ BIN_L * LVSATR	+ BIN_W * WVSATR  	+ BIN_WL * PVSATR ;
		PSATR_i		= PSATR 	+ BIN_L * LPSATR 	+ BIN_W * WPSATR  	+ BIN_WL * PPSATR ;
		PTWGR_i		= PTWGR 	+ BIN_L * LPTWGR  	+ BIN_W * WPTWGR  	+ BIN_WL * PPTWGR ;	
	end

	// Geometrical scaling
	T0 = NDEPL1 * max( pow(Inv_L, NDEPLEXP1) - pow(Inv_Llong, NDEPLEXP1), 0) + NDEPL2 * max( pow(Inv_L, NDEPLEXP2) - pow(Inv_Llong, NDEPLEXP2), 0);
	T1 = NDEPW * max( pow(Inv_W, NDEPWEXP) - pow(Inv_Wwide, NDEPWEXP), 0) + NDEPWL * pow(Inv_W * Inv_L, NDEPWLEXP);
	NDEP_i = NDEP_i * (1.0 + T0 + T1);

	T0 = NFACTORL * max( pow(Inv_L, NFACTORLEXP) - pow(Inv_Llong, NFACTORLEXP), 0);
	T1 = NFACTORW * max( pow(Inv_W, NFACTORWEXP) - pow(Inv_Wwide, NFACTORWEXP), 0) + NFACTORWL * pow(Inv_WL, NFACTORWLEXP);
	NFACTOR_i = NFACTOR_i * (1.0 + T0 + T1);

	T0 = (1.0 + CDSCDL * max( pow(Inv_L, CDSCDLEXP) - pow(Inv_Llong, CDSCDLEXP), 0) );	
	CDSCD_i = CDSCD_i * T0;
	if(ASYMMOD != 0)
		CDSCDR_i = CDSCDR_i * T0;
	CDSCB_i = CDSCB_i * (1.0 + CDSCBL * max( pow(Inv_L, CDSCBLEXP) - pow(Inv_Llong, CDSCBLEXP), 0) );
	U0_i = MULU0 * U0_i;

	if(MOBSCALE != 1) begin	
		if(U0LEXP > 0) begin
			U0_i = U0_i * (1.0 - U0L * max( pow(Inv_L, U0LEXP) - pow(Inv_Llong, U0LEXP), 0));
			if(ASYMMOD != 0)
				U0R_i = U0R_i * (1.0 - U0L * max( pow(Inv_L, U0LEXP) - pow(Inv_Llong, U0LEXP), 0));
		end else begin
			U0_i = U0_i * (1.0 - U0L);
		    if(ASYMMOD != 0)
			  	U0R_i = U0R_i * (1.0 - U0L);
		end
	end else begin
   		U0_i = U0_i * (1.0 - (UP1 * exp(-Leff / LP1)) - (UP2 * exp(-Leff / LP2)));
		if(ASYMMOD != 0)
			U0R_i = U0R_i * (1.0 - (UP1 * exp(-Leff / LP1)) - (UP2 * exp(-Leff / LP2))); 
	end

	T0 = UAL * max( pow(Inv_L, UALEXP) - pow(Inv_Llong, UALEXP), 0);
	T1 = UAW * max( pow(Inv_W, UAWEXP) - pow(Inv_Wwide, UAWEXP), 0) + UAWL * pow(Inv_WL, UAWLEXP);
	UA_i = UA_i * (1.0 + T0 + T1);
	if(ASYMMOD != 0)
		UAR_i = UAR_i * (1.0 + T0 + T1);
	T0 = EUL * max( pow(Inv_L, EULEXP) - pow(Inv_Llong, EULEXP), 0);
	T1 = EUW * max( pow(Inv_W, EUWEXP) - pow(Inv_Wwide, EUWEXP), 0) + EUWL * pow(Inv_WL, EUWLEXP);
	EU_i = EU_i * (1.0 + T0 + T1);
	T0 = 1.0 + UDL * max( pow(Inv_L, UDLEXP) - pow(Inv_Llong, UDLEXP), 0);
	UD_i = UD_i * T0;
	if(ASYMMOD != 0)
		UDR_i = UDR_i * T0;
	T0 = UCL * max( pow(Inv_L, UCLEXP) - pow(Inv_Llong, UCLEXP), 0);
	T1 = UCW * max( pow(Inv_W, UCWEXP) - pow(Inv_Wwide, UCWEXP), 0) + UCWL * pow(Inv_WL, UCWLEXP);
	UC_i = UC_i * (1.0 + T0 + T1);
	if(ASYMMOD != 0)
		UCR_i = UCR_i * (1.0 + T0 + T1);
	T0 = max( pow(Inv_L, DSUB) - pow(Inv_Llong, DSUB), 0);
	ETA0_i = ETA0_i * T0;
	if(ASYMMOD != 0)
		ETA0R_i = ETA0R_i * T0;

	ETAB_i = ETAB_i * max( pow(Inv_L, ETABEXP) - pow(Inv_Llong, ETABEXP), 0);
	T0 = 1.0 + PDIBLCL * max( pow(Inv_L, PDIBLCLEXP) - pow(Inv_Llong, PDIBLCLEXP), 0);	
	PDIBLC_i = PDIBLC_i * T0;
	if(ASYMMOD != 0)
		PDIBLCR_i = PDIBLCR_i * T0;

	T0 = DELTA_i * (1.0 + DELTAL * max( pow(Inv_L, DELTALEXP) - pow(Inv_Llong, DELTALEXP), 0));
	DELTA_i = min(T0, 0.5);
	FPROUT_i = FPROUT_i * (1.0 + FPROUTL * max( pow(Inv_L, FPROUTLEXP) - pow(Inv_Llong, FPROUTLEXP), 0));
	T0 = (1.0 + PCLML * max( pow(Inv_L, PCLMLEXP) - pow(Inv_Llong, PCLMLEXP), 0));
	PCLM_i = PCLM_i * T0;
	PCLM_i = max(PCLM_i,0);
	if(ASYMMOD != 0) begin
		PCLMR_i = PCLMR_i * T0;
		PCLMR_i = max(PCLMR_i,0);
	end

	T0 = VSATL * max( pow(Inv_L, VSATLEXP) - pow(Inv_Llong, VSATLEXP), 0);
	T1 = VSATW * max( pow(Inv_W, VSATWEXP) - pow(Inv_Wwide, VSATWEXP), 0) + VSATWL * pow(Inv_WL, VSATWLEXP);
	VSAT_i = VSAT_i * (1.0 + T0 + T1);
	if(ASYMMOD != 0)
		VSATR_i = VSATR_i * (1.0 + T0 + T1);

	PSAT_i = max(PSAT_i * (1.0 + PSATL * max( pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0)), 0.25);
	if(ASYMMOD != 0)
		PSATR_i = max(PSATR_i * (1.0 + PSATL * max( pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0)), 0.25);

	T0=(1.0 + PTWGL * max( pow(Inv_L, PTWGLEXP) - pow(Inv_Llong, PTWGLEXP), 0));	
	PTWG_i = PTWG_i * T0;
	if(ASYMMOD != 0)
		PTWGR_i = PTWGR_i * T0;

	ALPHA0_i = ALPHA0_i * (1.0 + ALPHA0L * max( pow(Inv_L, ALPHA0LEXP) - pow(Inv_Llong, ALPHA0LEXP), 0));

	AGIDL_i = AGIDL_i * (1.0 + AGIDLL * Inv_L + AGIDLW * Inv_W);
	AGISL_i = AGISL_i * (1.0 + AGISLL * Inv_L + AGISLW * Inv_W);

	AIGC_i = AIGC_i * (1.0 + AIGCL * Inv_L + AIGCW * Inv_W);
	AIGS_i = AIGS_i * (1.0 + AIGSL * Inv_L + AIGSW * Inv_W);
	AIGD_i = AIGD_i * (1.0 + AIGDL * Inv_L + AIGDW * Inv_W);
	PIGCD_i = PIGCD * (1.0 + PIGCDL * Inv_L);

	T0 = NDEPCVL1 * max( pow(Inv_Lact, NDEPCVLEXP1) - pow(Inv_Llong, NDEPCVLEXP1), 0) + NDEPCVL2 * max( pow(Inv_Lact, NDEPCVLEXP2) - pow(Inv_Llong, NDEPCVLEXP2), 0);
	T1 = NDEPCVW * max( pow(Inv_Wact, NDEPCVWEXP) - pow(Inv_Wwide, NDEPCVWEXP), 0) + NDEPCVWL * pow(Inv_Wact * Inv_Lact, NDEPCVWLEXP);
	NDEPCV_i = NDEPCV_i * (1.0 + T0 + T1);

	T0 = VFBCVL * max( pow(Inv_Lact, VFBCVLEXP) - pow(Inv_Llong, VFBCVLEXP), 0);
	T1 = VFBCVW * max( pow(Inv_Wact, VFBCVWEXP) - pow(Inv_Wwide, VFBCVWEXP), 0) + VFBCVWL * pow(Inv_WL, VFBCVWLEXP);
	VFBCV_i = VFBCV_i * (1.0 + T0 + T1);

	T0 = VSATCVL * max( pow(Inv_Lact, VSATCVLEXP) - pow(Inv_Llong, VSATCVLEXP), 0);
	T1 = VSATCVW * max( pow(Inv_W, VSATCVWEXP) - pow(Inv_Wwide, VSATCVWEXP), 0) + VSATCVWL * pow(Inv_WL, VSATCVWLEXP);
	VSATCV_i = VSATCV_i * (1.0 + T0 + T1);
	PCLMCV_i = PCLMCV_i * (1.0 + PCLMCVL * max( pow(Inv_Lact, PCLMCVLEXP) - pow(Inv_Llong, PCLMCVLEXP), 0));
	PCLMCV_i = max(PCLMCV_i,0);

	T0 = K1L * max( pow(Inv_L, K1LEXP) - pow(Inv_Llong, K1LEXP), 0);
	T1 = K1W * max( pow(Inv_W, K1WEXP) - pow(Inv_Wwide, K1WEXP), 0) + K1WL * pow(Inv_WL, K1WLEXP);
	K1_i = K1_i * (1.0 + T0 + T1);	
	
	T0 = K2L * max( pow(Inv_L, K2LEXP) - pow(Inv_Llong, K2LEXP), 0);
	T1 = K2W * max( pow(Inv_W, K2WEXP) - pow(Inv_Wwide, K2WEXP), 0) + K2WL * pow(Inv_WL, K2WLEXP);
	K2_i = K2_i * (1.0 + T0 + T1);

	PRWB_i = PRWB_i * (1.0 + PRWBL * max( pow(Inv_L, PRWBLEXP) - pow(Inv_Llong, PRWBLEXP), 0));

	//Global Scaling parameters for Temperature
	UTE_i = UTE_i * (1.0 + Inv_L * UTEL);
	UA1_i = UA1_i * (1.0 + Inv_L * UA1L);
	UD1_i = UD1_i * (1.0 + Inv_L * UD1L);
	AT_i = AT_i * (1.0 + Inv_L * ATL);
	PTWGT_i = PTWGT_i * (1.0 + Inv_L * PTWGTL);
 `ifdef __THERMAL_NODE__
   if ($port_connected(t) == 0) begin
     `ifdef __SHMOD__
          // There is no point to this strobe, so comment it out.
          // The behavior of the 5 terminal module with t not connected is
          // identical to the 4 terminal, so shut up about it.
          // $strobe("5 terminal Module, while 't' node is not connected, SH is activated.");
     `else
          Temp(t) <+ 0;
          $strobe("5 terminal Module, while 't' node is not connected, SH is not activated.");
     `endif
   end
 `endif
`ifdef __RDSMOD__
	if(RDSMOD == 1) begin
		RSW_i = RSW_i * (1.0 + RSWL * max( pow(Inv_L, RSWLEXP) - pow(Inv_Llong, RSWLEXP), 0));
		RDW_i = RDW_i * (1.0 + RDWL * max( pow(Inv_L, RDWLEXP) - pow(Inv_Llong, RDWLEXP), 0));
	end else begin
`endif
		RDSW_i = RDSW_i * (1.0 + RDSWL * max( pow(Inv_L, RDSWLEXP) - pow(Inv_Llong, RDSWLEXP),0));
`ifdef __RDSMOD__
	end
`else
//Warning Message For RDSMOD
	if(RDSMOD != 2)
		$strobe("[BSIM6] Although the model selector RDSMOD is set to %d, the external source/drain resistance model was not activated when the Verilog-A code was compiled.  Please uncomment \"`define __RDSMOD__\" in the beginning of the Verilog-A code.", RDSMOD);
`endif

	// Parameter Checking

	if (UCS_i < 1.0)
		UCS_i = 1.0;
	else if (UCS_i > 2.0)
		UCS_i = 2.0;

	
	if(ASYMMOD != 0) begin
		if (UCSR_i < 1.0)
			UCSR_i = 1.0;
		else if (UCSR_i > 2.0)
			UCSR_i = 2.0;

		if (UCR_i < 0) begin
			$strobe("Fatal: UCR_i = %e is negative.", UCR_i);
			$finish(0);
		end	
	end	
		
		
	if (CGIDL_i < 0) begin
		$strobe("Fatal: CGIDL_i = %e is negative.", CGIDL_i);
		$finish(0);
	end

	if (CGISL_i < 0) begin
		$strobe("Fatal: CGISL_i = %e is negative.", CGISL_i);
		$finish(0);
	end

	if (CKAPPAD_i <= 0) begin
		$strobe("Fatal: CKAPPAD_i = %e is non-positive.", CKAPPAD_i);
		$finish(0);
	end

	if (CKAPPAS_i <= 0) begin
		$strobe("Fatal: CKAPPAS_i = %e is non-positive.", CKAPPAS_i);
		$finish(0);
	end

	if (PDITS_i < 0) begin
		$strobe("Fatal: PDITS_i = %e is negative.", PDITS_i);
		$finish(0);
	end

	if (CIT_i < 0) begin
		$strobe("Fatal: CIT_i = %e is negative.", CIT_i);
		$finish(0);
	end

	if (NFACTOR_i < 0) begin
		$strobe("Fatal: NFACTOR_i = %e is negative.", NFACTOR_i);
		$finish(0);
	end
	
    if (K1_i < 0) begin
		$strobe("Fatal: K1_i = %e is positive.", K1_i);
		$finish(0);
	end

	if(NSD_i <= 0) begin
		$strobe("Fatal: NSD_i = %e is non-positive.", NSD_i);
		$finish(0);
	end
	if(NDEP_i <= 0) begin
		$strobe("Fatal: NDEP_i = %e is non-positive.", NDEP_i);
		$finish(0);
	end
	if(NDEPCV_i <= 0) begin
		$strobe("Fatal: NDEPCV_i = %e is non-positive.", NDEPCV_i);
		$finish(0);
	end
	if(IGBMOD != 0) begin
		if(NIGBINV_i <= 0) begin
			$strobe("Fatal: NIGBINV_i = %e is non-positive.", NIGBINV_i);
			$finish(0);
		end
		if(NIGBACC_i <= 0) begin
			$strobe("Fatal: NIGBACC_i = %e is non-positive.", NIGBACC_i);
			$finish(0);
		end
	end
	if(IGCMOD != 0) begin
		if(POXEDGE_i <= 0) begin
			$strobe("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i);
			$finish(0);
		end
	end
	if(CDSCD_i < 0) begin
		$strobe("Fatal: CDSCD_i = %e is negative.", CDSCD_i);
		$finish(0);
	end
	
	if(ASYMMOD != 0) begin
		if(CDSCDR_i < 0) begin
			$strobe("Fatal: CDSCDR_i = %e is negative.", CDSCDR_i);
			$finish(0);
		end
	end

	//* initialize variables used in geometry macros
	nuEndD = 0; nuEndS = 0; nuIntD = 0; nuIntS = 0; Rend = 0; Rint = 0;

	//* process drain series resistance
	DMCGeff = DMCG - DMCGT;
	DMCIeff = DMCI;
	DMDGeff = DMDG - DMCGT;

	if (RSH > 0) begin
		if (!$param_given(NRD)&& (RGEOMOD != 0))
			`BSIM6RdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 0, Rtot)
	end

	/* process source series resistance */
	if (RSH > 0) begin
		if (!$param_given(NRS)&& (RGEOMOD != 0))
			`BSIM6RdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 1, Rtot)
	end

	//* Processing S/D resistance and conductance below */
	if($param_given(NRS)) begin
		RSourceGeo = RSH * NRS;
	end else if (RGEOMOD > 0) begin
		`BSIM6RdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 1, RSourceGeo)
	end else
		RSourceGeo = 0.0;

	if($param_given(NRD))
		RDrainGeo = RSH * NRD;
	else if (RGEOMOD > 0) begin
		`BSIM6RdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 0, RDrainGeo)
	end else
		RDrainGeo = 0.0;

	/* End of Rsd processing */

	// Clamping of Source/Drain Resistances
	if(RSourceGeo <= 1.0e-3) RSourceGeo = 1.0e-3;
	if(RDrainGeo  <= 1.0e-3) RDrainGeo  = 1.0e-3;

`ifdef __RDSMOD__
	if(RDSMOD == 1) begin
		if (RSWMIN_i <= 0) RSWMIN_i = 0;
		if (RDWMIN_i <= 0) RDWMIN_i = 0;
		if (RSW_i <= 0) RSW_i = 0;
		if (RDW_i <= 0) RDW_i = 0;
	end else begin
`endif
		if (RDSWMIN_i <= 0) RDSWMIN_i = 0;
		if (RDSW_i <= 0) RDSW_i = 0;
`ifdef __RDSMOD__
	end
`endif
	// End - Clamping of Source/Drain Resistances

`ifdef __RBODYMOD__
	//Body resistance network
	Grbsb=0.0; Grbdb=0.0; Grbpb=0.0; Grbps=0.0; Grbpd=0.0;//Initialization
	if(RBODYMOD != 0) begin
		Lnl = ln(Leff * 1.0e6);
		Lnw = ln(Weff * 1.0e6);
		Lnnf = ln(NF);
		Bodymode = 5;
		Rbpb=RBPB;
		Rbpd=RBPD;
		Rbps=RBPS;
		Rbdb=RBDB;
		Rbsb=RBSB;

		if( !$param_given(RBPS0) || !$param_given(RBPD0))
			Bodymode = 1;
		else if( !$param_given(RBSBX0) && !$param_given(RBSBY0) || !$param_given(RBDBX0) && !$param_given(RBDBY0) )
			Bodymode = 3;

		if(RBODYMOD == 2) begin
			if (Bodymode == 5) begin
				Rbsbx = RBSBX0 * exp( RBSDBXL * Lnl + RBSDBXW * Lnw + RBSDBXNF * Lnnf );
				Rbsby = RBSBY0 * exp( RBSDBYL * Lnl + RBSDBYW * Lnw + RBSDBYNF * Lnnf );
				Rbsb = Rbsbx * Rbsby / (Rbsbx + Rbsby);
				Rbdbx =  RBDBX0 * exp( RBSDBXL * Lnl + RBSDBXW * Lnw + RBSDBXNF * Lnnf );
				Rbdby =  RBDBY0 * exp( RBSDBYL * Lnl + RBSDBYW * Lnw + RBSDBYNF * Lnnf );
				Rbdb = Rbdbx * Rbdby / (Rbdbx + Rbdby);
			end
			if ((Bodymode == 3)|| (Bodymode == 5)) begin
				Rbps = RBPS0 * exp( RBPSL * Lnl + RBPSW * Lnw + RBPSNF * Lnnf );
				Rbpd = RBPD0 * exp( RBPDL * Lnl + RBPDW * Lnw + RBPDNF * Lnnf );
			end
			Rbpbx =  RBPBX0 * exp( RBPBXL * Lnl + RBPBXW * Lnw + RBPBXNF * Lnnf );
			Rbpby =  RBPBY0 * exp( RBPBYL * Lnl + RBPBYW * Lnw + RBPBYNF * Lnnf );
			Rbpb = Rbpbx*Rbpby/(Rbpbx + Rbpby);
		end

		if ((RBODYMOD == 1 ) || ((RBODYMOD == 2 ) && (Bodymode == 5)) ) begin
			if (Rbdb < 1.0e-3)
				Grbdb = 1.0e3; /* in mho */
			else
				Grbdb = GBMIN + 1.0 / Rbdb;
			if (Rbpb < 1.0e-3)
				Grbpb = 1.0e3;
			else
				Grbpb = GBMIN + 1.0 / Rbpb;
			if (Rbps < 1.0e-3)
				Grbps = 1.0e3;
			else
				Grbps = GBMIN + 1.0 / Rbps;
			if (Rbsb < 1.0e-3)
				Grbsb = 1.0e3;
			else
				Grbsb = GBMIN + 1.0 / Rbsb;
			if (Rbpd < 1.0e-3)
				Grbpd = 1.0e3;
			else
				Grbpd = GBMIN + 1.0 / Rbpd;
		end else if((RBODYMOD == 2) && (Bodymode == 3)) begin
			Grbdb  =  GBMIN;
			Grbsb  =  GBMIN;
			if (Rbpb < 1.0e-3)
				Grbpb = 1.0e3;
			else
				Grbpb = GBMIN + 1.0 / Rbpb;
			if (Rbps < 1.0e-3)
				Grbps = 1.0e3;
			else
				Grbps = GBMIN + 1.0 / Rbps;
			if (Rbpd < 1.0e-3)
				Grbpd = 1.0e3;
			else
				Grbpd = GBMIN + 1.0 / Rbpd;
		end else if((RBODYMOD == 2) && (Bodymode == 1)) begin
			Grbdb  =  GBMIN;
			Grbsb  =  GBMIN;
			Grbps  =  1.0e3;
			Grbpd  =  1.0e3;
			if (Rbpb < 1.0e-3)
				Grbpb = 1.0e3;
			else
				Grbpb = GBMIN + 1.0 / Rbpb;
		end
	end
`else
	if(RBODYMOD != 0)
		$strobe("[BSIM6] Although the model selector RBODYMOD is set to %d, the body resistance model was not activated when the Verilog-A code was compiled.  Please uncomment \"`define __RBODYMOD__\" in the beginning of the Verilog-A code.", RBODYMOD);
`endif

	// Gate process resistance
`ifdef __RGATEMOD__
	Grgeltd = RSHG * (XGW + Weffcj / 3.0 / NGCON)/ ( NGCON * NF * (Lnew - XGL));
	if (Grgeltd > 0.0)
		Grgeltd = 1.0 / Grgeltd;
	else begin
		Grgeltd = 1.0e3; /* mho */
		if (RGATEMOD != 0)
			`STROBE("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
	end
`else
	if(RGATEMOD != 0)
		$strobe("[BSIM6] Although the model selector RGATEMOD is set to %d, the gate resistance model was not activated when the Verilog-A code was compiled.  Please uncomment \"`define __RGATEMOD__\" in the beginning of the Verilog-A code.", RGATEMOD);
`endif

	T0 = TOXE * TOXE;
	T1 = TOXE * POXEDGE_i;
	T2 = T1 * T1;
	ToxRatio = exp(NTOX_i * ln(TOXREF / TOXE))/ T0;
	ToxRatioEdge = exp(NTOX_i * ln(TOXREF / T1)) /T2;

	Aechvb = (TYPE == `ntype) ? 4.97232e-7 : 3.42537e-7;
	Bechvb = (TYPE == `ntype) ? 7.45669e11 : 1.16645e12;
	AechvbEdge = Aechvb * Weff * ToxRatioEdge;
	BechvbEdge = -Bechvb * TOXE * POXEDGE_i;
	Aechvb = Aechvb * ( Weff * Leff * ToxRatio);
	Bechvb = Bechvb * ( -TOXE);


// Self Heating 
`ifdef __SHMOD__
	// Parameters for self-heating
	if(SHMOD != 0 && RTH0 > 0) begin
		gth = (WTH0 + Weff) * NF / RTH0;
		cth = CTH0 * (WTH0 + Weff) * NF;
	end else begin
   		gth = 1.0; // set gth to some value to prevent a singular G matrix
		cth = 0.0;
	end
`else
	if(SHMOD != 0)
		$strobe("[bsim6] Although the model selector SHMOD is set to 1, the self-heating model was not activated when the Verilog-A code was compiled.  Please uncomment \"`define __SHMOD__\" in bsim6.va to activate it.");
`endif

`ifdef __XYCE__
     end   // initializeInstance
`endif // __XYCE__
	//***** Temperature Dependent Calculations Begin Here *****//
	if(TNOM <= -`P_CELSIUS0) begin
		T0 = `REFTEMP - `P_CELSIUS0;
		$strobe("Warning: TNOM = %e C <= %e C. Setting TNOM to %e C.", TNOM, -`P_CELSIUS0, T0);
		Tnom = `REFTEMP;
	end else begin
		Tnom = TNOM + `P_CELSIUS0;
	end

DevTemp = $temperature + DTEMP;	
/*  Calculate temperature dependent values for self-heating effect  */

`ifdef __SHMOD__
    if ((SHMOD != 0) && (RTH0 > 0)) begin
        delTemp1 = Temp(t);
     	end else begin  
`endif		
        delTemp1 = 0;
`ifdef __SHMOD__
	end
`endif	

    DevTemp = delTemp1 + DevTemp;

	TK = DevTemp;
	Vt = $vt(DevTemp);
	inv_Vt 	= 1.0/Vt;

	TRatio = DevTemp / Tnom;
	delTemp = DevTemp - Tnom;
	Vtm = `KboQ * DevTemp;
	Vtm0 = `KboQ * Tnom;
	Eg = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
	Eg0 = BG0SUB - TBGASUB * Tnom * Tnom / (Tnom + TBGBSUB);

	T1 = (DevTemp / Tnom) * sqrt(DevTemp / Tnom);
	ni = NI0SUB * T1 * lexp(Eg / (2.0 * Vtm0) - Eg / (2.0 * Vtm));
`ifdef __SHMOD__
    if ((SHMOD != 0) && (RTH0 > 0)) begin
        T0 = lln(NDEP_i/ni);
        phib  =  sqrt(T0 * T0 + 1.0E-6);
    end else begin
        phib  =   lln(NDEP_i/ni);
    end
`else
    phib  =   lln(NDEP_i/ni);
`endif		
`ifdef __SHMOD__
    if ((SHMOD != 0) && (RTH0 > 0)) begin
        T0 = lln(NDEP_i*NSD/ni*ni);
        Vbi  =  sqrt(T0 * T0 + 1.0E-6);
    end else begin
        Vbi  =   lln(NDEP_i*NSD/ni*ni);
    end
`else
    Vbi  =   lln(NDEP_i*NSD/ni*ni);
`endif
	if(NGATE_i > 0)
	Vfbsdr = -devsign * Vt * lln(NGATE_i/NSD_i) + VFBSDOFF;
		
	else
		Vfbsdr = 0.0;

	// Short Channel Effects
	Phist = max(0.4 + Vt * phib + PHIN_i, 0.4);
	sqrtPhist = sqrt(Phist);
	T1DEP = sqrt(2.0 * epssi / (`q * NDEP_i));
	litl  = sqrt((epssi / epsox) * TOXE * XJ_i);//SCBE Rout

	NFACTOR_t = NFACTOR_i * hypsmooth((1.0 + TNFACTOR * (TRatio - 1.0)),1e-3);
	ETA0_t = ETA0_i * (1.0 + TETA0 * (TRatio - 1.0));
	if(ASYMMOD != 0)
		ETA0R_t = ETA0R_i * (1.0 + TETA0 * (TRatio - 1.0));
	// Mobility Degradation
	eta_mu = (TYPE != `ntype) ? (`Oneby3 * ETAMOB) : (0.5 * ETAMOB);

	U0_t = U0_i * pow(TRatio, UTE_i);
	UA_t = UA_i * hypsmooth(1.0 + UA1_i*delTemp - 1.0E-6, 1.0E-3);
	UC_t = UC_i * hypsmooth(1.0 + UC1_i*delTemp - 1.0E-6, 1.0E-3);
	UD_t = UD_i * pow(TRatio, UD1_i);
	UCS_t = UCS_i * pow(TRatio, UCSTE_i);
	if(ASYMMOD != 0) begin
		U0R_t = U0R_i * pow(TRatio, UTE_i);
		UAR_t = UAR_i * hypsmooth(1.0 + UA1_i*delTemp - 1.0E-6, 1.0E-3);
		UCR_t = UCR_i * hypsmooth(1.0 + UC1_i*delTemp - 1.0E-6, 1.0E-3);
		UDR_t = UDR_i * pow(TRatio, UD1_i);
		UCSR_t = UCSR_i * pow(TRatio, UCSTE_i);
	end

	rdstemp = pow(TRatio, PRT_i);

	VSAT_t = VSAT_i * pow(TRatio, -AT_i);
	if(VSAT_t < 100.0) begin
		$strobe("Warning: VSAT(%f) = %e is less than 100, setting it to 100.", DevTemp, VSAT_t);
		VSAT_t = 100.0;
	end
	if(ASYMMOD != 0) begin
		VSATR_t = VSATR_i * pow(TRatio, -AT_i);
		if(VSATR_t < 100.0) begin
			$strobe("Warning: VSATR(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATR_t);
			VSATR_t = 100.0;
		end
	end

	VSATCV_t = VSATCV_i * pow(TRatio, -AT_i);
	if(VSATCV_t < 100.0) begin
		$strobe("Warning: VSATCV(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATCV_t);
		VSATCV_t = 100.0;
	end

	DELTA_t = 1.0 / ( hypsmooth((1.0/DELTA_i) * (1.0 + TDELTA * delTemp)-2.0 , 1.0E-3) + 2.0);
	PTWG_t = PTWG_i * hypsmooth(1.0 - PTWGT_i*delTemp - 1.0E-6, 1.0E-3);
	if(ASYMMOD != 0)
		PTWGR_t = PTWGR_i * hypsmooth(1.0 - PTWGT_i*delTemp - 1.0E-6, 1.0E-3);

	A1_t = A1_i * hypsmooth(1.0 + A11_i*delTemp - 1.0E-6, 1.0E-3);	
	A2_t = A2_i * hypsmooth(1.0 + A21_i*delTemp - 1.0E-6, 1.0E-3);

	BETA0_t = BETA0_i * pow(TRatio, IIT_i);
	BGIDL_t = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
	BGISL_t = BGISL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
	igtemp = lexp(IGT_i * lln(TRatio)); //pow(TRatio, IGT_i);

	//***Diode Model temperature Code Start***//
	CJS_t = CJS * hypsmooth(1.0 + TCJ * delTemp - 1.0E-6, 1.0E-3);
	CJD_t = CJD * hypsmooth(1.0 + TCJ * delTemp - 1.0E-6, 1.0E-3);
	CJSWS_t = CJSWS * hypsmooth(1.0 + TCJSW * delTemp - 1.0E-6, 1.0E-3);
	CJSWD_t = CJSWD * hypsmooth(1.0 + TCJSW * delTemp - 1.0E-6, 1.0E-3);
	CJSWGS_t = CJSWGS * hypsmooth(1.0 + TCJSWG * delTemp - 1.0E-6, 1.0E-3);
	CJSWGD_t = CJSWGD * hypsmooth(1.0 + TCJSWG * delTemp - 1.0E-6, 1.0E-3);
	PBS_t = hypsmooth(PBS - TPB * delTemp - 0.01, 1.0E-3) + 0.01;
	PBD_t = hypsmooth(PBD - TPB * delTemp - 0.01, 1.0E-3) + 0.01;
	PBSWS_t = hypsmooth(PBSWS - TPBSW * delTemp - 0.01, 1.0E-3) + 0.01;
	PBSWD_t = hypsmooth(PBSWD - TPBSW * delTemp - 0.01, 1.0E-3) + 0.01;
	PBSWGS_t = hypsmooth(PBSWGS - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
	PBSWGD_t = hypsmooth(PBSWGD - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;

	T0 = Eg0 / Vtm0 - Eg / Vtm;
	T1 = lln(TRatio);
	T3 = lexp((T0 + XTIS * T1) / NJS);
	JSS_t = JSS * T3;
	JSWS_t = JSWS * T3;
	JSWGS_t = JSWGS * T3;
	T3 = lexp((T0 + XTID * T1) / NJD);
	JSD_t = JSD * T3;
	JSWD_t = JSWD * T3;
	JSWGD_t = JSWGD * T3;
	JTSS_t = JTSS * lexp(Eg0 * XTSS * (TRatio - 1.0) / Vtm);
	JTSSWS_t = JTSSWS * lexp(Eg0 * XTSSWS * (TRatio - 1.0) / Vtm);
	JTSSWGS_t = JTSSWGS * (sqrt(JTWEFF / Weffcj) + 1.0) * lexp(Eg0 * XTSSWGS * (TRatio - 1) / Vtm);
	JTSD_t = JTSD * lexp(Eg0 * XTSD * (TRatio - 1.0) / Vtm);
	JTSSWD_t = JTSSWD * lexp(Eg0 * XTSSWD * (TRatio - 1.0) / Vtm);
	JTSSWGD_t = JTSSWGD * (sqrt(JTWEFF / Weffcj) + 1.0) * lexp(Eg0 * XTSSWGD * (TRatio - 1) / Vtm);

	//All NJT*'s smoothed to 0.01 to prevent divide by zero / negative values
	NJTS_t = hypsmooth(NJTS * (1.0 + TNJTS * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
	NJTSSW_t = hypsmooth(NJTSSW * (1.0 + TNJTSSW * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
	NJTSSWG_t = hypsmooth(NJTSSWG * (1.0 + TNJTSSWG * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
	NJTSD_t = hypsmooth(NJTSD * (1.0 + TNJTSD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
	NJTSSWD_t = hypsmooth(NJTSSWD * (1.0 + TNJTSSWD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
	NJTSSWGD_t = hypsmooth(NJTSSWGD * (1.0 + TNJTSSWGD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
	//***Diode Model temperature Code End***//

	// Effective Source/Drain junction area and perimeter
	`BSIM6PAeffGeo(NF,GEOMOD,MINZ,Weffcj,DMCGeff,DMCIeff,DMDGeff, temp_PSeff,temp_PDeff,temp_ASeff,temp_ADeff)
	if ($param_given(AS))
		ASeff=AS * WMLT * LMLT;
	else
		ASeff=temp_ASeff;
	if(ASeff<0.0) begin
		$strobe("Warning: (instance %M) ASeff = %e is negative, set to zero.", ASeff); 
		ASeff=0.0;
	end

	if ($param_given(AD))
		ADeff=AD * WMLT * LMLT;
	else
		ADeff=temp_ADeff;
	if(ADeff<0.0) begin
		$strobe("Warning: (instance %M) ADeff = %e is negative, set to zero.", ADeff); 
		ADeff=0.0;
	end

	if ($param_given(PS)) begin
		if (PERMOD == 0) begin
			PSeff = PS * WMLT; // PS does not include gate-edge perimeter
		end else begin
			PSeff = max(PS*WMLT - Weffcj * NF, 0.0); // PS includes gate-edge perimeter
		end
	end else begin
		PSeff=temp_PSeff;
		if(PSeff<0.0) begin // final check
			$strobe("Warning: (instance %M) PSeff = %e is negative.Set to 0.0", PSeff);
			PSeff=0.0;
		end
	end
	if ($param_given(PD)) begin
		if (PERMOD == 0) begin
			PDeff = PD * WMLT; // PD does not include gate-edge perimeter
		end else begin
			PDeff = max(PD*WMLT - Weffcj * NF, 0.0); // PD includes gate-edge perimeter
		end
	end else begin
		PDeff=temp_PDeff;
		if(PDeff<0.0) begin // final check
			$strobe("Warning: (instance %M) PDeff = %e is negative.Set to 0.0", PDeff);
			PDeff=0.0;
		end
	end


	Isbs = ASeff * JSS_t + PSeff * JSWS_t + Weffcj * NF * JSWGS_t;
	if(Isbs > 0.0) begin
		Nvtms = Vtm * NJS;
		XExpBVS = lexp(-BVS / Nvtms) * XJBVS;
		T2 = max(IJTHSFWD / Isbs, 10.0);
		Tb = 1.0 + T2 - XExpBVS;
		VjsmFwd = Nvtms * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVS)));
		T0 = lexp(VjsmFwd / Nvtms);
		IVjsmFwd = Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
		SslpFwd = Isbs * (T0 + XExpBVS / T0) / Nvtms;
		T2 = hypsmooth(IJTHSREV / Isbs - 10.0, 1.0E-3) + 10.0;
		VjsmRev = -BVS - Nvtms * lln((T2 - 1.0) / XJBVS);
		T1 = XJBVS * lexp(-(BVS + VjsmRev) / Nvtms);
		IVjsmRev = Isbs * (1.0 + T1);
		SslpRev = -Isbs * T1 / Nvtms;
	end else begin
		Nvtms = 0;
		XExpBVS = 0;
		VjsmFwd = 0;
		IVjsmFwd = 0;
		SslpFwd = 0;
		VjsmRev = 0;
		IVjsmRev = 0;
		SslpRev = 0;
	end

	// Drain-side junction current
  	Isbd = ADeff * JSD_t + PDeff * JSWD_t + Weffcj * NF * JSWGD_t;
	if(Isbd > 0.0) begin
		Nvtmd = Vtm * NJD;
		XExpBVD = lexp(-BVD / Nvtmd) * XJBVD;
		T2 = max(IJTHDFWD / Isbd, 10.0);
		Tb = 1.0 + T2 - XExpBVD;
		VjdmFwd = Nvtmd * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVD)));
		T0 = lexp(VjdmFwd / Nvtmd);
		IVjdmFwd = Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
		DslpFwd = Isbd * (T0 + XExpBVD / T0) / Nvtmd;
		T2 = hypsmooth(IJTHDREV / Isbd - 10.0, 1.0E-3) + 10.0;
		VjdmRev = -BVD - Nvtmd * lln((T2 - 1.0) / XJBVD);
		T1 = XJBVD * lexp(-(BVD + VjdmRev) / Nvtmd);
		IVjdmRev = Isbd * (1.0 + T1);
		DslpRev = -Isbd * T1 / Nvtmd;
	end else begin
		Nvtmd = 0;
		XExpBVD = 0;
		VjdmFwd = 0;
		IVjdmFwd = 0;
		DslpFwd = 0;
		VjdmRev = 0;
		IVjdmRev = 0;
		DslpRev = 0;
	end

	// Junction Capacitance
	Czbs = CJS_t * ASeff;
	Czbssw = CJSWS_t * PSeff;
	Czbsswg = CJSWGS_t * Weffcj * NF;
	Czbd = CJD_t * ADeff; 
	Czbdsw = CJSWD_t * PDeff;
	Czbdswg = CJSWGD_t * Weffcj * NF;

	//STI Stress Equations

	if (KU0 !=0 || KVSAT !=0 || KVTH0 !=0 || STK2 !=0 || STETA0 !=0) begin
		T0 = pow(Lnew, LLODKU0);
		
		W_tmp_stress = Wnew + WLOD;

		T1 = pow(W_tmp_stress, WLODKU0);
		tmp1_stress = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);

		kstress_u0 = 1.0 + tmp1_stress;

		T0 = pow(Lnew, LLODVTH);
		T1 = pow(W_tmp_stress, WLODVTH);
		tmp1_stress_vth = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
		kstress_vth0 = 1.0 + tmp1_stress_vth;

		T0 = (TRatio - 1.0);
		ku0_temp = kstress_u0 * (1.0 + TKU0 * T0) + 1.0e-9;

		Inv_sa = 0;	Inv_sb = 0;//Initialization of for loop
		for (i = 0; i < NF; i = i+1) begin : forloop
			T0 = 1.0 / NF / (SA + 0.5*L_mult + i * (SD +L_mult));
			T1 = 1.0 / NF / (SB + 0.5*L_mult + i * (SD +L_mult));
			Inv_sa = Inv_sa + T0;
			Inv_sb = Inv_sb + T1;
		end

		Inv_saref = 1.0 / (SAREF + 0.5 * L_mult);
		Inv_sbref = 1.0 / (SBREF + 0.5 * L_mult);
		Inv_odref = Inv_saref + Inv_sbref;
		rho_ref = (KU0/ku0_temp)*Inv_odref;
		Inv_od = Inv_sa + Inv_sb;
		rho = (KU0/ku0_temp)*Inv_od;
		mu0_mult = (1.0 + rho)/(1.0 + rho_ref);
		vsat_mult = (1.0 + rho*KVSAT)/(1.0 + rho_ref*KVSAT);
		vth0_stress = (KVTH0/kstress_vth0)*(Inv_od - Inv_odref);
		k2_stress = (STK2/pow(kstress_vth0,LODK2))*(Inv_od - Inv_odref);
		eta_stress = (STETA0/pow(kstress_vth0,LODETA0))*(Inv_od - Inv_odref);

		U0_t = U0_t * mu0_mult;
		VSAT_t = VSAT_t * vsat_mult;
		K2_i = K2_i + k2_stress;
		ETA0_t = ETA0_t + eta_stress;
	end else begin
		vth0_stress = 0;
	end
	///End of Stress Effect

	//Well Proximity Effect
   // XYCE MOD:  If we do not initialize these, then there are serious
   // problems with some compilers when WPEMOD is zero, because all of these
   // variables get USED unconditionally.
   local_sca = 0.0;
   local_scb = 0.0;
   local_scc = 0.0;

    if (WPEMOD)   begin
		Wdrn = W / NF;
		local_sca = SCA;
		local_scb = SCB;
		local_scc = SCC;
		if(!$param_given(SCA) && !$param_given(SCB) && !$param_given(SCC)) begin
			if($param_given(SC) && SC > 0.0) begin
				T1 = SC + Wdrn;
				T2 = 1.0 / SCREF;
				local_sca = SCREF * SCREF / (SC * T1);        
				local_scb = ( (0.1 * SC + 0.01 * SCREF) * 
							exp(-10.0 * SC * T2)  - (0.1 * T1 + 0.01 * SCREF) * 
							exp(-10.0 * T1 * T2) ) / Wdrn;
				local_scc = ( (0.05 * SC + 0.0025 * SCREF) * 
							exp(-20.0 * SC * T2)  - (0.05 * T1 + 0.0025 * SCREF) * 
							exp(-20.0 * T1 * T2) ) / Wdrn;
			end
			else
				`STROBE("Warning: (Instance %M) No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.");
		end
	
	end
	vth0_well = KVTH0WE_i*(local_sca + WEB*local_scb + WEC*local_scc);
	k2_well = K2WE_i*(local_sca + WEB*local_scb + WEC*local_scc);
	mu_well = 1.0 + KU0WE_i*(local_sca + WEB*local_scb + WEC*local_scc);
	
	U0_t = U0_t * mu_well;
	K2_i = K2_i + k2_well;
	// end of WPE
	
	// Load Terminal Voltages
	Vg = devsign * V(`IntrinsicGate, `IntrinsicBody);
	Vd = devsign * V(`IntrinsicDrain, `IntrinsicBody);
	Vs = devsign * V(`IntrinsicSource, `IntrinsicBody);
	Vds = Vd - Vs;
	Vds_noswap = Vds;
	Vsb_noswap = Vs;
	Vdb_noswap = Vd;

`ifdef __RBODYMOD__
	Vbs_jct = devsign * V(sbulk, `IntrinsicSource);//Beta6 modification
	Vbd_jct = devsign * V(dbulk,`IntrinsicDrain);
`else
	Vbs_jct = -Vs;
	Vbd_jct = -Vd;
`endif

	Vgd_noswap = Vg - Vd;
	Vgs_noswap = Vg - Vs;


`ifdef __RGATEMOD__
	Vgd_ov_noswap = devsign * V(`GateEdgeNode, `IntrinsicDrain);
	Vgs_ov_noswap = devsign * V(`GateEdgeNode, `IntrinsicSource);
`else
	Vgd_ov_noswap = Vgd_noswap;
	Vgs_ov_noswap = Vgs_noswap;
`endif

	// ***************************************************
	// Terminal Voltage Conditioning
	// ***************************************************

	// Source-drain Interchange
	sigvds = 1.0;
	if(Vds < 0.0) begin
		sigvds = -1.0;
		Vd = devsign * V(`IntrinsicSource, `IntrinsicBody);
		Vs = devsign * V(`IntrinsicDrain, `IntrinsicBody);
	end

	Vds = Vd - Vs;
	Vdsx = sqrt(Vds*Vds + 0.01) - 0.1;

	Vbsx = -(Vs + 0.5*(Vds-Vdsx));//Vbsx smoothing


// Asymmetry Model
	T0         =  tanh(0.6 * Vds_noswap / Vtm);
	wf         =  0.5 + 0.5 * T0;
	wr         =  1.0 - wf;

	if(ASYMMOD != 0) begin
		CDSCD_a    =  CDSCDR_i * wr + CDSCD_i * wf;
		ETA0_a     =  ETA0R_t * wr + ETA0_t * wf;
		PDIBLC_a   =  PDIBLCR_i * wr + PDIBLC_i * wf; 
		PCLM_a     =  PCLMR_i * wr + PCLM_i * wf;	    
		PSAT_a     =  PSATR_i * wr + PSAT_i * wf;	    
		VSAT_a     =  VSATR_t * wr + VSAT_t * wf;	    
		PTWG_a     =  PTWGR_t * wr + PTWG_t * wf;	    
		U0_a       =  U0R_t * wr + U0_t * wf;	    
		UA_a       =  UAR_t * wr + UA_t * wf;	    
		UC_a       =  UCR_t * wr + UC_t * wf;	    
		UD_a       =  UDR_t * wr + UD_t * wf;	    
		UCS_a      =  UCSR_t * wr + UCS_t * wf;

	end else begin
		CDSCD_a    =  CDSCD_i;
		ETA0_a     =  ETA0_i;
		PDIBLC_a   =  PDIBLC_i; 
		PCLM_a     =  PCLM_i;	    
		PSAT_a     =  PSAT_i;	    
		VSAT_a     =  VSAT_t;	    
		PTWG_a     =  PTWG_t;	    
		U0_a       =  U0_t;	    
		UA_a       =  UA_t;	    
		UC_a       =  UC_t;	    
		UD_a       =  UD_t;	    
		UCS_a      =  UCS_t;

	end

	// *** SCE, DIBL, SS degradation effects (Ref: BSIM4 Model)***

	`Smooth(Phist - Vbsx, 0.05, 0.1, PhistVbs)

	sqrtPhistVbs = sqrt(PhistVbs);
	Xdep 		= T1DEP * sqrtPhistVbs;
	Cdep		= epssi / Xdep;
	cdsc 		= CIT_i + NFACTOR_t + CDSCD_a * Vdsx - CDSCB_i * Vbsx;
	T1 			= 1.0 + cdsc/Cox;

	`Smooth(T1, 1, 0.05, n) //Limiting n to 1.0

	nVt 	= n * Vt;
	inv_nVt = 1.0/nVt;

	dVth_dibl 	= -(ETA0_a + ETAB_i*Vbsx) * Vdsx;//Vth Shift for DIBL
	dvth_temp = (KT1_i + KT1L / Leff + KT2_i*Vbsx) * (pow(TRatio,KT1EXP) - 1.0);//Vth shift with temperature
	`Smooth2(dVth_dibl, 0.0, 5.0e-5, dVth_dibl)
	/* Vth correction for Pocket implant*/
	if (DVTP0_i > 0.0) begin
		T0 = -DVTP1_i * Vdsx;
		if (T0 < -`EXPL_THRESHOLD)
			T2 = `MIN_EXPL;
		else
			T2 = exp(T0);
		T3 = Leff + DVTP0_i * (1.0 + T2);
		dVth_ldop = -nVt * lln(Leff / T3);
	end else
		dVth_ldop = 0;

	T4 = DVTP5_i + DVTP2_i/pow(Leff, DVTP3_i);
	dVth_ldop = dVth_ldop - T4 * tanh(DVTP4_i * Vdsx);

	//Normalization of terminal and flatband voltage by nVt
	VFB_i	= VFB_i + DELVT0;
	vg 		= Vg * inv_nVt;
	vs 		= Vs * inv_nVt;
	vfb 	= VFB_i * inv_nVt;

	dVth_VNUD 	= K1_i*(sqrtPhistVbs - sqrtPhist) - K2_i*Vbsx;  //Compute dVth_VNUD with "first-order" and "second-order" body-bias effect
	Vth_shift	= dVth_dibl + dVth_ldop + dVth_VNUD - dvth_temp + vth0_stress + vth0_well;
	vgfb 		= vg - vfb - Vth_shift * inv_nVt;


//********************************************Threshold Voltage for Operating Point Information**************************************************************//
	gam	= sqrt(2.0 * `q * epssi*NDEP_i * inv_Vt)/Cox;
	q_vth	= 0.5;
	T0 	= hypsmooth((2*phib+Vs*inv_Vt),1e-3);
	nq	= 1.0+ gam/(2.0*sqrt(T0));
	psip_th	= hypsmooth((Vs*inv_Vt+2*phib+ln(q_vth)+2*q_vth+ln(2*nq/gam * (2*q_vth*nq/gam + 2*sqrt(T0)))),1e-3);
	VTH	= VFB_i+ (psip_th-Vs*inv_Vt)*Vt + Vt*gam*sqrt(psip_th)+ Vth_shift;
//******************************************************************************************************************//

	//Normalized body factor
	gam = sqrt(2.0 * `q * epssi*NDEP_i * inv_nVt)/Cox;
	inv_gam = 1.0/gam;

	// psip: pinch-off voltage
	phib_n 	= phib/n;
	`PO_psip(vgfb,gam,0,phib_n,psip)

	`BSIM_q(psip,phib_n,vs,gam,qs) // normalized inversion charge at source end of channel

	// average charge-surf. pot. slope - Ref.: Charge-based MOS Transistor Modeling by C. Enz & E. Vittoz
	`Smooth(psip, 1.0, 2.0, psipclamp)
	sqrtpsip = sqrt(psipclamp);
	psiavg 	 = psip - 2.0*qs; // source side surf pot.
	`Smooth(psiavg, 1.0, 2.0, T0)
	nq 		 = 1.0 + gam / (sqrtpsip + sqrt(T0));

	// *** Drain Saturation Voltage ***
	EeffFactor = 1.0e-8 / (epsratio * TOXE);

	T0 = nVt * (vgfb - psip - 2.0*qs*(nq-1.0));
	`Smooth(T0, 0, 0.1, qbs)
	qis = 2.0 * nq * nVt * qs; //Source side qi and qb for Vdsat- normalized to Cox

	Eeffs = EeffFactor * (qbs + eta_mu * qis); // in the unit of MV/cm

	// Ref: BSIM4 Model mobility model
	T2 		= pow(0.5 * (1.0 + (qis / qbs)), UCS_a);
	T3		= (UA_a + UC_a*Vbsx) * pow(Eeffs, EU_i) + UD_a / T2;
	T4		= 1.0 + T3;	
	`Smooth(T4, 1.0, 0.0015, Dmobs) //Limiting Dmobs to 1.0
	
	WeffWRFactor = 1.0 / (pow(Weff*1.0e6, WR_i) * NF);

`ifdef __RDSMOD__
	if(RDSMOD == 1)
		Rdss = 0.0;
	else begin
`endif
		T0 = 1.0 + PRWG_i * qis;
		T1 = PRWB_i*(sqrtPhistVbs - sqrtPhist);
		T2 = 1.0 / T0 + T1;
		T3 = T2 + sqrt(T2*T2 + 0.01);
		Rdss = (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF * rdstemp;
		
`ifdef __RDSMOD__
	if (RDSMOD==2)
		Rdss = (RSourceGeo + (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF + RDrainGeo) * rdstemp;
	end
`endif

	T0			= pow(Dmobs, 1.0/PSAT_a);
	if (PSATB_i<0)
		T1		= 1.0 / (1.0 + PSATB_i * Vbsx);
	else
		T1		= 1.0 - PSATB_i * Vbsx;				 

	T2			= 10.0 *PSATX * qs * T1 / (10.0 *PSATX + qs * T1);
	if (PTWG_a<0)
		LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0/(1.0-PTWG_a*T2));
	else
		LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 + PTWG_a*T2);

	if (Rdss==0) begin// qdsat for external Rds
		// Accurate qdsat derived from consistent I-V
		T0 = 0.5 * LambdaC * (qs*qs + qs) / (1.0 + 0.5 * LambdaC *(1.0 + qs));
		T1 = 2.0 * LambdaC * (qs - T0);
		T2 = sqrt(1.0 + T1*T1);
		ln_T1_T2 = asinh(T1);//used VA function for asinh(T1)=ln(T1 + T2)
		if (T1 != 0)
			T3 =   T2 + (1.0/T1) * ln_T1_T2;
		else
			T3 =   T2 + (1.0/T2);

		T4 = T0 * T3 - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
		if (T1 != 0)
			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
		else
			T5 = (-2.0 * LambdaC) * (T1/T2) * (T1/T2) *(T1/T2);

		T6 = T0 * T5 + T3 + LambdaC * (2.0*T0 + 1.0);
		T0 = T0 - (T4/T6);

		T1 = 2.0 * LambdaC * (qs - T0);
		T2 = sqrt(1.0 + T1*T1);
		ln_T1_T2 = asinh(T1);
		if (T1 != 0)
			T3 =   T2 + (1.0/T1) * ln_T1_T2;
		else
			T3 =   T2 + (1.0/T2);

		T4 = T0 * T3 - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
		if (T1 != 0)
			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
		else
			T5 = (T1/T2) * (T1/T2) *(T1/T2);

		T6 = T0 * T5 + T3 + LambdaC * (2.0*T0 + 1.0);
		qdsat = T0 - (T4/T6);

	end else begin // qdsat for internal Rds -- Ref. : BSIM4 model
		// Accurate qdsat derived from consistent I-V
		T11 = Weff * 2.0 * nq * Cox * nVt * VSAT_a;
		T12 = T11 * LambdaC * Rdss / (2.0*nVt);
		T0  = 0.5 * LambdaC * (qs*qs + qs) / (1.0 + 0.5 * LambdaC *(1.0 + qs));
		T1  = 2.0 * LambdaC * (qs - T0);
		T2  = sqrt(1.0 + T1*T1);
		ln_T1_T2 = asinh(T1);//used VA function for asinh(T1)=ln(T1 + T2)
		if (T1 != 0)
			T3 =   T2 + (1.0/T1) * ln_T1_T2;
		else
			T3 =   T2 + (1.0/T2);

		T4  = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
		if (T1 != 0)
			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
		else
			T5 = (-2.0 * LambdaC) * (T1/T2) * (T1/T2) *(T1/T2);

		T6  = T0 * T5 + T3 + T12 * (qs + 2.0*T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
		T0  = T0 - T4/T6;

		T1  = 2.0 * LambdaC * (qs - T0);
		T2  = sqrt(1.0 + T1*T1);
		ln_T1_T2 = asinh(T1);
		if (T1 != 0)
			T3 =   T2 + (1.0/T1) * ln_T1_T2;
		else
			T3 =   T2 + (1.0/T2);

		T4  = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs*qs + qs) - (T0*T0 + T0) );
		if (T1 != 0)
			T5 = (-2.0 * LambdaC) * (T1*T2 - ln_T1_T2) / (T1*T1);
		else
			T5 = (-2.0 * LambdaC) * (T1/T2) * (T1/T2) *(T1/T2);

		T6  = T0 * T5 + T3 + T12 * (qs + 2.0*T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
		qdsat  = T0 - T4/T6;
	end

	vdsat 	= psip -2.0*phib_n - (2.0*qdsat + ln( (qdsat*2.0*nq*inv_gam)*((qdsat*2.0*nq*inv_gam) + (gam/(nq-1.0)) ) ));
	Vdsat 	= vdsat * nVt;

	// normalized charge qdeff at drain end of channel
	`Smooth(Vdsat - Vs, 0.0, 1e-3, Vdssat) //Vdssat clamped to avoid negative values during transient simulation
	T7 		= pow(Vds/Vdssat , 1.0/DELTA_t);
	T8 		= pow(1.0+T7, -DELTA_t);
	Vdseff 	=  Vds*T8;
	vdeff 	= (Vdseff + Vs) * inv_nVt;
	`BSIM_q(psip,phib_n,vdeff,gam,qdeff)

	//*********************************************************
	// Reevaluation of nq to include qdeff --needed for gummel symmetry
	psiavg = psip - qs - qdeff -1.0;
	`Smooth(psiavg, 1.0, 2.0, T0)
	T2 = sqrt(T0);
	nq = 1.0 + gam/(sqrtpsip+T2);
	//Inversion and bulk charge
	DQSD2 = (qs-qdeff)*(qs-qdeff);
	T0 = 1.0 / (1.0 + qs + qdeff);
	T1 = DQSD2 * T0;
	Qb = vgfb -psip - (nq-1.0)*( qs + qdeff + `Oneby3 * T1);
	T2 = `Oneby3*nq;
	T3 = T1*T0;
	Qs = T2*( 2.0*qs + qdeff + 0.5*(1.0+0.8*qs+1.2*qdeff)*T3);
	Qd = T2*( qs + 2.0*qdeff + 0.5*(1.0+1.2*qs+0.8*qdeff)*T3);

	//*********************************************************

	// *** Mobility Degradation (Ref: BSIM4 Model)***
	//Average charges (qba and qia) - normalized to Cox
	`Smooth(nVt*Qb, 0, 0.1, qba)
	qia = nVt*( Qs + Qd);

	Eeffm 	= EeffFactor * (qba + eta_mu * qia); // in the unit of MV/cm
	T2 		= pow(0.5 * (1.0 + (qia / qba)), UCS_a);
	T3		=(UA_a + UC_a * Vbsx) * pow(Eeffm, EU_i) + UD_a / T2;
	T4		= 1.0 + T3;	
	`Smooth(T4, 1.0, 0.0015, Dmob) //Limiting Dmob to 1.0	
	
	// *** Output Conductance Modules ***
	Esat 	= 2.0 * VSAT_a / (U0_a / Dmob);
	EsatL 	= Esat * Leff;
	if(PVAG_i  > 0)
		PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
	else
		PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);

	// Output conductance due to DIBL - Ref: BSIM4 Model
	DIBLfactor 	= PDIBLC_a;
	diffVds 	= Vds - Vdseff;
	Vgst2Vtm 	= qia + 2.0 * nVt;
	if (DIBLfactor > 0) begin
		T3 		= Vgst2Vtm / (Vdssat + Vgst2Vtm);
		T4 		= hypsmooth((1.0 + PDIBLCB_i * Vbsx),1e-3);
		T5		= 1/T4;
		VaDIBL 	        = Vgst2Vtm / DIBLfactor * T3 * PVAGfactor * T5;
		Moc 		= 1.0 + diffVds / VaDIBL;
	end else begin
		Moc = 1.0;
	end

	// Degradation factor due to pocket implant -- Ref BSIM4
	if (FPROUT_i <= 0.0)
		Fp = 1.0;
	else begin
		T9 = FPROUT_i * sqrt(Leff) / Vgst2Vtm;
		Fp = 1.0 / (1.0 + T9);
	end

	// Channel Length Modulation -- Ref BSIM4
	Vasat = Vdssat + EsatL;
	if(PCLM_a != 0) begin
		if(PCLMG < 0.0)
			T1 = PCLM_a / (1.0 - PCLMG * qia / EsatL)/Fp;
		else
			T1 = PCLM_a * (1.0 + PCLMG * qia / EsatL)/Fp;
		MdL = 1.0 + T1 * lln(1.0 + diffVds / T1 / Vasat);
	end else
		MdL = 1.0;
	Moc = Moc * MdL;

	// Calculate Vadits -- Ref BSIM4
	T1 = lexp(PDITSD_i * Vds);
	if (PDITS_i > 0.0) begin
		T2 		= 1.0 + PDITSL * Leff;
		VaDITS 	= (1.0 + T2 * T1) / PDITS_i;
		VaDITS 	= VaDITS * Fp;
	end else
		VaDITS 	= `MAX_EXPL;

	T4  = diffVds / VaDITS;
	T0  = 1.0 + T4;
	Moc = Moc * T0;

	// Calculate Vascbe -- Ref BSIM4
	if (PSCBE2_i > 0.0) begin
		if (diffVds > PSCBE1_i * litl / `EXPL_THRESHOLD) begin
			T0 		= PSCBE1_i * litl / diffVds;
			VaSCBE 	= Leff * exp(T0) / PSCBE2_i;
		end else
			VaSCBE 	= `MAX_EXPL * Leff/PSCBE2_i;
	end else
		VaSCBE = `MAX_EXPL;

	Mscbe 	= 1.0 + (diffVds / VaSCBE);
	Moc = Moc * Mscbe;

	// *** Velocity Saturation ***
	T0			= pow(Dmob, 1.0/PSAT_a);
	if (PSATB_i<0)
		T1		= 1.0 / (1.0 + PSATB_i * Vbsx);
	else
		T1		= 1.0 - PSATB_i * Vbsx;

	T2			= 10.0* PSATX * qia * T1 / (10.0 *PSATX + qia * T1);
	if (PTWG_a<0)
		LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0/(1.0- PTWG_a * T2));
	else
		LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 + PTWG_a * T2);

	T1			= 2.0 * LambdaC * (qs - qdeff);
	T2			= sqrt(1.0 + T1 * T1);

	if (T1 != 0)
		Dvsat	= 0.5 * ( T2 + (1.0/T1) * asinh(T1) );
	else
		Dvsat	= 0.5 * ( T2 + (1.0/T2) );
	Dptwg		= Dvsat;


	// *** S/D series resistance -- Ref: BSIM4 Model
`ifdef __RDSMOD__
	Rsource = 0.0; Rdrain = 0.0; //Initialization
	if(RDSMOD == 1) begin
		Rdsi = 0.0;
		Dr = 1.0;

		// Rs (Source side resistance for all fingers)
		T2 		= Vgs_noswap - Vfbsdr;
		T3 		= sqrt(T2 * T2 + 0.01);
		Vgs_eff = 0.5 * (T2 + T3);
		T5 		= 1.0 + PRWG_i * Vgs_eff;
		T6 		= (1.0/T5) + PRWB_i * Vsb_noswap;
		T4 		= 0.5 * (T6 + sqrt(T6 * T6 + 0.01));
		Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T4) * WeffWRFactor);

		// Rd (Drain side resistance for all fingers)
		T2 		= Vgd_noswap - Vfbsdr;
		T3 		= sqrt(T2 * T2 + 0.01);
		Vgd_eff = 0.5 * (T2 + T3);
		T5 		= 1.0 + PRWG_i * Vgd_eff;
		T6 		= (1.0/T5) + PRWB_i * Vdb_noswap;
		T4 		= 0.5 * (T6 + sqrt(T6 * T6 + 0.01));
		Rdrain 	= rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T4) * WeffWRFactor);

	end else begin
`endif
		// Ref: (1) BSIM4 Model
		//      (2) "Operation and Modeling of the MOS Transistor" by Yannis Tsividis
		T0 = 1.0 + PRWG_i * qia;//reevaluate for gummel symmetry
		T1 = PRWB_i*(sqrtPhistVbs - sqrtPhist);
		T2 = 1.0 / T0 + T1;
		T3 = 0.5 * (T2 + sqrt(T2*T2 + 0.01));
		Rdsi = rdstemp * (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF ;
		Rdrain = RDrainGeo;
		Rsource = RSourceGeo;
		Dr = 1.0 + U0_a /(Dvsat * Dmob) * Cox * Weff / Leff * qia * Rdsi;
		
`ifdef __RDSMOD__
	if(RDSMOD == 2) begin
			
			Rdsi = rdstemp * (RSourceGeo + (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF + RDrainGeo ) ;
			Rdrain = 0;
			Rsource = 0;
			Dr = 1.0 + U0_a /(Dvsat * Dmob) * Cox * Weff / Leff * qia * Rdsi;
		end
	end
`endif


// ************* Non-saturation effect *************

		T0     =  A1_t + A2_t / (qia + 2.0 * n*Vtm);
		DQSD   =  qs-qdeff;
		T1     =  T0 * DQSD * DQSD;
		T2     =  T1 + 1.0 - 0.001;
		T3     =  -1.0 + 0.5 * (T2 + sqrt(T2*T2 + 0.004));   //max(T1,-1.0)
		Nsat   =  0.5 * (1.0 + sqrt(1.0 + T3));


// ************* Non-saturation effect Ends *************


	Dtot 		= Dmob * Dvsat * Dr;

	ueff = U0_a / Dtot; //Effective Mobility including mobility degradation

	// ***************************************************
	// I-V Equation
	// ***************************************************

	ids = 2.0 * NF * nq * ueff * Weff/Leff * Cox * nVt * nVt *((qs - qdeff)*(1.0 + qs + qdeff)) *Moc/Nsat;


`ifdef __RGATEMOD__
	/* Calculate Rg */
	Gcrg = 0.0;
	if (RGATEMOD > 1) begin
		//idsovvds= ueff*Weff/Leff*Cox*qia*Moc;
		idsovvds= ueff*Weff/Leff*Cox*qia;
		T9 = XRCRG2 * Vt;
		T0 = T9 * ueff * Weff/Leff * Cox;
		Gcrg = XRCRG1 * NF * (T0 + idsovvds);
		if (RGATEMOD == 2) begin
			T11 = Grgeltd + Gcrg;
			Gcrg = Grgeltd * Gcrg / T11;
		end
	end
`endif

	//Impact Ionization Current (Ref: BSIM4 Model)
	if ((ALPHA0_i <= 0.0) || (BETA0_t <= 0.0))
		Iii = 0.0;
	else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
		T1 = - BETA0_t / diffVds;
		Iii = ALPHA0_i * diffVds * ids * lexp(T1)/Mscbe;
	end else begin
		Iii = ALPHA0_i * diffVds * ids * `MIN_EXPL/Mscbe;
	end
	ISUB = Iii * devsign;

	// *** Gate Current ***// Ref: BSIM4 Model

	igbinv = 0.0;	igbacc = 0.0;	igb = 0.0;
	igcs = 0.0;		igcd = 0.0;		igs = 0.0;	igd = 0.0;
	//Initialization

	if ((IGCMOD != 0) || (IGBMOD != 0)) begin
		Voxm = nVt * (vgfb -psip + qs + qdeff);
		T1 = sqrt(Voxm*Voxm + 1.0E-4);
		Voxmacc = 0.5*(-Voxm + T1);
		Voxminv = 0.5*( Voxm + T1);

		// Igbinv
	if (IGBMOD != 0) begin
		T1 = Voxmacc / NIGBACC_i / Vt; //representative of Qb in acc
		Vaux_Igbacc = NIGBACC_i * Vt * lln(1 + lexp(-T1));
		T2 = AIGBACC_i - BIGBACC_i * Voxmacc;
		T3 = 1.0 + CIGBACC_i * Voxmacc;
		T4 = -7.45669e11 * TOXE * T2 * T3;
		T5 = lexp (T4);
		T6 = 4.97232e-7;
		igbacc = NF * Weff * Leff * T6 * ToxRatio * Vg * Vaux_Igbacc * T5;
		igbacc = igbacc * igtemp;

		T1 = (Voxminv - EIGBINV_i) / NIGBINV_i / Vt;
		Vaux_Igbinv = NIGBINV_i * Vt * lln(1.0 + lexp(T1));
		T2 = AIGBINV_i - BIGBINV_i * Voxminv;
		T3 = 1.0 + CIGBINV_i * Voxminv;
		T4 = -9.82222e11 * TOXE * T2 * T3;
		T5 = lexp (T4);
		T6 = 3.75956e-7;
		igbinv = NF * Weff * Leff * T6 * ToxRatio * Vg * Vaux_Igbinv * T5;
		igbinv = igbinv * igtemp;
		igb = (igbacc + igbinv);
	end

	if(IGCMOD != 0) begin
		// Igcinv
		T1 = AIGC_i - BIGC_i * Voxminv;
		T2 = 1.0 + CIGC_i * Voxminv;
		T3 = Bechvb * T1 * T2;
		T4 = nq * nVt * (qs + qdeff) * lexp(T3);
		igc0 = NF * Aechvb * T4 * (Vg + 0.5 *Vdsx - 0.5*(Vs+Vd)) * igtemp;

		// Gate-current partitioning
		Vdseffx = sqrt(Vdseff*Vdseff + 0.01) - 0.1;
		T1 = PIGCD_i * Vdseffx;
		T1_exp = lexp(-T1);
		T3 = T1 + T1_exp -1.0 + 1.0E-4;
		T4 = 1.0 - (T1 + 1.0) * T1_exp + 1.0E-4;
		T5 = T1 * T1 + 2.0E-4;
		if(sigvds > 0) begin
			igcd = igc0 * T4 / T5;
			igcs = igc0 * T3 / T5;
		end else begin
			igcs = igc0 * T4 / T5;
			igcd = igc0 * T3 / T5;
		end

		// Igs
		T2 	= Vgs_noswap - Vfbsdr;
		Vgs_eff = sqrt(T2 * T2 + 1.0e-4);
		T1 = AIGS_i - BIGS_i * Vgs_eff;
		T2 = 1.0 + CIGS_i * Vgs_eff;
		T3 = BechvbEdge * T1 * T2;
		T4 = lexp(T3);
		igs_mult = igtemp * NF * AechvbEdge * DLCIG_i;
		igs = igs_mult * Vgs_noswap * Vgs_eff * T4;
		

		// Igd
		T2 	= Vgd_noswap - Vfbsdr;
		Vgd_eff 	= sqrt(T2 * T2 + 1.0e-4);
		T1 = AIGD_i - BIGD_i * Vgd_eff;
		T2 = 1.0 + CIGD_i * Vgd_eff;
		T3 = BechvbEdge * T1 * T2;
		T4 = lexp(T3);
		igd_mult = igtemp * NF * AechvbEdge * DLCIGD_i;
		igd = igd_mult * Vgd_noswap * Vgd_eff * T4;
	end
	end

	IGS = devsign * igs;
	IGD = devsign * igd;
	IGB = devsign * igb;
	IGCS = devsign * igcs;
	IGCD = devsign * igcd;

	// GIDL/GISL current (Ref: BSIM4 Model)
	igisl = 0.0;
	igidl = 0.0;
	if (GIDLMOD != 0) begin
		T0 = epsratio * TOXE;
		// GIDL
		if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0) || (CGIDL_i < 0.0)) begin
			T6 = 0.0;
		end else begin
			T1 = (- Vgd_noswap - EGIDL_i + Vfbsdr) / T0;
			T1 =  hypsmooth(T1, 1.0E-2);
			T2 = BGIDL_t / (T1 + 1.0E-3);
			if (CGIDL_i !=0) begin
				T3 = Vdb_noswap*Vdb_noswap*Vdb_noswap;
				T4 = CGIDL_i + abs(T3) + 1.0E-9;
				T5 = hypsmooth(T3/T4, 1.0E-6) - 1.0E-6;
			end else
				T5 = 1.0;
			T6 = AGIDL_i * Weff * T1 * lexp(-T2) * T5;
		end
		igidl = T6;

		// GISL
		if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0) || (CGISL_i < 0.0)) begin
			T6 = 0.0;
		end else begin
			T1 = (- Vgs_noswap - EGISL_i + Vfbsdr) / T0;
			T1 =  hypsmooth(T1, 1.0E-2);
			T2 = BGISL_t / (T1 + 1.0E-3);
			if (CGISL_i !=0) begin
				T3 = Vsb_noswap*Vsb_noswap*Vsb_noswap;
				T4 = CGISL_i + abs(T3) + 1.0E-9;
				T5 = hypsmooth(T3/T4, 1.0E-6) - 1.0E-6;
			end else
				T5 = 1.0;
			T6 = AGISL_i * Weff * T1 * lexp(-T2) * T5;
		end
		igisl = T6;
	end // GIDLMOD

	IGIDL = devsign * NF * igidl;
	IGISL = devsign * NF * igisl;

	// Junction Current and Capacitances
	// Source-side junction current
	if(Isbs > 0.0) begin
		if (Vbs_jct < VjsmRev) begin
			T0 = Vbs_jct / Nvtms;
			T1 = lexp(T0) - 1.0;
			T2 = IVjsmRev + SslpRev * (Vbs_jct - VjsmRev);
			Ibs = T1 * T2;
		end else if (Vbs_jct <= VjsmFwd) begin
			T0 = Vbs_jct / Nvtms;
			T1 = (BVS + Vbs_jct) / Nvtms;
			T2 = lexp(-T1);
			Ibs = Isbs * (lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
		end else
			Ibs = IVjsmFwd + SslpFwd * (Vbs_jct - VjsmFwd);
	end else
		Ibs = 0.0;

	//Source-side junction tunneling current
	if(JTSS_t > 0.0) begin
		if((VTSS - Vbs_jct) < (VTSS * 1.0e-3)) begin
			T0 = -Vbs_jct / Vtm0 / NJTS_t;
			T1 = lexp(T0 * 1.0e+3) - 1.0;
			Ibs = Ibs - ASeff * JTSS_t * T1;
		end else begin
			T0 = -Vbs_jct / Vtm0 / NJTS_t;
			T1 = lexp(T0 * VTSS / (VTSS - Vbs_jct)) - 1.0;
			Ibs = Ibs - ASeff * JTSS_t * T1;
		end
	end
	if(JTSSWS_t > 0.0) begin
		if((VTSSWS - Vbs_jct) < (VTSSWS * 1.0e-3)) begin
			T0 = -Vbs_jct / Vtm0 / NJTSSW_t;
			T1 = lexp(T0 * 1.0e+3) - 1.0;
			Ibs = Ibs - PSeff * JTSSWS_t * T1;
		end else begin
			T0 = -Vbs_jct / Vtm0 / NJTSSW_t;
			T1 = lexp(T0 * VTSSWS / (VTSSWS - Vbs_jct)) - 1.0;
			Ibs = Ibs - PSeff * JTSSWS_t * T1;
		end
	end
	if(JTSSWGS_t > 0.0) begin
		if((VTSSWGS - Vbs_jct) < (VTSSWGS * 1.0e-3)) begin
			T0 = -Vbs_jct / Vtm0 / NJTSSWG_t;
			T1 = lexp(T0 * 1.0e+3) - 1.0;
			Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
		end else begin
			T0 = -Vbs_jct / Vtm0 / NJTSSWG_t;
			T1 = lexp(T0 * VTSSWGS / (VTSSWGS - Vbs_jct)) - 1.0;
			Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
		end
	end


	// Drain-side junction current
	if(Isbd > 0.0) begin
		if (Vbd_jct < VjdmRev) begin
			T0 = Vbd_jct / Nvtmd;
			T1 = lexp(T0) - 1.0;
			T2 = IVjdmRev + DslpRev * (Vbd_jct - VjdmRev);
			Ibd = T1 * T2;
		end else if (Vbd_jct <= VjdmFwd) begin
			T0 = Vbd_jct / Nvtmd;
			T1 = (BVD + Vbd_jct) / Nvtmd;
			T2 = lexp(-T1);
			Ibd = Isbd * (lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
		end else
			Ibd = IVjdmFwd + DslpFwd * (Vbd_jct - VjdmFwd);
	end else
		Ibd = 0.0;

	//Drain-side junction tunneling current
	if(JTSD_t > 0.0) begin
		if((VTSD - Vbd_jct) < (VTSD * 1.0e-3)) begin
			T0 = -Vbd_jct / Vtm0 / NJTSD_t;
			T1 = lexp(T0 * 1.0e+3) - 1.0;
			Ibd = Ibd - ADeff * JTSD_t * T1;
		end else begin
			T0 = -Vbd_jct / Vtm0 / NJTSD_t;
			T1 = lexp(T0 * VTSD/ (VTSD - Vbd_jct)) - 1.0;
			Ibd = Ibd - ADeff * JTSD_t * T1;
		end
	end
	if(JTSSWD_t > 0.0) begin
		if((VTSSWD - Vbd_jct) < (VTSSWD * 1.0e-3)) begin
			T0 = -Vbd_jct / Vtm0 / NJTSSWD_t;
			T1 = lexp(T0 * 1.0e+3) - 1.0;
			Ibd = Ibd - PDeff * JTSSWD_t * T1;
		end else begin
			T0 = -Vbd_jct / Vtm0 / NJTSSWD_t;
			T1 = lexp(T0 * VTSSWD / (VTSSWD - Vbd_jct)) - 1.0;
			Ibd = Ibd - PDeff * JTSSWD_t * T1;
		end
	end
	if(JTSSWGD_t > 0.0) begin
		if((VTSSWGD - Vbd_jct) < (VTSSWGD * 1.0e-3)) begin
			T0 = -Vbd_jct / Vtm0 / NJTSSWGD_t;
			T1 = lexp(T0 * 1.0e+3) - 1.0;
			Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
		end else begin
			T0 = -Vbd_jct / Vtm0 / NJTSSWGD_t;
			T1 = lexp(T0 * VTSSWGD / (VTSSWGD - Vbd_jct)) - 1.0;
			Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
		end
	end

	// *** Junction capacitance (!!no swapping !!) ***
	/* Source Bulk Junction */
	if (Czbs > 0.0) begin
		T1 = Vbs_jct/PBS_t;
		if (T1<0.9) begin
			arg = 1.0 - T1;
			if (MJS == 0.5)  sarg = 1.0 / sqrt(arg);
			else             sarg = lexp(-MJS * lln(arg));
			Qbs = PBS_t * Czbs * (1.0 - arg * sarg) / (1.0 - MJS);
		end else begin
			T2 = pow(0.1,-MJS);
			T3 = 1.0/(1.0-MJS);
			T4 = T2 * (T1-1.0) * (5.0*MJS*(T1-1.0) + (1.0+MJS) );
			T5 = T3 * (1.0 - 0.05*MJS*(1.0+MJS)*T2 );
			Qbs = PBS_t * Czbs * (T4 + T5); //Quadratic equation for Qbs when Vbs_jct/PBS_t<=0.9
		end
	end else begin
		Qbs = 0.0;
	end

	if (Czbssw > 0.0) begin
		T1 = Vbs_jct/PBSWS_t;
		if (T1<0.9) begin
			arg = 1.0 - T1;
			if (MJSWS == 0.5)  sarg = 1.0 / sqrt(arg);
			else               sarg = lexp(-MJSWS * lln(arg));
			Qbs = Qbs + PBSWS_t * Czbssw * (1.0 - arg * sarg) / (1.0 - MJSWS);
		end else begin
			T2 = pow(0.1,-MJSWS);
			T3 = 1.0/(1.0-MJSWS);
			T4 = T2 * (T1-1.0) * (5.0*MJSWS*(T1-1.0) + (1.0+MJSWS) );
			T5 = T3 * (1.0 - 0.05*MJSWS*(1.0+MJSWS)*T2 );
			Qbs = Qbs + PBSWS_t * Czbssw * (T4 + T5);
		end
	end

	if (Czbsswg > 0.0) begin
		T1 = Vbs_jct/PBSWGS_t;
		if (T1<0.9) begin
			arg = 1.0 - T1;
			if (MJSWGS == 0.5)  sarg = 1.0 / sqrt(arg);
			else                sarg = lexp(-MJSWGS * lln(arg));
			Qbs = Qbs + PBSWGS_t * Czbsswg * (1.0 - arg * sarg) / (1.0 - MJSWGS);
		end else begin
			T2 = pow(0.1,-MJSWGS);
			T3 = 1.0/(1.0-MJSWGS);
			T4 = T2 * (T1-1.0) * (5.0*MJSWGS*(T1-1.0) + (1.0+MJSWGS) );
			T5 = T3 * (1.0 - 0.05*MJSWGS*(1.0+MJSWGS)*T2 );
			Qbs = Qbs + PBSWGS_t * Czbsswg * (T4 + T5);
		end
	end

	/* Drain Bulk Junction */
	if (Czbd > 0.0) begin
		T1 = Vbd_jct/PBD_t;
		if (T1<0.9) begin
			arg = 1.0 - T1;
			if (MJD == 0.5)  sarg = 1.0 / sqrt(arg);
			else             sarg = lexp(-MJD * lln(arg));
			Qbd = PBD_t * Czbd * (1.0 - arg * sarg) / (1.0 - MJD);
		end else begin
			T2 = pow(0.1,-MJD);
			T3 = 1.0/(1.0-MJD);
			T4 = T2 * (T1-1.0) * (5.0*MJD*(T1-1.0) + (1.0+MJD) );
			T5 = T3 * (1.0 - 0.05*MJD*(1.0+MJD)*T2 );
			Qbd = PBD_t * Czbd * (T4 + T5);
		end
	end else begin
		Qbd = 0.0;
	end

	if (Czbdsw > 0.0) begin
		T1 = Vbd_jct/PBSWD_t;
		if (T1<0.9) begin
			arg = 1.0 - T1;
			if (MJSWD == 0.5)  sarg = 1.0 / sqrt(arg);
			else               sarg = lexp(-MJSWD * lln(arg));
			Qbd = Qbd + PBSWD_t * Czbdsw * (1.0 - arg * sarg) / (1.0 - MJSWD);
		end else begin
			T2 = pow(0.1,-MJSWD);
			T3 = 1.0/(1.0-MJSWD);
			T4 = T2 * (T1-1.0) * (5.0*MJSWD*(T1-1.0) + (1.0+MJSWD) );
			T5 = T3 * (1.0 - 0.05*MJSWD*(1.0+MJSWD)*T2 );
			Qbd = Qbd + PBSWD_t * Czbdsw * (T4 + T5);
		end
	end

	if (Czbdswg > 0.0) begin
		T1 = Vbd_jct/PBSWGD_t;
		if (T1<0.9) begin
			arg = 1.0 - T1;
			if (MJSWGD == 0.5)  sarg = 1.0 / sqrt(arg);
			else                sarg = lexp(-MJSWGD * lln(arg));
			Qbd = Qbd + PBSWGD_t * Czbdswg * (1.0 - arg * sarg) / (1.0 - MJSWGD);
		end else begin
			T2 = pow(0.1,-MJSWGD);
			T3 = 1.0/(1.0-MJSWGD);
			T4 = T2 * (T1-1.0) * (5.0*MJSWGD*(T1-1.0) + (1.0+MJSWGD) );
			T5 = T3 * (1.0 - 0.05*MJSWGD*(1.0+MJSWGD)*T2 );
			Qbd = Qbd + PBSWGD_t * Czbdswg * (T4 + T5);
		end
	end

	//*************** Noise Modeling - Ref. BSIM4
	Nt = 4.0 * Vt * `q;

	//Parameter Checking
	if(LINTNOI >= Leff/2.0) begin
		$strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
		LINTNOI_i = 0;
	end else begin
		LINTNOI_i = LINTNOI;
	end

	Esatnoi = 2.0 * VSAT_a / ueff;

	if(NOIA > 0 || NOIB > 0 || NOIC > 0) begin
		Leffnoi = Leff - 2.0 * LINTNOI_i;
		Leffnoisq = Leffnoi * Leffnoi;
		if(EM <= 0.0)
			DelClm = 0.0;
		else begin
			T0 = (diffVds / litl + EM) / Esatnoi;
			DelClm = litl * lln(T0);
			if (DelClm < 0.0)  DelClm = 0.0;
		end
		T1 = `q * `q * `q * Vt * abs(ids) * ueff;
		T2 = 1.0e10 * Cox * Leffnoisq;
		N0 = 2.0 * nq * Cox * Vt * qs / `q;
		Nl = 2.0 * nq * Cox * Vt * qdeff / `q;
		Nstar = Vt / `q * (Cox + Cdep + CIT);
		T3 = NOIA * lln((N0 + Nstar) / (Nl + Nstar));
		T4 = NOIB * (N0 - Nl);
		T5 = 0.5 * NOIC * (N0 * N0 - Nl * Nl);
		T6 = `q * Vt * ids * ids;
		T7 = 1.0e10 * Leffnoisq * Weff * NF;
		T8 = NOIA + NOIB * Nl + NOIC * Nl * Nl;
		T9 = (Nl + Nstar) * (Nl + Nstar);
		Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
		T10 = NOIA * `q * Vt;
		T11 = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
		Swi = T10 / T11 * ids * ids;
		T1 = Swi + Ssi;

		if (T1 > 0.0)	FNPowerAt1Hz = (Ssi * Swi) / T1;
		else			FNPowerAt1Hz = 0.0;
	end else begin
		FNPowerAt1Hz = 0.0;
	end

	I(`IntrinsicDrain,`IntrinsicSource) <+ flicker_noise(`MFACTOR_USE*FNPowerAt1Hz, EF, "1overf");

`ifdef __TNOISW__
	T0 = qia/Esatnoi/Leff;
	T1 = T0 * T0;
	T3 = RNOIA * (1.0 + TNOIA * Leff * T1);
	T4 = RNOIB * (1.0 + TNOIB * Leff * T1);
	ctnoi = RNOIC * (1.0 + TNOIC * Leff * T1);
	betanoisq = T3 * T3;
	thetanoisq = T4 * T4;

	cm_igid=0; //Initialization
	case(TNOIMOD)
	0: begin
`endif
		QSi = - NF * Weff * Leff * Cox *Vt * Qs;
		QDi = - NF * Weff * Leff * Cox *Vt * Qd;
		T0 = ueff * abs(QSi+QDi);
		T1 = T0 * Rdsi + Leff * Leff;
		Gtnoi = (T0 / T1) * NTNOI;
		sidn = Nt * Gtnoi;
		I(`IntrinsicDrain, `IntrinsicSource) <+ white_noise(`MFACTOR_USE*sidn, "id");
`ifdef __TNOISW__
	end
	1: begin
		Vtn = 2.0 * nq * nVt;
		T0 = ueff * Dptwg * Moc * Cox * Vtn;
		T1 = 0.5 * (qs + qdeff);
		T3 = T1 + 0.5;
		T4 = T3 * T3;
		T5 = T4 * T3;
		T6 = qs - qdeff;
		T7 = T6 * T6;
		T8 = T7 * T6;
		T9 = (6.0 * T1 + 0.5) * T7;
		Lvsat = Leff * Dptwg;
		T10 = Lvsat / Leff;
		mid = T0 * NF * Weff/Lvsat * (T1 + T7/(12.0 * T3)) * 3.0 * betanoisq;
		mig = Lvsat * T10 * T10 * (T1/T4 - T9/(60.0 * T4 * T4) + T7 * T7/(144.0 * T4 * T5)) * 15.0/4.0 * thetanoisq/(NF * Weff * 12.0 * T0);
		migid = T10 * (T6/(12.0 * T3) - T8/(144.0 * T5)) * ctnoi/0.395;
		sqid =  sqrt(Nt * mid);

		if (mig == 0) begin
			sqig = 0.0;
			cm_igid = 0.0;
		end else begin
			sqig =  sqrt(Nt / mig);
			if (sqid == 0) begin
				cm_igid = 0.0;
			end else begin
				cm_igid = migid * sqig / sqid;
			end
		end

		I(N2)   <+  white_noise(`MFACTOR_USE*cm_igid, "corl");
		I(NI)   <+  white_noise(`MFACTOR_USE*sqig * sqig * (1.0 - cm_igid), "corl");
		I(NI)   <+  `MFACTOR_USE*(-sqig * V(N2));
		I(NC)   <+  ddt(`MFACTOR_USE*mig * Cox * Weff * NF * Leff * V(NC));
		I(`IntrinsicDrain,`IntrinsicSource)  <+  white_noise(`MFACTOR_USE*sqid * sqid * (1.0 - cm_igid), "id");
		I(`IntrinsicDrain,`IntrinsicSource)  <+  `MFACTOR_USE*sqid * V(N2);
		I(`IntrinsicGate,`IntrinsicSource)  <+  ddt(`MFACTOR_USE*0.5 * ((1.0 + sigvds) * mig * Cox * Weff * NF * Leff * V(NC)));
		I(`IntrinsicGate,`IntrinsicDrain)  <+  ddt(`MFACTOR_USE*0.5 * ((1.0 - sigvds) * mig * Cox * Weff * NF * Leff * V(NC)));
	end
	endcase

	I(N2)   <+  `MFACTOR_USE*V(N2);
	I(NR)   <+  `MFACTOR_USE*V(NR);
`else
	if(TNOIMOD != 0)
		$strobe("[BSIM6] Although the model selector TNOIMOD is set to 1, the correlated thermal noise model was not activated when the Verilog-A code was compiled.  Please uncomment \"`define __TNOISW__\" in the beginning of the Verilog-A code.");
`endif

	// Gate current shot noise
	if(IGCMOD != 0) begin
		I(`IntrinsicGate, `IntrinsicSource)	<+ white_noise(`MFACTOR_USE*2.0 * `q * abs(igcs + igs), "igs");
		I(`IntrinsicGate, `IntrinsicDrain)	<+ white_noise(`MFACTOR_USE*2.0 * `q * abs(igcd + igd), "igd");
	end

	if(IGBMOD != 0) I(`IntrinsicGate, `IntrinsicBody) <+ white_noise(`MFACTOR_USE*2.0 * `q * abs(igb), "igb");

	//*********************************
	//C-V Model
	//*********************************
vgfbCV 		= vgfb;
gamg2 		= (2.0 * `q * epssi*NGATE_i)/(Cox*Cox*Vt);
invgamg2 	= (NGATE_i>0) ? (1.0/gamg2) : 0.0;

if (CVMOD==1) begin
	VFBCV_i	= VFBCV_i + DELVT0;
	vg 	= Vg * inv_Vt;
	vs 	= Vs * inv_Vt;
	vfb 	= VFBCV_i * inv_Vt;
	vgfbCV 	= vg - vfb;

	phib = ln(NDEPCV_i / ni);
	//Normalized body factor
	gam = sqrt(2.0 * `q * epssi*NDEPCV_i * inv_Vt)/Cox;
	inv_gam = 1.0/gam;
	gamg2 = (2.0 * `q * epssi*NGATE_i)/(Cox*Cox*Vt);
	invgamg2 = (NGATE_i>0) ? (1.0/gamg2) : 0.0;
	DPD = (NGATE_i>0) ? (NDEPCV_i/NGATE_i) : 0.0;

	// psip: pinch-off voltage
	`PO_psip(vgfbCV,gam,DPD,phib,psip)
	`BSIM_q(psip,phib,vs,gam,qs) // normalized inversion charge at source end of channel

	`Smooth(psip, 1.0, 2.0, psipclamp)
	sqrtpsip = sqrt(psipclamp);
	psiavg 	 = psip - 2.0*qs; // source side surf pot.
	`Smooth(psiavg, 1.0, 2.0, T0)
	nq 		 = 1.0 + gam / (sqrtpsip + sqrt(T0));

	// *** Drain Saturation Voltage ***
	T0 = Vt * (vgfbCV - psip - 2.0*qs*(nq-1.0));
	`Smooth(T0, 0, 0.1, qbs)
	qis = 2.0 * nq * Vt * qs; //Source side qi and qb for Vdsat- normalized to Cox

	Eeffs = EeffFactor * (qbs + eta_mu * qis); // in the unit of MV/cm

	// Ref: BSIM4 Model mobility model
	T3		=(UA_a + UC_a * Vbsx) * pow(Eeffs, EU_i);
	T4		= 1.0 + T3;	
	`Smooth(T4, 1.0, 0.0015, Dmobs) //Limiting Dmobs to 1.0	


	LambdaC_by2 = (U0_a / Dmobs) * Vt / (VSATCV_t * Lact);
	qdsat 		= LambdaC_by2 * (qs*qs + qs) / (1.0 + LambdaC_by2 *(1.0 + qs));
	vdsatcv 	= psip -2.0*phib - (2.0*qdsat + ln( (qdsat*2.0*nq*inv_gam)*((qdsat*2.0*nq*inv_gam) + (gam/(nq-1.0)) ) ));
	VdsatCV 	= vdsatcv * Vt;

	// normalized charge qdeff at drain end of channel
	`Smooth(VdsatCV - Vs, 0.0, 1e-3, VdssatCV)
	T7 		= pow(Vds/VdssatCV , 1.0/DELTA_t);
	T8 		= pow(1.0+T7, -DELTA_t);
	Vdseff 	=  Vds*T8;
	vdeff 	= (Vdseff + Vs) * inv_Vt;
	`BSIM_q(psip,phib,vdeff,gam,qdeff)

	// Reevaluation of nq to include qdeff --needed for gummel symmetry
	psiavg = psip - qs - qdeff -1.0;
	`Smooth(psiavg, 1.0, 2.0, T0)
	T2 = sqrt(T0);
	T3 = 1.0 + DPD + gam/(sqrtpsip+T2);
	T4 = 0.5 + DPD*T2*inv_gam;
	T5 = sqrt( T4*T4 + T3*(qs+qdeff)*invgamg2);
	nq = T3/ (T4+T5);

	//*********************************************************
	//CV Expressions including Velocity Saturation and CLM
	//*********************************************************
	// --- Velocity Saturation for CV ---
	T0 = Vt * (vgfbCV - psip - 2.0*qs*(nq-1.0));
	`Smooth(T0, 0, 0.1, qbs)
	T1 = Vt * (vgfbCV - psip - 2.0*qdeff*(nq-1.0));
	`Smooth(T1, 0, 0.1, qbd)
	qb = 0.5*(qbs+qbd);
	qia = nq * Vt * (qs + qdeff);

	Eeffm 	= EeffFactor * (qb + eta_mu * qia); // in the unit of MV/cm
	T3	= (UA_a + UC_a * Vbsx) * pow(Eeffm, EU_i);
	T4		= 1.0 + T3;	
	`Smooth(T4, 1.0, 0.0015, Dmob) //Limiting Dmob to 1.0	

	LambdaC 	= 2.0 * (U0_a / Dmob) * Vt / (VSATCV_t * Lact);
	dps 		= qs - qdeff;
	T1		= 2.0 * (LambdaC * dps) * (LambdaC * dps);
	zsat		= sqrt(1.0 + T1);
	Dvsat 		= 0.5 * (1.0 + zsat);
	// --- CLM for CV ---
	Esat 	= 2.0 * VSATCV_t / (U0_a / Dmob);
	EsatL 	= Esat * Lact;
	Vasat = VdssatCV + EsatL;
	diffVds 	= Vds - Vdseff;
	

end
	if(PCLMCV_i != 0) begin
		MdL = 1.0 + PCLMCV_i * lln(1.0 + diffVds / PCLMCV_i / Vasat);
	end else
		MdL = 1.0;

	MdL_2		= MdL*MdL;
	inv_MdL 	= 1.0/MdL;
	inv_MdL_2	= 1.0/MdL_2;
	MdL_less_1 	= MdL - 1.0;
	vgpqm = vgfbCV - psip;
	DQSD = (qs-qdeff);
	DQSD2 = (qs-qdeff)*(qs-qdeff);
	sis = vgpqm + 2.0*qs;
	sid = vgpqm + 2.0*qdeff;
	`Smooth(sis, 0.0, 0.5, T1)
	`Smooth(sid, 0.0, 0.5, T2)
	Temps = sqrt(0.25 + T1*invgamg2);
	Tempd = sqrt(0.25 + T2*invgamg2);
	T1 = sis / (1.0 + 2.0*Temps);
	T2 = sid / (1.0 + 2.0*Tempd);
	T3 = Temps + Tempd;
	T4 = `Oneby3*(DQSD2/(T3*T3*T3));
	T5 = (Dvsat * inv_MdL) / (1.0 + qs + qdeff);
	T6 = 0.8*(T3*T3 + Temps*Tempd) * T5;
	T7 = T6 + (2.0*invgamg2);
	T8 = `Oneby3 * DQSD2 * T5;
	dqgeff = sid * (2.0*Tempd - 1.0)/(2.0*Tempd + 1.0);
	qbeff = vgpqm - 2.0 * (nq-1.0)*qdeff + dqgeff;
	Qb = inv_MdL * (T1 + T2 + (T4*T7 - nq*( qs + qdeff + T8))) + MdL_less_1 * qbeff ;

	T9 = qs + qdeff;
	T10 = DQSD2*T5*T5;
	Qi = nq * inv_MdL * (T9 + `Oneby3 * DQSD2*T5) + 2.0*nq*MdL_less_1*qdeff;
	Qd1 = nq * inv_MdL_2 * ( 0.5*T9 - (DQSD/6.0)*(1.0 - DQSD*T5 - 0.2*T10));
	Qd2 = nq * (MdL - inv_MdL) * qdeff;
	Qd = Qd1 + Qd2;
	Qs = Qi - Qd;
	//*********************************************************

	//Quantum Mechanical Effect

	`Smooth(Vt*Qb, 0, 0.1, qbaCV)
	qiaCV = Vt*( Qs + Qd);

	T0 = (qiaCV + ETAQM * qbaCV) / QM0;
	T1 = 1.0 + pow(T0, 0.7*BDOS);
	XDCinv = ADOS * 1.9e-9 / T1;

	Coxeffinv = 3.9 * `EPS0 / (BSIM6TOXP * 3.9 / EPSROX + XDCinv / epsratio);

	QBi = -NF*Wact*Lact*(`EPS0 * EPSROX / BSIM6TOXP)*Vt*Qb;
	WLCOXVtinv = NF*Wact*Lact*Coxeffinv*Vt;

	QSi = -WLCOXVtinv*Qs;
	QDi = -WLCOXVtinv*Qd;
	QGi = -(QBi + QSi + QDi);


	//Outer fringing capacitance
	if (!$param_given(CF))
		CF_i = 2.0 * EPSROX * `EPS0 / `M_PI * ln(CFRCOEFF*(1.0 + 0.4e-6 / TOXE));
	Cgsof = CGSO + CF_i ;
	Cgdof = CGDO + CF_i ;

	//Overlap Capacitance
	if (COVMOD == 0) begin
		Qovs	= -Wact*NF*Cgsof*Vgs_ov_noswap;
		Qovd	= -Wact*NF*Cgdof*Vgd_ov_noswap;
	end else begin
		T0 		= sqrt((Vgs_ov_noswap -Vfbsdr + `DELTA_1)*(Vgs_ov_noswap -Vfbsdr + `DELTA_1) +4.0 * `DELTA_1);
		Vgsov	= 0.5*(Vgs_ov_noswap -Vfbsdr + `DELTA_1 - T0);
		T1		= sqrt(1.0 - 4.0*Vgsov/CKAPPAS_i);
		Qovs	= -Wact*NF*( Cgsof*Vgs_ov_noswap + CGSL_i*( Vgs_ov_noswap -Vfbsdr - Vgsov - 0.5*CKAPPAS_i*(-1.0 + T1)));

		T0		= sqrt((Vgd_ov_noswap -Vfbsdr + `DELTA_1)*(Vgd_ov_noswap -Vfbsdr + `DELTA_1) +4.0 * `DELTA_1);
		Vgdov	= 0.5*(Vgd_ov_noswap -Vfbsdr + `DELTA_1 - T0);
		T2		= sqrt(1.0 - 4.0*Vgdov/CKAPPAD_i);
		Qovd	= -Wact*NF*( Cgdof*Vgd_ov_noswap + CGDL_i*( Vgd_ov_noswap -Vfbsdr - Vgdov - 0.5*CKAPPAD_i*(-1.0 + T2)));
	end

	Qovb	= - devsign * NF*Lact*CGBO* V(`GateEdgeNode, `IntrinsicBody);
	Qovg	= - (Qovs + Qovd + Qovb);
	//****************************************************
	// Edge FET Model Implementation
	//****************************************************
	if (EDGEFET == 1) begin
		NFACTOREDGE_t = NFACTOREDGE * hypsmooth((1.0 + TNFACTOREDGE * (TRatio - 1.0)),1e-3);
		ETA0EDGE_t = ETA0EDGE * (1.0 + TETA0EDGE * (TRatio - 1.0));

		cdsc = CITEDGE + NFACTOREDGE_t + CDSCDEDGE * Vdsx - CDSCBEDGE * Vbsx;
		T1 = 1.0 + cdsc/Cox;
			
		`Smooth(T1, 1.0, 0.05, n) 
		
		nVt = n * Vt;
		inv_nVt = 1.0/nVt;
		vg 	= Vg * inv_nVt;
		vs 	= Vs * inv_nVt;
		vfb = VFB_i * inv_nVt;
		
		dvth_dibl 	= -(ETA0EDGE_t + ETABEDGE*Vbsx) * Vdsx;// DIBL for Edge Device
		dvth_temp = (KT1EDGE + KT1LEDGE / Leff + KT2EDGE*Vbsx) * (pow(TRatio,KT1EXPEDGE) - 1.0);
		litl_edge = litl*(1.0 + DVT2EDGE*Vbsx) ;
		
		theta_sce_edge = 0.5*DVT0EDGE/(cosh(DVT1EDGE*Leff/litl_edge) - 1.0) ;
		dvth_sce = theta_sce_edge * (Vbi - Phist)  ;		

		Vth_shift	= dvth_dibl  - dvth_temp + dvth_sce + DVTEDGE;
		vgfb = vg - vfb - Vth_shift * inv_nVt;

		//Normalized body factor
		DGAMMAEDGE_i = DGAMMAEDGE*(1.0 + DGAMMAEDGEL*pow(Leff,-DGAMMAEDGELEXP)) ;
		gam = sqrt(2.0 * `q * epssi*NDEP_i * inv_nVt)/Cox;
		gam = gam*(1.0 + DGAMMAEDGE_i);
		inv_gam = 1.0/gam;
		phib_n 	= phib/n;
		
		`PO_psip(vgfb,gam,0,phib_n,psip)

		`BSIM_q(psip,phib_n,vs,gam,qs) 

		vdsatedge = 2.0*nVt*qs +  2.0*nVt;      // Approximate Pinch Off voltage

        Vdsatedge =  vdsatedge;

        Vdsatedge = Vdsatedge + Vs ; 

	    `Smooth(Vdsatedge - Vs, 0.0, 1.0e-3, Vdssate) //Vdssat clamped to avoid negative values during transient simulation

	    T7 	= pow(Vds/Vdssate , 1.0/DELTA_t);
	    T8 	= pow(1.0+T7, -DELTA_t);
	    Vdseff 	=  Vds*T8;
	    vdeff 	= (Vdseff + Vs) * inv_nVt;

		`BSIM_q(psip,phib_n,vdeff,gam,qdeff)
	
	///////////Nq calculation for Edge FET//////////
		`Smooth(psip, 1.0, 2.0, psipclamp)
		sqrtpsip = sqrt(psipclamp);
	
	    psiavg = psip - qs - qdeff -1.0;
	    `Smooth(psiavg, 1.0, 2.0, T0)
	    T2 = sqrt(T0);
	    nq = 1.0 + gam/(sqrtpsip+T2);
			
		ids_edge = 2.0 * NF * nq * ueff * WEDGE/Leff * Cox * nVt * nVt *((qs - qdeff)*(1.0 + qs + qdeff)) *Moc;
		ids = ids_edge + ids ;
   	end
	//Edge FET Parasitic Device Drain Current Model Ends ///

	//Charge expressions including fringing and overlap cap
	QB = devsign *(QBi + Qovb + Qbs + Qbd);

	if (sigvds > 0) begin
		QSI = devsign * QSi;
		QDI = devsign * QDi;
		QS = devsign *(QSi + Qovs - Qbs);
		QD = devsign *(QDi + Qovd - Qbd);
	end else begin
		QSI = devsign * QDi;
		QDI = devsign * QSi;
		QS = devsign *(QDi + Qovs - Qbs);
		QD = devsign *(QSi + Qovd - Qbd);
	end

	QG = devsign *(QGi + Qovg);

	//Output
	//Intrinsic Charges
	QBI = devsign * QBi;
	QGI = devsign * QGi;
	
	//QSI and QDI are defined above

	//Intrinsic Capacitances
	CGSI = - ddx(QGI,V(`IntrinsicSource));
	CGDI = - ddx(QGI,V(`IntrinsicDrain));
	CGBI = - ddx(QGI,V(`IntrinsicBody));
	CGGI = ddx(QGI,V(`IntrinsicGate));

	CSSI = ddx(QSI,V(`IntrinsicSource));
	CSDI = - ddx(QSI,V(`IntrinsicDrain));
	CSBI = - ddx(QSI,V(`IntrinsicBody));
	CSGI = - ddx(QSI,V(`IntrinsicGate));

	CDSI = - ddx(QDI,V(`IntrinsicSource));
	CDDI = ddx(QDI,V(`IntrinsicDrain));
	CDBI = - ddx(QDI,V(`IntrinsicBody));
	CDGI = - ddx(QDI,V(`IntrinsicGate));

	CBSI = - ddx(QBI,V(`IntrinsicSource));
	CBDI = - ddx(QBI,V(`IntrinsicDrain));
	CBBI =  ddx(QBI,V(`IntrinsicBody));
	CBGI = - ddx(QBI,V(`IntrinsicGate));

	//Total Capacitances
	CGS = -ddx(QG,V(`IntrinsicSource));
	CGD = -ddx(QG,V(`IntrinsicDrain));
	CGB = -ddx(QG,V(`IntrinsicBody));
        CGG = CGGI + ddx(devsign*Qovg,V(`GateEdgeNode));
	CSS = ddx(QS,V(`IntrinsicSource));
	CSD = -ddx(QS,V(`IntrinsicDrain));
	CSB = CSBI - ddx((QS-QSI),V(sbulk));
	CSG = CSGI - ddx((QS-QSI),V(`GateEdgeNode));

	CDS = -ddx(QD,V(`IntrinsicSource));
	CDD = ddx(QD,V(`IntrinsicDrain));
	CDB = CDBI - ddx((QD-QDI),V(dbulk));
	CDG = CDGI - ddx((QD-QDI),V(`GateEdgeNode));
	CBS = -ddx(QB,V(`IntrinsicSource));
	CBD = -ddx(QB,V(`IntrinsicDrain));
	CBB = CBBI + ddx(QB,V(sbulk)) + ddx(QB,V(dbulk)) + ddx((devsign * Qovb), V( `IntrinsicBody));
	CBG = -ddx(QB,V(`IntrinsicGate)) - ddx((devsign * Qovb), V(`GateEdgeNode));

	//Total extrinsic capacitance
	CGSEXT 	= - devsign * ddx(Qovg,V(`IntrinsicSource));//Gate-Source Overlap + outer fringing
	CGDEXT 	= - devsign * ddx(Qovg,V(`IntrinsicDrain));//Gate-Drain Overlap + outer fringing
	CGBOV	= - devsign * ddx(Qovg,V(`IntrinsicBody));//Gate-Body Overlap

	//Total Source and Drain junction capacitances
	CAPBS 	= - devsign *ddx(Qbs,V(`IntrinsicSource));
	CAPBD 	= - devsign *ddx(Qbd,V(`IntrinsicDrain));

	//W & L
	WEFF	= Weff;//Effective width for IV
	LEFF	= Leff;//Effective length for IV
	WEFFCV	= Wact;//Effective width for CV
	LEFFCV	= Lact;//Effective length for CV


	//Currents and derivatives
	if (sigvds>0) begin
		IDS	= devsign * ids;//Intrinsic drain to source current
		IDEFF	=  IDS - (IGD + IGCD) + ISUB + IGIDL;//Total drain current
		ISEFF	= -IDS - (IGS + IGCS) + IGISL;//Total source current
	end else begin
		IDS	= - devsign * ids;//Intrinsic drain to source current
		IDEFF	=  IDS - (IGD + IGCD) + IGIDL;//Total drain current
		ISEFF	= -IDS - (IGS + IGCS) + ISUB + IGISL;//Total source current
	end

	IGEFF 	= IGB + IGS + IGCS + IGD + IGCD;//Total gate tunneling current
	IBS 	= - devsign * Ibs;//Source junction current
	IBD 	= - devsign * Ibd;//Source junction current

	VDS	= V(`IntrinsicDrain, `IntrinsicSource);//Drain-Source Voltage
	VGS 	= V(`IntrinsicGate,`IntrinsicSource);
	VBS	= -V(`IntrinsicSource, `IntrinsicBody);//Source-body Voltage
	VDSAT	= Vdssat;//Drain-Source saturation Voltage
	GM		= ddx(IDS,V(`IntrinsicGate));//Transconductance
	GMBS	= ddx(IDS,V(`IntrinsicBody));//Body transconductance
	GDS		= ddx(IDS,V(`IntrinsicDrain));//Output conductance

	// Loading variables
	I(`IntrinsicGate, `IntrinsicBody)	<+ ddt(`MFACTOR_USE*QGI);
	I(`IntrinsicSource, `IntrinsicBody)	<+ ddt(`MFACTOR_USE*QSI);
	I(`IntrinsicDrain, `IntrinsicBody)	<+ ddt(`MFACTOR_USE*QDI);

	I(`GateEdgeNode, `IntrinsicSource)	<+ ddt(`MFACTOR_USE*(-devsign * Qovs));
	I(`GateEdgeNode, `IntrinsicDrain) 	<+ ddt(`MFACTOR_USE*(-devsign * Qovd));
	I(`GateEdgeNode, `IntrinsicBody)	<+ ddt(`MFACTOR_USE*(-devsign * Qovb));

	//Drain to Source Current
	I(`IntrinsicDrain, `IntrinsicSource)	<+ `MFACTOR_USE*devsign * sigvds * ids;

	if(IGBMOD != 0)
		I(`IntrinsicGate, `IntrinsicBody)	<+ `MFACTOR_USE*IGB;
	if(IGCMOD != 0) begin
		I(`IntrinsicGate, `IntrinsicSource)	<+ `MFACTOR_USE*(IGS + IGCS);
		I(`IntrinsicGate, `IntrinsicDrain)	<+ `MFACTOR_USE*(IGD + IGCD);
	end

	if (sigvds>0) begin
		I(`IntrinsicDrain, `IntrinsicBody)	<+ `MFACTOR_USE*(ISUB + IGIDL);
		I(`IntrinsicSource, `IntrinsicBody)	<+ `MFACTOR_USE*IGISL;
	end else begin
		I(`IntrinsicDrain, `IntrinsicBody)	<+ `MFACTOR_USE*IGIDL;
		I(`IntrinsicSource, `IntrinsicBody)	<+ `MFACTOR_USE*(ISUB + IGISL);
	end

	// External S/D Resistance

`ifdef __RDSMOD__
	if(RDSMOD != 2) begin
		gdpr = 1.0 / Rdrain; /* Note: gdpr considers all fingers */
		gspr = 1.0 / Rsource; /* Note: gspr considers all fingers */
		I(d, di) <+ `MFACTOR_USE*V(d, di) * gdpr;
		I(s, si) <+ `MFACTOR_USE*V(s, si) * gspr;
		I(d,di) <+ white_noise(`MFACTOR_USE*Nt * gdpr, "rd");
		I(s,si) <+ white_noise(`MFACTOR_USE*Nt * gspr, "rs");
	end else begin
		V(d, di) <+ 0;
		V(s, si) <+ 0;
	end
`endif

`ifdef __RGATEMOD__
	if (RGATEMOD == 0) begin
		V(g, gm) <+ 0;
	end else begin : rgate
		real Ggate, Gnoise;
		if (RGATEMOD == 2) begin
			Ggate = Gcrg;
			Gnoise = Gcrg * Gcrg / Grgeltd;
		end else begin
			Ggate = Grgeltd;
			Gnoise = Grgeltd;
		end
		I(g, gm) <+ `MFACTOR_USE*V(g, gm) * Ggate;
		I(g, gm) <+ white_noise( `MFACTOR_USE*Nt * Gnoise, "rg");
	end

	if (RGATEMOD == 3) begin
		I(gm,gi) <+ `MFACTOR_USE*V(gm,gi) * Gcrg;
	end else begin
		V(gm,gi) <+ 0;
	end
`endif

`ifdef __SHMOD__
	if (SHMOD !=0 && RTH0 > 0) begin
		if (RDSMOD != 2) begin
			Pwr(t) <+ `MFACTOR_USE*(-(devsign * sigvds * ids * V(`IntrinsicDrain, `IntrinsicSource) + V(d,`IntrinsicDrain) * V(d,`IntrinsicDrain) / Rdrain + V(s,`IntrinsicSource) * V(s,`IntrinsicSource) / Rsource) + delTemp1 * gth);
                        Pwr(t) <+ ddt(`MFACTOR_USE*delTemp1 * cth);
		end else begin
			Pwr(t) <+ `MFACTOR_USE*(-(devsign * sigvds * ids * V(`IntrinsicDrain, `IntrinsicSource)) + delTemp1 * gth);
                        Pwr(t) <+ ddt(`MFACTOR_USE*delTemp1 * cth);
		end
	end else begin
                Temp(t) <+ 0;
        end        
`endif

`ifdef __RBODYMOD__
	if(RBODYMOD != 0) begin
		I(bi,sbulk) <+ `MFACTOR_USE*V(bi,sbulk) * Grbps;
		I(b,sbulk)  <+ `MFACTOR_USE*V(b,sbulk)  * Grbsb;
		I(b,bi)     <+ `MFACTOR_USE*V(b,bi)     * Grbpb;
		I(b,dbulk)  <+ `MFACTOR_USE*V(b,dbulk)  * Grbdb;
		I(bi,dbulk) <+ `MFACTOR_USE*V(bi,dbulk) * Grbpd;
		I(sbulk,bi) <+ white_noise(`MFACTOR_USE*Nt * Grbps, "rbps");
		I(sbulk,b)  <+ white_noise(`MFACTOR_USE*Nt * Grbsb, "rbsb");
		I(b,bi)     <+ white_noise(`MFACTOR_USE*Nt * Grbpb, "rbpb");
		I(dbulk,bi) <+ white_noise(`MFACTOR_USE*Nt * Grbpd, "rbpd");
		I(dbulk,b)  <+ white_noise(`MFACTOR_USE*Nt * Grbdb, "rbdb");
	end else begin
		V(b,sbulk)  <+ 0;
		V(b,bi)     <+ 0;
		V(b,dbulk)  <+ 0;
	end
`endif

	// Diode Current and Capacitance
`ifdef __RBODYMOD__
	if(RBODYMOD != 0) begin
		I(sbulk, `IntrinsicSource) <+ `MFACTOR_USE*devsign * Ibs;
		I(dbulk, `IntrinsicDrain)  <+ `MFACTOR_USE*devsign * Ibd;
		I(sbulk, `IntrinsicSource) <+ `MFACTOR_USE*devsign * ddt(Qbs);
		I(dbulk, `IntrinsicDrain)  <+ `MFACTOR_USE*devsign * ddt(Qbd);
	end else begin
`endif
		I(`IntrinsicBody, `IntrinsicSource) <+ `MFACTOR_USE*devsign * Ibs;
		I(`IntrinsicBody, `IntrinsicDrain)  <+ `MFACTOR_USE*devsign * Ibd;
		I(`IntrinsicBody, `IntrinsicSource) <+ `MFACTOR_USE*devsign * ddt(Qbs);
		I(`IntrinsicBody, `IntrinsicDrain)  <+ `MFACTOR_USE*devsign * ddt(Qbd);
`ifdef __RBODYMOD__
	end
`endif

end
endmodule
