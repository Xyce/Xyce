
// *********************************************************************************************
// ****                                                                                     ****
// ****                                    L-UTSOI Model                                    ****
// ****                                   Version 102.4.0                                   ****
// ****                                                                                     ****
// ****                      Ultra Thin Fully Depleted SOI MOSFET Model                     ****
// ****                                                                                     ****
// ****                                   Verilog-A code                                    ****
// ****                Authors: T. Poiroux, O. Rozeau, S. Martinie, M.A. Jaud               ****
// ****                                                                                     ****
// *********************************************************************************************
//
// *********************************************************************************************
// ****                                                                                     ****
// ****                                License information                                  ****
// ****                                                                                     ****
// ****   Copyright 2020 CEA-Leti                                                           ****
// ****                                                                                     ****
// ****   Licensed under Educational Community License, Version 2.0 (the "License"); you    ****
// ****   may not use this file except in compliance with the License. You may obtain a     ****
// ****   copy of the license at http://opensource.org/licenses/ECL-2.0                     **** 
// ****                                                                                     ****
// ****   Unless required by applicable law or agreed to in writing, software distributed   ****
// ****   under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR       ****
// ****   CONDITIONS OF ANY KIND, either express or implied. See the License for the        ****
// ****   specific language governing permissions and limitations under the License.        ****
// ****                                                                                     ****
// *********************************************************************************************
//
// *********************************************************************************************
// ****                                                                                     ****
// ****   Notice:                                                                           ****
// ****   The L-UTSOI standard has been supported by the members of Silicon Integration     ****
// ****   Initiative's Compact Model Coalition. A link to the most recent version of this   ****
// ****   standard can be found at: http://www.si2.org/cmc                                  ****
// ****   CMC Release Date:  January 23, 2020                                               ****
// ****   Public Release Date:  July 23, 2021                                               ****
// ****                                                                                     ****
// ****                                                                                     ****
// ****   This model is suitable for undoped ultrathin film SOI MOSFET                      ****
// ****   The core of the model (drain current and intrinsic charges) is valid also         ****
// ****   for independent double gate MOSFET, since it accounts for back interface          ****
// ****   conduction                                                                        ****
// ****                                                                                     ****
// ****   Includes:                                                                         ****
// ****       - specific surface potential calculations for FDSOI, valid also for IDG       ****
// ****       - specific drain current expression for FDSOI, valid also for IDG             ****
// ****       - specific intrinsic charges model, valid also for IDG                        ****
// ****       - field-dependent mobility including remote coulomb scattering                ****
// ****       - quantum confinement effect                                                  ****
// ****       - velocity saturation                                                         ****
// ****       - channel length modulation                                                   ****
// ****       - series-resistance with gate voltage dependence                              ****
// ****       - short-channel effects                                                       ****
// ****       - overlap capacitances (SP-based)                                             ****
// ****       - gate leakage current                                                        ****
// ****       - gate-induced drain/source leakage (GIDL, GISL)                              ****
// ****       - self heating effect                                                         ****
// ****       - narrow-width effects                                                        ****
// ****       - stress model                                                                ****
// ****       - noise (1/f, thermal, induced gate and shot noise)                           ****
// ****       - source/drain junctions asymmetry                                            ****
// ****       - global and local scale levels                                               ****
// ****                                                                                     ****
// *********************************************************************************************


`include "discipline.h"

// Flag for .OP calculations. Commenting this line cancels OP-related variables definition and OP calculations
`define OP_CALC

// *************************************************************************************************************************
// Macros and constants used in L-UTSOI model
// *************************************************************************************************************************

// Channel type
`define PMOS                   -1
`define NMOS                   +1

// Some functions
`define MIN_FUNC(x,y,a)         0.5*((x)+(y)-sqrt(((x)-(y))*((x)-(y))+(a)))
`define MAX_FUNC(x,y,a)         0.5*((x)+(y)+sqrt(((x)-(y))*((x)-(y))+(a)))

// Constants
`define PI                      3.1415926535898
`define INV3                    0.3333333333333
`define INV6                    0.1666666666667
`define INV60                   0.0166666666667
`define INV42                   0.0238095238095
`define INV30                   0.0333333333333
`define INV28                   0.0357142857143
`define INV14                   0.0714285714286
`define INV180                  0.0055555555556
`define INV300                  0.0033333333333
`define SQRT2                   1.4142135623731
`define LN2                     0.6931471805599
`define LN10                    2.3025850929941
`define X1OV                    1.25

// Physical constants
`define EPSOX                   3.45313E-11
`define QMN                     1.27520989
`define QMP                     1.54120870
`define KBOL                    1.3806488E-23
`define QELE                    1.602176565E-19
`define HBAR                    1.054571726E-34
`define MELE                    9.10938291E-31
`define KBOL_QELE               8.617332384961E-05

// Channel material constants
`define EPSSI                   1.04479E-10        // eps_rel = 11.8 for Si
`define EPSGE                   1.43438E-10        // eps_rel = 16.2 for Ge
`define EG0SI                   1.17               // bandgap for Si at 0K
`define EG0GE                   0.744              // bandgap for Ge at 0K
`define ALPHASI                 4.730e-4           // 1st bandgap temperature dependence parameter for Si
`define ALPHAGE                 4.774e-4           // 1st bandgap temperature dependence parameter for Ge
`define BETASI                  636                // 2nd bandgap temperature dependence parameter for Si
`define BETAGE                  235                // 2nd bandgap temperature dependence parameter for Ge
`define CG                     -0.4                // non linearity coefficient for SiGe bandgap
`define NIFACT300               4.05E25            // sqrt of NcNv for Si at 300K

// Constants needed for exponential approximation
`define EXP_THRESHOLD           80.0
`define MIN_EXP                 1.80485e-35
`define MAX_EXP                 5.54062e34

// Constants defined for drain current calculation
`define QI_LOW                  1.0E-6
`define QI_TH                   0.5
`define XSAT_MIN                6.0
`define XSAT_MAX                600.0
`define SAT_FACT                0.94
`define SMTH_SQ                 36.0
`define FIELD_SMTH              2.0

// dev3_exp       3rd order dev of exp()
`define dev3_exp(u)    (1.0 + (u) * (1.0 + 0.5 * (u) * (1.0 + (u) * `INV3)))

// lin_exp        Linearization of exponential function
`define lin_exp(x, res) \
    if (abs(x) < `EXP_THRESHOLD) begin \
        res = exp(x); \
    end else begin \
        if (x < -`EXP_THRESHOLD) begin \
            res =  `MIN_EXP / `dev3_exp(- x - `EXP_THRESHOLD); \
        end else begin \
            res =  `MAX_EXP * `dev3_exp(x - `EXP_THRESHOLD); \
        end \
    end
    
// linmin_exp     Linearization of exponential function below threshold
`define linmin_exp(x, res) \
    if (x > -`EXP_THRESHOLD) begin \
        res = exp(x); \
    end else begin \
        res = `MIN_EXP / `dev3_exp(-x - `EXP_THRESHOLD); \
    end
    
// linmax_exp     Linearization of exponential function above threshold
`define linmax_exp(x, res) \
    if (x < `EXP_THRESHOLD) begin \
        res = exp(x); \
    end else begin \
        res = `MAX_EXP * `dev3_exp(x - `EXP_THRESHOLD); \
    end

// ln_one_plus_exp function
`define ln_one_plus_exp(x, res) \
    if (x < `EXP_THRESHOLD) begin \
        res = ln(1.0 + exp(x)); \
    end else begin \
        res = (x); \
    end

//  Parameter definition macros: "des" description argument is intended to
//  be a short description, the "inf" information argument is intended to be
//  a detailed description (e.g. for display as part of on-line help).
//
//  MPR      model    parameter real
//  MPI      model    parameter integer
//  IPR      instance parameter real
//  IPI      instance parameter integer
//  OPP      operating point parameter, includes units and description for printing
//  OPM      operating point parameter, scales with $mfactor
//  OPD      operating point parameter, scales with 1/$mfactor
//
//  Instance parameters have the attribute *type="instance"* and note that
//  compilers treat these as both instance and model parameters, with a
//  specified instance value taking precedence over a specified model card value.
//
//  There are some issues with passing range directives with some compilers,
//  so for each parameter declaration there are multiple versions:
//  cc       closed lower bound, closed upper bound
//  co       closed lower bound, open   upper bound
//  cz       closed lower bound of zero (no upper bound)
//  oc       open   lower bound, closed upper bound
//  oo       open   lower bound, open   upper bound
//  oz       open   lower bound of zero (no upper bound)
//  nb       no bounds
//  sw       switch (integer only, values  0=false  and >0=true)
//  ty       switch (integer only, values -1=n-type and +1=p-type)
//
`define ALIAS(alias,paramName) aliasparam alias = paramName;
`define OPP(nam,uni,des)               (*units=uni,                             desc=des*)           real    nam;
`define OPM(nam,uni,des)               (*units=uni, multiplicity="multiply",    desc=des*)           real    nam;
`define OPD(nam,uni,des)               (*units=uni, multiplicity="divide",      desc=des*)           real    nam;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter real    nam=def from[lwr:upr];
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter real    nam=def from[lwr:upr);
`define MPRcz(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter real    nam=def from[  0:inf);
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter real    nam=def from(lwr:upr];
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter real    nam=def from(lwr:upr);
`define MPRoz(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter real    nam=def from(  0:inf);
`define MPRnb(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter real    nam=def;
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter integer nam=def from[lwr:upr];
`define MPIco(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter integer nam=def from[lwr:upr);
`define MPIcz(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter integer nam=def from[  0:inf);
`define MPIoc(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter integer nam=def from(lwr:upr];
`define MPIoo(nam,def,uni,lwr,upr,des) (*units=uni                            , desc=des*) parameter integer nam=def from(lwr:upr);
`define MPIoz(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter integer nam=def from(  0:inf);
`define MPInb(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter integer nam=def;
`define MPIsw(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter integer nam=def from[  0:inf);
`define MPIty(nam,def,uni,        des) (*units=uni                            , desc=des*) parameter integer nam=def from[ -1:  1] exclude 0;
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def from[lwr:upr];
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def from[lwr:upr);
`define IPRcz(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def from[  0:inf);
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def from(lwr:upr];
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def from(lwr:upr);
`define IPRoz(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def from(  0:inf);
`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter real    nam=def;
`define IPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from[lwr:upr];
`define IPIco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from[lwr:upr);
`define IPIcz(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from[  0:inf);
`define IPIoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from(lwr:upr];
`define IPIoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from(lwr:upr);
`define IPIoz(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from(  0:inf);
`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def;
`define IPIsw(nam,def,uni,        des) (*units=uni, type="instance",            desc=des*) parameter integer nam=def from[  0:inf);

// Mathematical function for surface potential calculation
`define sigma2(a, b, c, tau, eta, y) \
    nu          =  a + c; \
    mutau       =  nu * nu + tau * (0.5 * c * c - a * b); \
    y           =  eta + a * nu * tau / (mutau + nu / mutau * tau * tau * c * (c * c * `INV3 - a * b));

`define sigma3(a, c, tau, eta, y) \
    nu          =  a + c; \
    mutau       =  nu * nu + tau * (0.5 * c * c - a); \
    y           =  eta + a * nu * tau / (mutau + nu / mutau * tau * tau * c * (c * c * `INV3 - a));

// Initial guess on surface potentials and gate charges
`define init_q(xg1_i, xg2_i, delta_n, q1, q2) \
    q_temp1     =  1.0 / (k1 + 1.0); \
    q_temp2     =  1.0 / (k2 + 1.0); \
    q_x1sat     =  ln((k1 + k2 * q_temp2) * diff_min / A0) + delta_n + 3.0; \
    q_x2sat     =  ln((k2 + k1 * q_temp1) * diff_min / A0) + delta_n + 3.0; \
    `ln_one_plus_exp((q_x1sat - x1_WI0) * `INV3, q_temp3) \
    q_x1        =  q_x1sat - 3.0 * q_temp3; \
    `ln_one_plus_exp((q_x2sat - x2_WI0) * `INV3, q_temp3) \
    q_x2        =  q_x2sat - 3.0 * q_temp3; \
    q_x1_WI     =  (k1 * xg1_i + q_x2) * q_temp1; \
    q_x2_WI     =  (k2 * xg2_i + q_x1) * q_temp2; \
    `ln_one_plus_exp((q_x1sat - q_x1_WI) * `INV3, q_temp3) \
    q_x1        =  q_x1sat - 3.0 * q_temp3; \
    `ln_one_plus_exp((q_x2sat - q_x2_WI) * `INV3, q_temp3) \
    q_x2        =  q_x2sat - 3.0 * q_temp3; \
    q1          =  xg1_i - q_x1; \
    q2          =  xg2_i - q_x2; \
    q_rac_qsq   =  0.0; \
    q_invexpq   =  0.0;

// Global correction on front gate charge by 2nd order Taylor dvpt of resolution function
`define corr_global_q(xg1_i, xg2_i, delta_n, q1) \
    q_k1q1      =  k1 * q1; \
    `linmax_exp(xg1_i - q1 - delta_n, q_temp1) \
    q_Aexp      =  A0 * q_temp1; \
    q_qsq       =  q_k1q1 * q_k1q1 - q_Aexp; \
    q_d1_qsq    =  2.0 * k1 * q_k1q1 + q_Aexp; \
    q_d2_qsq    =  2.0 * k1 * k1 - q_Aexp; \
    if (q_qsq < -0.005) begin \
        q_rac_qsq   =  sqrt(abs(q_qsq)); \
        q_qcoth     =  q_rac_qsq / tan(0.5 * q_rac_qsq); \
        q_temp1     =  0.25 * q_d1_qsq / q_qsq; \
        q_d1_qcoth  =  (q_qsq + q_qcoth * (2.0 - q_qcoth)) * q_temp1; \
        q_d2_qcoth  =  (q_d1_qsq - 2.0 * q_d1_qcoth * (1.0 + q_qcoth)) * q_temp1 + q_d1_qcoth * q_d2_qsq / q_d1_qsq; \
        q_temp2     =  1.0 - 0.5 * q_qcoth; \
        q_d1_ln     =  q_d1_qsq / q_qsq * q_temp2; \
        q_d2_ln     =  (q_d2_qsq * q_temp2 - q_d1_qsq * (q_d1_ln + 0.5 * q_d1_qcoth)) / q_qsq; \
    end else begin \
        if (q_qsq > 0.005) begin \
            q_rac_qsq   =  sqrt(abs(q_qsq)); \
            q_invexpq   =  exp(-q_rac_qsq); \
            q_qcoth     =  q_rac_qsq * (1.0 + q_invexpq) / (1.0 - q_invexpq); \
            q_temp1     =  0.25 * q_d1_qsq / q_qsq; \
            q_d1_qcoth  =  (q_qsq + q_qcoth * (2.0 - q_qcoth)) * q_temp1; \
            q_d2_qcoth  =  (q_d1_qsq - 2.0 * q_d1_qcoth * (1.0 + q_qcoth)) * q_temp1 + q_d1_qcoth * q_d2_qsq / q_d1_qsq; \
            q_temp2     =  1.0 - 0.5 * q_qcoth; \
            q_d1_ln     =  q_d1_qsq / q_qsq * q_temp2; \
            q_d2_ln     =  (q_d2_qsq * q_temp2 - q_d1_qsq * (q_d1_ln + 0.5 * q_d1_qcoth)) / q_qsq; \
        end else begin \
            q_temp3     = `INV6 * (1.0 - q_qsq * `INV60 * (1.0 - q_qsq * `INV42 * (1.0 - q_qsq * 0.025))); \
            q_qcoth     =  2.0 + q_qsq * q_temp3; \
            q_temp1     = `INV6 * (1.0 - q_qsq * `INV30 * (1.0 - q_qsq * `INV28 * (1.0 - q_qsq * `INV30))); \
            q_d1_qcoth  =  q_d1_qsq * q_temp1; \
            q_temp2     = `INV180 * (1.0 - q_qsq * `INV14 * (1.0 - 0.05 * q_qsq * (1.0 - 0.0420875420875421 * q_qsq))); \
            q_d2_qcoth  =  q_d2_qsq * q_temp1 - q_d1_qsq * q_d1_qsq * q_temp2; \
            q_d1_ln     = -0.5 * q_d1_qsq * q_temp3; \
            q_d2_ln     = -0.5 * q_d2_qsq * q_temp3 + 0.25 * `INV180 * q_d1_qsq * q_d1_qsq * (1.0 - q_qsq * `INV42 * (2.0 - 0.075 * q_qsq)); \
        end \
    end \
    if (q_qsq > 0.005) begin \
        q_temp2     =  4.0 * q_qsq / (1.0 - q_invexpq * (2.0 - q_invexpq)); \
        q_sh_term   =  q_temp2 * q_invexpq; \
        q_ln_term   =  ln(q_temp2) - q_rac_qsq; \
    end else begin \
        if (q_qsq < -0.005) begin \
            q_temp2     =  sin(0.5 * q_rac_qsq); \
            q_sh_term   = -q_qsq / (q_temp2 * q_temp2); \
            q_ln_term   =  ln(q_sh_term); \
        end else begin \
            q_sh_term   =  4.0 - q_qsq * `INV3 * (1.0 - 0.05 * q_qsq * (1.0 - 0.0396825396825397 * q_qsq)); \
            q_ln_term   =  ln(q_sh_term); \
        end \
    end \
    if (1.01 * q_k1q1 + q_qcoth > 0.0) begin \
        q_expnum    =  q_k1q1 + q_qcoth; \
        q_d1_expnum =  k1 + q_d1_qcoth; \
        q_d2_expnum =  q_d2_qcoth; \
    end else begin \
        q_temp2     =  1.0 / (q_k1q1 - q_qcoth); \
        q_temp3     =  q_d1_qcoth - k1; \
        q_expnum    =  (q_Aexp - q_sh_term) * q_temp2; \
        q_d1_expnum =  (q_temp3 * q_expnum - q_Aexp - q_d1_ln * q_sh_term) * q_temp2; \
        q_d2_expnum =  (q_d2_qcoth * q_expnum + 2.0 * q_temp3 * q_d1_expnum + q_Aexp - (q_d2_ln + q_d1_ln * q_d1_ln) * q_sh_term) * q_temp2; \
    end \
    if (q_expnum > 0.0) begin \
        q_lnexpnum  =  ln(q_expnum); \
        q_temp1     =  1.0 / q_expnum; \
        q_d1_lnexpnum =  q_d1_expnum * q_temp1; \
        q_d2_lnexpnum =  q_d2_expnum * q_temp1 - q_d1_lnexpnum * q_d1_lnexpnum; \
    end else begin \
        q_lnexpnum  =  q_k1q1 + `LN2 + ln(-q_k1q1); \
        q_temp1     =  1.0 / q1; \
        q_d1_lnexpnum =  k1 + q_temp1; \
        q_d2_lnexpnum = -q_temp1 * q_temp1; \
    end \
    q_q2_int    =  xg2_i - xg1_i + q1 + 2.0 * q_lnexpnum - q_ln_term; \
    q_d1_q2     =  1.0 + 2.0 * q_d1_lnexpnum - q_d1_ln; \
    q_d2_q2     =  2.0 * q_d2_lnexpnum - q_d2_ln; \
    q_qi_int    =  q_k1q1 + k2 * q_q2_int; \
    q_d1_qi     =  k1 + k2 * q_d1_q2; \
    q_d2_qi     =  k2 * q_d2_q2; \
    q_zero      =  q_qi_int * q_expnum - q_Aexp; \
    if (q_zero == 0.0) begin \
        q_eps2      =  0.0; \
    end else begin \
        q_d1_zero   =  q_d1_qi * q_expnum + q_qi_int * q_d1_expnum + q_Aexp; \
        q_d2_zero   =  q_d2_qi * q_expnum + 2.0 * q_d1_qi * q_d1_expnum + q_qi_int * q_d2_expnum - q_Aexp; \
        q_eps1      = -q_zero / q_d1_zero; \
        q_eps2      = -q_zero / (q_d1_zero + 0.5 * q_eps1 * q_d2_zero); \
    end \
    q1          =  q1 + q_eps2;

// First strong inversion correction on front gate charge from
// 1st order Taylor dvpt of first Poisson integral at front interface side
`define corr_str_inv1(xg1_i, delta_n, q1, q2) \
    q_k1q1      =  k1 * q1; \
    q_k2q2      =  k2 * q2; \
    q_qi_int    =  q_k1q1 + q_k2q2; \
    q_a         =  1.0 + 0.065345483024 * q_qi_int; \
    q_b         =  39.478417604 + 8.5797362674 * q_qi_int + q_k1q1 * q_k2q2; \
    q_c         =  39.478417604 * (2.0 * q_qi_int + q_k1q1 * q_k2q2); \
    q_disc      =  sqrt(q_b * q_b - 4.0 * q_a * q_c); \
    q_qsq       =  (q_disc - q_b) / (2.0 * q_a); \
    q_delta     =  q_k1q1 * q_k1q1 - q_qsq; \
    if (q_delta > 0.0) begin \
        q_zero      =  q_delta * (ln(q_delta / A0) + delta_n - xg1_i + q1); \
        q_d1_zero   =  2.0 * k1 * q_k1q1 + q_delta; \
        q_dx1       =  xg1_i - q1 - q_x1sat; \
        if (((q_zero < 0.0) && (q_d1_zero > 0.0) && (q_dx1 + `LN10 + ln(k1) > 0.0)) || (q_dx1 > 1.0)) begin \
            q1          =  q1 - q_zero / q_d1_zero; \
        end \
    end

// Second strong inversion correction on front gate charge from
// 1st order Taylor dvpt of first Poisson integral at front interface side
`define corr_str_inv2(xg1_i, delta_n, q1, q2) \
    q_k1q1      =  k1 * q1; \
    q_k2q2      =  k2 * q2; \
    q_qi_int    =  q_k1q1 + q_k2q2; \
    q_a         =  1.0 + 0.065345483024 * q_qi_int; \
    q_b         =  39.478417604 + 8.5797362674 * q_qi_int + q_k1q1 * q_k2q2; \
    q_c         =  39.478417604 * (2.0 * q_qi_int + q_k1q1 * q_k2q2); \
    q_disc      =  sqrt(q_b * q_b - 4.0 * q_a * q_c); \
    q_qsq       =  (q_disc - q_b) / (2.0 * q_a); \
    if (q_qsq < -0.005) begin \
        q_rac_qsq   =  sqrt(abs(q_qsq)); \
        q_qcoth     =  q_rac_qsq / tan(0.5 * q_rac_qsq); \
        q_d1_qcoth  =  0.25 * (q_qsq + q_qcoth * (2.0 - q_qcoth)) / q_qsq; \
    end else begin \
        if (q_qsq > 0.005) begin \
            q_rac_qsq   =  sqrt(abs(q_qsq)); \
            q_invexpq   =  exp(-q_rac_qsq); \
            q_qcoth     =  q_rac_qsq * (1.0 + q_invexpq) / (1.0 - q_invexpq); \
            q_d1_qcoth  =  0.25 * (q_qsq + q_qcoth * (2.0 - q_qcoth)) / q_qsq; \
        end else begin \
            q_qcoth     =  2.0 + q_qsq * `INV6 * (1.0 - q_qsq * `INV60 * (1.0 - q_qsq * `INV42)); \
            q_d1_qcoth  = `INV6 * (1.0 - q_qsq * `INV30 * (1.0 - q_qsq * `INV28 * (1.0 - q_qsq * `INV30))); \
        end \
    end \
    q_qsq       =  q_qsq - (q_qi_int * q_qcoth + q_k1q1 * q_k2q2 + q_qsq) / (q_qi_int * q_d1_qcoth + 1.0); \
    q_delta     =  q_k1q1 * q_k1q1 - q_qsq; \
    if (q_delta > 0.0) begin \
        q_zero      =  q_delta * (ln(q_delta / A0) + delta_n - xg1_i + q1); \
        q_d1_zero   =  2.0 * k1 * q_k1q1 + q_delta; \
        q_dx1       =  xg1_i - q1 - q_x1sat; \
        if (((q_zero < 0.0) && (q_d1_zero > 0.0) && (q_dx1 + `LN10 + ln(k1) > 0.0)) || (q_dx1 > 1.0)) begin \
            q1          =  q1 - q_zero / q_d1_zero; \
        end \
    end

//  Front gate charge calculation for a quasi-Fermi level delta_n.phit
`define func_q(xg1_i, xg2_i, delta_n, q1, q2) \
    `init_q(xg1_i, xg2_i, delta_n, q1, q2) \
    `corr_global_q(xg1_i, xg2_i, delta_n, q1) \
    `corr_str_inv1(xg1_i, delta_n, q1, q2) \
    `corr_str_inv2(xg1_i, delta_n, q1, q2) \
    `corr_global_q(xg1_i, xg2_i, delta_n, q1) \
    `corr_global_q(xg1_i, xg2_i, delta_n, q1)

//  Inversion charge calculation for a quasi-Fermi level delta_n.phit
`define func_qi(xg1_i, xg2_i, delta_n, q1, q2, qi, k1q1, k2q2, qsq, Aexp1, Aexp2) \
    k1q1        =  k1 * q1; \
    `linmax_exp(xg1_i - q1 - delta_n, q_temp1) \
    Aexp1       =  A0 * q_temp1; \
    qsq         =  k1q1 * k1q1 - Aexp1; \
    if (Aexp1 == 0.0) begin \
        qi          =  1.0e-80; \
        k2q2        =  qi - k1q1; \
        q2          =  k2q2 / k2; \
    end else begin \
        if (qsq < -0.005) begin \
            q_rac_qsq   =  sqrt(abs(qsq)); \
            q_qcoth     =  q_rac_qsq / tan(0.5 * q_rac_qsq); \
        end else begin \
            if (qsq > 0.005) begin \
                q_rac_qsq   =  sqrt(abs(qsq)); \
                q_invexpq   =  exp(-q_rac_qsq); \
                q_qcoth     =  q_rac_qsq * (1.0 + q_invexpq) / (1.0 - q_invexpq); \
            end else begin \
                q_qcoth     =  2.0 + qsq * `INV6 * (1.0 - qsq * `INV60 * (1.0 - qsq * `INV42)); \
            end \
        end \
        if (1.01 * k1q1 + q_qcoth > 0.0) begin \
            q_temp1     =  k1q1 + q_qcoth; \
            if (Aexp1 * k1q1 < 0.9 * k1q1 * k1q1 * q_temp1) begin \
                qi          =  Aexp1 / q_temp1 + 1.0e-80; \
                k2q2        =  qi - k1q1; \
                q2          =  k2q2 / k2; \
            end else begin \
                if (qsq > 0.005) begin \
                    q_temp2     =  ln(4.0 * qsq / (1.0 - q_invexpq * (2.0 - q_invexpq))) - q_rac_qsq; \
                end else begin \
                    if (qsq < -0.005) begin \
                        q_temp3     =  sin(0.5 * q_rac_qsq); \
                        q_temp2     =  ln(-qsq / (q_temp3 * q_temp3)); \
                    end else begin \
                        q_temp2     =  ln(4.0 - qsq * `INV3 * (1.0 - 0.05 * qsq * (1.0 - 0.0396825396825397 * qsq))); \
                    end \
                end \
                q2          =  xg2_i - xg1_i + q1 + 2.0 * ln(q_temp1) - q_temp2; \
                k2q2        =  k2 * q2; \
                qi          =  k1q1 + k2q2; \
            end \
        end else begin \
            if (qsq > 0.005) begin \
                `linmax_exp(q1 + delta_n - xg1_i - q_rac_qsq, q_temp3) \
                q_temp2     =  q_temp3 / A0; \
                q_temp1     =  4.0 * qsq * q_temp2 / (1.0 - q_invexpq * (2.0 - q_invexpq)); \
            end else begin \
                if (qsq < -0.005) begin \
                    q_temp2     =  sin(0.5 * q_rac_qsq); \
                    q_temp1     = -qsq / (q_temp2 * q_temp2) / Aexp1; \
                end else begin \
                    q_temp1     =  (4.0 - qsq * `INV3 * (1.0 - 0.05 * qsq * (1.0 - 0.0396825396825397 * qsq))) / Aexp1; \
                end \
            end \
            qi          =  (k1q1  - q_qcoth) / (1.0 - q_temp1) + 1.0e-80; \
            k2q2        =  qi - k1q1; \
            q2          =  k2q2 / k2; \
        end \
    end \
    `linmax_exp(xg2_i - q2 - delta_n, q_temp1) \
    Aexp2       =  A0 * q_temp1;

//  Substrate surface potential calculation
`define spsub(spsub, xg1_i, xg2_i, xn_i) \
    SPSUB_xgb   =  xg1_i - xg2_i; \
    `lin_exp((-xn_i),SPSUB_delta) \
    if (abs(SPSUB_xgb) <= margin_sub) begin \
        SPSUB_temp1 =  inv_xisub * inv_xisub * `INV6 / `SQRT2; \
        spsub       =  SPSUB_xgb * inv_xisub * (1.0 + SPSUB_xgb * (1.0 - SPSUB_delta) * Gfsub * SPSUB_temp1); \
    end else begin \
        if (SPSUB_xgb < -margin_sub) begin \
            SPSUB_yg    = -SPSUB_xgb; \
            SPSUB_ysub  =  1.25 * (SPSUB_yg * inv_xisub); \
            SPSUB_eta   =  0.5 * (SPSUB_ysub + 10.0 - sqrt((SPSUB_ysub - 6.0) * (SPSUB_ysub - 6.0) + 64.0)); \
            SPSUB_temp  =  SPSUB_yg - SPSUB_eta; \
            SPSUB_a     =  SPSUB_temp * SPSUB_temp + Gfsub2 * (SPSUB_eta + 1.0); \
            SPSUB_c     =  2.0 * SPSUB_temp - Gfsub2; \
            SPSUB_tau   = -SPSUB_eta + ln(SPSUB_a * inv_Gfsub2); \
            `sigma3(SPSUB_a, SPSUB_c, SPSUB_tau, SPSUB_eta, SPSUB_y0) \
            `linmax_exp(SPSUB_y0, SPSUB_delta0) \
            SPSUB_delta1 =  1.0 / SPSUB_delta0; \
            SPSUB_temp  =  1.0 / (2.0 + SPSUB_y0 * SPSUB_y0); \
            SPSUB_xi0   =  SPSUB_y0 * SPSUB_y0 * SPSUB_temp; \
            SPSUB_xi1   =  4.0 * (SPSUB_y0 * SPSUB_temp * SPSUB_temp); \
            SPSUB_xi2   =  (8.0 * SPSUB_temp - 12.0 * SPSUB_xi0) * SPSUB_temp * SPSUB_temp; \
            SPSUB_temp  =  SPSUB_yg - SPSUB_y0; \
            SPSUB_temp1 =  SPSUB_delta * SPSUB_delta1; \
            SPSUB_pC    =  2.0 * SPSUB_temp + Gfsub2 * (SPSUB_delta0 - 1.0 - SPSUB_temp1 + SPSUB_delta * (1.0 - SPSUB_xi1)); \
            SPSUB_qC    =  SPSUB_temp * SPSUB_temp - Gfsub2 * (SPSUB_delta0 - SPSUB_y0 - 1.0 + SPSUB_temp1 + SPSUB_delta * (SPSUB_y0 - 1.0 - SPSUB_xi0)); \
            SPSUB_temp  =  2.0 - Gfsub2 * (SPSUB_delta0 + SPSUB_temp1 - SPSUB_delta * SPSUB_xi2); \
            SPSUB_temp  =  SPSUB_pC * SPSUB_pC - 2.0 * (SPSUB_qC * SPSUB_temp); \
            spsub       = -SPSUB_y0 - 2.0 * (SPSUB_qC / (SPSUB_pC + sqrt(SPSUB_temp))); \
        end else begin \
            SPSUB_xg1   =  1.0 / (1.25 + Gfsub * 0.732464877560822); \
            SPSUB_A_fac =  (1.25 * xisub * SPSUB_xg1 - 1.0) * SPSUB_xg1; \
            SPSUB_xbar  =  SPSUB_xgb * inv_xisub * (1.0 + SPSUB_A_fac * SPSUB_xgb); \
            `linmin_exp((-SPSUB_xbar), SPSUB_temp) \
            SPSUB_w     =  1.0 - SPSUB_temp; \
            SPSUB_x1    =  SPSUB_xgb + Gfsub2 * 0.5 - Gfsub * sqrt(SPSUB_xgb + Gfsub2 * 0.25 - SPSUB_w); \
            SPSUB_bx    =  xn_i + 3.0; \
            SPSUB_eta   = `MIN_FUNC(SPSUB_x1, SPSUB_bx, 5.0) - 0.5 * (SPSUB_bx - sqrt(SPSUB_bx * SPSUB_bx + 5.0)); \
            SPSUB_temp  =  SPSUB_xgb - SPSUB_eta; \
            SPSUB_temp1 =  exp(-SPSUB_eta); \
            SPSUB_temp2 =  1.0 / (2.0 + SPSUB_eta * SPSUB_eta); \
            SPSUB_xi0   =  SPSUB_eta * SPSUB_eta * SPSUB_temp2; \
            SPSUB_xi1   =  4.0 * (SPSUB_eta * SPSUB_temp2 * SPSUB_temp2); \
            SPSUB_xi2   =  (8.0 * SPSUB_temp2 - 12.0 * SPSUB_xi0) * SPSUB_temp2 * SPSUB_temp2; \
            SPSUB_a     =  max(1.0e-40, SPSUB_temp * SPSUB_temp - Gfsub2 * (SPSUB_temp1 + SPSUB_eta - 1.0 - SPSUB_delta * (SPSUB_eta + 1.0 + SPSUB_xi0))); \
            SPSUB_b     =  1.0 - 0.5 * (Gfsub2 * (SPSUB_temp1 - SPSUB_delta * SPSUB_xi2)); \
            SPSUB_c     =  2.0 * SPSUB_temp + Gfsub2 * (1.0 - SPSUB_temp1 - (SPSUB_delta) * (1.0 + SPSUB_xi1)); \
            SPSUB_tau   =  xn_i - SPSUB_eta + ln(SPSUB_a / Gfsub2); \
            `sigma2(SPSUB_a, SPSUB_b, SPSUB_c, SPSUB_tau, SPSUB_eta, SPSUB_x0) \
            if (SPSUB_x0 < `EXP_THRESHOLD) begin \
                SPSUB_delta0 =  exp(SPSUB_x0); \
                SPSUB_delta1 =  1.0 / SPSUB_delta0; \
                SPSUB_delta0 =  SPSUB_delta * SPSUB_delta0; \
            end else begin \
                if (SPSUB_x0 > (xn_i - `EXP_THRESHOLD)) begin \
                    SPSUB_delta0 =  exp(SPSUB_x0 - xn_i); \
                    SPSUB_delta1 =  SPSUB_delta / SPSUB_delta0; \
                end else begin \
                    SPSUB_delta0 = `MIN_EXP / `dev3_exp(xn_i - SPSUB_x0 - `EXP_THRESHOLD); \
                    SPSUB_delta1 = `MIN_EXP / `dev3_exp(SPSUB_x0 - `EXP_THRESHOLD); \
                end \
            end \
            SPSUB_temp  =  1.0 / (2.0 + SPSUB_x0 * SPSUB_x0); \
            SPSUB_xi0   =  SPSUB_x0 * SPSUB_x0 * SPSUB_temp; \
            SPSUB_xi1   =  4.0 * (SPSUB_x0 * SPSUB_temp * SPSUB_temp); \
            SPSUB_xi2   =  (8.0 * SPSUB_temp - 12.0 * SPSUB_xi0) * SPSUB_temp * SPSUB_temp; \
            SPSUB_temp  =  SPSUB_xgb - SPSUB_x0; \
            SPSUB_pC    =  2.0 * SPSUB_temp + Gfsub2 * (1.0 - SPSUB_delta1 + SPSUB_delta0 - SPSUB_delta * (1.0 + SPSUB_xi1)); \
            SPSUB_qC    =  SPSUB_temp * SPSUB_temp - Gfsub2 * (SPSUB_delta1 + SPSUB_x0 - 1.0 + SPSUB_delta0 - SPSUB_delta * (SPSUB_x0 + 1.0 + SPSUB_xi0)); \
            SPSUB_temp  =  2.0 - Gfsub2 * (SPSUB_delta1 + SPSUB_delta0 - SPSUB_delta * SPSUB_xi2); \
            SPSUB_temp  =  SPSUB_pC * SPSUB_pC - 2.0 * (SPSUB_qC * SPSUB_temp); \
            spsub       =  SPSUB_x0 + 2.0 * (SPSUB_qC / (SPSUB_pC + sqrt(SPSUB_temp))); \
        end \
    end

//  Surface potential calculation for the overlap regions for gate currents, GIDL/GISL and overlap capacitances
`define sp_fdsoi_ov(sp,xgf_ov) \
    if (abs(xgf_ov) <= x_mrg_ov) begin \
        sp          = -xgf_ov * inv_xi_ov; \
    end else begin \
        if (xgf_ov < -x_mrg_ov) begin \
            SP_OV_ygf   = -xgf_ov; \
            SP_OV_z     = `X1OV * SP_OV_ygf * inv_xi_ov; \
            SP_OV_eta   =  0.5 * (SP_OV_z + 10.0 - sqrt((SP_OV_z - 6.0) * (SP_OV_z - 6.0) + 64.0)); \
            SP_OV_a     =  (SP_OV_ygf - SP_OV_eta) * (SP_OV_ygf - SP_OV_eta) + GOV2 * (SP_OV_eta + 1.0); \
            SP_OV_c     =  2.0 * (SP_OV_ygf - SP_OV_eta) - GOV2; \
            SP_OV_tau   =  ln(SP_OV_a / GOV2) - SP_OV_eta; \
            SP_OV_nu    =  SP_OV_a + SP_OV_c; \
            SP_OV_mutau =  SP_OV_nu * SP_OV_nu + SP_OV_tau * (0.5 * SP_OV_c * SP_OV_c - SP_OV_a); \
            SP_OV_temp  =  SP_OV_mutau + SP_OV_nu / SP_OV_mutau * SP_OV_tau * SP_OV_tau * SP_OV_c * (SP_OV_c * SP_OV_c * `INV3 - SP_OV_a); \
            SP_OV_y0    =  SP_OV_eta + SP_OV_a * SP_OV_nu * SP_OV_tau / SP_OV_temp; \
            `lin_exp(SP_OV_y0, SP_OV_D0) \
            SP_OV_temp  =  SP_OV_ygf - SP_OV_y0; \
            SP_OV_p     =  2.0 * SP_OV_temp + GOV2 * (SP_OV_D0 - 1.0); \
            SP_OV_q     =  SP_OV_temp * SP_OV_temp + GOV2 * (SP_OV_y0 + 1.0 - SP_OV_D0); \
            SP_OV_xi    =  1.0 - GOV2 * 0.5 * SP_OV_D0; \
            SP_OV_temp  =  SP_OV_p * SP_OV_p - 4.0 * (SP_OV_xi * SP_OV_q); \
            SP_OV_w     =  2.0 * SP_OV_q / (SP_OV_p + sqrt(SP_OV_temp)); \
            sp          = -(SP_OV_y0 + SP_OV_w); \
        end else begin \
            SP_OV_Afac  =  (xi_ov * `X1OV * inv_xg1 - 1.0) * inv_xg1; \
            SP_OV_xbar  =  xgf_ov * inv_xi_ov * (1.0 + SP_OV_Afac * xgf_ov); \
            `lin_exp((-SP_OV_xbar), SP_OV_temp) \
            SP_OV_w     =  1.0 - SP_OV_temp; \
            SP_OV_x0    =  xgf_ov + GOV2 * 0.5 - GOV * sqrt(xgf_ov + GOV2 * 0.25 - SP_OV_w); \
            `lin_exp((-SP_OV_x0), SP_OV_D0) \
            SP_OV_p     =  2.0 * (xgf_ov - SP_OV_x0) + GOV2 * (1 - SP_OV_D0); \
            SP_OV_q     =  (xgf_ov - SP_OV_x0) * (xgf_ov - SP_OV_x0) - GOV2 * (SP_OV_x0 - 1.0 + SP_OV_D0); \
            SP_OV_xi    =  1.0 - GOV2 * 0.5 * SP_OV_D0; \
            SP_OV_temp  =  SP_OV_p * SP_OV_p - 4.0 * (SP_OV_xi * SP_OV_q); \
            SP_OV_u     =  2.0 * SP_OV_q / (SP_OV_p + sqrt(SP_OV_temp)); \
            sp          =  SP_OV_x0 + SP_OV_u; \
        end \
        sp          = -sp; \
    end

// *************************************************************************************************************************
// Model Calculation
// *************************************************************************************************************************

`define EXTERNAL_TH_NODE

`ifdef EXTERNAL_TH_NODE
module l_utsoi(D,G,S,B,Tnode) (* xyceModelGroup="MOSFET" xyceLevelNumber="10240" xyceDeviceName="L_UTSOI MOSFET" xyceTypeVariable="TYPE"*);
    inout      D, G, S, B, Tnode;
`else
module l_utsoi(D,G,S,B);
    inout      D, G, S, B;
`endif

    //  Electrical node definitions
    electrical D;
    electrical G;
    electrical S;
    electrical B;

    //  Temperature node for self heating
    thermal    Tnode;
    branch (Tnode) THPWR;
    branch (Tnode) THRC;

    //  Internal node for noise model
    electrical NSIG;
    branch (NSIG) NOII;
    branch (NSIG) NOIR;
    branch (NSIG) NOIC;

    //  Model flags and reference temperature
    // *********************************************************************************************************************

        //  Model selection
        `MPIcc(SWSCALE        ,0          ,""         ,0           ,1           ,"Parameter set mode (local=0, global=1)")
        `MPRnb(VERSION        ,102.4      ,""                                   ,"Model version")

        //  Switch parameters that turn models/effects On (=1) or Off (=0)
        `MPIcc(SWSUBDEP       ,0         ,""         ,0           ,1           ,"Flag for substrate depletion model (without=0, with=1)")
        `MPIcc(SWIGATE        ,0         ,""         ,0           ,1           ,"Flag for gate current (without=0, with=1)")
        `MPIcc(SWGIDL         ,0         ,""         ,0           ,1           ,"Flag for GIDL current (without=0, with=1)")
        `MPIcc(SWSHE          ,0         ,""         ,0           ,1           ,"Flag for self heating effect (without=0, with=1)")
        `MPIcc(SWIGN          ,1         ,""         ,0           ,1           ,"Flag for induced gate noise model (without=0, with=1)")
        `MPIcc(SWJUNASYM      ,0         ,""         ,0           ,1           ,"Flag for source/drain junction asymmetry (without=0, with=1)")
        `MPIcc(SWIMPACT       ,0         ,""         ,0           ,1           ,"Flag for impact ionization current (without=0, with=1)")

        //  Quantum effect parameter
        `MPRcz(QMC            ,1.0        ,""                                   ,"Quantum correction factor (no correction=0, full correction=1)")

        //  Device type selection
        `MPIty(TYPE           ,1          ,""                                   ,"Channel type parameter, +1=NMOS -1=PMOS")

        //  Reference temperature and max temperature elevation
        `MPRco(TR             ,21.0       ,"C"        ,-273.0      ,inf         ,"Nominal temperature")
        `MPRco(TMAX           ,150.0      ,"C"        ,0.0         ,inf         ,"Maximum self-heating temperature elevation")

    //  Instance parameters definition
    // *********************************************************************************************************************

        //  Instance parameters
        `IPRco(L              ,1.0e-06    ,"m"        ,1.0e-09     ,inf         ,"Channel length")
        `IPRco(W              ,1.0e-06    ,"m"        ,1.0e-09     ,inf         ,"Channel width")
        `IPRcz(ASOURCE        ,1.0e-12    ,"m^2"                                ,"Source region area")
        `IPRcz(ADRAIN         ,1.0e-12    ,"m^2"                                ,"Drain region area")
        `IPRcz(PSOURCE        ,1.0e-06    ,"m"                                  ,"Source region perimeter")
        `IPRcz(PDRAIN         ,1.0e-06    ,"m"                                  ,"Drain region perimeter")
        `IPRcz(SA             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly at source side")
        `IPRcz(SB             ,0.0        ,"m"                                  ,"Distance between OD-edge and poly at drain side")
        `IPRcz(SD             ,0.0        ,"m"                                  ,"Distance between neighboring fingers")
        `IPIco(NF             ,1          ,""         ,1           ,inf         ,"Number of fingers")
        `IPIcz(MULT           ,1          ,""                                   ,"Number of devices in parallel")
        `IPRnb(DELVTO         ,0.0        ,"V"                                  ,"Threshold voltage shift parameter")
        `IPRcz(FACTUO         ,1.0        ,""                                   ,"Low-field mobility pre-factor")

    //  Local parameters definition SWSCALE=0
    // *********************************************************************************************************************

        //  Process parameters
        `MPRcc(TOXE           ,2.0e-09    ,"m"        ,3.0e-10     ,1.0e-06     ,"Front gate equivalent oxide thickness")
        `MPRcc(TSI            ,1.0e-08    ,"m"        ,3.0e-09     ,2.0e-08     ,"Silicon or SiGe film thickness")
        `MPRcc(XGE            ,0.0        ,""         ,0.0         ,1.0         ,"Fraction of Ge content in the channel")
        `MPRcc(TBOX           ,1.0e-07    ,"m"        ,3.0e-10     ,1.0e-06     ,"Buried oxide thickness")
        `MPRnb(NCH            ,0.0        ,"cm^-3"                              ,"Thin film doping (n-type=negative value, p-type=positive value)")
        `MPRnb(NSUB           ,3.0e18     ,"cm^-3"                              ,"Substrate doping (n-type=negative value, p-type=positive value)")
        `MPRcz(CT             ,0.0        ,""                                   ,"Interface states factor")
        `MPRcc(TOXP           ,2.0e-09    ,"m"        ,3.0e-10     ,1.0e-06     ,"Front gate physical oxide thickness")
        `MPRcc(NOV            ,1.0e20     ,"cm^-3"    ,1.0e15      ,1.0e21      ,"Effective doping of overlap-ldd regions")
        `MPRcc(NOVD           ,1.0e20     ,"cm^-3"    ,1.0e15      ,1.0e21      ,"Effective doping of overlap-ldd regions ar drain side")
        `MPRnb(VFB            ,0.0        ,"V"                                  ,"Flat-band voltage of the front gate at TR")
        `MPRnb(VFBB           ,0.0        ,"V"                                  ,"Flat-band voltage of the back gate at TR")
        `MPRnb(STVFB          ,0.0        ,"V/K"                                ,"Temperature dependence of VFB and VFBB")

        //  Gate to interface coupling parameters
        `MPRcc(CICF           ,1.0        ,""         ,0.1         ,10.0        ,"Long channel front interface coupling coefficient")
        `MPRcc(CIC            ,1.0        ,""         ,0.1         ,10.0        ,"Long channel back interface coupling coefficient")
        `MPRcc(PSCE           ,0.0        ,""         ,0.0         ,5.0         ,"Short channel effect coefficient")
        `MPRcz(PSCEB          ,1.0        ,""                                   ,"Short channel back to front interface asymmetry factor")
        `MPRcc(NSDDC          ,1.0e22     ,"cm^-3"    ,1.0e18      ,1.0e22      ,"Source/Drain effective doping level for DC model")
        `MPRcz(PSCEDLB        ,0.0        ,""                                   ,"Back bias dependence of short channel effect modulation")
        `MPRcc(PNCE           ,0.0        ,""         ,-1.0        ,1.0         ,"Narrow channel effect on body factor")

        //  DIBL parameters
        `MPRcz(CF             ,0.0        ,""                                   ,"DIBL parameter")
        `MPRcz(CFB            ,1.0        ,""                                   ,"DIBL back to front interface asymmetry factor")
        `MPRnb(STCF           ,0.0        ,"1/K"                                ,"Temperature dependence of CF, with same scaling as CF")
        `MPRco(CFD            ,0.2        ,"V"        ,0.05        ,inf         ,"Drain voltage dependence parameter of DIBL")
        `MPRnb(CFDL           ,0.0        ,""                                   ,"DIBL modulation coefficient due to Leff variation")
        `MPRcz(CFDLB          ,0.0        ,""                                   ,"Back bias dependence of DIBL modulation")

        //  Mobility parameters
        `MPRco(BETN           ,5.0e-02    ,"m^2/V/s"  ,1.0e-10     ,inf         ,"Front channel aspect ratio times zero-field mobility")
        `MPRcc(BETNB          ,1.0        ,""         ,0.1         ,10.0        ,"Back channel over front channel zero-field mobility ratio")
        `MPRnb(STBET          ,1.5        ,""                                   ,"Temperature dependence of BETN")
        `MPRcz(CS             ,0.0        ,""                                   ,"Remote Coulomb scattering parameter at TR")
        `MPRcz(CSFI           ,0.0        ,""                                   ,"Field dependence of Coulomb scattering at front interface")
        `MPRcz(CSBI           ,0.0        ,""                                   ,"Field dependence of Coulomb scattering at back interface")
        `MPRnb(STCS           ,0.0        ,""                                   ,"Temperature dependence of CS")
        `MPRcz(THECS          ,1.5        ,""                                   ,"Remote Coulomb scattering exponent at TR")
        `MPRnb(STTHECS        ,0.0        ,""                                   ,"Temperature dependence of THECS")
        `MPRco(CSTHR          ,2.0        ,""         ,1.0e-03     ,inf         ,"Remote Coulomb scattering threshold level")
        `MPRco(CSTHRB         ,1.0        ,""         ,0.1         ,inf         ,"Remote Coulomb scattering threshold asymmetry parameter")
        `MPRcz(MUE            ,0.0        ,"cm/MV"                              ,"Front channel mobility reduction coefficient at TR")
        `MPRnb(STMUE          ,0.0        ,""                                   ," Temperature dependence of MUE")
        `MPRcz(THEMU          ,1.5        ,""                                   ,"Front channel mobility reduction exponent at TR")
        `MPRnb(STTHEMU        ,0.0        ,""                                   ,"Temperature dependence of THEMU")
        `MPRnb(XCOR           ,0.0        ,""                                   ,"Front channel non-universality factor")
        `MPRnb(XCORB          ,1.0        ,""                                   ,"Asymmetry term of non-universality factor")
        `MPRnb(STXCOR         ,0.0        ,""                                   ,"Temperature dependence of XCOR")
        `MPRcz(FETA           ,1.0        ,""                                   ,"Effective field parameter")

        //  Series resistance parameters (for resistance modeling as part of intrinsic mobility reduction)
        `MPRcz(RS           ,30.0         ,"Ohm"                                ,"Source/Drain series resistance at TR")
        `MPRcz(RSIG         ,0.0          ,""                                   ,"Source/Drain extension resistance coefficient")
        `MPRnb(STRS         ,0.0          ,""                                   ,"Temperature dependence of RS")
        `MPRco(RSG          ,0.0          ,""         ,-0.5        ,inf         ,"Transverse electric field dependence of RS")
        `MPRnb(THERSG       ,2.0          ,""                                   ,"Transverse electric field dependence exponent of RS")
        `MPRnb(RSB          ,0.0          ,""                                   ,"Back bias dependence of RS")

        //  Velocity saturation parameters
        `MPRcz(THESAT       ,0.0          ,"V^-1"                               ,"Velocity saturation parameter at TR")
        `MPRnb(STTHESAT     ,-0.1         ,""                                   ,"Temperature dependence of THESAT")
        `MPRco(THESATG      ,0.0          ,""         ,-0.5        ,inf         ,"Front gate bias dependence of velocity saturation")
        `MPRco(THESATB      ,0.0          ,""         ,-0.5        ,inf         ,"Back gate bias dependence of velocity saturation")

        //  Saturation voltage parameters
        `MPRcc(AX           ,8.0          ,""         ,1.0         ,16.0        ,"Linear/saturation transition exponent")

        //  Channel length modulation (CLM) parameters
        `MPRcz(ALP          ,0.0          ,""                                   ,"CLM pre-factor")
        `MPRcz(ALP1         ,0.0          ,"V"                                  ,"CLM enhancement factor above threshold")
        `MPRnb(ALPB         ,0.0          ,""                                   ,"Back bias dependence of channel length modulation")
        `MPRco(VP           ,0.05         ,"V"        ,1.0e-10     ,inf         ,"CLM logarithm dependence factor")
        `MPRcz(VPG          ,0.0          ,""                                   ,"Transverse electric field dependence of CLM logarithm factor")

        //  Gate current parameters
        `MPRcc(GCO          ,0.0          ,""         ,-10.0       ,10.0        ,"Gate tunneling energy adjustment in inversion")
        `MPRcz(IGINV        ,0.0          ,"A"                                  ,"Gate to channel current pre-factor")
        `MPRcz(IGOVINV      ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor in inversion")
        `MPRcz(IGOVINVD     ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor in inversion at drain side")
        `MPRcz(IGOVACC      ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor in accumulation")
        `MPRcz(IGOVACCD     ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor in accumulation at drain side")
        `MPRnb(STIG         ,0.0          ,""                                   ,"Temperature dependence of all gate currents")
        `MPRcc(GC2CH        ,0.375        ,""         ,0.0         ,10.0        ,"Gate to channel current slope factor")
        `MPRcc(GC3CH        ,0.063        ,""         ,-2.0        ,2.0         ,"Gate to channel current curvature factor")
        `MPRcc(GC2OVINV     ,0.375        ,""         ,0.0         ,10.0        ,"Gate current slope factor for overlap regions in inversion mode")
        `MPRcc(GC3OVINV     ,0.063        ,""         ,-2.0        ,2.0         ,"Gate current curvature factor for overlap regions in inversion mode")
        `MPRcc(GC2OVACC     ,0.375        ,""         ,0.0         ,10.0        ,"Gate current slope factor for overlap regions in accumulation mode")
        `MPRcc(GC3OVACC     ,0.063        ,""         ,-2.0        ,2.0         ,"Gate current curvature factor for overlap regions in accumulation mode")
        `MPRnb(GCDOV        ,0.0          ,"V^-1"                               ,"High drain voltage dependence of overlap gate current")
        `MPRnb(GCVDOV       ,1.0          ,"V"                                  ,"Threshold of high drain voltage effect on overlap gate current")
        `MPRco(CHIB         ,3.1          ,"V"        ,1.0         ,inf         ,"Tunneling barrier height")
        `MPRcz(NIGINV       ,0.0          ,""                                   ,"Gate tunneling slope adjustment in subthreshold regime")
        `MPRcz(FNOVINV      ,0.0          ,"A"                                  ,"Extra gate to overlap current pre-factor in inversion")
        `MPRcz(FNOVINVD     ,0.0          ,"A"                                  ,"Extra gate to overlap current pre-factor in inversion at drain side")
        `MPRcc(GCOVINVFN    ,0.2          ,""         ,0.1         ,10.0        ,"Extra gate current slope factor for overlap regions in inversion mode")
        `MPRnb(STIGFN       ,0.0          ,""                                   ,"Temperature dependence of extra gate to overlap current")

        //  Gate Induced Drain/Source Leakage (GIDL/GISL) parameters
        `MPRcz(AGIDL        ,0.0          ,"A/V^3"                              ,"GIDL pre-factor")
        `MPRcz(AGIDLD       ,0.0          ,"A/V^3"                              ,"GIDL pre-factor at drain side")
        `MPRcz(BGIDL        ,41.0         ,"V"                                  ,"GIDL probability factor at TR")
        `MPRcz(BGIDLD       ,41.0         ,"V"                                  ,"GIDL probability factor at TR at drain side")
        `MPRnb(STBGIDL      ,0.0          ,"V/K"                                ,"Temperature dependence of BGIDL")
        `MPRnb(STBGIDLD     ,0.0          ,"V/K"                                ,"Temperature dependence of BGIDL at drain side")
        `MPRnb(CGIDL        ,0.0          ,"V^-1"                               ,"Substrate bias dependence of GIDL")
        `MPRnb(CGIDLD       ,0.0          ,"V^-1"                               ,"Substrate bias dependence of GIDL at drain side")
        `MPRnb(DGIDL        ,0.0          ,"V^-1"                               ,"High longitudinal field parameter of GIDL")
        `MPRnb(DGIDLD       ,0.0          ,"V^-1"                               ,"High longitudinal field parameter of GIDL at drain side")

        //  Impact Ionization parameters
        `MPRcz(A1           ,1.0          ,""                                   ,"Impact ionization pre-factor")
        `MPRcz(A2           ,10.0         ,""                                   ,"Impact ionization exponent at TR")
        `MPRnb(STA2         ,0.0          ,""                                   ,"Temperature dependence of A2")
        `MPRcz(A3           ,1.0          ,""                                   ,"Saturation voltage dependence of impact-ionization")

        //  Charge model parameters
        `MPRco(AREAQ        ,1.0e-12      ,"m^2"      ,1.0e-18     ,inf         ,"Effective channel area for intrinsic CV")
        `MPRcz(CGBOV        ,0.0          ,"F"                                  ,"Oxide capacitance for gate-substrate overlap")
        `MPRcc(NSDAC        ,1.0e22       ,"cm^-3"    ,1.0e18      ,1.0e22      ,"Source/Drain effective doping level for AC model")
        `MPRcz(FIF          ,0.0          ,""                                   ,"Inner fringe capacitance prefactor")
        `MPRcz(FSCEAC       ,0.0          ,""                                   ,"Short channel effect adjustment factor for charge model")
        `MPRcz(COV          ,0.0          ,"F"                                  ,"Overlap capacitance per side")
        `MPRcz(COVD         ,0.0          ,"F"                                  ,"Overlap capacitance at drain side")
        `MPRnb(COVDL        ,0.0          ,""                                   ,"Overlap capacitance modulation coefficient due to Leff variation")
        `MPRnb(COVDLB       ,0.0          ,""                                   ,"Overlap capacitance modulation with back bias")
        `MPRnb(DVFBOV       ,0.0          ,"V"                                  ,"Overlap capacitance flat-band voltage adjustment")
        `MPRcz(CFR          ,0.0          ,"F"                                  ,"Outer fringe capacitance per side")
        `MPRcz(CFRD         ,0.0          ,"F"                                  ,"Outer fringe capacitance at drain side")
        `MPRcz(CSD          ,1.04e-18     ,"F"                                  ,"Drain-source capacitance")
        `MPRcz(CSDBP        ,0.0          ,"F/m"                                ,"Drain/source to substrate perimeter capacitance")

        //  Self heating parameters
        `MPRco(RTH          ,1.0e04       ,"K/W"      ,1.0e-06     ,inf         ,"Thermal resistance")
        `MPRnb(STRTH        ,0.0          ,""                                   ,"Temperature dependence of RTH")
        `MPRcz(CTH          ,1.0e-11      ,"J/K"                                ,"Thermal capacitance")

        //  Noise model parameters
        `MPRcz(FNT          ,1.0          ,""                                   ,"Thermal noise coefficient")
        `MPRcz(FNTEXC       ,0.0          ,""                                   ,"Excess noise coefficient")
        `MPRcz(NFA          ,8.0e22       ,"V^-1/m^4"                           ,"First coefficient of flicker noise")
        `MPRcz(NFB          ,3.0e07       ,"V^-1/m^2"                           ,"Second coefficient of flicker noise")
        `MPRcz(NFC          ,0.0          ,"V^-1"                               ,"Third coefficient of flicker noise")
        `MPRcc(NFE          ,0.0          ,""         ,-1.0        ,1.0         ,"Flicker noise front transverse field effect coefficient")
        `MPRcc(NFEB         ,0.0          ,""         ,-1.0        ,1.0         ,"Flicker noise back transverse field effect coefficient")
        `MPRco(EF           ,1.0          ,""         ,0.1         ,inf         ,"Frequency coefficient of flicker noise")

    //  Global parameters definition SWSCALE=1
    // *********************************************************************************************************************

        //  Geometry scaling parameters
        `MPRnb(LVARO        ,0.0          ,"m"                                  ,"Geometry independent difference between physical and drawn gate lengths")
        `MPRnb(LVARL        ,0.0          ,""                                   ,"Length dependence of LPS")
        `MPRnb(LVARW        ,0.0          ,""                                   ,"Width dependence of LPS")
        `MPRnb(LAP          ,0.0          ,"m"                                  ,"Effective channel length reduction per side")
        `MPRnb(WVARO        ,0.0          ,"m"                                  ,"Geometry-independent difference between physical and drawn field-oxide opening")
        `MPRnb(WVARL        ,0.0          ,""                                   ,"Length dependence of WOD")
        `MPRnb(WVARW        ,0.0          ,""                                   ,"Width dependence of WOD")
        `MPRnb(WOT          ,0.0          ,"m"                                  ,"Effective reduction of channel width per side")
        `MPRnb(DLQ          ,0.0          ,"m"                                  ,"Effective channel length additional offset for charge model")
        `MPRnb(DWQ          ,0.0          ,"m"                                  ,"Effective channel width additional offset for charge model")

        //  Process parameters
        `MPRcc(TOXEO        ,2.0e-09      ,"m"        ,3.0e-10     ,1.0e-06     ,"Front gate equivalent oxide thickness")
        `MPRcc(TSIO         ,1.0e-08      ,"m"        ,3.0e-09     ,2.0e-08     ,"Silicon or SiGe film thickness")
        `MPRcc(XGEO         ,0.0          ,""         ,0.0         ,1.0         ,"Fraction of Ge content in the channel")
        `MPRcc(TBOXO        ,1.0e-07      ,"m"        ,3.0e-10     ,1.0e-06     ,"Buried oxide thickness")
        `MPRnb(NCHO         ,0.0          ,"cm^-3"                              ,"Thin film doping (n-type=negative value, p-type=positive value)")
        `MPRnb(NSUBO        ,3.0e18       ,"cm^-3"                              ,"Substrate doping (n-type=negative value, p-type=positive value)")
        `MPRcz(CTO          ,0.0          ,""                                   ,"Interface states factor")
        `MPRcc(TOXPO        ,2.0e-09      ,"m"        ,3.0e-10     ,1.0e-06     ,"Front gate physical oxide thickness")
        `MPRcc(NOVO         ,1.0e20       ,"cm^-3"    ,1.0e15      ,1.0e21      ,"Effective doping of overlap-ldd regions")
        `MPRcc(NOVDO        ,1.0e20       ,"cm^-3"    ,1.0e15      ,1.0e21      ,"Effective doping of overlap-ldd regions at drain side")
        `MPRnb(VFBO         ,0.0          ,"V"                                  ,"Geometry-independent front gate flat-band voltage at TR")
        `MPRnb(VFBL         ,0.0          ,"V"                                  ,"Length dependence of VFB")
        `MPRnb(VFBLEXP      ,2.0          ,""                                   ,"Exponent describing length dependence of VFB")
        `MPRcz(VFBL2        ,0.0          ,""                                   ,"Second order length dependence of VFB")
        `MPRnb(VFBLEXP2     ,2.0          ,""                                   ,"Exponent of second order length dependence of VFB")
        `MPRnb(VFBW         ,0.0          ,"V"                                  ,"Width dependence of VFB")
        `MPRnb(VFBLW        ,0.0          ,"V"                                  ,"Area dependence of VFB")
        `MPRnb(VFBBO        ,0.0          ,"V"                                  ,"Geometry-independent back gate flat-band voltage at TR")
        `MPRcz(VFBLBO       ,0.0          ,""                                   ,"Roll-off back to front interface asymmetry factor")
        `MPRnb(STVFBO       ,0.0          ,"V/K"                                ,"Geometry-independent temperature dependence of VFB and VFBB")
        `MPRnb(STVFBL       ,0.0          ,""                                   ,"Length dependence of STVFB")
        `MPRnb(STVFBW       ,0.0          ,""                                   ,"Width dependence of STVFB")
        `MPRnb(STVFBLW      ,0.0          ,""                                   ,"Area dependence of STVFB")

        //  Gate to interface coupling parameters
        `MPRcc(CICFO        ,1.0          ,""         ,0.1         ,10.0        ,"Long channel front interface coupling coefficient")
        `MPRcc(CICO         ,1.0          ,""         ,0.1         ,10.0        ,"Long channel back interface coupling coefficient")
        `MPRnb(PSCEL        ,0.0          ,""                                   ,"Length dependence of PSCE")
        `MPRnb(PSCELEXP     ,2.0          ,""                                   ,"Exponent describing length dependence of PSCE")
        `MPRnb(PSCEW        ,0.0          ,""                                   ,"Width dependence of PSCE")
        `MPRcz(PSCEBO       ,1.0          ,""                                   ,"Short channel back to front interface asymmetry factor")
        `MPRcc(NSDDCO       ,1.0e22       ,"cm^-3"    ,1.0e18      ,1.0e22      ,"Source/Drain effective doping level for DC model")
        `MPRcz(PSCEDLBO     ,0.0          ,""                                   ,"Back bias dependence of short channel effect modulation")
        `MPRnb(PNCEW        ,0.0          ,""                                   ,"Narrow channel effect on body factor for a width of WEN")

        //  DIBL parameters
        `MPRnb(CFL          ,0.0          ,""                                   ,"Length dependence of DIBL-parameter")
        `MPRnb(CFLEXP       ,2.0          ,""                                   ,"Exponent for length dependence of CF")
        `MPRnb(CFW          ,0.0          ,""                                   ,"Width dependence of CF")
        `MPRcz(CFBO         ,1.0          ,""                                   ,"DIBL back to front interface asymmetry factor")
        `MPRnb(STCFL        ,0.0          ,"1/K"                                ,"Temperature dependence of CF, with same scaling as CF")
        `MPRco(CFDO         ,0.2          ,"V"        ,0.05        ,inf         ,"Drain voltage dependence parameter of DIBL")
        `MPRnb(CFDLL        ,0.0          ,""                                   ,"DIBL modulation coefficient due to Leff variation")
        `MPRnb(CFDLW        ,0.0          ,""                                   ,"Width dependence of CFDL")
        `MPRcz(CFDLBO       ,0.0          ,""                                   ,"Back bias dependence of DIBL modulation")

        //  Mobility parameters
        `MPRcz(UO           ,5.0e-02      ,"m^2/V/s"                            ,"Front channel zero-field mobility at TR")
        `MPRnb(FBET1        ,0.0          ,""                                   ,"First length dependence modulation of BETN")
        `MPRnb(FBET1W       ,0.0          ,""                                   ,"Width dependence of FBET1")
        `MPRco(LP1          ,1.0e-08      ,"m"        ,1.0e-10     ,inf         ,"First characteristic length of BETN scaling")
        `MPRnb(LP1W         ,0.0          ,""                                   ,"Width dependence of LP1")
        `MPRnb(FBET2        ,0.0          ,""                                   ,"Second length dependence modulation of BETN")
        `MPRco(LP2          ,1.0e-08      ,"m"        ,1.0e-10     ,inf         ,"Second characteristic length of BETN scaling")
        `MPRnb(BETW1        ,0.0          ,""                                   ,"First width dependence modulation of BETN")
        `MPRnb(BETW2        ,0.0          ,""                                   ,"Second width dependence modulation of BETN")
        `MPRco(WBET         ,1.0e-08      ,"m"        ,1.0e-10     ,inf         ,"Characteristic width of BETN scaling")
        `MPRcc(BETNBO       ,1.0          ,""         ,0.1         ,10.0        ,"Back channel over front channel zero-field mobility ratio")
        `MPRnb(STBETO       ,1.5          ,""                                   ,"Geometry independent temperature dependence of BETN")
        `MPRnb(STBETL       ,0.0          ,""                                   ,"Length dependence of STBET")
        `MPRnb(STBETW       ,0.0          ,""                                   ,"Width dependence of STBET")
        `MPRnb(STBETLW      ,0.0          ,""                                   ,"Area dependence of STBET")
        `MPRnb(CSO          ,0.0          ,""                                   ,"Remote Coulomb scattering parameter at TR")
        `MPRnb(CSL          ,0.0          ,""                                   ,"Length dependence of CS")
        `MPRnb(CSLEXP       ,1.0          ,""                                   ,"Exponent describing length dependence of CS")
        `MPRnb(CSW          ,0.0          ,""                                   ,"Width dependence of CS")
        `MPRnb(CSLW         ,0.0          ,""                                   ,"Area dependence of CS")
        `MPRcz(CSFIO        ,0.0          ,""                                   ,"Field dependence of Coulomb scattering at front interface")
        `MPRcz(CSBIO        ,0.0          ,""                                   ,"Field dependence of Coulomb scattering at back interface")
        `MPRnb(STCSO        ,0.0          ,""                                   ,"Temperature dependence of CS")
        `MPRnb(STCSL        ,0.0          ,""                                   ,"Length dependence of STCS")
        `MPRnb(STCSW        ,0.0          ,""                                   ,"Width dependence of STCS")
        `MPRnb(STCSLW       ,0.0          ,""                                   ,"Area dependence of STCS")
        `MPRcz(THECSO       ,1.5          ,""                                   ,"Remote Coulomb scattering exponent at TR")
        `MPRnb(STTHECSO     ,0.0          ,""                                   ,"Temperature dependence of THECS")
        `MPRco(CSTHRO       ,2.0          ,""         ,1.0e-03     ,inf         ,"Remote Coulomb scattering threshold level")
        `MPRco(CSTHRBO      ,1.0          ,""         ,0.1         ,inf         ,"Remote Coulomb scattering threshold asymmetry parameter")
        `MPRcz(MUEO         ,0.0          ,"cm/MV"                              ,"Front channel mobility reduction coefficient at TR")
        `MPRnb(STMUEO       ,0.0          ,""                                   ,"Temperature dependence of MUE")
        `MPRcz(THEMUO       ,1.5          ,""                                   ,"Front channel mobility reduction exponent at TR")
        `MPRnb(STTHEMUO     ,0.0          ,""                                   ,"Temperature dependence of THEMU")
        `MPRnb(XCORO        ,0.0          ,""                                   ,"Geometry-independent part of non-universality factor")
        `MPRnb(XCORL        ,0.0          ,""                                   ,"Length dependence of XCOR")
        `MPRnb(XCORLEXP     ,1.0          ,""                                   ,"Exponent describing length dependence of XCOR")
        `MPRnb(XCORW        ,0.0          ,""                                   ,"Width dependence of XCOR")
        `MPRnb(XCORLW       ,0.0          ,""                                   ,"Area dependence of XCOR")
        `MPRnb(XCORBO       ,1.0          ,""                                   ,"Asymmetry term of non-universality factor")
        `MPRnb(STXCORO      ,0.0          ,""                                   ,"Temperature dependence of XCOR")
        `MPRcz(FETAO        ,1.0          ,""                                   ,"Effective field parameter")

        //  Series resistance parameters (for resistance modeling as part of intrinsic mobility reduction)
        `MPRnb(RSW1         ,30.0         ,"Ohm"                                ,"Source/Drain series resistance for channel width WEN at TR")
        `MPRnb(RSW2         ,0.0          ,""                                   ,"Higher-order width scaling of source/drain series resistance")
        `MPRcz(RSIGO        ,0.0          ,""                                   ,"Source/Drain extension resistance coefficient")
        `MPRnb(STRSO        ,0.0          ,""                                   ,"Temperature dependence of RS")
        `MPRco(RSGO         ,0.0          ,""         ,-0.5        ,inf         ,"Transverse electric field dependence of RS")
        `MPRnb(THERSGO      ,2.0          ,""                                   ,"Transverse electric field dependence exponent of RS")
        `MPRnb(RSBO         ,0.0          ,""                                   ,"Back bias dependence of RS")

        //  Velocity saturation parameters
        `MPRcz(THESATO      ,0.0          ,"s/m^2"                              ,"Geometry independent velocity saturation parameter at TR")
        `MPRnb(THESATL      ,0.0          ,"s/m^2"                              ,"Length dependence of THESAT")
        `MPRnb(THESATLEXP   ,1.0          ,""                                   ,"Exponent for length dependence of THESAT")
        `MPRnb(THESATW      ,0.0          ,""                                   ,"Width dependence of THESAT")
        `MPRnb(THESATLW     ,0.0          ,""                                   ,"Area dependence of THESAT")
        `MPRnb(STTHESATO    ,-0.1         ,""                                   ,"Geometry independent temperature dependence of THESAT")
        `MPRnb(STTHESATL    ,0.0          ,""                                   ,"Length dependence of STTHESAT")
        `MPRnb(STTHESATW    ,0.0          ,""                                   ,"Width dependence of STTHESAT")
        `MPRnb(STTHESATLW   ,0.0          ,""                                   ,"Area dependence of STTHESAT")
        `MPRco(THESATGO     ,0.0          ,""         ,-0.5        ,inf         ,"Front gate bias dependence of velocity saturation")
        `MPRco(THESATBO     ,0.0          ,""         ,-0.5        ,inf         ,"Back gate bias dependence of velocity saturation")

        //  Saturation voltage parameters
        `MPRnb(AXO          ,8.0          ,""                                   ,"Geometry independent linear/saturation transition exponent")
        `MPRcz(AXL          ,0.0          ,""                                   ,"Length dependence of AX")
        `MPRnb(AXLEXP       ,1.0          ,""                                   ,"Exponent for length dependence of AX")
        `MPRcz(AXL2         ,0.0          ,""                                   ,"Second order length dependence of AX")
        `MPRnb(AXLEXP2      ,1.5          ,""                                   ,"Exponent for second order length dependence of AX")

        //  Channel length modulation (CLM) parameters
        `MPRnb(ALPL1        ,0.0          ,""                                   ,"Length dependence of CLM pre-factor ALP")
        `MPRnb(ALPLEXP      ,1.0          ,""                                   ,"Exponent for length dependence of ALP")
        `MPRcz(ALPL2        ,0.0          ,""                                   ,"Second order length dependence of ALP")
        `MPRnb(ALPLEXP2     ,2.0          ,""                                   ,"Exponent for second order length dependence of ALP")
        `MPRnb(ALPW         ,0.0          ,""                                   ,"Width dependence of ALP")
        `MPRnb(ALP1L1       ,0.0          ,"V"                                  ,"Length dependence of CLM enhancement factor above threshold ALP1")
        `MPRnb(ALP1LEXP     ,0.5          ,""                                   ,"Exponent for length dependence of ALP1")
        `MPRcz(ALP1L2       ,0.0          ,""                                   ,"Second order length dependence of ALP1")
        `MPRnb(ALP1LEXP2    ,1.5          ,""                                   ,"Exponent for second order length dependence of ALP1")
        `MPRnb(ALP1W        ,0.0          ,""                                   ,"Width dependence of ALP1")
        `MPRnb(ALPBO        ,0.0          ,""                                   ,"Back bias dependence of channel length modulation")
        `MPRco(VPO          ,0.05         ,"V"       ,1.0e-10      ,inf         ,"CLM logarithm dependence factor")
        `MPRcz(VPGO         ,0.0          ,""                                   ,"Transverse electric field dependence of CLM logarithm factor")

        //  Gate current parameters
        `MPRcc(GCOO         ,0.0          ,""        ,-10.0        ,10.0        ,"Gate tunneling energy adjustment in inversion")
        `MPRcz(IGINVLW      ,0.0          ,"A"                                  ,"Gate to channel current pre-factor for a channel area of WEN.LEN")
        `MPRcz(IGOVINVW     ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor for a width of WEN in inversion")
        `MPRcz(IGOVINVDW    ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor for a width of WEN in inversion at drain side")
        `MPRcz(IGOVACCW     ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor for a width of WEN in accumulation")
        `MPRcz(IGOVACCDW    ,0.0          ,"A"                                  ,"Gate to overlap current pre-factor for a width of WEN in accumulation at drain side")
        `MPRnb(STIGO        ,0.0          ,""                                   ,"Temperature dependence of all gate currents")
        `MPRcc(GC2CHO       ,0.375        ,""        ,0.0          ,10.0        ,"Gate to channel current slope factor")
        `MPRcc(GC3CHO       ,0.063        ,""        ,-2.0         ,2.0         ,"Gate to channel current curvature factor")
        `MPRcc(GC2OVINVO    ,0.375        ,""        ,0.0          ,10.0        ,"Gate current slope factor for overlap regions in inversion mode")
        `MPRcc(GC3OVINVO    ,0.063        ,""        ,-2.0         ,2.0         ,"Gate current curvature factor for overlap regions in inversion mode")
        `MPRcc(GC2OVACCO    ,0.375        ,""        ,0.0          ,10.0        ,"Gate current slope factor for overlap regions in accumulation mode")
        `MPRcc(GC3OVACCO    ,0.063        ,""        ,-2.0         ,2.0         ," Gate current curvature factor for overlap regions in accumulation mode")
        `MPRnb(GCDOVL       ,0.0          ,"V^-1"                               ,"High drain voltage dependence of overlap gate current")
        `MPRnb(GCVDOVO      ,1.0          ,"V"                                  ,"Threshold of high drain voltage effect on overlap gate current")
        `MPRco(CHIBO        ,3.1          ,"V"       ,1.0          ,inf         ,"Tunneling barrier height")
        `MPRcz(NIGINVO      ,0.0          ,""                                   ,"Gate tunneling slope adjustment in subthreshold regime")
        `MPRcz(FNOVINVW     ,0.0          ,"A"                                  ,"Extra gate to overlap current pre-factor for a width of WEN in inversion")
        `MPRcz(FNOVINVDW    ,0.0          ,"A"                                  ,"Extra gate to overlap current pre-factor for a width of WEN in inversion at drain side")
        `MPRcc(GCOVINVFNO   ,0.2          ,""        ,0.1          ,10.0        ,"Extra gate current slope factor for overlap regions in inversion mode")
        `MPRnb(STIGFNO      ,0.0          ,""                                   ,"Temperature dependence of extra gate to overlap current")

        //  Gate Induced Drain/Source Leakage (GIDL/GISL) parameters
        `MPRnb(AGIDLO       ,0.0          ,"A/V^3"                              ,"GIDL geometry independent pre-factor")
        `MPRnb(AGIDLDO      ,0.0          ,"A/V^3"                              ,"GIDL geometry independent pre-factor at drain side")
        `MPRnb(AGIDLW       ,0.0          ,"A/V^3"                              ,"GIDL pre-factor for a width of WEN")
        `MPRnb(AGIDLDW      ,0.0          ,"A/V^3"                              ,"GIDL pre-factor for a width of WEN at drain side")
        `MPRcz(BGIDLO       ,41.0         ,"V"                                  ,"GIDL probability factor at TR")
        `MPRcz(BGIDLDO      ,41.0         ,"V"                                  ,"GIDL probability factor at TR at drain side")
        `MPRnb(STBGIDLO     ,0.0          ,"V/K"                                ,"Temperature dependence of BGIDL")
        `MPRnb(STBGIDLDO    ,0.0          ,"V/K"                                ,"Temperature dependence of BGIDL at drain side")
        `MPRnb(CGIDLO       ,0.0          ,"V^-1"                               ,"Substrate bias dependence of GIDL")
        `MPRnb(CGIDLDO      ,0.0          ,"V^-1"                               ,"Substrate bias dependence of GIDL at drain side")
        `MPRnb(DGIDLO       ,0.0          ,"V^-1"                               ,"High field geometry independent parameter of GIDL")
        `MPRnb(DGIDLDO      ,0.0          ,"V^-1"                               ,"High field geometry independent parameter of GIDL at drain side")
        `MPRnb(DGIDLL       ,0.0          ,"V^-1"                               ,"High longitudinal field parameter of GIDL")
        `MPRnb(DGIDLDL      ,0.0          ,"V^-1"                               ,"High longitudinal field parameter of GIDL at drain side")

        //  Impact Ionization parameters
        `MPRnb(A1O          ,1.0          ,""                                   ,"Geometry independent impact ionization pre-factor")
        `MPRnb(A1L          ,0.0          ,""                                   ,"Length dependence of A1")
        `MPRnb(A1W          ,0.0          ,""                                   ,"Width dependence of A1")
        `MPRcz(A2O          ,10.0         ,""                                   ,"Impact ionization exponent at TR")
        `MPRnb(STA2O        ,0.0          ,""                                   ,"Temperature dependence of A2")
        `MPRnb(A3O          ,1.0          ,""                                   ,"Geometry independent saturation-voltage dependence of II")
        `MPRnb(A3L          ,0.0          ,""                                   ,"Length dependence of A3")
        `MPRnb(A3W          ,0.0          ,""                                   ,"Width dependence of A3")

        //  Charge model parameters
        `MPRnb(CGBOVO       ,0.0          ,"F"                                  ,"Geometry independent gate-substrate overlap capacitance part")
        `MPRnb(CGBOVL       ,0.0          ,"F"                                  ,"Length dependent gate-substrate overlap capacitance part for a length of LEN")
        `MPRcc(NSDACO       ,1.0e22       ,"cm^-3"   ,1.0e18       ,1.0e22      ,"Source/Drain effective doping level for AC model")
        `MPRcz(FIFW         ,0.0          ,""                                   ,"Inner fringe capacitance prefactor for a width of WEN")
        `MPRcz(FSCEACO      ,0.0          ,""                                   ,"Short channel effect adjustment factor for charge model")
        `MPRcz(LOVO         ,0.0          ,"m"                                  ,"Overlap length for gate/source-drain hdd overlap capacitance")
        `MPRcz(LOVDO        ,0.0          ,"m"                                  ,"Overlap length for gate/drain hdd overlap capacitance")
        `MPRnb(COVDLO       ,0.0          ,""                                   ,"Overlap capacitance modulation coefficient due to Leff variation")
        `MPRnb(COVDLW       ,0.0          ,""                                   ,"Width dependence of COVDL")
        `MPRnb(COVDLBO      ,0.0          ,""                                   ,"Overlap capacitance modulation with back bias")
        `MPRnb(DVFBOVO      ,0.0          ,"V"                                  ,"Overlap capacitance flat-band voltage adjustment")
        `MPRnb(CFRO         ,0.0          ,"F"                                  ,"Corner related outer fringe capacitance")
        `MPRnb(CFRDO        ,0.0          ,"F"                                  ,"Corner related outer fringe capacitance at drain side")
        `MPRnb(CFRW         ,0.0          ,"F"                                  ,"Outer fringe capacitance per side for a width of WEN")
        `MPRnb(CFRDW        ,0.0          ,"F"                                  ,"Outer fringe capacitance per side for a width of WEN at drain side")
        `MPRcz(CSDO         ,1.0          ,""                                   ,"Drain-source capacitance correction factor")
        `MPRcz(CSDBPO       ,0.0          ,"F/m"                                ,"Drain/source to substrate perimeter capacitance")

        //  Self heating parameters
        `MPRcz(RTHO         ,1.0e05       ,"K/W"                                ,"Geometry independent thermal resistance")
        `MPRnb(RTHL         ,1.5          ,""                                   ,"Length dependence of RTH")
        `MPRnb(RTHW         ,3.0          ,""                                   ,"Width dependence of RTH")
        `MPRnb(RTHLW        ,4.5          ,""                                   ,"Area dependence of RTH")
        `MPRnb(STRTHO       ,0.0          ,""                                   ,"Temperature dependence of RTH")
        `MPRcz(CTHO         ,1.0e-12      ,"J/K"                                ,"Geometry independent thermal capacitance")
        `MPRco(LAMBTHO      ,1.0e-07      ,"m"       ,1.0e-09      ,inf         ,"Characteristic length of lateral thermal coupling for multifinger devices")
        `MPRcz(FTHO         ,0.0          ,""                                   ,"First neighbour thermal coupling factor for multifinger devices")

        //  Noise Parameters
        `MPRcz(FNTO         ,1.0          ,""                                   ,"Thermal noise coefficient")
        `MPRcz(FNTEXCL      ,0.0          ,""                                   ,"Length dependence coefficient of excess noise")
        `MPRnb(FNTEXCLEXP   ,2.0          ,""                                   ,"Length dependence exponent of excess noise")
        `MPRnb(NFALW        ,8.0e22       ,"V^-1/m^4"                           ,"First coefficient of flicker noise")
        `MPRnb(NFAW         ,0.0          ,"V^-1/m^4"                           ,"Long channel first coefficient of flicker noise")
        `MPRcz(NFBLW        ,3.0e07       ,"V^-1/m^2"                           ,"Second coefficient of flicker noise")
        `MPRcz(NFCLW        ,0.0          ,"V^-1"                               ,"Third coefficient of flicker noise")
        `MPRcc(NFEO         ,0.0          ,""        ,-1.0         ,1.0         ,"Flicker noise front transverse field effect coefficient")
        `MPRcc(NFEBO        ,0.0          ,""        ,-1.0         ,1.0         ,"Flicker noise back transverse field effect coefficient")
        `MPRco(EFO          ,1.0          ,""        ,0.1          ,inf         ,"Frequency coefficient of flicker noise")

        //  General Stress Model Parameters
        `MPIcc(SWSTRESS     ,1            ,""        ,0            ,2           ,"Stress model selection flag: 0=disable, 1=classical STI stress model, 2=strained channel stress model")
        `MPRco(SAREF        ,1.0e-06      ,"m"       ,1.0e-09      ,inf         ,"Reference distance between OD-edge and poly from one side")
        `MPRco(SBREF        ,1.0e-06      ,"m"       ,1.0e-09      ,inf         ,"Reference distance between OD-edge and poly from other side")

        //  Stress Model Parameters for SWSTRESS=1
        `MPRnb(WLOD         ,0.0          ,"m"                                  ,"Width parameter")
        `MPRnb(KUO          ,0.0          ,"m"                                  ,"Mobility degradation/enhancement coefficient")
        `MPRcc(KVSAT        ,0.0          ,""        ,-1.0         ,1.0         ,"Saturation velocity degradation/enhancement coefficient")
        `MPRnb(TKUO         ,0.0          ,""                                   ,"Temperature dependence of KUO")
        `MPRnb(LKUO         ,0.0          ,"m^LLODKUO"                          ,"Length dependence of KUO")
        `MPRnb(WKUO         ,0.0          ,"m^WLODKUO"                          ,"Width dependence of KUO")
        `MPRnb(PKUO         ,0.0          ,"m^(LLODKUO+WLODKUO)"                ,"Cross-term dependence of KUO")
        `MPRcz(LLODKUO      ,0.0          ,""                                   ,"Length parameter for UO stress effect")
        `MPRcz(WLODKUO      ,0.0          ,""                                   ,"Width parameter for UO stress effect")
        `MPRnb(KVTHO        ,0.0          ,"Vm"                                 ,"Threshold shift parameter")
        `MPRnb(LKVTHO       ,0.0          ,"m^LLODVTH"                          ,"Length dependence of KVTHO")
        `MPRnb(WKVTHO       ,0.0          ,"m^WLODVTH"                          ,"Width dependence of KVTHO")
        `MPRnb(PKVTHO       ,0.0          ,"m^(LLODVTH+WLODVTH)"                ,"Cross-term dependence of KVTHO")
        `MPRcz(LLODVTH      ,0.0          ,""                                   ,"Length parameter for VTH-stress effect")
        `MPRcz(WLODVTH      ,0.0          ,""                                   ,"Width parameter for VTH-stress effect")
        `MPRnb(STETAO       ,0.0          ,"m"                                  ,"Eta0 shift factor related to VTHO change")
        `MPRcz(LODETAO      ,1.0          ,""                                   ,"Eta0 shift modification factor for stress effect")

        //  Stress Model Parameters for SWSTRESS=2
        `MPRcc(STRLAMBDA    ,1.0e-07      ,"m"       ,1.0e-09      ,1.0e-05     ,"Relaxation characteristic length")
        `MPRco(STRALPHA     ,3.0          ,""        ,0.5          ,inf         ,"Asymmetry parameter")
        `MPRnb(STRDVFBO     ,0.0          ,"V"                                  ,"Threshold shift parameter")
        `MPRnb(STRWDVFBO    ,0.0          ,""                                   ,"Width dependence of threshold shift parameter")
        `MPRnb(STRDCFL      ,0.0          ,""                                   ,"DIBL variation parameter")
        `MPRnb(STRRUO       ,0.0          ,""                                   ,"Mobility degradation/enhancement coefficient")
        `MPRnb(STRTRUO      ,0.0          ,""                                   ,"Temperature dependence of mobility degradation/enhancement coefficient")
        `MPRnb(STRRVSAT     ,0.0          ,""                                   ,"Saturation velocity degradation/enhancement coefficient")


// XYCE HACK:  Add a  multiplicity parameter "M".  Xyce does not do
// implicit multiplicity.
        `IPIcz(M           ,1          ,""                                   ,"multiplicity factor")


    //  Variables
    // *********************************************************************************************************************

        //  Variables for model initializing
        integer SWSHE_i;
        real TKR, TKD;

        //  Clipped instance parameters
        real W_i, ASOURCE_i, ADRAIN_i, PSOURCE_i, PDRAIN_i, MULT_i;

        //  Clipped local parameters including temperature dependence
        real TOX1_i, VFB1_i, CIC1_i, PSCE1_i, CF1_i, BETN1_i, THESAT1_i;
        real TOX2_i, VFB2_i, CIC2_i, PSCE2_i, CF2_i, BETN2_i, THESAT2_i;
        real TSI_i, XGE_i, TYPECH_i, NCH_i, TYPESUB_i, NSUB_i, NOV_i, NOVD_i, STVFB_i, NSDDC_i, PSCEDLB_i, PNCE_i, STCF_i, CFD_i, CFDL_i, CFDLB_i, STBET_i, MUE_i, STMUE_i;
        real THEMU_i, STTHEMU_i, CS_i, CSFI_i, CSBI_i, STCS_i, THECS_i, STTHECS_i, CSTHR_i, CSTHRB_i, STXCOR_i, FETA_i, RS_i, RSIG_i, STRS_i;
        real RSG_i, THERSG_i, RSB_i, CT_i, TOXP_i, XCOR_i, XCORB_i, THESAT_i, STTHESAT_i, AX_i, ALP_i, ALP1_i, ALPB_i, VP_i, VPG_i;
        real GCO_i, IGINV_i, IGOVINV_i, IGOVINVD_i, IGOVACC_i, IGOVACCD_i, STIG_i, STIGFN_i, FNOVINV_i, FNOVINVD_i;
        real GC2CH_i, GC3CH_i, GC2OVINV_i, GC3OVINV_i, GC2OVACC_i, GC3OVACC_i, GCDOV_i, GCVDOV_i, CHIB_i, NIGINV_i, GCOVINVFN_i;
        real AGIDL_i, AGIDLD_i, BGIDL_i, BGIDLD_i, STBGIDL_i, STBGIDLD_i, CGIDL_i, CGIDLD_i, DGIDL_i, DGIDLD_i;
        real A1_i, A2_i, STA2_i, A3_i;
        real AREAQ_i, CGBOV_i, NSDAC_i, FIF_i, FSCEAC_i, COV_i, COVD_i, COVDL_i, COVDLB_i, DVFBOV_i, CFR_i, CFRD_i, CSD_i, CSDBP_i;
        real RTH_i, STRTH_i, CTH_i, FNT_i, FNTEXC_i, NFA_i, NFB_i, NFC_i, NFE_i, NFEB_i, EF_i;

        //  Clipped local parameters including scaling effect
        real PSCE_p, CF_p, BETN_p, PNCE_p, CS_p, RS_p, THESAT_p, AX_p, ALP_p, ALP1_p, AGIDL_p, AGIDLD_p, A1_p, A3_p;
        real CGBOV_p, CFR_p, CFRD_p, RTH_p, CTH_p, NFA_p;

        //  Clipped local parameters without temperature dependence
        real VFB1_t, CF1_t, BETN1_t;
        real VFB2_t, CF2_t, BETN2_t;
        real MUE_t, THEMU_t;
        real CS_t, THECS_t, RS_t;
        real XCOR_t, THESAT_t;
        real IGINV_t, IGOVINV_t, IGOVINVD_t, IGOVACC_t, IGOVACCD_t, FNOVINV_t, FNOVINVD_t;
        real BGIDL_t, BGIDLD_t;
        real A2_t;
        real RTH_t;

        //  Internal variables used in the global scaling part 
        real LEN, WEN, iL, iW, delLPS, delWOD, LE, WE, LEcv, WEcv, iLE, iWE, iAE, lphy, wphy, lambda_LE, GPE, GWE, GE, gamAX;

        //  Internal variables used in the initializeInstance part
        real temp, temp1, temp2, temp3, temp4;
        real TKC, TKC_sq, DTC, dT, rT, rTn, phit0, inv_phit0, phit, inv_phit, invNF, one_m_xge, epsch, EgSi, EgGe;
        real dEg, Eg, Eg_2phit0, Eg_2phit, dVfbch, niratio, Cox1Init, Cox2Init, Cox1Prime, Cox2Prime, dVfb1Nch, dVfb2Nch, CsiPrime_0, k1_1D, k2_1D, keq_1D;
        real Ceq_1D, neff, neff_sub, A0_Csisq, xth_1D, xSDdep, dVfbQM, qq, tsisq, Gfsub, Gfsub2, inv_Gfsub2, xisub, inv_xisub, margin_sub;
        real xb_sub, xn_sub, GOV, GOV2, xi_ov, x_mrg_ov, inv_xi_ov;
        real inv_xg1, fmue, inv_qi1cs, inv_qi2cs, eta_mu, one_m_eta, frs, sat_phit;
        real alp1_phit, inv_CHIB, tempM, BCH, BOV, GCQCH, GCQOVINV, GCQOVACC, alpha_b, Dch, Dov, n_iginv, area_phit, inner_sd, xsd, fif_phit;
        real lambda2D, lnrTn, tf_bet, tf_mue, tf_themu, tf_cs, tf_thecs, tf_xcor, tf_ther, tf_thesat, tf_ig, tf_rth, nt, nt0, fac_exc;

        //  Internal variables used in the evaluateStatic and evaluateDynamic parts
        real Vgsu, Vdsu, Vsbu, Vsdu, Vgdu, Vdbu;
        real Vgs, Vds, Vsb, sigVds, Vgb, xdsx, dxdsx, CsiPrime, keq, xd, xg2eff;
        real A0, exp_dxth, dxth, diff_min, Dx_WI, Dx_WIsq, deltaxinf, dinf, inv_dinf, deltaxi, gamma, wd;
        real xgs_ovcv, xgd_ovcv, xgs_ov, xgd_ov, xd0, keq_1D_QM, Dx_WI_1D, x_WI_1D, x_1D, xedge, dleff;
        real dxg1_dibl, xg1, e1, tox1fact, k1_1D_QM, k1, inv_k1, xg10, sce1, xg1x, x1_WI0, s1, q1s, q1d, k1q1s, k1q1d, q1chapinf;
        real dxg2_dibl, xg2, e2, tox2fact, k2_1D_QM, k2, inv_k2, xg20, sce2, xg2x, x2_WI0, s2, q2s, q2d, k2q2s, k2q2d, q2chapinf;
        real qsqs, qis, vs, ps_cub, qs_cub, racs, deltaxsats, qidsats, sums, dqsqs_dxn_qi, dqis_dxn_qi, xdrifts, ds;
        real qsqd, qid, vd, pd_cub, qd_cub, racd, deltaxsatd, qidsatd, sumd, dqsqd_dxn_qi, dqid_dxn_qi, xdriftd, dd;
        real Aexp1s, Aexp1d, a1s, a1d, b1s, b1d, esurf1s, ecpl1s, eeff1s, qi1s, c1s, Gmob1s;
        real Aexp2s, Aexp2d, a2s, a2d, b2s, b2d, esurf2s, ecpl2s, eeff2s, qi2s, c2s, Gmob2s;
        real esurf1d, ecpl1d, eeff1d, esurf1, ecpl1, eeff1, qi1m, c1, Gmob1, qmfact1, wsat1, sat_fact1;
        real esurf2d, ecpl2d, eeff2d, esurf2, ecpl2, eeff2, qi2m, c2, Gmob2, qmfact2, wsat2, sat_fact2;
        real Gcss, frscsi, Grss, Gmobs, betneff, Gcs, Grs, qidsat, deltaxsat, xndssat, xdeff, qim, fcors, fcor;
        real Gmob, csum, dxdrift, inv_qimstar1, r1, dL_L, GdL, dL1_L, FdL, Ggamma, sqrt_zsat, zsat, vsat_fact, hsat, Gvsat, qmfact;
        real Ls, Ld, Us, Ud, idrift2, norm_Ids, fact_Ids, Ids;
        real k1q1m, delta_k1q1, q1s_chap, q1d_chap, zeta1, ksi1, inv_k1h1_0, inv_k1h1, prod1, k1q1eff, k1q1deff;
        real k2q2m, delta_k2q2, q2s_chap, q2d_chap, zeta2, ksi2, inv_k2h2_0, inv_k2h2, prod2, k2q2eff, k2q2deff;
        real xs_ov, xd_ov, xs_ovcv, xd_ovcv, Vovs, Vovd, Vovscv, Vovdcv, Vtovs, Vtovd;
        real arg2mina, psi_t, zg, arg1, Dsi, Dgate, TP, TP2, igoveff, igovefffowler, gc2oveff, gc3oveff, gcqoveff, half_x_ds, Vm, q1m, Voxm, x_m;
        real Igc0, igc, igcd_h, u0, x, u0_div_H, Ag, Bg, xsq, inv_x, ex, inv_ex;
        real xeffs, xeffd, xstars, xstard, lambdaf, lambdab, xalphaf, xalphab, xedgefs, xedgefd, xedgebs, xedgebd;
        real Igsov, Igdov, Igc, Igcs, Igcd, Igs, Igd, Ithpwr, Ithrc, Igidl, Igisl;
        real Idse, Igse, Igde, Igidle, Igisle, Ithpwre, Ithrce;
        real Qg, Qb, Qd, Qs;
        real Qgse, Qgde, Qovs, Qovd, Qgbe, Qdse, Qdsub, Qssub, Qth, Qgsif, Qgdif, Qbsif, Qbdif;

        //  Internal variables used in the stress model
        real tmpa, tmpb, iloop, Invsa, Invsb, Invsaref, Invsbref, Lx, Wx, templ, tempw;
        real Kstressu0, rhobeta, rhobetaref, Kstressvth0, temp0, str_g, str_gref, ruo;

        //  Internal variables used in the noise model
        real Nunit, dm, qimstar, Nstar, Nmstar, DeltaN, Sids_fl, t1, sqrt_t2, t2, r, lc, lcinv2, g_ideal, t2x12, gSid, sqrt_zsatexc;
        real Sidexc, Sids_th, COX_qm, CGeff, CSGeff, CDGeff, gSig, SigR_th, migid, cigid2, Sids_th_u, Sigs_sh, Sigd_sh, Sids_sh;

        //  Internal variables used in the surface potentials and inversion charge calculation routines
        real q_temp1, q_temp2, q_temp3, q_x1sat, q_x2sat, q_x1_WI, q_x2_WI, q_x1, q_x2, q_k1q1, q_Aexp, q_qsq, q_d1_qsq;
        real q_d2_qsq, q_rac_qsq, q_qcoth, q_d1_qcoth, q_invexpq, q_d2_qcoth, q_sh_term, q_ln_term, q_d1_ln, q_d2_ln;
        real q_expnum, q_d1_expnum, q_d2_expnum, q_lnexpnum, q_d1_lnexpnum, q_d2_lnexpnum, q_q2_int, q_d1_q2, q_d2_q2, q_qi_int;
        real q_d1_qi, q_d2_qi, q_zero, q_d1_zero, q_d2_zero, q_eps1, q_eps2, q_k2q2, q_a, q_b, q_c, q_disc, q_delta, q_dx1;

        //  Internal variables used in the substrate depletion calculation routines
        real nu, mutau;
        real SPSUB_temp, SPSUB_temp1, SPSUB_temp2, SPSUB_xgb, SPSUB_delta, SPSUB_yg, SPSUB_ysub, SPSUB_eta, SPSUB_a, SPSUB_b;
        real SPSUB_c, SPSUB_tau, SPSUB_y0, SPSUB_delta0, SPSUB_delta1, SPSUB_xi0, SPSUB_xi1, SPSUB_xi2, SPSUB_pC, SPSUB_qC;
        real SPSUB_xg1, SPSUB_A_fac, SPSUB_xbar, SPSUB_w, SPSUB_x1, SPSUB_bx, SPSUB_x0;

        //  Internal variables used in the overlap surface potential calculation routines
        real SP_OV_ygf, SP_OV_z, SP_OV_eta, SP_OV_a, SP_OV_c, SP_OV_tau, SP_OV_nu, SP_OV_mutau, SP_OV_temp;
        real SP_OV_y0, SP_OV_D0, SP_OV_p, SP_OV_q, SP_OV_xi, SP_OV_w, SP_OV_Afac, SP_OV_xbar, SP_OV_x0, SP_OV_u;

        //  Internal variables used in Impact Ionization calculation
        real delVsat, mavl, Iimpact, shot_iavl;

        //  Gmin variable
        real gmin;

        //  Variables for operating point (.op)
        `ifdef OP_CALC
            real r1init_op, r2init_op, x1init_op, x2init_op, xth1init_op, xth2init_op, xg1thinit_op, vthinit_op;
            real inv_phit0_op, EgSi_op, EgGe_op, dEg_op, Eg_op, Eg_2phit0_op, dVfbch_op, neff_op, inv_phit_op;
            real A0_Csisq_op, xth_1D_op, xSDdep_op, CF1_op, CF2_op, xd0_op, qq_op, VFB1_op, VFB2_op;
            real xd_op, xdsx_op, dxdsx_op, xg10_op, xg20_op, xg2eff_op, e1_op, e2_op, CsiPrime_op;
            real k1_1D_QM_op, k2_1D_QM_op, keq_1D_QM_op, Dx_WI_1D_op, x_WI_1D_op, x_1D_op;
            real dleff_op, xedge_op, sce1_op, sce2_op, dxg1_dibl_op, dxg2_dibl_op, xg1_op, xg2_op, xg2x_op, k1_op, k2_op;
            real A0_op, exp_dxth_op, dxth_op, diff_min_op, r1_op, r2_op, x1sat_op, x2sat_op, xth1_op, xth2_op, xg1th_op;
            real Vdsat, qde, qge, qbe;
            `OPP(type              ,""             ,"Flag for channel type")
            `OPP(vds               ,"V"            ,"Internal drain-source DC voltage (NMOS convention)")
            `OPP(vsb               ,"V"            ,"Internal source-bulk DC voltage (NMOS convention)")
            `OPP(vgs               ,"V"            ,"Internal gate-source DC voltage (NMOS convention)")
            `OPP(vth               ,"V"            ,"Threshold voltage")
            `OPP(vth_drive         ,"V"            ,"Effective gate drive voltage, including back bias, drain bias effects and self-heating")
            `OPP(vdsat             ,"V"            ,"Drain saturation voltage at the given bias")
            `OPP(vdsat_marg        ,"V"            ,"Vds voltage margin")
            `OPP(id                ,"A"            ,"Total DC drain current flowing into drain terminal")
            `OPP(ig                ,"A"            ,"Total DC gate current flowing into gate terminal")
            `OPP(is                ,"A"            ,"Total DC source current flowing into source terminal")
            `OPP(ib                ,"A"            ,"Total DC bulk current flowing into bulk terminal")
            `OPP(ids               ,"A"            ,"DC channel current, excluding tunnel, GISL and GIDL currents")
            `OPP(igidl             ,"A"            ,"DC Gate Induced Drain Leakage current")
            `OPP(igisl             ,"A"            ,"DC Gate Induced Source Leakage current")
            `OPP(igs               ,"A"            ,"DC gate-source leakage current")
            `OPP(igd               ,"A"            ,"DC gate-drain leakage current")
            `OPP(idb               ,"A"            ,"DC drain-bulk current")
            `OPP(isb               ,"A"            ,"DC source-bulk current")
            `OPP(gm                ,"A/V"          ,"Internal DC transconductance")
            `OPP(gmb               ,"A/V"          ,"Internal DC bulk transconductance")
            `OPP(gds               ,"A/V"          ,"Internal DC output conductance")
            `OPP(cgg               ,"F"            ,"Internal AC gate capacitance, including overlap capacitances")
            `OPP(cgd               ,"F"            ,"Internal AC gate-drain transcapacitance, including overlap capacitances")
            `OPP(cgs               ,"F"            ,"Internal AC gate-source transcapacitance, including overlap capacitances")
            `OPP(cgb               ,"F"            ,"Internal AC gate-bulk transcapacitance")
            `OPP(cdd               ,"F"            ,"Internal AC drain capacitance")
            `OPP(cdg               ,"F"            ,"Internal AC drain-gate transcapacitance")
            `OPP(cds               ,"F"            ,"Internal AC drain-source transcapacitance")
            `OPP(cdb               ,"F"            ,"Internal AC drain-bulk transcapacitance")
            `OPP(cbb               ,"F"            ,"Internal AC bulk capacitance")
            `OPP(cbg               ,"F"            ,"Internal AC bulk-gate transcapacitance")
            `OPP(cbs               ,"F"            ,"Internal AC bulk-source transcapacitance")
            `OPP(cbd               ,"F"            ,"Internal AC bulk-drain transcapacitance")
            `OPP(css               ,"F"            ,"Internal AC source capacitance")
            `OPP(csg               ,"F"            ,"Internal AC source-gate transcapacitance")
            `OPP(csb               ,"F"            ,"Internal AC source-bulk transcapacitance")
            `OPP(csd               ,"F"            ,"Internal AC source-drain transcapacitance")
            `OPP(tk                ,"K"            ,"MOSFET device temperature")
            `OPP(dtsh              ,"K"            ,"MOSFET device temperature increase due to self-heating")
            `OPP(self_gain         ,""             ,"Internal L-UTSOI model self gain")
            `OPP(rout              ,"Ohm"          ,"AC output resistance")
            `OPP(beff              ,"A/V^2"        ,"Gain factor in saturation")
            `OPP(ft                ,"Hz"           ,"Unity gain frequency at the given bias")
            `OPP(rgate             ,"Ohm"          ,"MOS gate resistance (intrinsic input resistance)")
            `OPP(gmoverid          ,"1/V"          ,"Gm over Id")
            `OPP(vearly            ,"V"            ,"Equivalent Early voltage")
        `endif

    //  Analog block
    // *********************************************************************************************************************
    analog begin

        //  Initialize Model
        //  **************************************************************************************************************
`ifdef insideADMS
        @(initial_model)
`endif
        begin : initializeModel

            // *********** Transistor temperature ***********
                TKR        =  273.15 + TR;
                TKD        =  min($temperature, 1000.0);

            // *********** Flag for self-heating effect ***********
                if (((SWSCALE == 0) && (RTH > 0.0)) || ((SWSCALE > 0) && (RTHO > 0.0))) begin
                    SWSHE_i    =  SWSHE;
                end else begin
                    SWSHE_i    =  0;
                end

            // *********** Gmin definition ***********
                gmin    =  $simparam("gmin",0.0);

        end    // initializeModel

        //  Initialize Instance
        //  **************************************************************************************************************
`ifdef insideADMS
        @(initial_instance)
`endif
        begin : initializeInstance

            // *********** Initializing channel temperature ***********
                DTC        =  0.0;
                TKC        =  TKD;
                TKC_sq     =  TKC * TKC;
                dT         =  TKC - TKR;
                rT         =  TKC / TKR;
                rTn        =  TKR / TKC;
                phit0      =  TKC * `KBOL_QELE;
                inv_phit0  =  1.0 / phit0;

            // *********** Calculation of local parameters ***********
                if (SWSCALE == 0) begin    //  Local mode
                    //  Instance parameters used in local mode
                    ADRAIN_i   =  ADRAIN;
                    ASOURCE_i  =  ASOURCE;
                    PDRAIN_i   =  PDRAIN;
                    PSOURCE_i  =  PSOURCE;
                    MULT_i     =  MULT;
                    //  Process parameters
                    TOX1_i     =  TOXE;
                    TSI_i      =  TSI;
                    XGE_i      =  XGE;
                    TOX2_i     =  TBOX;
                    TYPECH_i   =  1.0;         // P-type thin film
                    if (NCH < 0) begin         // N-type thin film
                        TYPECH_i   = -1.0;
                    end
                    NCH_i      =  min(abs(NCH), 1.0e19) * 1.0e6;
                    TYPESUB_i  =  1.0;         // P-type substrate
                    if (NSUB < 0) begin        // N-type thin film
                        TYPESUB_i  = -1.0;
                    end
                    NSUB_i     =  min(max(abs(NSUB), 1.0e16), 1.0e21) * 1.0e6;
                    CT_i       =  CT;
                    TOXP_i     =  TOXP;
                    NOV_i      =  NOV * 1.0e6;
                    NOVD_i     =  NOVD * 1.0e6;
                    VFB1_t     =  VFB;
                    VFB2_t     =  VFBB;
                    STVFB_i    =  STVFB;
                    //  Gate to interface coupling parameters
                    CIC1_i     =  CICF;
                    CIC2_i     =  CIC;
                    PSCE1_i    =  PSCE;
                    PSCE2_i    =  PSCEB * PSCE1_i * TOX2_i / TOX1_i;
                    NSDDC_i    =  NSDDC * 1.0e6;
                    PSCEDLB_i  =  PSCEDLB;
                    PNCE_i     =  PNCE;
                    //  DIBL parameters
                    CF1_t      =  CF;
                    CF2_t      =  CFB * CF1_t * TOX2_i / TOX1_i;
                    STCF_i     =  STCF;
                    CFD_i      =  CFD;
                    CFDL_i     =  CFDL;
                    CFDLB_i    =  CFDLB;
                    //  Mobility parameters
                    BETN1_t    =  BETN;
                    BETN2_t    =  BETNB * BETN1_t;
                    STBET_i    =  STBET;
                    CS_t       =  CS;
                    CSFI_i     =  CSFI;
                    CSBI_i     =  CSBI;
                    STCS_i     =  STCS;
                    THECS_t    =  THECS;
                    STTHECS_i  =  STTHECS;
                    CSTHR_i    =  CSTHR;
                    CSTHRB_i   =  CSTHRB;
                    MUE_t      =  MUE;
                    STMUE_i    =  STMUE;
                    THEMU_t    =  THEMU;
                    STTHEMU_i  =  STTHEMU;
                    XCOR_t     =  XCOR;
                    XCORB_i    =  XCORB;
                    STXCOR_i   =  STXCOR;
                    FETA_i     =  FETA;
                    //  Series resistance parameters
                    RS_t       =  RS;
                    RSIG_i     =  RSIG;
                    STRS_i     =  STRS;
                    RSG_i      =  RSG;
                    THERSG_i   =  THERSG;
                    RSB_i      =  RSB;
                    //  Velocity saturation parameters
                    THESAT_t   =  THESAT;
                    STTHESAT_i =  STTHESAT;
                    THESAT1_i  =  THESATG;
                    THESAT2_i  =  THESATB;
                    //  Saturation voltage parameters
                    AX_i       =  AX;
                    //  Channel length modulation (CLM) parameters
                    ALP_i      =  ALP;
                    ALP1_i     =  ALP1;
                    ALPB_i     =  ALPB;
                    VP_i       =  VP;
                    VPG_i      =  VPG;
                    //  Gate current parameters
                    GCO_i      =  GCO;
                    IGINV_t    =  IGINV;
                    IGOVINV_t  =  IGOVINV;
                    IGOVINVD_t =  IGOVINVD;
                    FNOVINV_t  =  FNOVINV;
                    FNOVINVD_t =  FNOVINVD;
                    IGOVACC_t  =  IGOVACC;
                    IGOVACCD_t =  IGOVACCD;
                    STIG_i     =  STIG;
                    STIGFN_i   =  STIGFN;
                    GC2CH_i    =  GC2CH;
                    GC3CH_i    =  GC3CH;
                    GC2OVINV_i =  GC2OVINV;
                    GCOVINVFN_i =  GCOVINVFN;
                    GC3OVINV_i =  GC3OVINV;
                    GC2OVACC_i =  GC2OVACC;
                    GC3OVACC_i =  GC3OVACC;
                    GCDOV_i    =  GCDOV;
                    GCVDOV_i   =  GCVDOV;
                    CHIB_i     =  CHIB;
                    NIGINV_i   =  NIGINV;
                    //  Gate Induced Drain/Source Leakage (GIDL/GISL) parameters
                    AGIDL_i    =  AGIDL;
                    AGIDLD_i   =  AGIDLD;
                    BGIDL_t    =  BGIDL;
                    BGIDLD_t   =  BGIDLD;
                    STBGIDL_i  =  STBGIDL;
                    STBGIDLD_i =  STBGIDLD;
                    CGIDL_i    =  CGIDL;
                    CGIDLD_i   =  CGIDLD;
                    DGIDL_i    =  DGIDL;
                    DGIDLD_i   =  DGIDLD;
                    //  Impact ionization parameters
                    A1_i       =  A1;
                    A2_t       =  A2;
                    STA2_i     =  STA2;
                    A3_i       =  A3;
                    //  Charge model parameters
                    AREAQ_i    =  AREAQ;
                    CGBOV_i    =  CGBOV;
                    NSDAC_i    =  NSDAC * 1.0e6;
                    FIF_i      =  FIF;
                    FSCEAC_i   =  FSCEAC;
                    COV_i      =  COV;
                    COVD_i     =  COVD;
                    COVDL_i    =  COVDL;
                    COVDLB_i   =  COVDLB;
                    DVFBOV_i   =  DVFBOV;
                    CFR_i      =  CFR;
                    CFRD_i     =  CFRD;
                    CSD_i      =  CSD;
                    CSDBP_i    =  CSDBP;
                    //  Self heating parameters
                    RTH_t      =  RTH;
                    STRTH_i    =  STRTH;
                    CTH_i      =  CTH;
                    //  Noise model parameters
                    FNT_i      =  FNT;
                    FNTEXC_i   =  FNTEXC;
                    NFA_i      =  NFA;
                    NFB_i      =  NFB;
                    NFC_i      =  NFC;
                    NFE_i      =  NFE;
                    NFEB_i     =  NFEB;
                    EF_i       =  EF;
                end else begin    //  Global mode
                    //  Clipping of instance parameters used only in global mode
                    invNF      =  1.0 / NF;
                    W_i        =  max(W * invNF, 1.0e-9);
                    //  Instance parameters used in local mode
                    ADRAIN_i   =  ADRAIN * invNF;
                    ASOURCE_i  =  ASOURCE * invNF;
                    PDRAIN_i   =  PDRAIN * invNF;
                    PSOURCE_i  =  PSOURCE * invNF;
                    MULT_i     =  MULT * NF;
                    //  Scaling parameters
                    LEN        =  1.0e-6;
                    WEN        =  1.0e-6;
                    iL         =  LEN / L;
                    iW         =  WEN / W_i;
                    delLPS     =  LVARO * (1.0 + LVARL * iL) * (1.0 + LVARW * iW);
                    delWOD     =  WVARO * (1.0 + WVARW * iW) * (1.0 + WVARL * iL);
                    LE         =  max((L + delLPS - 2.0 * LAP), 1.0e-9);
                    WE         =  max((W_i + delWOD - 2.0 * WOT), 1.0e-9);
                    LEcv       =  max((L + delLPS - 2.0 * LAP + DLQ), 1.0e-9);
                    WEcv       =  max((W_i + delWOD - 2.0 * WOT + DWQ), 1.0e-9);
                    iLE        =  LEN / LE;
                    iWE        =  WEN / WE;
                    iAE        =  iLE * iWE;
                    temp       =  max((L + delLPS), 1.0e-9);
                    lphy       =  temp / LEN;
                    temp       =  max((W_i + delWOD), 1.0e-9);
                    wphy       =  temp / WEN;
                    //  Process parameters
                    TOX1_i     =  TOXEO;
                    TSI_i      =  TSIO;
                    XGE_i      =  XGEO;
                    TOX2_i     =  TBOXO;
                    TYPECH_i   =  1.0;          // P-type thin film
                    if (NCHO < 0) begin         // N-type thin film
                        TYPECH_i   = -1.0;
                    end
                    NCH_i      =  min(abs(NCHO), 1.0e19) * 1.0e6;
                    TYPESUB_i  =  1.0;          // P-type substrate
                    if (NSUBO < 0) begin        // N-type thin film
                        TYPESUB_i  = -1.0;
                    end
                    NSUB_i     =  min(max(abs(NSUBO), 1.0e16), 1.0e21) * 1.0e6;
                    CT_i       =  CTO;
                    TOXP_i     =  TOXPO;
                    NOV_i      =  NOVO * 1.0e6;
                    NOVD_i     =  NOVDO * 1.0e6;
                    temp       =  VFBL * pow(iLE, VFBLEXP) / (1.0 + VFBL2 * pow(iLE, VFBLEXP2));
                    VFB1_t     =  VFBO + temp + VFBW * iWE + VFBLW * iAE;
                    VFB2_t     =  VFBBO + VFBLBO * TOX2_i / TOX1_i * temp;
                    STVFB_i    =  STVFBO * (1.0 + STVFBL * iLE) * (1.0 + STVFBW * iWE) * (1.0 + STVFBLW * iAE);
                    //  Gate to interface coupling parameters
                    CIC1_i     =  CICFO;
                    CIC2_i     =  CICO;
                    one_m_xge  =  1.0 - XGE_i;
                    epsch      = `EPSSI * one_m_xge + `EPSGE * XGE_i;
                    lambda_LE  =  sqrt(epsch / `EPSOX * TSI_i * (TOX1_i + 4.0e-10)) / LE;
                    PSCE_p     =  PSCEL * 2.0 * pow(lambda_LE, PSCELEXP) * (1.0 + PSCEW * iWE);
                    PSCE1_i    =  min(max(PSCE_p, 0.0), 5.0);
                    PSCE2_i    =  PSCEBO * PSCE1_i * TOX2_i / TOX1_i;
                    NSDDC_i    =  NSDDCO * 1.0e6;
                    PSCEDLB_i  =  PSCEDLBO;
                    PNCE_p     =  PNCEW * iWE;
                    PNCE_i     =  min(max(PNCE_p, -1.0), 1.0);
                    //  DIBL parameters
                    temp       =  pow(lambda_LE, CFLEXP) * (1.0 + CFW * iWE);
                    CF_p       =  CFL * temp;
                    CF1_t      =  max(CF_p, 0.0);
                    CF2_t      =  CFBO * CF1_t * TOX2_i / TOX1_i;
                    STCF_i     =  STCFL * temp;
                    CFD_i      =  CFDO;
                    CFDL_i     =  CFDLL * iLE / max(1.0 + CFDLW * iWE, 1.0e-3);
                    CFDLB_i    =  CFDLBO;
                    //  Mobility parameters
                    temp1      = -LE / (LP1 * max(1.0 + LP1W * iWE, 1.0e-3));
                    `linmin_exp(temp1,temp2)
                    temp3      = -LE / LP2;
                    `linmin_exp(temp3,temp4)
                    GPE        =  max(1.0 + FBET1 * (1.0 + FBET1W * iWE) * (temp2 - 1.0) / temp1 + FBET2 * (temp4 - 1.0) / temp3, 1.0e-6);
                    GWE        =  max(1.0 + BETW1 * iWE + BETW2 * iWE * ln(1.0 + WE / WBET), 1.0e-6);
                    GE         =  UO / GPE * GWE;
                    BETN_p     =  GE * WE / LE;
                    BETN1_t    =  max(BETN_p, 1.0e-10);
                    BETN2_t    =  BETNBO * BETN1_t;
                    STBET_i    =  STBETO * (1.0 + STBETL * iLE) * (1.0 + STBETW * iWE) * (1.0 + STBETLW * iAE);
                    CS_p       =  (CSO + CSL * pow(iLE, CSLEXP)) * (1.0 + CSW * iWE) * (1.0 + CSLW * iAE);
                    CS_t       =  max(CS_p, 0.0);
                    CSFI_i     =  CSFIO;
                    CSBI_i     =  CSBIO;
                    STCS_i     =  STCSO * (1.0 + STCSL * iLE) * (1.0 + STCSW * iWE) * (1.0 + STCSLW * iAE);
                    THECS_t    =  THECSO;
                    STTHECS_i  =  STTHECSO;
                    CSTHR_i    =  CSTHRO;
                    CSTHRB_i   =  CSTHRBO;
                    MUE_t      =  MUEO;
                    STMUE_i    =  STMUEO;
                    THEMU_t    =  THEMUO;
                    STTHEMU_i  =  STTHEMUO;
                    XCOR_t     =  (XCORO + XCORL * pow(iLE, XCORLEXP)) * (1.0 + XCORW * iWE) * (1.0 + XCORLW * iAE);
                    XCORB_i    =  XCORBO;
                    STXCOR_i   =  STXCORO;
                    FETA_i     =  FETAO;
                    //  Series resistance parameters
                    RS_p       =  RSW1 * iWE * (1.0 + RSW2 * iWE);
                    RS_t       =  max(RS_p, 0.0);
                    RSIG_i     =  RSIGO;
                    STRS_i     =  STRSO;
                    RSG_i      =  RSGO;
                    THERSG_i   =  THERSGO;
                    RSB_i      =  RSBO;
                    //  Velocity saturation parameters
                    THESAT_p   =  GE * (THESATO + THESATL * pow(iLE, THESATLEXP)) * (1.0 + THESATW * iWE) * (1.0 + THESATLW * iAE);
                    THESAT_t   =  max(THESAT_p, 0.0);
                    STTHESAT_i =  STTHESATO * (1.0 + STTHESATL * iLE) * (1.0 + STTHESATW * iWE) * (1.0 + STTHESATLW * iAE);
                    THESAT1_i  =  THESATGO;
                    THESAT2_i  =  THESATBO;
                    //  Saturation voltage parameters
                    AX_p       =  AXO / (1.0 + AXL * pow(iLE, AXLEXP) / (1.0 + AXL2 * pow(iLE, AXLEXP2)));
                    AX_i       =  min(max(AX_p, 1.0), 16.0);
                    //  Channel length modulation (CLM) parameters
                    ALP_p      =  ALPL1 * pow(iLE, ALPLEXP) * (1.0 + ALPW * iWE) / (1.0 + ALPL2 * pow(iLE, ALPLEXP2));
                    ALP_i      =  max(ALP_p, 0.0);
                    ALP1_p     =  ALP1L1 * pow(iLE, ALP1LEXP) * (1.0 + ALP1W * iWE) / (1.0 + ALP1L2 * pow(iLE, ALP1LEXP2));
                    ALP1_i     =  max(ALP1_p, 0.0);
                    ALPB_i     =  ALPBO;
                    VP_i       =  VPO;
                    VPG_i      =  VPGO;
                    //  Gate current parameters
                    GCO_i      =  GCOO;
                    IGINV_t    =  IGINVLW / iAE;
                    IGOVINV_t  =  IGOVINVW / iWE;
                    IGOVINVD_t =  IGOVINVDW / iWE;
                    FNOVINV_t  =  FNOVINVW / iWE;
                    FNOVINVD_t =  FNOVINVDW / iWE;
                    IGOVACC_t  =  IGOVACCW / iWE;
                    IGOVACCD_t =  IGOVACCDW / iWE;
                    STIG_i     =  STIGO;
                    STIGFN_i   =  STIGFNO;
                    GC2CH_i    =  GC2CHO;
                    GC3CH_i    =  GC3CHO;
                    GC2OVINV_i =  GC2OVINVO;
                    GCOVINVFN_i =  GCOVINVFNO;
                    GC3OVINV_i =  GC3OVINVO;
                    GC2OVACC_i =  GC2OVACCO;
                    GC3OVACC_i =  GC3OVACCO;
                    GCDOV_i    =  GCDOVL * iLE;
                    GCVDOV_i   =  GCVDOVO;
                    CHIB_i     =  CHIBO;
                    NIGINV_i   =  NIGINVO;
                    //  Gate Induced Drain/Source Leakage (GIDL/GISL) parameters
                    AGIDL_p    =  AGIDLO + AGIDLW / iWE;
                    AGIDL_i    =  max(AGIDL_p, 0.0);
                    AGIDLD_p   =  AGIDLDO + AGIDLDW / iWE;
                    AGIDLD_i   =  max(AGIDLD_p, 0.0);
                    BGIDL_t    =  BGIDLO;
                    BGIDLD_t   =  BGIDLDO;
                    STBGIDL_i  =  STBGIDLO;
                    STBGIDLD_i =  STBGIDLDO;
                    CGIDL_i    =  CGIDLO;
                    CGIDLD_i   =  CGIDLDO;
                    DGIDL_i    =  DGIDLO + DGIDLL * iLE;
                    DGIDLD_i   =  DGIDLDO + DGIDLDL * iLE;
                    //  Impact ionization parameters
                    A1_p       =  A1O * (1.0 + A1L * iLE) * (1.0 + A1W * iWE);
                    A1_i       =  max(A1_p, 0.0);
                    A2_t       =  A2O;
                    STA2_i     =  STA2O;
                    A3_p       =  A3O * (1.0 + A3L * iLE) * (1.0 + A3W * iWE);
                    A3_i       =  max(A3_p, 0.0);
                    //  Charge model parameters
                    AREAQ_i    =  WEcv * LEcv;
                    CGBOV_p    =  CGBOVO + CGBOVL * lphy;
                    CGBOV_i    =  max(CGBOV_p, 0.0);
                    NSDAC_i    =  NSDACO * 1.0e6;
                    FIF_i      =  FIFW * WEcv / WEN;
                    FSCEAC_i   =  FSCEACO;
                    temp       = `EPSOX / TOX1_i * WEcv;
                    COV_i      =  temp * LOVO;
                    COVD_i     =  temp * LOVDO;
                    COVDL_i    =  COVDLO / max(1.0 + COVDLW * WEN / WEcv, 1.0e-3);
                    COVDLB_i   =  COVDLBO;
                    DVFBOV_i   =  DVFBOVO;
                    CFR_p      =  CFRO + CFRW * wphy;
                    CFR_i      =  max(CFR_p, 0.0);
                    CFRD_p     =  CFRDO + CFRDW * wphy;
                    CFRD_i     =  max(CFRD_p, 0.0);
                    CSD_i      =  CSDO * epsch * TSI_i * WE / LE;
                    CSDBP_i    =  CSDBPO;
                    //  Self heating parameters
                    temp       =  max(1.0 + RTHL * lphy + RTHW * wphy + RTHLW * lphy * wphy, 1.0e-10);
                    temp1      =  0.0;
                    if ((NF > 1.0) && (SD > 0.0)) begin
                        temp2  = -(SD + L) / LAMBTHO;
                        `lin_exp(temp2, temp3)
                        temp4  =  1.0 - temp3;
                        temp1  =  2.0 * FTHO * temp3 * (temp4 - (1.0 - pow(temp3, NF)) / NF) / (temp4 * temp4);
                    end
                    temp       =  temp / (1.0 + temp1);
                    RTH_p      =  RTHO / temp;
                    RTH_t      =  max(RTH_p, 1.0e-6);
                    STRTH_i    =  STRTHO;
                    CTH_p      =  CTHO * temp;
                    CTH_i      =  max(CTH_p, 0.0);
                    //  Noise model parameters
                    FNT_i      =  FNTO;
                    FNTEXC_i   =  FNTEXCL * BETN_p * BETN_p * iWE * iWE * pow(iLE, FNTEXCLEXP - 2.0);
                    NFA_p      =  NFALW * iAE + NFAW * iWE;
                    NFA_i      =  max(NFA_p, 0.0);
                    NFB_i      =  NFBLW * iAE;
                    NFC_i      =  NFCLW * iAE;
                    NFE_i      =  NFEO;
                    NFEB_i     =  NFEBO;
                    EF_i       =  EFO;
                    //  Stress model
                    if ((SWSTRESS > 0) && (SA > 0.0) && (SB > 0.0) && ((NF == 1.0) || ((NF > 1.0) && (SD > 0.0)))) begin
                        if (SWSTRESS == 1) begin
                            tmpa       =  0.0;
                            tmpb       =  0.0;
                            iloop      =  0.0;
                            while (iloop < (NF - 0.5)) begin
                                tmpa       =  tmpa + 1.0 / (SA + 0.5 * L + iloop * (SD + L));
                                tmpb       =  tmpb + 1.0 / (SB + 0.5 * L + iloop * (SD + L));
                                iloop      =  iloop + 1.0;
                            end
                            Invsa      =  tmpa / NF;
                            Invsb      =  tmpb / NF;
                            Invsaref   =  1.0 / (SAREF + 0.5 * L);
                            Invsbref   =  1.0 / (SBREF + 0.5 * L);
                            Lx         =  max(L + delLPS, 1.0e-9);
                            Wx         =  max(W_i + delWOD + WLOD, 1.0e-9);
                            templ      =  1.0 / pow(Lx, LLODKUO);
                            tempw      =  1.0 / pow(Wx, WLODKUO);
                            Kstressu0  =  (1.0 + LKUO * templ + WKUO * tempw + PKUO * templ * tempw) * (1.0 + TKUO * (rT - 1.0));
                            rhobeta    =  KUO * (Invsa + Invsb) / Kstressu0;
                            rhobetaref =  KUO * (Invsaref + Invsbref) / Kstressu0;
                            templ      =  1.0 / pow(Lx, LLODVTH);
                            tempw      =  1.0 / pow(Wx, WLODVTH);
                            Kstressvth0 =  max(1.0 + LKVTHO * templ + WKVTHO * tempw + PKVTHO * templ * tempw, 1e-20);
                            temp0      =  Invsa + Invsb - Invsaref - Invsbref;
                            // Stress effect on mobility
                            BETN_p     =  BETN_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                            BETN1_t    =  max(BETN_p, 1.0e-10);
                            BETN2_t    =  BETNBO * BETN1_t;
                            // Stress effect on saturation velocity
                            THESAT_p   =  THESAT_p * (1.0 + rhobeta) * (1.0 + KVSAT * rhobetaref) / ((1.0 + rhobetaref) * (1.0  + KVSAT * rhobeta));
                            THESAT_t   =  max(THESAT_p, 0.0);
                            // Stress effect on threshold voltage
                            VFB1_t     =  VFB1_t + KVTHO * temp0 / Kstressvth0;
                            VFB2_t     =  VFB2_t + KVTHO * temp0 / Kstressvth0;
                            // Stress effect on DIBL
                            CF_p       =  CF_p + STETAO * temp0 / pow(Kstressvth0, LODETAO);
                            CF1_t      =  max(CF_p, 0.0);
                            CF2_t      =  CFBO * CF1_t * TOX2_i / TOX1_i;
                        end else begin
                            tmpa       =  0.0;
                            iloop      =  0.0;
                            temp       = -1.0 / STRALPHA;
                            while (iloop < (NF - 0.5)) begin
                                `linmin_exp((-(SA + 0.5 * L + iloop * (SD + L)) / STRLAMBDA), temp1)
                                `linmin_exp((-(SB + 0.5 * L + (NF - 1.0 - iloop) * (SD + L)) / STRLAMBDA), temp2)
                                temp3      =  pow(1.0 - temp1, -STRALPHA);
                                temp4      =  pow(1.0 - temp2, -STRALPHA);
                                tmpa       =  tmpa + pow(0.5 * (temp3 + temp4), temp);
                                iloop      =  iloop + 1.0;
                            end
                            str_g      =  1.0 - tmpa / NF;
                            `linmin_exp((-(SAREF + 0.5 * L) / STRLAMBDA), temp1)
                            `linmin_exp((-(SBREF + 0.5 * L) / STRLAMBDA), temp2)
                            temp3      =  pow(1.0 - temp1, -STRALPHA);
                            temp4      =  pow(1.0 - temp2, -STRALPHA);
                            str_gref   =  1.0 - pow(0.5 * (temp3 + temp4), temp);
                            Wx         =  max(W_i + delWOD + WLOD, 1.0e-9);
                            ruo        =  STRRUO / (1.0 + STRTRUO * (rT - 1.0));
                            rhobeta    =  ruo * str_g;
                            rhobetaref =  ruo * str_gref;
                            temp0      =  str_g - str_gref;
                            Kstressvth0 =  max(1.0 + STRWDVFBO * Wx / WEN, 1.0e-20);
                            // Stress effect on mobility
                            BETN_p     =  BETN_p * (1.0 + rhobeta) / (1.0 + rhobetaref);
                            BETN1_t    =  max(BETN_p, 1.0e-10);
                            BETN2_t    =  BETNBO * BETN1_t;
                            // Stress effect on saturation velocity
                            THESAT_p   =  THESAT_p * (1.0 + rhobeta) * (1.0 + STRRVSAT * rhobetaref) / ((1.0 + rhobetaref) * (1.0 + STRRVSAT * rhobeta));
                            THESAT_t   =  max(THESAT_p, 0.0);
                            // Stress effect on threshold voltage
                            VFB1_t     =  VFB1_t + STRDVFBO * temp0 / Kstressvth0;
                            VFB2_t     =  VFB2_t + STRDVFBO * temp0 / Kstressvth0;
                            // Stress effect on DIBL
                            CF_p       =  CF_p + STRDCFL * temp0 * pow(lambda_LE, CFLEXP) * (1.0 + CFW * iWE);
                            CF1_t      =  max(CF_p, 0.0);
                            CF2_t      =  CFBO * CF1_t * TOX2_i / TOX1_i;
                        end
                    end
                end

            // *********** Source/drain symmetrization ***********
                if (SWJUNASYM == 0) begin
                    NOVD_i     =  NOV_i;
                    IGOVINVD_t =  IGOVINV_t;
                    FNOVINVD_t =  FNOVINV_t;
                    IGOVACCD_t =  IGOVACC_t;
                    AGIDLD_i   =  AGIDL_i;
                    BGIDLD_t   =  BGIDL_t;
                    STBGIDLD_i =  STBGIDL_i;
                    CGIDLD_i   =  CGIDL_i;
                    DGIDLD_i   =  DGIDL_i;
                    COVD_i     =  COV_i;
                    CFRD_i     =  CFR_i;
                end

            // *********** Local process parameters ***********
                one_m_xge  =  1.0 - XGE_i;
                epsch      = `EPSSI * one_m_xge + `EPSGE * XGE_i;
                EgSi       = `EG0SI - `ALPHASI * TKC_sq / (`BETASI + TKC);
                EgGe       = `EG0GE - `ALPHAGE * TKC_sq / (`BETAGE + TKC);
                dEg        =  (EgGe - EgSi + `CG * one_m_xge) * XGE_i;
                Eg         =  EgSi + dEg;
                Eg_2phit0  =  0.5 * Eg * inv_phit0;
                niratio    =  1.0 / (1.0 + sqrt(10.0 * XGE_i));
                dVfbch     =  0.05 * XGE_i - 0.5 * dEg;
                temp       = `QELE * NCH_i * 0.5 * TSI_i / `EPSOX;
                if (TYPECH_i > 0) begin        // P-type thin film
                    dVfb1Nch   =  temp * (TOX1_i + QMC * 4.0e-10);
                    dVfb2Nch   =  temp * (TOX2_i + QMC * 4.0e-10);
                end else begin                // N-type thin film
                    dVfb1Nch   = -temp * (TOX1_i + QMC * 4.0e-10);
                    dVfb2Nch   = -temp * (TOX2_i + QMC * 4.0e-10);
                end
                temp       =  sqrt(TKC * `INV300);
                temp1      = `NIFACT300 * temp * temp * temp;
                neff       =  temp1 * niratio * exp(-Eg_2phit0);
                neff_sub   =  temp1 * exp(-0.5 * EgSi * inv_phit0);
                Cox1Init   = `EPSOX / TOX1_i;
                Cox2Init   = `EPSOX / TOX2_i;
                if (PNCE_i > 0) begin
                    Cox1Prime  =  Cox1Init * (1.0 + PNCE_i);
                    Cox2Prime  =  Cox2Init;
                end else begin
                    Cox1Prime  =  Cox1Init;
                    Cox2Prime  =  Cox2Init * (1.0 - PNCE_i);
                end
                CsiPrime_0 =  epsch / TSI_i;
                phit       =  phit0 * (1.0 + CT_i * rTn);
                inv_phit   =  1.0 / phit;
                Eg_2phit   =  0.5 * Eg * inv_phit;

            // *********** Interface coupling effects ***********
                k1_1D      =  Cox1Prime / CsiPrime_0;
                k2_1D      =  Cox2Prime / CsiPrime_0;
                keq_1D     =  1.0 / (1.0 + 1.0 / k1_1D + 1.0 / k2_1D);
                Ceq_1D     =  CsiPrime_0 * keq_1D;
                A0_Csisq   =  2.0 * `QELE * neff * epsch * inv_phit;
                xth_1D     =  ln((CsiPrime_0 * CsiPrime_0) / A0_Csisq) - `LN2;
                xSDdep     =  0.5 * `QELE * NSDDC_i * TSI_i / (Cox1Prime + Cox2Prime) * inv_phit;

            // *********** DIBL effect ***********
                temp       =  STCF_i * dT;
                CF1_i      =  CF1_t + temp;
                CF2_i      =  CF2_t + temp;
                xd0        =  CFD_i * inv_phit;

            // *********** Substrate parameters ***********
                Gfsub      =  sqrt(2.0 * `QELE * NSUB_i * `EPSSI * inv_phit0) / Ceq_1D;
                Gfsub2     =  Gfsub * Gfsub;
                inv_Gfsub2 =  1.0 / Gfsub2;
                xisub      =  1.0 + Gfsub / `SQRT2;
                inv_xisub  =  1.0 / xisub;
                margin_sub =  1.0e-5 * xisub;
                xb_sub     =  ln(NSUB_i / neff_sub);
                xn_sub     =  2.0 * xb_sub;
                if (SWSUBDEP > 0) begin
                    VFB2_t     =  VFB2_t + TYPESUB_i * phit0 * xb_sub;
                end

            // *********** QM corrections ***********
                dVfbQM     =  0.0;
                qq         =  0.0;
                tsisq      =  1.0e18 * TSI_i * TSI_i;
                if (QMC > 0.0) begin
                    if (TYPE == `NMOS) begin
                        dVfbQM     =  0.409618895 / tsisq;
                        qq         =  0.4 * QMC * `QMN * exp(-`INV3 * ln(phit * tsisq));
                    end else begin
                        dVfbQM     =  0.723134895 / tsisq;
                        qq         =  0.4 * QMC * `QMP * exp(-`INV3 * ln(phit * tsisq));
                    end
                end
                temp       =  TYPE * STVFB_i * dT + dVfbQM;
                VFB1_i     =  TYPE * (VFB1_t + dVfbch + dVfb1Nch) + temp + DELVTO;
                VFB2_i     =  TYPE * (VFB2_t + dVfbch + dVfb2Nch) + temp;

            // *********** Mobility parameters ***********
                lnrTn      =  ln(rTn);
                tf_bet     =  exp(STBET_i * lnrTn) * FACTUO;
                BETN1_i    =  BETN1_t * tf_bet;
                BETN2_i    =  BETN2_t * tf_bet;
                tf_mue     =  exp(STMUE_i * lnrTn);
                MUE_i      =  MUE_t * tf_mue;
                tf_themu   =  exp(STTHEMU_i * lnrTn);
                THEMU_i    =  THEMU_t * tf_themu;
                tf_cs      =  exp(STCS_i * lnrTn);
                CS_i       =  CS_t * tf_cs;
                tf_thecs   =  exp(STTHECS_i * lnrTn);
                THECS_i    =  THECS_t * tf_thecs;
                tf_xcor    =  exp(STXCOR_i * lnrTn);
                XCOR_i     =  XCOR_t * tf_xcor;
                temp       =  1.0e-8 * phit / TSI_i;
                fmue       =  temp * MUE_i;
                inv_qi1cs  =  1.0 / (`QI_TH * CSTHR_i);
                inv_qi2cs  =  inv_qi1cs / CSTHRB_i;
                if (TYPE == `NMOS) begin
                    eta_mu     =  0.5 * FETA_i;
                end else begin
                    eta_mu     =  `INV3 * FETA_i;
                end
                one_m_eta  =  1.0 - eta_mu;

            // *********** Series resistance ***********
                tf_ther    =  exp(STRS_i * lnrTn);
                RS_i       =  RS_t * tf_ther;
                frs        =  2.0 * RS_i * phit;

            // *********** Velocity saturation ***********
                gamAX      =  exp(0.375 * ln(exp(16.0 / AX_i * `LN2) - 1.0)) - 1.0;
                tf_thesat  =  exp(STTHESAT_i * lnrTn);
                THESAT_i   =  THESAT_t * tf_thesat * tf_bet;
                sat_phit   =  THESAT_i * phit;

            // *********** Channel length modulation ***********
                alp1_phit  =  ALP1_i * inv_phit;

            // *********** Gate current ***********
                tf_ig      =  exp(-STIG_i * lnrTn);
                IGINV_i    =  IGINV_t * tf_ig;
                IGOVINV_i  =  IGOVINV_t * tf_ig;
                IGOVINVD_i =  IGOVINVD_t * tf_ig;
                IGOVACC_i  =  IGOVACC_t * tf_ig;
                IGOVACCD_i =  IGOVACCD_t * tf_ig;
                tf_ig      =  exp(-STIGFN_i * lnrTn);
                FNOVINV_i  =  FNOVINV_t * tf_ig;
                FNOVINVD_i =  FNOVINVD_t * tf_ig;
                inv_CHIB   =  1.0 / CHIB_i;
                tempM      =  4.0 * `INV3 * sqrt(2.0 * `QELE * `MELE * CHIB_i) / `HBAR;
                BCH        =  tempM * TOXP_i;
                BOV        =  tempM * TOXP_i;
                GCQCH      =  0.0;
                if (GC3CH_i < 0.0) begin
                    GCQCH      = -0.495 * GC2CH_i / GC3CH_i;
                end
                GCQOVINV   =  0.0;
                if (GC3OVINV_i < 0.0) begin
                    GCQOVINV   = -0.495 * GC2OVINV_i / GC3OVINV_i;
                end
                GCQOVACC   =  0.0;
                if (GC3OVACC_i < 0.0) begin
                    GCQOVACC   = -0.495 * GC2OVACC_i / GC3OVACC_i;
                end
                alpha_b    =  0.5 * Eg;
                Dch        =  GCO_i * phit;
                Dov        =  GCO_i * phit0;
                n_iginv    =  1.0 / (1.0 + NIGINV_i * Eg_2phit);

            // *********** GIDL/GISL current ***********
                temp       =  4.0e-18 / (TOXP_i * TOXP_i);
                AGIDL_i    =  AGIDL_i * temp;
                AGIDLD_i   =  AGIDLD_i * temp;
                temp       =  TOXP_i * 5.0e8;
                tempM      = `MAX_FUNC(1.0 + STBGIDL_i * dT, 0.0, 0.01);
                BGIDL_i    =  BGIDL_t * tempM * temp;
                tempM      = `MAX_FUNC(1.0 + STBGIDLD_i * dT, 0.0, 0.01);
                BGIDLD_i   =  BGIDLD_t * tempM * temp;

            // *********** Impact Ionization ***********
                A2_i       =  A2_t * exp(-STA2_i * lnrTn);

            // *********** Charge model parameters ***********
                area_phit  =  AREAQ_i * phit;
                inner_sd   =  0.25 * `QELE * NSDAC_i / (epsch * phit);
                xsd        =  ln(NSDAC_i / neff);
                fif_phit   =  FIF_i * 1.25e-6 * phit;
                lambda2D   =  sqrt(epsch / `EPSOX * TSI_i * (TOX1_i + 4.0e-10));

            // *********** Thermal resistance ***********
                tf_rth     =  exp(STRTH_i * lnrTn);
                RTH_i      =  RTH_t * tf_rth;

            // *********** Noise ***********
                nt         =  FNT_i * 4.0 * `KBOL * TKC;
                nt0        =  nt;
                fac_exc    = `MELE * 1.0e12 * FNTEXC_i;

        end    // initializeInstance

        //  Calculation of All Currents
        //  **************************************************************************************************************
        begin : evaluateStatic

            // *********** Bias affectation ***********
                if (TYPE == `NMOS) begin
                    Vgsu       =  V(G, S);
                    Vdsu       =  V(D, S);
                    Vsbu       =  V(S, B);
                end else begin
                    Vgsu       = -V(G, S);
                    Vdsu       = -V(D, S);
                    Vsbu       = -V(S, B);
                end

            // *********** Unswapped biases ***********
                Vsdu       = -Vdsu;
                Vgdu       =  Vgsu + Vsdu;
                Vdbu       =  Vdsu + Vsbu;

            // *********** Source-drain interchange ***********
                if (Vdsu < 0.0) begin
                    sigVds     = -1.0;
                    Vds        =  Vsdu;
                    Vgs        =  Vgdu;
                    Vsb        =  Vdbu;
                end else begin
                    sigVds     =  1.0;
                    Vds        =  Vdsu;
                    Vgs        =  Vgsu;
                    Vsb        =  Vsbu;
                end
                Vgb        =  Vgs + Vsb;

            // *********** Recalculation of temperature dependent variables in case of self heating ***********
                if (SWSHE_i > 0) begin
                    DTC        =  Temp(THPWR);
                    // Channel temperature
                    TKC        =  TKD + DTC;
                    TKC_sq     =  TKC * TKC;
                    dT         =  TKC - TKR;
                    rT         =  TKC / TKR;
                    rTn        =  TKR / TKC;
                    phit0      =  TKC * `KBOL_QELE;
                    inv_phit0  =  1.0 / phit0;
                    // Local process parameters
                    EgSi       = `EG0SI - `ALPHASI * TKC_sq / (`BETASI + TKC);
                    EgGe       = `EG0GE - `ALPHAGE * TKC_sq / (`BETAGE + TKC);
                    dEg        = (EgGe - EgSi + `CG * one_m_xge) * XGE_i;
                    Eg         =  EgSi + dEg;
                    Eg_2phit0  =  0.5 * Eg * inv_phit0;
                    dVfbch     =  0.05 * XGE_i - 0.5 * dEg;
                    temp       =  sqrt(TKC * `INV300);
                    temp1      = `NIFACT300 * temp * temp * temp;
                    neff       =  temp1 * niratio * exp(-Eg_2phit0);
                    phit       =  phit0 * (1.0 + CT_i * rTn);
                    inv_phit   =  1.0 / phit;
                    Eg_2phit   =  0.5 * Eg * inv_phit;
                    // Interface coupling effects
                    A0_Csisq   =  2.0 * `QELE * neff * epsch * inv_phit;
                    xth_1D     =  ln((CsiPrime_0 * CsiPrime_0) / A0_Csisq) - `LN2;
                    xSDdep     =  0.5 * `QELE * NSDDC_i * TSI_i / (Cox1Prime + Cox2Prime) * inv_phit;
                    // DIBL effect
                    temp       =  STCF_i * dT;
                    CF1_i      =  CF1_t + temp;
                    CF2_i      =  CF2_t + temp;
                    xd0        =  CFD_i * inv_phit;
                    // QM corrections
                    qq         =  0.0;
                    if (QMC > 0.0) begin
                        if (TYPE == `NMOS) begin
                            qq         =  0.4 * QMC * `QMN * exp(-`INV3 * ln(phit * tsisq));
                        end else begin
                            qq         =  0.4 * QMC * `QMP * exp(-`INV3 * ln(phit * tsisq));
                        end
                    end
                    temp       =  TYPE * STVFB_i * dT + dVfbQM;
                    VFB1_i     =  TYPE * (VFB1_t + dVfbch + dVfb1Nch) + temp + DELVTO;
                    VFB2_i     =  TYPE * (VFB2_t + dVfbch + dVfb2Nch) + temp;
                    // Mobility parameters
                    lnrTn      =  ln(rTn);
                    tf_bet     =  exp(STBET_i * lnrTn) * FACTUO;
                    BETN1_i    =  BETN1_t * tf_bet;
                    BETN2_i    =  BETN2_t * tf_bet;
                    tf_mue     =  exp(STMUE_i * lnrTn);
                    MUE_i      =  MUE_t * tf_mue;
                    tf_themu   =  exp(STTHEMU_i * lnrTn);
                    THEMU_i    =  THEMU_t * tf_themu;
                    tf_cs      =  exp(STCS_i * lnrTn);
                    CS_i       =  CS_t * tf_cs;
                    tf_thecs   =  exp(STTHECS_i * lnrTn);
                    THECS_i    =  THECS_t * tf_thecs;
                    tf_xcor    =  exp(STXCOR_i * lnrTn);
                    XCOR_i     =  XCOR_t * tf_xcor;
                    temp       =  1.0e-8 * phit / TSI_i;
                    fmue       =  temp * MUE_i;
                    // Series resistance
                    tf_ther    =  exp(STRS_i * lnrTn);
                    RS_i       =  RS_t * tf_ther;
                    frs        =  2.0 * RS_i * phit;
                    // Velocity saturation
                    tf_thesat  =  exp(STTHESAT_i * lnrTn);
                    THESAT_i   =  THESAT_t * tf_thesat * tf_bet;
                    sat_phit   =  THESAT_i * phit;
                    // Channel length modulation
                    alp1_phit  =  ALP1_i * inv_phit;
                    // Gate current
                    tf_ig      =  exp(-STIG_i * lnrTn);
                    IGINV_i    =  IGINV_t * tf_ig;
                    IGOVINV_i  =  IGOVINV_t * tf_ig;
                    IGOVINVD_i =  IGOVINVD_t * tf_ig;
                    IGOVACC_i  =  IGOVACC_t * tf_ig;
                    IGOVACCD_i =  IGOVACCD_t * tf_ig;
                    tf_ig      =  exp(-STIGFN_i * lnrTn);
                    FNOVINV_i  =  FNOVINV_t * tf_ig;
                    FNOVINVD_i =  FNOVINVD_t * tf_ig;
                    alpha_b    =  0.5 * Eg;
                    Dch        =  GCO_i * phit;
                    Dov        =  GCO_i * phit0;
                    n_iginv    =  1.0 / (1.0 + NIGINV_i * Eg_2phit);
                    // GIDL/GISL current
                    temp       =  TOXP_i * 5.0e8;
                    tempM      = `MAX_FUNC(1.0 + STBGIDL_i * dT, 0.0, 0.01);
                    BGIDL_i    =  BGIDL_t * tempM * temp;
                    tempM      = `MAX_FUNC(1.0 + STBGIDLD_i * dT, 0.0, 0.01);
                    BGIDLD_i   =  BGIDLD_t * tempM * temp;
                    // Impact Ionization
                    A2_i       =  A2_t * exp(-STA2_i * lnrTn);
                    // Charge model parameters
                    area_phit  =  AREAQ_i * phit;
                    inner_sd   =  0.25 * `QELE * NSDAC_i / (epsch * phit);
                    xsd        =  ln(NSDAC_i / neff);
                    fif_phit   =  FIF_i * 1.25e-6 * phit;
                    // Thermal resistance
                    tf_rth     =  exp(STRTH_i * lnrTn);
                    RTH_i      =  RTH_t * tf_rth;
                    // Noise
                    nt         =  FNT_i * 4.0 * `KBOL * TKC;
                end

            // *********** Conditioning of terminal voltages ***********
                xd         =  Vds * inv_phit;
                xdsx       =  (sqrt(Vds * Vds + 0.01) - 0.1) * inv_phit;
                dxdsx      =  0.5 * (xd - xdsx);
                xg10       =  (Vgs - VFB1_i) * inv_phit - dxdsx;
                xg20       =  (-Vsb - VFB2_i) * inv_phit - dxdsx;
                // For overlap current and charge
                xgs_ov     = -Vgsu * inv_phit0;
                xgd_ov     = -Vgdu * inv_phit0;
                temp       =  TYPE * DVFBOV_i * inv_phit0 + Eg_2phit0;
                xgs_ovcv   =  xgs_ov + temp;
                xgd_ovcv   =  xgd_ov + temp;

            // *********** Substrate depletion effect ***********
                if (SWSUBDEP > 0) begin
                    temp       =  TYPE * TYPESUB_i;
                    temp1      =  temp * xg10;
                    temp2      =  temp * xg20;
                    `spsub(temp3, temp1, temp2, xn_sub)
                    xg2eff     =  temp * (temp3 + temp2);
                end else begin
                    xg2eff     =  xg20;
                end

            // *********** Quantum mechanical corrections below threshold ***********
                temp       =  keq_1D * (xg10 - xg2eff);
                if (QMC > 0.0) begin
                    e1         = `MAX_FUNC(temp, 15.0, 225.0);
                    e2         = `MAX_FUNC(-temp, 15.0, 225.0);
                    temp1      =  qq * exp(-`INV3 * ln(e1));
                    temp2      =  qq * exp(-`INV3 * ln(e2));
                    temp3      =  1.0 - temp1 - temp2;
                    CsiPrime   =  CsiPrime_0 / temp3;
                    tox1fact   =  1.0 + k1_1D * temp1;
                    tox2fact   =  1.0 + k2_1D * temp2;
                    k1_1D_QM   =  k1_1D * temp3 / tox1fact;
                    k2_1D_QM   =  k2_1D * temp3 / tox2fact;
                    keq_1D_QM  =  1.0 / (1.0 + 1.0 / k1_1D_QM + 1.0 / k2_1D_QM);
                    tox1fact   =  1.0 + k1_1D_QM * temp1;
                    tox2fact   =  1.0 + k2_1D_QM * temp2;
                end else begin
                    CsiPrime   =  CsiPrime_0;
                    k1_1D_QM   =  k1_1D;
                    k2_1D_QM   =  k2_1D;
                    keq_1D_QM  =  keq_1D;
                    tox1fact   =  1.0;
                    tox2fact   =  1.0;
                end

            // *********** Short channel effects ***********
                Dx_WI_1D   =  keq_1D_QM * (xg10 - xg2eff);
                if (Dx_WI_1D > 0.0) begin
                    `ln_one_plus_exp(-Dx_WI_1D, temp)
                    x_WI_1D    =  xg10 - Dx_WI_1D / k1_1D_QM + temp - `LN2;
                end else begin
                    `ln_one_plus_exp(Dx_WI_1D, temp)
                    x_WI_1D    =  xg2eff + Dx_WI_1D / k2_1D_QM + temp - `LN2;
                end
                x_1D       = `MIN_FUNC(x_WI_1D, xth_1D, 4.0);
                // For short channel effects
                dleff      =  sqrt(1.0 + 2.0 * (xth_1D - x_1D) / xSDdep) - 1.0;
                xedge      =  x_1D + xSDdep * dleff;
                temp       = `MAX_FUNC(1.0 + PSCEDLB_i * xg20, 0.5, 0.01);
                sce1       =  1.0 / (1.0 + PSCE1_i * temp);
                sce2       =  1.0 / (1.0 + PSCE2_i * temp);
                // For DIBL
                temp       =  2.0 * xd0 * (sqrt(1.0 + xdsx / xd0) - 1.0) * (1.0 + CFDL_i * dleff) * (1.0 + CFDLB_i * xg20);
                dxg1_dibl  =  CF1_i * temp;
                dxg2_dibl  =  CF2_i * temp;
                // For drain current and intrinsic charge models
                xg1        =  (xg10 - xedge + dxg1_dibl) * sce1 + xedge + dxdsx;
                xg2        =  (xg2eff - xedge + dxg2_dibl) * sce2 + xedge + dxdsx;
                xg1x       = `MIN_FUNC(xg2 + CIC1_i * (xg1 - xg2), `XSAT_MAX, 0.01);
                xg2x       = `MIN_FUNC(xg1 + CIC2_i * (xg2 - xg1), `XSAT_MAX, 0.01);

            // *********** Coupling factors ***********
                k1         =  k1_1D_QM / sce1;
                k2         =  k2_1D_QM / sce2;
                inv_k1     =  1.0 / k1;
                inv_k2     =  1.0 / k2;
                keq        =  1.0 / (1.0 + inv_k1 + inv_k2);
                A0         =  A0_Csisq / (CsiPrime * CsiPrime);
                exp_dxth   =  (1.0 + k1) / (1.0 + k2);
                dxth       =  ln(exp_dxth);
                if (dxth > 1.0e-8) begin
                    diff_min   =  2.0 * dxth * (exp_dxth + 1.0) / (exp_dxth - 1.0);
                end else begin
                    diff_min   =  2.0 * (2.0 + dxth);
                end
                Dx_WI      =  keq * (xg1x - xg2x);
                Dx_WIsq    =  Dx_WI * Dx_WI;
                x1_WI0     =  xg1x - Dx_WI * inv_k1;
                x2_WI0     =  xg2x + Dx_WI * inv_k2;

            // *********** Inversion charge at source side ***********
                `func_q(xg1x, xg2x, 0.0, q1s, q2s)
                `func_qi(xg1x, xg2x, 0.0, q1s, q2s, qis, k1q1s, k2q2s, qsqs, Aexp1s, Aexp2s)
                // Calculation of (dqsq/dxn)/qi and xdrift at source side
                a1s        =  0.0;
                a2s        =  0.0;
                b1s        =  0.0;
                b2s        =  0.0;
                sums       =  0.0;
                dqsqs_dxn_qi =  0.0;
                if (qis > `QI_LOW) begin
                    b1s        =  Aexp1s * inv_k1;
                    b2s        =  Aexp2s * inv_k2;
                    a1s        =  b1s + 2.0 * k1q1s;
                    a2s        =  b2s + 2.0 * k2q2s;
                    sums       =  2.0 * qis + b1s + b2s;
                    if (abs(qsqs) > 0.005) begin
                        temp1      =  a1s * a2s + 2.0 * (q1s + 2.0) * a2s + 2.0 * (q2s + 2.0) * a1s;
                        dqsqs_dxn_qi =  -4.0 * qsqs * sums / (qis * temp1);
                    end else begin
                        temp1      = `INV6 * (1.0 - qsqs * `INV30 * (1.0 - qsqs * `INV28 * (1.0 - qsqs * `INV30)));
                        temp2      =  a1s * Aexp1s + a2s * Aexp2s + a1s * a2s * qis * (1.0 + qis * temp1);
                        dqsqs_dxn_qi =  Aexp1s * Aexp2s * sums / (qis * temp2);
                    end
                end
                xdrifts    =  ln(qis);

            // *********** Mobility attenuation and series resistance at source side ***********
                `ln_one_plus_exp(k1q1s / `FIELD_SMTH, temp1)
                esurf1s    = `FIELD_SMTH * temp1;
                `ln_one_plus_exp(k2q2s / `FIELD_SMTH, temp2)
                esurf2s    = `FIELD_SMTH * temp2;
                ecpl1s     =  esurf2s - k2q2s;
                ecpl2s     =  esurf1s - k1q1s;
                eeff1s     =  eta_mu * esurf1s + one_m_eta * ecpl1s;
                eeff2s     =  eta_mu * esurf2s + one_m_eta * ecpl2s;
                temp       =  qis / (esurf1s + esurf2s);
                qi1s       =  esurf1s * temp;
                qi2s       =  esurf2s * temp;
                c1s        =  esurf1s * BETN1_i;
                c2s        =  esurf2s * BETN2_i;
                temp1      =  XCOR_i * (ecpl1s + XCORB_i * ecpl2s);
                temp2      = `MAX_FUNC(1.0 + temp1, 0.0, 0.01);
                temp3      = `MAX_FUNC(1.0 + 0.2 * temp1, 0.0, 0.01);
                fcors      =  temp2 / temp3;
                Gcss       =  CS_i * (1.0 + CSFI_i * ecpl1s + CSBI_i * ecpl2s) * exp(-THECS_i * ln(1.0 + qi1s * inv_qi1cs + qi2s * inv_qi2cs));
                if (RSG_i == 0.0) begin
                    temp3      =  1.0;
                end else begin
                    if (RSG_i < 0.0) begin
                        temp1      =  RSG_i * exp(THERSG_i * ln(qis + 1.0e-12));
                        temp3      =  1.0 - temp1;
                    end else begin
                        temp1      =  RSG_i * exp(THERSG_i * ln(qis + 1.0e-12));
                        temp3      =  1.0 / (1.0 + temp1);
                    end
                end
                frscsi     =  frs * CsiPrime * `MAX_FUNC(1.0 - RSB_i * xg20, 0.0, 0.01);
                Grss       =  frscsi * (qis * temp3 + RSIG_i);
                Gmob1s     =  (1.0 + exp(THEMU_i * ln(fmue * eeff1s + 1.0e-6)) + Gcss + BETN1_i * Grss);
                Gmob2s     =  (1.0 + exp(THEMU_i * ln(fmue * eeff2s + 1.0e-6)) + Gcss + BETN2_i * Grss);
                Gmobs      =  fcors * (c1s + c2s) / (c1s / Gmob1s + c2s / Gmob2s);

            // *********** Calculation of various quantities at the onset of saturation ***********
                if (abs(Dx_WI) > 0.007) begin
                    if (Dx_WI > 0.0) begin
                        temp       =  exp(-Dx_WI);
                        s1         =  Dx_WI / (1.0 - temp);
                        s2         =  temp * s1;
                        deltaxinf  =  ln(A0 / (qis * s1)) - `LN2 + x1_WI0;
                    end else begin
                        temp       =  exp(Dx_WI);
                        s2         =  Dx_WI / (temp - 1.0);
                        s1         =  temp * s2;
                        deltaxinf  =  ln(A0 / (qis * s2)) - `LN2 + x2_WI0;
                    end
                    q1chapinf  = -Dx_WI / (keq * (1.0 - s1 - Dx_WI * inv_k2));
                    q2chapinf  =  Dx_WI / (keq * (1.0 - s2 + Dx_WI * inv_k1));
                    dinf       =  Dx_WI / ((s2 * inv_k2 + 0.5) / q2chapinf - (s1 * inv_k1 + 0.5) / q1chapinf);
                end else begin
                    temp       =  0.5 * `INV6 * Dx_WIsq;
                    temp1      =  0.5 * Dx_WI;
                    s1         =  1.0 + temp1 + temp;
                    s2         =  1.0 - temp1 + temp;
                    temp2      = `INV6 * temp1;
                    q1chapinf  =  1.0 / (keq * (0.5 + inv_k2 + temp2));
                    q2chapinf  =  1.0 / (keq * (0.5 + inv_k1 - temp2));
                    deltaxinf  =  ln(A0 / (qis * (1.0 - 0.5 * temp))) - `LN2 + 0.5 * (x1_WI0 + x2_WI0);
                    dinf       = -12.0 / (4.0 - 3.0 * keq + 12.0 * keq / (k1 * k2) + keq * (inv_k1 - inv_k2) * Dx_WI + `INV3 * (0.2 - 0.25 * keq) * Dx_WIsq);
                end
                inv_dinf   =  1.0 / dinf;

            // *********** Drain saturation voltage ***********
                if (qis > `QI_LOW) begin
                    // Front gate bias dependence of velocity saturation
                    wsat1      =  100.0 * esurf1s / (100.0 + esurf1s);
                    if (THESAT1_i < 0.0) begin
                        sat_fact1  =  1.0 / (1.0 - THESAT1_i * wsat1);
                    end else begin
                        sat_fact1  =  1.0 + THESAT1_i * wsat1;
                    end
                    // Back gate bias dependence of velocity saturation
                    wsat2      =  100.0 * esurf2s / (100.0 + esurf2s);
                    if (THESAT2_i < 0.0) begin
                        sat_fact2  =  1.0 / (1.0 - THESAT2_i * wsat2);
                    end else begin
                        sat_fact2  =  1.0 + THESAT2_i * wsat2;
                    end
                    // deltaxsat and qidsat calculation
                    dqis_dxn_qi =  dqsqs_dxn_qi * sums / (a1s * a2s) - (Aexp1s / a1s + Aexp2s / a2s) / qis;
                    ds         =  dqis_dxn_qi * qis / (dqis_dxn_qi + 1.0);
                    temp1      =  dinf - ds;
                    deltaxi    =  (qis + dinf * deltaxinf) / temp1;
                    deltaxi    =  0.5 * (deltaxi + sqrt(deltaxi * deltaxi + 1.0e-6));
                    gamma      =  sat_phit / Gmobs * 0.5 * (sat_fact1 + sat_fact2);
                    vs         =  1.0 - qis / ds;
                    vd         =  1.0 + deltaxinf;
                    wd         =  ((2.0 * ds - qis) * inv_dinf - 2.0 - deltaxinf) * deltaxi;
                    if (gamma > 1.0e-14) begin
                        ps_cub     =  2.0 / (gamma * gamma);
                        qs_cub     =  ps_cub * vs;
                        pd_cub     =  ps_cub + wd;
                        qd_cub     =  ps_cub * vd;
                        racs       =  sqrt(qs_cub * qs_cub + 0.148148148148 * ps_cub * ps_cub * ps_cub + 1.0e-20);
                        racd       =  sqrt(qd_cub * qd_cub + 0.148148148148 * pd_cub * pd_cub * pd_cub + 1.0e-20);
                        deltaxsats =  exp(`INV3 * ln(0.5 * (racs + qs_cub))) - exp(`INV3 * ln(0.5 * (racs - qs_cub)));
                        deltaxsatd =  exp(`INV3 * ln(0.5 * (racd + qd_cub))) - exp(`INV3 * ln(0.5 * (racd - qd_cub)));
                    end else begin
                        deltaxsats =  vs;
                        deltaxsatd =  vd;
                    end
                    temp3      =  temp1 * temp1;
                    deltaxsat  = `SAT_FACT * `MAX_FUNC(deltaxsats, deltaxsatd, 10.0 * temp3);
                    qidsats    =  qis + ds * deltaxsat;
                    qidsatd    =  dinf * (deltaxsat - deltaxinf);
                    qidsat     = `MAX_FUNC(qidsats, qidsatd,`SMTH_SQ * temp3);
                end else begin
                    ds         =  dinf;
                    deltaxsat  = `SAT_FACT * (1.0 + deltaxinf);
                    qidsat     =  0.5 * qis + dinf * (deltaxsat - 0.5 * deltaxinf);
                end
                // xndssat calculation
                `ln_one_plus_exp(qidsat - `QI_TH, temp1)
                temp2      =  temp1 + `QI_TH;
                temp3      =  deltaxsat + ln(qis / temp2);
                `ln_one_plus_exp(temp3 - `XSAT_MIN, temp1)
                temp3      =  temp1 + `XSAT_MIN;
                `ln_one_plus_exp(`XSAT_MAX - temp3, temp1)
                xndssat    =  `XSAT_MAX - temp1;

            // *********** Effective drain voltage  ***********
                temp1      =  xd / xndssat;
                temp2      =  temp1 * temp1;
                temp3      =  temp2 * temp2;
                temp4      =  temp3 * temp3;
                temp       =  exp(2.666666666667 * ln(1.0 + gamAX * temp3));
                xdeff      =  xd * exp(-0.0625 * ln(temp + temp4 * temp4));

            // *********** Inversion charge at drain side ***********
                `func_q(xg1x, xg2x, xdeff, q1d, q2d)
                `func_qi(xg1x, xg2x, xdeff, q1d, q2d, qid, k1q1d, k2q2d, qsqd, Aexp1d, Aexp2d)
                // Calculation of (dqsq/dxn)/qi and xdrift at drain side
                a1d         =  0.0;
                a2d         =  0.0;
                b1d         =  0.0;
                b2d         =  0.0;
                sumd        =  0.0;
                dqsqd_dxn_qi =  0.0;
                if (qis > `QI_LOW) begin
                    b1d         =  Aexp1d * inv_k1;
                    b2d         =  Aexp2d * inv_k2;
                    a1d         =  b1d + 2.0 * k1q1d;
                    a2d         =  b2d + 2.0 * k2q2d;
                    sumd        =  2.0 * qid + b1d + b2d;
                    if (abs(qsqd) > 0.005) begin
                        temp1       =  a1d * a2d + 2.0 * (q1d + 2.0) * a2d + 2.0 * (q2d + 2.0) * a1d;
                        dqsqd_dxn_qi =  -4.0 * qsqd * sumd / (qid * temp1);
                    end else begin
                        temp1       = `INV6 * (1.0 - qsqd * `INV30 * (1.0 - qsqd * `INV28 * (1.0 - qsqd * `INV30)));
                        temp2       =  a1d * Aexp1d + a2d * Aexp2d + a1d * a2d * qid * (1.0 + qid * temp1);
                        dqsqd_dxn_qi =  Aexp1d * Aexp2d * sumd / (qid * temp2);
                    end
                end
                xdriftd     =  xdeff + ln(qid);

            // *********** Mid-point inversion charge ***********
                qim         =  0.5 * (qis + qid);
                dxdrift     =  xdriftd - xdrifts;

            // *********** Mobility attenuation and series resistance ***********
                `ln_one_plus_exp(k1q1d / `FIELD_SMTH, temp1)
                esurf1d     = `FIELD_SMTH * temp1;
                `ln_one_plus_exp(k2q2d / `FIELD_SMTH, temp2)
                esurf2d     = `FIELD_SMTH * temp2;
                ecpl1d      =  esurf2d - k2q2d;
                ecpl2d      =  esurf1d - k1q1d;
                eeff1d      =  eta_mu * esurf1d + one_m_eta * ecpl1d;
                eeff2d      =  eta_mu * esurf2d + one_m_eta * ecpl2d;
                esurf1      =  0.5 * (esurf1s + esurf1d);
                esurf2      =  0.5 * (esurf2s + esurf2d);
                temp        =  1.0 / (esurf1 + esurf2);
                qi1m        =  qim * esurf1 * temp;
                qi2m        =  qim * esurf2 * temp;
                ecpl1       =  0.5 * (ecpl1s + ecpl1d);
                ecpl2       =  0.5 * (ecpl2s + ecpl2d);
                eeff1       =  0.5 * (eeff1s + eeff1d);
                eeff2       =  0.5 * (eeff2s + eeff2d);
                c1          =  esurf1 * BETN1_i;
                c2          =  esurf2 * BETN2_i;
                csum        =  c1 + c2;
                betneff     =  csum * temp;
                temp1       =  XCOR_i * (ecpl1 + XCORB_i * ecpl2);
                temp2       = `MAX_FUNC(1.0 + temp1, 0.0, 0.01);
                temp3       = `MAX_FUNC(1.0 + 0.2 * temp1, 0.0, 0.01);
                fcor        =  temp2 / temp3;
                Gcs         =  CS_i * (1.0 + CSFI_i * ecpl1 + CSBI_i * ecpl2) * exp(-THECS_i * ln(1.0 + qi1m * inv_qi1cs + qi2m * inv_qi2cs));
                if (RSG_i == 0.0) begin
                    temp3       =  1.0;
                end else begin
                    if (RSG_i < 0.0) begin
                        temp1       =  RSG_i * exp(THERSG_i * ln(qim + 1.0e-12));
                        temp3       =  1.0 - temp1;
                    end else begin
                        temp1       =  RSG_i * exp(THERSG_i * ln(qim + 1.0e-12));
                        temp3       =  1.0 / (1.0 + temp1);
                    end
                end
                Grs         =  frscsi * (qim * temp3 + RSIG_i);
                Gmob1       =  (1.0 + exp(THEMU_i * ln(fmue * eeff1 + 1.0e-6)) + Gcs + BETN1_i * Grs);
                Gmob2       =  (1.0 + exp(THEMU_i * ln(fmue * eeff2 + 1.0e-6)) + Gcs + BETN2_i * Grs);
                Gmob        =  fcor * csum / (c1 / Gmob1 + c2 / Gmob2);

            // *********** Channel length modulation ***********
                inv_qimstar1 =  1.0 / (4.0 + qim);
                if (ALPB_i > 0) begin
                    temp        =  1.0 / (1.0 + ALPB_i * qi2m);
                end else begin
                    temp        =  1.0 - ALPB_i * qi2m;
                end
                r1          =  qim * inv_qimstar1 * temp;
                temp1       =  ln(1.0 + (xd - xdeff) / (VP_i * inv_phit + VPG_i * qim * qim)) * r1;
                dL_L        =  ALP_i * temp1;
                GdL         =  1.0 / (1.0 + dL_L * (1.0 + dL_L));
                dL1_L       =  (ALP_i + alp1_phit * inv_qimstar1) * temp1;
                FdL         =  (1.0 + dL1_L * (1.0 + dL1_L)) * GdL;

            // *********** Velocity saturation ***********
                // Front gate bias dependence of velocity saturation
                wsat1       =  100.0 * esurf1 / (100.0 + esurf1);
                if (THESAT1_i < 0.0) begin
                    sat_fact1   =  1.0 / (1.0 - THESAT1_i * wsat1);
                end else begin
                    sat_fact1   =  1.0 + THESAT1_i * wsat1;
                end
                // Back gate bias dependence of velocity saturation
                wsat2       =  100.0 * esurf2 / (100.0 + esurf2);
                if (THESAT2_i < 0.0) begin
                    sat_fact2   =  1.0 / (1.0 - THESAT2_i * wsat2);
                end else begin
                    sat_fact2   =  1.0 + THESAT2_i * wsat2;
                end
                // Gvsat calculation
                Ggamma      =  sat_phit * dxdrift * 0.5 * (sat_fact1 + sat_fact2);
                sqrt_zsat   =  Ggamma / (Gmob * GdL);
                zsat        =  sqrt_zsat * sqrt_zsat;
                vsat_fact   =  sqrt(1.0 + zsat);
                hsat        =  (1.0 + 1.5 * zsat) / vsat_fact;
                Gvsat       =  Gmob * GdL * vsat_fact;

            // *********** Quantum mechanical corrections ***********
                if (QMC > 0.0) begin
                    temp1       =  0.6 * qq * exp(-`INV6 * ln(esurf1 * esurf1 + 60.0));
                    temp2       =  0.6 * qq * exp(-`INV6 * ln(esurf2 * esurf2 + 60.0));
                    qmfact1     =  (1.0 + k1 * temp1) / tox1fact;
                    qmfact2     =  (1.0 + k2 * temp2) / tox2fact;
                    qmfact      =  (esurf1 + esurf2) / (esurf1 / qmfact1 + esurf2 / qmfact2);
                end else begin
                    qmfact1     =  1.0;
                    qmfact2     =  1.0;
                    qmfact      =  1.0;
                end

            // *********** Drain-source current ***********
                if (qis > `QI_LOW) begin
                    if (qid > `QI_LOW) begin
                        dqid_dxn_qi =  dqsqd_dxn_qi * sumd / (a1d * a2d) - (Aexp1d / a1d + Aexp2d / a2d) / qid;
                        dd          =  dqid_dxn_qi * qid / (dqid_dxn_qi + 1.0);
                    end else begin
                        dd          =  dinf;
                    end
                    temp1       =  dd - ds;
                    temp2       =  1.0 + `SMTH_SQ * temp1 * temp1;
                    if (abs(temp1) > 1.0e-3) begin
                        temp3       =  qid - qis;
                        Ls          =  temp3 - dd * dxdrift;
                        Ld          =  temp3 - ds * dxdrift;
                        Us          =  sqrt(Ls * Ls + temp2);
                        Ud          =  sqrt(Ld * Ld + temp2);
                        idrift2     =  0.25 / temp1 * (Ud * Ls - Us * Ld + temp2 * ln((Ld + Ud) / (Ls + Us)));
                    end else begin
                        temp3       =  dxdrift * temp1;
                        idrift2     = -0.25 * `INV6 * dxdrift * temp3 * temp3 / sqrt(temp2);
                    end
                end else begin
                    dd          =  dinf;
                    idrift2     =  0.0;
                end
                norm_Ids    =  qim * dxdrift + idrift2 + qis - qid;
                fact_Ids    =  phit * phit * betneff;
                Ids         =  fact_Ids * CsiPrime * norm_Ids * FdL / Gvsat / qmfact;

            // *********** Variables for calculation of intrinsic charges and gate current ***********
                if (qis > `QI_LOW) begin
                    if (norm_Ids > 1.0e-30) begin
                        q1s_chap    =  a1s / (Aexp1s / qis - dqsqs_dxn_qi);
                        q1d_chap    =  a1d / (Aexp1d / qid - dqsqd_dxn_qi);
                        inv_k1h1_0  =  (q1s_chap - q1d_chap) / norm_Ids;
                        q2s_chap    =  a2s / (Aexp2s / qis - dqsqs_dxn_qi);
                        q2d_chap    =  a2d / (Aexp2d / qid - dqsqd_dxn_qi);
                        inv_k2h2_0  =  (q2s_chap - q2d_chap) / norm_Ids;
                    end else begin
                        inv_k1h1_0  =  0.0;
                        inv_k2h2_0  =  0.0;
                    end
                end else begin
                    zeta1       = -2.0 * s1 * (inv_k1 / q1chapinf + inv_dinf);
                    zeta2       = -2.0 * s2 * (inv_k2 / q2chapinf + inv_dinf);
                    temp        =  (zeta2 - zeta1) * inv_dinf;
                    temp1       =  zeta1 * inv_k1;
                    temp2       =  zeta2 * inv_k2;
                    temp3       =  temp1 + temp2;
                    temp4       =  3.0 + 2.0 * (s1 * inv_k1 + s2 * inv_k2);
                    ksi1        =  (temp2 + temp - temp3 / q1chapinf) / temp4;
                    ksi2        =  (temp1 - temp - temp3 / q2chapinf) / temp4;
                    inv_k1h1_0  = -q1chapinf * (ksi1 * q1chapinf + inv_dinf);
                    inv_k2h2_0  = -q2chapinf * (ksi2 * q2chapinf + inv_dinf);
                end
                inv_k1h1    =  inv_k1h1_0 * hsat;
                inv_k2h2    =  inv_k2h2_0 * hsat;
                delta_k1q1  =  0.5 * (k1q1d - k1q1s);
                delta_k2q2  =  0.5 * (k2q2d - k2q2s);
                prod1       =  delta_k1q1 * inv_k1h1;
                prod2       =  delta_k2q2 * inv_k2h2;

            // *********** Surface potential in gate overlap regions ***********
                xs_ov       =  0.0;
                xd_ov       =  0.0;
                xs_ovcv     =  0.0;
                xd_ovcv     =  0.0;
                GOV         =  sqrt(2.0 * `QELE * NOV_i * epsch * inv_phit0) / Cox1Prime;
                GOV2        =  GOV * GOV;
                xi_ov       =  1.0 + GOV / `SQRT2;
                x_mrg_ov    =  1.0e-5 * xi_ov;
                inv_xi_ov   =  1.0 / xi_ov;
                inv_xg1     =  1.0 / (`X1OV + GOV * 7.324648775608221e-1);
                if (((SWIGATE > 0) && ((IGOVINV_i > 0.0) || (IGOVACC_i > 0.0))) || ((SWGIDL > 0) && (AGIDL_i > 0.0))) begin
                    `sp_fdsoi_ov(xs_ov, xgs_ov)
                end
                if (COV_i > 0.0) begin
                    `sp_fdsoi_ov(xs_ovcv, xgs_ovcv)
                end
                GOV         =  sqrt(2.0 * `QELE * NOVD_i * epsch * inv_phit0) / Cox1Prime;
                GOV2        =  GOV * GOV;
                xi_ov       =  1.0 + GOV / `SQRT2;
                x_mrg_ov    =  1.0e-5 * xi_ov;
                inv_xi_ov   =  1.0 / xi_ov;
                inv_xg1     =  1.0 / (`X1OV + GOV * 7.324648775608221e-1);
                if (((SWIGATE > 0) && ((IGOVINVD_i > 0.0) || (IGOVACCD_i > 0.0))) || ((SWGIDL > 0) && (AGIDLD_i > 0.0))) begin
                    `sp_fdsoi_ov(xd_ov, xgd_ov)
                end
                if (COVD_i > 0.0) begin
                    `sp_fdsoi_ov(xd_ovcv, xgd_ovcv)
                end
                Vovs        = -phit0 * (xgs_ov + xs_ov);
                Vovd        = -phit0 * (xgd_ov + xd_ov);
                Vovscv      = -phit0 * (xgs_ovcv + xs_ovcv);
                Vovdcv      = -phit0 * (xgd_ovcv + xd_ovcv);
            
            // *********** Gate currents *********** 
                Igsov       =  0.0;
                Igdov       =  0.0;
                Igc         =  0.0;
                Igs         =  0.0;
                Igd         =  0.0;
                Igcs        =  0.0;
                Igcd        =  0.0;
                if (SWIGATE > 0) begin
                    //  Gate-source overlap-LDD component of gate current
                    if ((IGOVINV_i > 0.0) || (IGOVACC_i > 0.0)) begin
                        arg2mina    =  Vovs + Dov;
                        psi_t       = `MIN_FUNC(0.0, arg2mina, 0.01);
                        zg          =  sqrt(Vovs * Vovs + 1.0e-4) * inv_CHIB;
                        `lin_exp(0.5 * xgs_ov, temp)
                        temp1       =  1.0 / (1.0 + temp);
                        temp2       =  1.0 - temp1;
                        gc2oveff    =  GC2OVACC_i * temp1 + GC2OVINV_i * temp2;
                        gc3oveff    =  GC3OVACC_i * temp1 + GC3OVINV_i * temp2;
                        gcqoveff    =  GCQOVACC * temp1 + GCQOVINV * temp2;
                        igoveff     =  IGOVACC_i * temp1 + IGOVINV_i * temp2;
                        igovefffowler =  FNOVINV_i * temp2 * 1.0e-6;
                        temp1       =  BOV * (-1.0 * GCOVINVFN_i/zg);
                        if (gc3oveff < 0.0) begin
                            zg          = `MIN_FUNC(zg, gcqoveff, 1.0e-6);
                        end
                        arg1        =  3.0 + xs_ov + psi_t * inv_phit0;
                        `lin_exp(arg1, Dsi)
                        arg1        =  3.0 + xs_ov + psi_t * inv_phit0 + xgs_ov;
                        `lin_exp(arg1, Dgate)
                        temp        =  BOV * (-1.5 + zg * (gc2oveff + gc3oveff * zg));
                        if (temp > 0.0) begin
                            TP          = `dev3_exp(temp);
                        end else begin
                            `linmin_exp(temp, TP)
                        end
                        if (temp1 > 0.0) begin
                            TP2         = `dev3_exp(temp1);
                        end else begin
                            `linmin_exp(temp1, TP2)
                        end
                        temp        =  (1.0 + Dsi) / (1.0 + Dgate);
                        if (temp < 1.0e-80) begin
                            temp        =  1.0e-80;
                        end
                        temp1       =  GCDOV_i * (Vgdu - GCVDOV_i);
                        `lin_exp(temp1, temp2)
                        temp3       =  GCDOV_i * Vsdu + temp1;
                        `lin_exp(temp3, temp4)
                        Igsov       =  igoveff * TP * ln(temp) * (1.0 + temp2) / (1.0 + temp4) - igovefffowler * TP2 * (1.0 + temp2) / (1.0 + temp4);
                    end
                    //  Gate-drain overlap-LDD component of gate current
                    if ((IGOVINVD_i > 0.0) || (IGOVACCD_i > 0.0)) begin
                        arg2mina    =  Vovd + Dov;
                        psi_t       = `MIN_FUNC(0.0, arg2mina, 0.01);
                        zg          =  sqrt(Vovd * Vovd + 1.0e-4) * inv_CHIB;
                        `lin_exp(0.5 * xgd_ov, temp)
                        temp1       =  1.0 / (1.0 + temp);
                        temp2       =  1.0 - temp1;
                        gc2oveff    =  GC2OVACC_i * temp1 + GC2OVINV_i * temp2;
                        gc3oveff    =  GC3OVACC_i * temp1 + GC3OVINV_i * temp2;
                        gcqoveff    =  GCQOVACC * temp1 + GCQOVINV * temp2;
                        igoveff     =  IGOVACCD_i * temp1 + IGOVINVD_i * temp2;
                        igovefffowler =  FNOVINVD_i * temp2 * 1.0e-6;
                        temp1       =  BOV * (-1.0 * GCOVINVFN_i/zg);
                        if (gc3oveff < 0.0) begin
                            zg          = `MIN_FUNC(zg, gcqoveff, 1.0e-6);
                        end
                        arg1        =  3.0 + xd_ov + psi_t * inv_phit0;
                        `lin_exp(arg1, Dsi)
                        arg1        =  3.0 + xd_ov + psi_t * inv_phit0 + xgd_ov;
                        `lin_exp(arg1, Dgate)
                        temp        =  BOV * (-1.5 + zg * (gc2oveff + gc3oveff * zg));
                        if (temp > 0.0) begin
                            TP          = `dev3_exp(temp);
                        end else begin
                            `linmin_exp(temp, TP)
                        end
                        if (temp1 > 0.0) begin
                            TP2         = `dev3_exp(temp1);
                        end else begin
                            `linmin_exp(temp1, TP2)
                        end
                        temp        =  (1.0 + Dsi) / (1.0 + Dgate);
                        if (temp < 1.0e-80) begin
                            temp        =  1.0e-80;
                        end
                        temp1       =  GCDOV_i * (Vgsu - GCVDOV_i);
                        `lin_exp(temp1, temp2)
                        temp3       =  GCDOV_i * Vdsu + temp1;
                        `lin_exp(temp3, temp4)
                        Igdov       =  igoveff * TP * ln(temp) * (1.0 + temp2) / (1.0 + temp4) - igovefffowler * TP2 * (1.0 + temp2) / (1.0 + temp4);
                    end
                    //  Gate-channel component of gate current (no gate to bulk current in FDSOI)
                    if (IGINV_i > 0.0) begin
                        half_x_ds   = -delta_k1q1 * inv_k1;
                        `lin_exp(2.0 * half_x_ds - xdeff, temp)
                        Vm          =  phit * (half_x_ds + `LN2 - ln(1.0 + temp));
                        q1m         =  0.5 * (q1s + q1d);
                        Voxm        =  phit * q1m;
                        arg2mina    =  Voxm + Dch;
                        psi_t       = `MIN_FUNC(0.0, arg2mina, 0.01);
                        zg          =  sqrt(Voxm * Voxm + 1.0e-4) * inv_CHIB;
                        if (GC3CH_i < 0.0) begin
                            zg          = `MIN_FUNC(zg, GCQCH, 1.0e-06);
                        end
                        x_m         =  xg1x - q1m;
                        arg1        = (x_m + (psi_t - alpha_b - Vm) * inv_phit) * n_iginv;
                        `lin_exp(arg1,Dsi)
                        arg1        = -(Vgs - Vm) * inv_phit * n_iginv;
                        `lin_exp(arg1,temp)
                        Dgate       =  Dsi * temp;
                        temp        =  BCH * (-1.5 + zg * (GC2CH_i + GC3CH_i * zg));
                        if (temp > 0.0) begin
                            TP          = `dev3_exp(temp);
                        end else begin
                            `lin_exp(temp, TP)
                        end
                        Igc0        =  IGINV_i * TP * ln((1.0 + Dsi) / (1.0 + Dgate));
                        // Source/drain partitioning of gate-channel current
                        if ((xg1x <= 0.0) || ((GC2CH_i == 0.0) && (GC3CH_i == 0.0))) begin
                            igc         =  1.0;
                            igcd_h      =  0.5;
                        end else begin
                            temp        =  GC2CH_i + 2.0 * GC3CH_i * zg;
                            u0          =  CHIB_i / (temp * BCH) * inv_phit;
                            x           =  half_x_ds / u0;
                            u0_div_H    =  u0 * inv_k1h1 * k1;
                            Bg          =  u0_div_H * (1.0 - u0_div_H) * 0.5;
                            Ag          =  0.5 - 3.0 * Bg;
                            if (x < 1.0e-3) begin
                                xsq         =  x * x;
                                igc         =  1.0 + xsq * (`INV6 + u0_div_H * `INV3 + xsq * `INV6 * (0.05 + 0.2 * u0_div_H));
                                igcd_h      =  0.5 * igc - x * `INV6 * (1.0 + xsq * (0.4 * (Bg + 0.25) + 0.0285714285714 * xsq * (0.125 + Bg)));
                            end else begin
                                inv_x       =  1.0 / x;
                                `lin_exp(x, ex)
                                inv_ex      =  1.0 / ex;
                                temp        =  ex - inv_ex;
                                temp2       =  ex + inv_ex;
                                igc         =  0.5 * ((1.0 - u0_div_H) * temp * inv_x + u0_div_H * temp2);
                                igcd_h      =  0.5 * (igc - temp * (Bg - Ag * inv_x * inv_x) - Ag * temp2 * inv_x);
                            end
                        end
                        Igc         =  Igc0 * igc;
                        Igcd        =  Igc0 * igcd_h;
                        Igcs        =  Igc - Igcd;
                    end
                    if (sigVds < 0.0) begin
                        Igs         =  Igcd + Igsov;
                        Igd         =  Igcs + Igdov;
                    end else begin
                        Igs         =  Igcs + Igsov;
                        Igd         =  Igcd + Igdov;
                    end
                end

            // *********** GIDL/GISL current ***********
                Igisl       =  0.0;
                // GISL current computation
                if ((SWGIDL > 0) && (AGIDL_i > 0.0) && (Vovs < 0.0)) begin
                    Vtovs       =  sqrt(Vovs * Vovs + CGIDL_i * CGIDL_i * Vsbu * Vsbu + 1.0e-6);
                    temp        = -BGIDL_i / Vtovs;
                    `lin_exp(temp, temp2)
                    temp3       =  DGIDL_i * Vsdu;
                    `lin_exp(temp3, temp4)
                    Igisl       = -AGIDL_i * Vsdu * Vovs * Vtovs * temp2 * 0.5 * (1.0 + temp4);
                end
                Igidl       =  0.0;
                // GIDL current computation
                if ((SWGIDL > 0) && (AGIDLD_i > 0.0) && (Vovd < 0.0)) begin
                    Vtovd       =  sqrt(Vovd * Vovd + CGIDLD_i * CGIDLD_i * Vdbu * Vdbu + 1.0e-6);
                    temp        = -BGIDLD_i / Vtovd;
                    `lin_exp(temp, temp2)
                    temp3       =  DGIDLD_i * Vdsu;
                    `lin_exp(temp3, temp4)
                    Igidl       = -AGIDLD_i * Vdsu * Vovd * Vtovd * temp2 * 0.5 * (1.0 + temp4);
                end

            // *********** Impact Ionization current adapted from PSP 103 ***********
                mavl        =  0.0;
                Iimpact     =  0.0;
                if (SWIMPACT != 0) begin
                    delVsat     =  (xd - A3_i * xdeff) / inv_phit;
                    if (delVsat > 0) begin
                        temp2       = -1.0 * A2_i / (delVsat + 1.0e-30);
                        `lin_exp(temp2, temp)
                        mavl        =  A1_i * delVsat * temp;
                        Iimpact     =  mavl * Ids;
                    end
                end

             // *********** Self heating effect ***********
                if (SWSHE_i > 0) begin
                    temp        =  abs(Ids * Vds) * RTH_i;
                    if (temp > 1.0e8 * TMAX) begin
                        Ithpwr      = -(TMAX + 0.25 / TMAX) / RTH_i;
                    end else begin
                        Ithpwr      = -(1.0 * `MIN_FUNC(temp, TMAX, 1.0) + 0.25 / TMAX) / RTH_i;
                    end
                    Ithrc       =  DTC / RTH_i;
                end else begin
                    Ithpwr      =  0.0;
                    Ithrc       =  0.001 * Temp(THPWR);
                end

        end    // evaluateStatic

        //  Calculation of All Charges
        //  *************************************************************************************************************        
        begin : evaluateDynamic

            // *********** Quantum mechanical corrections ***********
                temp        =  FSCEAC_i * (Dx_WI_1D - Dx_WI) / (1.0 + 0.25 * qim);
                k1q1m       =  0.5 * (k1q1s + k1q1d) + temp;
                k2q2m       =  0.5 * (k2q2s + k2q2d) - temp;
                if (QMC > 0.0) begin
                    k1q1eff     =  k1q1m + qi1m / qmfact1 - qi1m;
                    k2q2eff     =  k2q2m + qi2m / qmfact2 - qi2m;
                end else begin
                    k1q1eff     =  k1q1m;
                    k2q2eff     =  k2q2m;
                end

            // *********** Intrinsic charge model ***********
                // Front interface
                temp1       =  delta_k1q1 * prod1 * `INV3;
                temp2       =  delta_k1q1 * `INV6 * (1.0 + prod1 * (1.0 - 0.2 * prod1));
                k1q1deff    =  0.5 * k1q1eff + temp2;
                k1q1eff     =  k1q1eff + temp1;
                // Back interface
                temp1       =  delta_k2q2 * prod2 * `INV3;
                temp2       =  delta_k2q2 * `INV6 * (1.0 + prod2 * (1.0 - 0.2 * prod2));
                k2q2deff    =  0.5 * k2q2eff + temp2;
                k2q2eff     =  k2q2eff + temp1;
                // Electrode charges
                temp        =  CsiPrime * area_phit;
                Qg          =  temp * k1q1eff;
                Qb          =  temp * k2q2eff;
                Qd          = -temp * (k1q1deff + k2q2deff);

            // *********** Inner fringe charge ***********
                if (FIF_i > 0.0) begin
                    temp        =  xth_1D + 2.0 * `LN2;
                    xeffs       =  xdrifts + temp;
                    xeffd       =  xdriftd + temp;
                    xstars      = `MIN_FUNC(xeffs, xth_1D, 9.0);
                    xstard      = `MIN_FUNC(xeffd, xth_1D + xd, 9.0);
                    lambdaf     =  lambda2D * sqrt(keq * (0.5 + inv_k2));
                    lambdab     =  lambda2D * sqrt(keq * k1 * inv_k2 * (0.5 + inv_k1));
                    xalphaf     =  lambdaf * lambdaf * inner_sd;
                    xalphab     =  lambdab * lambdab * inner_sd;
                    temp1       =  xsd - xstars;
                    temp2       =  xsd + xd - xstard;
                    temp        =  2.0 * xalphaf;
                    xedgefs     =  xstars + temp * (sqrt(1.0 + temp1 / xalphaf) - 1.0);
                    xedgefd     =  xstard + temp * (sqrt(1.0 + temp2 / xalphaf) - 1.0);
                    temp        =  2.0 * xalphab;
                    xedgebs     =  xstars + temp * (sqrt(1.0 + temp1 / xalphab) - 1.0);
                    xedgebd     =  xstard + temp * (sqrt(1.0 + temp2 / xalphab) - 1.0);
                    temp        =  fif_phit * CsiPrime;
                    temp1       = -temp * lambdaf * k1 * sce1;
                    temp2       = -temp * lambdab * k2 * sce2;
                    temp        = `MAX_FUNC(xedgefs - xeffs, 0.0, 1.0);
                    Qgsif       =  temp1 * temp * temp / (xedgefs - xstars);
                    temp        = `MAX_FUNC(xedgefd - xeffd, 0.0, 1.0);
                    Qgdif       =  temp1 * temp * temp / (xedgefd - xstard);
                    temp        = `MAX_FUNC(xedgebs - xeffs, 0.0, 1.0);
                    Qbsif       =  temp2 * temp * temp / (xedgebs - xstars);
                    temp        = `MAX_FUNC(xedgebd - xeffd, 0.0, 1.0);
                    Qbdif       =  temp2 * temp * temp / (xedgebd - xstard);
                end else begin
                    Qgsif       =  0.0;
                    Qgdif       =  0.0;
                    Qbsif       =  0.0;
                    Qbdif       =  0.0;
                end

            // *********** Outer fringe and overlaps charges ***********
                Qgse        =  CFR_i * Vgsu;
                Qgde        =  CFRD_i * Vgdu;
                temp        = `MAX_FUNC(1.0 - COVDL_i * dleff * (1.0 - COVDLB_i * xg20), 0.0, 0.2);
                Qovs        =  COV_i * Vovscv * temp;
                Qovd        =  COVD_i * Vovdcv * temp;
                Qgbe        =  CGBOV_i * Vgb;

            // *********** Drain-source coupling charge ***********
                Qdse        =  CSD_i * Vds;

             // *********** Substrate extrinsic charge model ***********
                Qssub       = -(Cox2Init * ASOURCE_i + CSDBP_i * PSOURCE_i) * Vsbu;
                Qdsub       = -(Cox2Init * ADRAIN_i + CSDBP_i * PDRAIN_i) * Vdbu;

            // *********** Self heating effect ***********
                if (SWSHE_i > 0) begin
                    Qth         =  CTH_i * DTC;
                end else begin
                    Qth         =  0.0;
                end

        end    // evaluateDynamic

        //  Currents contributions
        //  *************************************************************************************************************
        begin : loadStatic

            // *********** Intrinsic MOSFET current and Impact Ionization ***********
                Idse        =  MULT_i * (Ids + Iimpact);

            // *********** Gate currents ***********
                Igse        =  MULT_i * Igs;
                Igde        =  MULT_i * Igd;
            
            // *********** GIDL/GISL currents ***********
                Igidle      =  MULT_i * Igidl;
                Igisle      =  MULT_i * Igisl;

            // *********** Self heating power ***********
                Ithpwre     =  MULT_i * Ithpwr;
                Ithrce      =  MULT_i * Ithrc;

            // *********** Convert back for NMOS-PMOS and Source-Drain interchange ***********
                if (sigVds < 0) begin
                    I(S, D)     <+  M*TYPE * Idse;
                end else begin
                    I(D, S)     <+  M*TYPE * Idse;
                end
                I(D, S)     <+  M*TYPE * (Igidle - Igisle);
                I(G, S)     <+  M*TYPE * Igse;
                I(G, D)     <+  M*TYPE * Igde;
                I(S, B)     <+  0.0;
                I(D, B)     <+  0.0;
                I(G, B)     <+  0.0;
                I(D, S)     <+  M*gmin * V(D, S);

            // *********** Self heating effect ***********
                Pwr(THPWR)  <+  M*Ithpwre;
                Pwr(THRC)   <+  M*Ithrce;

        end    // loadStatic

        //  Charges contributions
        //  *************************************************************************************************************
        begin : loadDynamic

            // *********** Intrinsic MOSFET charges ***********
                Qg          =  MULT_i * Qg;
                Qb          =  MULT_i * Qb;
                Qd          =  MULT_i * Qd;
                Qs          = -(Qg + Qb + Qd);

            // *********** Inner fringe charges ***********
                Qgsif       =  MULT_i * Qgsif;
                Qgdif       =  MULT_i * Qgdif;
                Qbsif       =  MULT_i * Qbsif;
                Qbdif       =  MULT_i * Qbdif;

            // *********** Fringe/overlap charges ***********
                Qgse        =  MULT_i * Qgse;
                Qgde        =  MULT_i * Qgde;
                Qovs        =  MULT_i * Qovs;
                Qovd        =  MULT_i * Qovd;
            
            // *********** Gate-bulk overlap charge ***********
                Qgbe        =  MULT_i * Qgbe;

            // *********** Substrate extrinsic charge ***********
                Qssub       =  MULT_i * Qssub;
                Qdsub       =  MULT_i * Qdsub;

            // *********** Drain-source coupling charge ***********
                Qdse        =  MULT_i * Qdse;

            // *********** Self heating energy ***********
                Qth         =  MULT_i * Qth;

            // *********** Convert back Source-Drain interchange ***********
                if (sigVds < 0.0) begin
                    temp        =  Qd;      // Qd <--> Qs
                    Qd          =  Qs;
                    Qs          =  temp;
                    Qdse        = -Qdse;    // Qdse <--> -Qdse
                    temp        =  Qgdif;   // Qgdif <--> Qgsif
                    Qgdif       =  Qgsif;
                    Qgsif       =  temp;
                    temp        =  Qbdif;   // Qbdif <--> Qbsif
                    Qbdif       =  Qbsif;
                    Qbsif       =  temp;
                end

            // *********** Introduction of dynamic currents ***********
                I(G, S)     <+  M*TYPE * (ddt(Qg) + ddt(Qgse) + ddt(Qovs) + ddt(Qgsif));
                I(B, S)     <+  M*TYPE * (ddt(Qb) + ddt(Qssub) + ddt(Qbsif));
                I(D, S)     <+  M*TYPE * (ddt(Qd) + ddt(Qdse));
                I(G, D)     <+  M*TYPE * (ddt(Qgde) + ddt(Qovd) + ddt(Qgdif));
                I(B, D)     <+  M*TYPE * (ddt(Qdsub) + ddt(Qbdif));
                I(G, B)     <+  M*TYPE * ddt(Qgbe);

            // *********** Self heating effect ***********
                Pwr(THRC)   <+  M*ddt(Qth);

        end    // loadDynamic

        //  Noise
        //  *************************************************************************************************************
        begin : noise

            // *********** Noise variable calculation ***********
                Nunit       =  CsiPrime / `QELE * phit;
                dm          = -0.5 * (ds + dd);
                qimstar     =  qim + dm;

            // *********** Channel current thermal noise ***********
                temp        =  qim / qimstar;
                t1          = `MAX_FUNC(temp, 0.0, 1.0e-20);
                sqrt_t2     = -`INV6 * delta_k1q1 * inv_k1h1_0;
                t2          =  sqrt_t2 * sqrt_t2;
                r           =  hsat - 1.0;
                lc          =  max(1.0 - 12.0 * r * t2, 1.0e-20);
                lcinv2      =  1.0 / (lc * lc);
                g_ideal     =  betneff * CsiPrime * phit * qimstar * FdL / Gvsat / qmfact;
                t2x12       =  12.0 * t2;
                temp1       =  t1 + t2x12 - 2.0 * (1.0 + t1) * t2x12 * r;
                temp2       =  max(temp1, 1.0e-40);
                gSid        =  g_ideal * lcinv2 * temp2;
                if (FNTEXC_i > 0.0) begin
                    // Introduction of excess noise
                    sqrt_zsatexc =  Ggamma / Gmob;
                    Sidexc      =  fac_exc * Ids * xdeff * phit0 / ((1.0 + sqrt_zsatexc * sqrt_zsatexc) * lc * lc);
                    gSid        =  gSid + Sidexc / nt0;
                end
                Sids_th     =  MULT_i * nt * gSid;

            // *********** Induced gate noise and correlation ***********
                COX_qm      =  k1 * CsiPrime * AREAQ_i / qmfact1;
                CGeff       =  (1.0 + zsat) * COX_qm;
                CDGeff      =  CGeff * (0.5 - 0.25 * sigVds * sqrt_t2);
                CSGeff      =  CGeff - CDGeff;
                migid       =  0.0;
                cigid2      =  0.0;
                if (SWIGN > 0) begin
                    temp1       =  t1 / 12.0 - t2 * (t1 + 0.2 - t2x12) - 1.6 * t2 * (t1 + 1.0 - t2x12) * r;
                    temp2       =  max(temp1, 1.0e-40);
                    gSig        =  g_ideal * lc * lc / temp2;
                    SigR_th     =  MULT_i * nt * gSig;
                    if (gSid > 0) begin
                        migid       =  lcinv2 * sqrt_t2 * (1.0 - t2x12 - (t1 + 19.2 * t2 - t1 * t2x12) * r);
                        cigid2      =  migid * migid * gSig / gSid;
                        cigid2      = `MIN_FUNC(`MAX_FUNC(cigid2, 0.0, 1.0e-40), 1.0, 1.0e-40);
                    end
                end else begin
                    gSig        =  1.0;
                    SigR_th     =  0.0;
                end
                Sids_th_u   =  Sids_th * (1.0 - cigid2);

            // *********** Channel current flicker noise ***********
                Nstar       =  Nunit;
                Nmstar      =  Nunit * (qim + 1.0);
                DeltaN      =  Nunit * (qis - qid);
                temp1       = (NFA_i - NFB_i * Nstar + NFC_i * Nstar * Nstar) * ln((Nmstar + 0.5 * DeltaN) / (Nmstar - 0.5 * DeltaN));
                temp2       =  temp1 + (NFB_i + NFC_i * (Nmstar - 2.0 * Nstar)) * DeltaN;
                temp        =  1.0 + (NFE_i * esurf1 + NFEB_i * esurf2) / (qim + 1.0);
                temp3       = `MAX_FUNC(temp, 0.01, 1.0e-4);
                temp        = `QELE * fact_Ids * Ids / Gvsat * temp2 / Nstar * temp3;
                Sids_fl     =  MULT_i * max(temp, 0.0);

            // *********** Gate currents shot noise ***********
                Sigs_sh     =  2.0 * `QELE * abs(Igse);
                Sigd_sh     =  2.0 * `QELE * abs(Igde);

            // *********** Noise related impact ionization currents ***********
                shot_iavl   =  2.0 * `QELE * ((mavl + 1.0) * abs(Iimpact));

            // *********** GIDL/GISL shot noise ***********
                Sids_sh     =  2.0 * `QELE * abs(Igidle - Igisle) + shot_iavl;

            // *********** Noise contributions ***********
                // Thermal induced gate noise
                I(NOII)     <+  white_noise(M*SigR_th, "ign_g");
                I(NOIR)     <+  M*gSig * V(NOIR);
                I(NOIC)     <+  M*ddt(CGeff * V(NOIC));
                I(G, S)     <+  M*ddt(-CSGeff * V(NOIC));
                I(G, D)     <+  M*ddt(-CDGeff * V(NOIC));
                // Drain current thermal noise
                I(D, S)     <+  white_noise(M*Sids_th_u, "thermal_ids");
                I(D, S)     <+  M*sigVds * migid * I(NOII);
                // Drain current flicker noise
                I(D, S)     <+  flicker_noise(M*Sids_fl, EF_i, "flicker");
                // Gate currents shot noise
                I(G, S)     <+  white_noise(M*Sigs_sh, "shot_igs");
                I(G, D)     <+  white_noise(M*Sigd_sh, "shot_igd");
                // GIDL/GISL shot noise
                I(D, S)     <+  white_noise(M*Sids_sh, "shot_ids");
        end    // noise

        //  Operating point info
        //  *************************************************************************************************************
        begin : OPinfo

        `ifdef OP_CALC

            // *********** Operation point output variables **********
            
            // Device type
                type        =  TYPE;

            // Threshold voltage
                r1init_op   =  k2 / k1 / (1.0 + k2);
                r2init_op   =  k1 / k2 / (1.0 + k1);
                x1init_op   =  ln(k1 * (1.0 + r1init_op) * diff_min / A0) + 2.0;
                x2init_op   =  ln(k2 * (1.0 + r2init_op) * diff_min / A0) + 2.0;
                xth1init_op =  (1.0 + r1init_op) * x1init_op - xg2x * r1init_op;
                xth2init_op =  (1.0 + 1.0 / r2init_op) * x2init_op - xg2x / r2init_op;
                xg1thinit_op =  (`MIN_FUNC(xth1init_op, xth2init_op, 38.0) - xg2) / CIC1_i + xg2;
                vthinit_op  =  phit * ((xg1thinit_op - xedge) / sce1 - dxg1_dibl + xedge) + VFB1_i;
                // Calculation of self-heating free quantities
                inv_phit0_op =  1.0 / (TKD * `KBOL_QELE);
                EgSi_op     = `EG0SI - `ALPHASI * TKD * TKD / (`BETASI + TKD);
                EgGe_op     = `EG0GE - `ALPHAGE * TKD * TKD / (`BETAGE + TKD);
                dEg_op      =  (EgGe_op - EgSi_op + `CG * one_m_xge) * XGE_i;
                Eg_op       =  EgSi_op + dEg_op;
                Eg_2phit0_op =  0.5 * Eg_op * inv_phit0_op;
                dVfbch_op   =  0.05 * XGE_i - 0.5 * dEg_op;
                temp        =  sqrt(TKD * `INV300);
                temp1       = `NIFACT300 * temp * temp * temp;
                neff_op     =  temp1 * niratio * exp(-Eg_2phit0_op);
                inv_phit_op =  inv_phit0_op / (1.0 + CT_i * TKR / TKD);
                A0_Csisq_op =  2.0 * `QELE * neff_op * epsch * inv_phit_op;
                xth_1D_op   =  ln((CsiPrime_0 * CsiPrime_0) / A0_Csisq_op) - `LN2;
                xSDdep_op   =  0.5 * `QELE * NSDDC_i * TSI_i / (Cox1Prime + Cox2Prime) * inv_phit_op;
                temp        =  STCF_i * (TKD - TKR);
                CF1_op      =  CF1_t + temp;
                CF2_op      =  CF2_t + temp;
                xd0_op      =  CFD_i * inv_phit_op;
                qq_op       =  0.0;
                if (QMC > 0.0) begin
                    if (TYPE == `NMOS) begin
                        qq_op       =  0.4 * QMC * `QMN * exp(-`INV3 * ln(tsisq / inv_phit_op));
                    end else begin
                        qq_op       =  0.4 * QMC * `QMP * exp(-`INV3 * ln(tsisq / inv_phit_op));
                    end
                end
                temp        =  TYPE * STVFB_i * (TKD - TKR) + dVfbQM;
                VFB1_op     =  TYPE * (VFB1_t + dVfbch_op + dVfb1Nch) + temp + DELVTO;
                VFB2_op     =  TYPE * (VFB2_t + dVfbch_op + dVfb2Nch) + temp;
                // Conditioning of terminal voltages for threshold voltage conditions
                xd_op       =  Vds * inv_phit_op;
                xdsx_op     =  (sqrt(Vds * Vds + 0.01) - 0.1) * inv_phit_op;
                dxdsx_op    =  0.5 * (xd_op - xdsx_op);
                xg10_op     =  (vthinit_op - VFB1_op) * inv_phit_op - dxdsx_op;
                xg20_op     =  (-Vsb - VFB2_op) * inv_phit_op - dxdsx_op;
                // Substrate depletion effect at threshold voltage
                if (SWSUBDEP > 0) begin
                    temp        =  TYPE * TYPESUB_i * (xg10_op - xg20_op) / Gfsub;
                    if (temp < 0.0) begin
                        temp1       = -2.0 * ln(1.0 - temp);
                    end else begin
                        temp1       =  temp * temp / (1.0 + 2.0 * temp / Gfsub);
                    end
                    xg2eff_op   =  xg20_op + TYPE * TYPESUB_i * temp1;
                end else begin
                    xg2eff_op   =  xg20_op;
                end
                // Quantum mechanical corrections below threshold
                temp        =  keq_1D * (xg10_op - xg2eff_op);
                if (QMC > 0.0) begin
                    e1_op       = `MAX_FUNC(temp, 15.0, 225.0);
                    e2_op       = `MAX_FUNC(-temp, 15.0, 225.0);
                    temp1       =  qq_op * exp(-`INV3 * ln(e1_op));
                    temp2       =  qq_op * exp(-`INV3 * ln(e2_op));
                    temp3       =  1.0 - temp1 - temp2;
                    CsiPrime_op =  CsiPrime_0 / temp3;
                    k1_1D_QM_op =  k1_1D * temp3 / (1.0 + k1_1D * temp1);
                    k2_1D_QM_op =  k2_1D * temp3 / (1.0 + k2_1D * temp2);
                    keq_1D_QM_op = 1.0 / (1.0 + 1.0 / k1_1D_QM_op + 1.0 / k2_1D_QM_op);
                end else begin
                    CsiPrime_op =  CsiPrime_0;
                    k1_1D_QM_op =  k1_1D;
                    k2_1D_QM_op =  k2_1D;
                    keq_1D_QM_op = keq_1D;
                end
                // Short channel effects
                Dx_WI_1D_op =  keq_1D_QM_op * (xg10_op - xg2eff_op);
                if (Dx_WI_1D_op > 0.0) begin
                    `ln_one_plus_exp(-Dx_WI_1D_op, temp)
                    x_WI_1D_op  =  xg10_op - Dx_WI_1D_op / k1_1D_QM_op + temp - `LN2;
                end else begin
                    `ln_one_plus_exp(Dx_WI_1D_op, temp)
                    x_WI_1D_op  =  xg2eff_op + Dx_WI_1D_op / k2_1D_QM_op + temp - `LN2;
                end
                x_1D_op     = `MIN_FUNC(x_WI_1D_op, xth_1D_op, 4.0);
                dleff_op    =  sqrt(1.0 + 2.0 * (xth_1D_op - x_1D_op) / xSDdep_op) - 1.0;
                xedge_op    =  x_1D_op + xSDdep_op * dleff_op;
                temp        = `MAX_FUNC(1.0 + PSCEDLB_i * xg20_op, 0.5, 0.01);
                sce1_op     =  1.0 / (1.0 + PSCE1_i * temp);
                sce2_op     =  1.0 / (1.0 + PSCE2_i * temp);
                temp        =  2.0 * xd0_op * (sqrt(1.0 + xdsx_op / xd0_op) - 1.0) * (1.0 + CFDL_i * dleff_op) * (1.0 + CFDLB_i * xg20_op);
                dxg1_dibl_op =  CF1_op * temp;
                dxg2_dibl_op =  CF2_op * temp;
                xg1_op      =  (xg10_op - xedge_op + dxg1_dibl_op) * sce1_op + xedge_op + dxdsx_op;
                xg2_op      =  (xg2eff_op - xedge_op + dxg2_dibl_op) * sce2_op + xedge_op + dxdsx_op;
                xg2x_op     =  xg1_op + CIC2_i * (xg2_op - xg1_op);
                // Coupling factors at threshold voltage
                k1_op       =  k1_1D_QM_op / sce1_op;
                k2_op       =  k2_1D_QM_op / sce2_op;
                A0_op       =  A0_Csisq_op / (CsiPrime_op * CsiPrime_op);
                exp_dxth_op =  (1.0 + k1_op) / (1.0 + k2_op);
                dxth_op     =  ln(exp_dxth_op);
                if (dxth_op > 1.0e-8) begin
                    diff_min_op = 2.0 * dxth_op * (exp_dxth_op + 1.0) / (exp_dxth_op - 1.0);
                end else begin
                    diff_min_op = 2.0 * (2.0 + dxth_op);
                end
                // Final threshold voltage calculation
                r1_op       =  k2_op / k1_op / (1.0 + k2_op);
                r2_op       =  k1_op / k2_op / (1.0 + k1_op);
                x1sat_op    =  ln(k1_op * (1.0 + r1_op) * diff_min_op / A0_op) + 2.0;
                x2sat_op    =  ln(k2_op * (1.0 + r2_op) * diff_min_op / A0_op) + 2.0;
                xth1_op     =  (1.0 + r1_op) * x1sat_op - xg2x_op * r1_op;
                xth2_op     =  (1.0 + 1.0 / r2_op) * x2sat_op - xg2x_op / r2_op;
                xg1th_op    =  (`MIN_FUNC(xth1_op, xth2_op, 38.0) - xg2) / CIC1_i + xg2;
                vth         =  ((xg1th_op - xedge_op) / sce1_op - dxg1_dibl_op + xedge_op) / inv_phit_op + VFB1_op;

            // Saturation voltage calculation
                Vdsat       =  phit * xndssat;

            // Calculation of output variables
                // Output voltages
                vds         =  Vds;
                vsb         =  Vsb;
                vgs         =  Vgs;
                vth_drive   =  vgs - vth;
                vdsat       =  Vdsat;
                vdsat_marg  =  vds - vdsat;
                // Output currents
                if (sigVds < 0) begin
                    igidl       =  Igisle;
                    igisl       =  Igidle;
                    igs         =  Igde;
                    igd         =  Igse;
                end else begin
                    igidl       =  Igidle;
                    igisl       =  Igisle;
                    igs         =  Igse;
                    igd         =  Igde;
                end
                ids         =  Idse;
                id          =  Idse + igidl - igisl - igd;
                is          = -Idse - igidl + igisl - igs;
                ig          =  Igse + Igde;
                ib          =  0.0;
                idb         =  0.0;
                isb         =  0.0;
                // Conductances and transconductances
                gm          =  TYPE * ddx(id, V(G));
                gmb         =  TYPE * ddx(id, V(B));
                if (sigVds < 0.0) begin
                    gds         =  TYPE * ddx(id, V(S));
                end else begin
                    gds         =  TYPE * ddx(id, V(D));
                end
                // Capacitances and transcapacitances
                if (sigVds < 0.0) begin
                    qde         =  Qs - Qdse - Qgse - Qovs - Qssub - Qgsif - Qbsif;
                end else begin
                    qde         =  Qd + Qdse - Qgde - Qovd - Qdsub - Qgdif - Qbdif;
                end
                qge         =  Qg + Qgse + Qgde + Qovs + Qovd + Qgbe + Qgsif + Qgdif;
                qbe         =  Qb + Qssub + Qdsub - Qgbe + Qbsif + Qbdif;
                if (sigVds < 0.0) begin
                    cdd         =  TYPE * ddx(qde, V(S));
                    cgd         = -TYPE * ddx(qge, V(S));
                    cbd         = -TYPE * ddx(qbe, V(S));
                end else begin
                    cdd         =  TYPE * ddx(qde, V(D));
                    cgd         = -TYPE * ddx(qge, V(D));
                    cbd         = -TYPE * ddx(qbe, V(D));
                end
                cdg         = -TYPE * ddx(qde, V(G));
                cgg         =  TYPE * ddx(qge, V(G));
                cbg         = -TYPE * ddx(qbe, V(G));
                cdb         = -TYPE * ddx(qde, V(B));
                cgb         = -TYPE * ddx(qge, V(B));
                cbb         =  TYPE * ddx(qbe, V(B));
                cds         =  cdd - cdg - cdb;
                cgs         =  cgg - cgd - cgb;
                cbs         =  cbb - cbd - cbg;
                csd         =  cdd - cgd - cbd;
                csg         =  cgg - cdg - cbg;
                csb         =  cbb - cgb - cdb;
                css         =  csg + csd + csb;

            // Miscellaneous
                // Channel temperature and self-heating elevation
                tk          =  TKC;
                dtsh        =  DTC;
                // Analog gain, output resistance and Early voltage
                if (abs(gds) < 1.0e-40) begin
                    self_gain   =  0.0;
                    rout        =  0.0;
                    vearly      =  0.0;
                end else begin
                    self_gain   =  gm / gds;
                    rout        =  1.0 / gds;
                    vearly      =  id / gds;
                end
                // Gain factor
                if (abs(vth_drive) < 1.0e-40) begin
                    beff        =  0.0;
                end else begin
                    beff        =  2.0 * abs(id) / (vth_drive * vth_drive);
                end
                // Unity gain frequency
                if (abs(cgg) < 1.0e-40) begin
                    ft          =  0.0;
                end else begin
                    ft          =  gm / (2.0 * `PI * cgg);
                end
                // Gate resistance
                rgate       =  0.0;
                // Transconductance over drain current ratio
                if (abs(id) < 1.0e-40) begin
                    gmoverid    =  0.0;
                end else begin
                    gmoverid    =  gm / id;
                end
        `endif

        end    // OPinfo

    end    // analog block

endmodule
