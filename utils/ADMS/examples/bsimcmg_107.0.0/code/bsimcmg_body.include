// ********************************************************
// **** BSIM-CMG 107.0.0 released by Navid, Juan, and Sriramkumar on 07/12/2013 ****/
// *  BSIM Common Multi-Gate Model Equations (Verilog-A)
// ********************************************************
//
// ********************************************************
// * Copyright 2012 Regents of the University of California. 
// * All rights reserved.
// *
// * Project Director: Prof. Chenming Hu.
// * Authors: Sriramkumar V., Navid Paydavosi, Juan Duarte, Darsen Lu, 
// *          Chung-Hsun Lin, Mohan Dunga, Shijing Yao,
// *          Ali Niknejad, Chenming Hu
// ********************************************************
// ********************************************************
// *   NONDISCLOSURE STATEMENT
// Software is distributed as is, completely without warranty or service
// support. The University of California and its employees are not liable
// for the condition or performance of the software.
// The University of California owns the copyright and grants users a perpetual,
// irrevocable, worldwide, non-exclusive, royalty-free license with 
// respect to the software as set forth below.
// The University of California hereby disclaims all implied warranties.
// The University of California grants the users the right to modify, copy,
// and redistribute the software and documentation, both within the user's
// organization and externally, subject to the following restrictions
// 1. The users agree not to charge for the University of California code
// itself but may charge for additions, extensions, or support.
// 2. In any product based on the software, the users agree to acknowledge
// the University of California that developed the software. This
// acknowledgment shall appear in the product documentation.
// 3. The users agree to obey all U.S. Government restrictions governing
// redistribution or export of the software.
// 4. The users agree to reproduce any copyright notice which appears on
// the software on any copy or modification of such made available
// to others
// Agreed to on __Sept. 11, 2012_________________
// By: ___University of California, Berkeley____ 
//     ___Chenming Hu_____________________ 
//     ___Professor in Graduate School _______
// ********************************************************

// Clamped exponential function
analog function real lexp;
	input   x;
	real x;

	begin
		if(x > `EXPL_THRESHOLD) begin
			lexp =  `MAX_EXPL * (1.0+(x)-`EXPL_THRESHOLD);
		end else if(x < -`EXPL_THRESHOLD) begin
			lexp =  `MIN_EXPL;
		end else begin
			lexp =  exp(x);
		end
	end
endfunction

// Clamped log function
analog function real lln;
	input   x;
	real x;

	begin
		lln  =  ln(max(x , `N_MINLOG));
	end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
	input   x , c;
	real x , c;

	begin
		hypsmooth  =  0.5 * (x + sqrt(x*x + 4*c*c));
	end
endfunction

// Hyperbolic smooth max function
analog function real hypmax;
	input   x , xmin, c;
	real x , xmin, c;

	begin
		hypmax  =  xmin + 0.5 * (x-xmin-c + sqrt((x-xmin-c)*(x-xmin-c)-4*xmin*c));
	end
endfunction


// Node definitions
`ifdef __RGATEMOD__
	`define GateEdgeNode ge
`else
	`define GateEdgeNode g
`endif
`ifdef __NQSMOD1__
	`define IntrinsicGate gi
`else
	`define IntrinsicGate `GateEdgeNode
`endif

/***************************/
/*  Instance Parameters    */
/***************************/

/* Note: Some instance parameters are also model parameters.  */
/*       Please refer to the technical note for details.      */
parameter real L         =  30n from [1n:inf) `attr(type="instance" xyceAlsoModel="YES" info="Designed Gate Length");      // Designed Gate Length
parameter real D         =  40n from [1n:inf) `attr(type="instance" xyceAlsoModel="YES" info="Diameter of the cylinder (GEOMOD=3)");      // Diameter of the cylinder (GEOMOD=3)
parameter real TFIN      =  15n from [1n:inf) `attr(type="instance" xyceAlsoModel="YES" info="Body (Fin) thickness");      // Body (Fin) thickness
parameter real FPITCH    =  80n from [TFIN:inf) `attr(type="instance" xyceAlsoModel="YES" info="Fin pitch");    // Fin pitch
parameter integer NF     =  1 from [1:inf) `attr(info="Number of fingers");         // Number of fingers
parameter real NFIN      =  1.0 from (0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of fins per finger (real number enables optimization)");       // Number of fins per finger (real number enables optimization)
parameter integer NGCON  =  1 from [1:2] `attr(type="instance" xyceAlsoModel="YES" info="number of gate contact (1 or 2 sided)");           // number of gate contact (1 or 2 sided)
parameter real ASEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Source to substrate overlap area through oxide");             // Source to substrate overlap area through oxide
parameter real ADEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Drain to substrate overlap area through oxide");             // Drain to substrate overlap area through oxide
parameter real PSEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Perimeter of source to substrate overlap region through oxide");             // Perimeter of source to substrate overlap region through oxide
parameter real PDEO  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Perimeter of drain to substrate overlap region through oxide");             // Perimeter of drain to substrate overlap region through oxide
parameter real ASEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Source junction area (BULKMOD=1)");             // Source junction area (BULKMOD=1)
parameter real ADEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Drain junction area (BULKMOD=1)");             // Drain junction area (BULKMOD=1)
parameter real PSEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Source to substrate PN junction perimeter (BULKMOD=1)");             // Source to substrate PN junction perimeter (BULKMOD=1)
parameter real PDEJ  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Drain to substrate PN junction perimeter (BULKMOD=1)");             // Drain to substrate PN junction perimeter (BULKMOD=1)
parameter real COVS  =  0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant g/s overlap capacitance (CGEOMOD=1)");             // Constant g/s overlap capacitance (CGEOMOD=1)
parameter real COVD  =  COVS from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant g/d overlap capacitance (CGEOMOD=1)");          // Constant g/d overlap capacitance (CGEOMOD=1)
parameter real CGSP  =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant gate-to-source fringe capacitance (CGEOMOD=1)");           // Constant gate-to-source fringe capacitance (CGEOMOD=1)
parameter real CGDP  =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant gate-to-drain fringe capacitance (CGEOMOD=1)");           // Constant gate-to-drain fringe capacitance (CGEOMOD=1)
parameter real CDSP  =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Constant drain-to-source fringe capacitance (All CGEOMOD)");           // Constant drain-to-source fringe capacitance (All CGEOMOD)
parameter real NRS   =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of source diffusion squares");           // Number of source diffusion squares
parameter real NRD   =  0.0 from [0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Number of source diffusion squares");           // Number of source diffusion squares
parameter real LRSD  =  L from (0:inf) `attr(type="instance" xyceAlsoModel="YES" info="Length of the source/drain");             // Length of the source/drain

//Variability Handles
parameter real XL    	 =  0 `attr(info="L offset for channel length due to mask/etch effect");                      // L offset for channel length due to mask/etch effect
parameter real DTEMP 	 =  0 `attr(info="Variability in Device Temperature	");                      // Variability in Device Temperature	
parameter real DELVTRAND =  0 `attr(info="Variability in Vth" type="instance" xyceAlsoModel="yes");                      // Variability in Vth
parameter real U0MULT    =  1 from [0:inf) `attr(info="Variability in carrier mobility" type="instance" xyceAlsoModel="yes");         // Variability in carrier mobility
parameter real IDS0MULT  =  1 from [0:inf) `attr(info="Variability in Drain current for misc. reasons	");         // Variability in Drain current for misc. reasons	


/************************/
/*  Model Parameters    */
/************************/
parameter integer DEVTYPE  =  `ntype from [`ptype:`ntype];
parameter integer BULKMOD  =  0 from [0:1] `attr(info="Bulk model");
                                                    // 0: SOI multi-gate
                                                    // 1: Bulk multi-gate
parameter integer COREMOD  =  0 from [0:1] `attr(info="Surface potential algorithm");         // 0: Default surface potential algorithm
                                                    // 1: Simplified (efficient) surface potential algorithm
parameter integer GEOMOD   =  1 from [0:3] `attr(info="Geometry mode selector");
                                                    // 0: Double gate
                                                    // 1: Triple gate
                                                    // 2: Quadruple gate
                                                    // 3: Cylindrical gate
parameter integer CGEO1SW = 0 from [0:1]; // For CGEOMOD=1 only, this switch enables the parameters COVS, COVD, CGSP,  
                                                    // and CGDP to be in F per fin, per gate-finger, per unit channel width
parameter integer RDSMOD   =  0 from [0:1] `attr(info="Resistance model selector");
                                                    // 0: Internal s/d resistance model
                                                    // 1: External s/d resistance model
parameter integer ASYMMOD  =  0 from [0:1] `attr(info="Asymmetric model selector");         // 0: Asymmetry Model turned off - forward mode parameters used
                                                    // 1: Asymmetry Model turned on
parameter integer IGCMOD   =  0 from [0:1] `attr(info="model selector for Igc, Igs, and Igd");         // 0: Turn off Igc, Igs and Igd
                                                    // 1: Turn on Igc, Igs and Igd
parameter integer IGBMOD   =  0 from [0:1] `attr(info="model selector for Igb");         // 0: Turn off Igb
                                                    // 1: Turn on Igb
parameter integer GIDLMOD  =  0 from [0:1] `attr(info="GIDL/GISL current switcher");         // 0: Turn off GIDL/GISL current
                                                    // 1: Turn on GIDL/GISL current
parameter integer IIMOD    =  0 from [0:2] `attr(info="Impact ionization model switch");         // 0: No impact ionization current
                                                    // 1: BSIM4-based model
                                                    // 2: BSIMSOI-based model
parameter integer NQSMOD   =  0 from [0:2];         // 0: NQS models turned off  **NQSMOD=3 is disabled for now.**
                                                    // 1: NQS gate resistance / gi node turned on
                                                    // 2: NQS charge deficit model (BSIM4) / q node turned on
                                                    // 3: NQS charge segmentation model / Nseg nodes turned on
parameter integer SHMOD    =  0 from [0:1] `attr(info="Self heating and T node switcher --- NOT USED IN XYCE");         // 0: No self-heating
                                                    // 1: Self-heating turned on
parameter integer RGATEMOD =  0 from [0:1] `attr(info="Gate electrode resistor and ge node switcher --- NOT USED IN XYCE");         // 0: Gate electrode resistance / ge node turned off
                                                    // 1: Gate electrode resistance / ge node turned on
parameter integer RGEOMOD  =  0 from [0:1] `attr(info="Bias independent parasitic resistance model selector");         // Geometry-dependent source/drain resistance
                                                    // 0: RSH-based; 1: Holistic
parameter integer CGEOMOD  =  0 from [0:2] `attr(info="parasitic capacitance model selector");         // Geometry dependent parasitic capacitance model selector
parameter integer CAPMOD   =  0 from[0:1] `attr(info="Accumulation region capacitance model selector");          // For BULKMOD =1;
                                                    // 0: No accumulation capacitance; 1: Accumulation capacitance included
parameter real LINT    =  0 `attr(info="Length reduction parameter (dopant diffusion effect)");                        // Length reduction parameter (dopant diffusion effect)
parameter real LL      =  0 `attr(info="Length reduction parameter (dopant diffusion effect)");                        // Length reduction parameter (dopant diffusion effect)
parameter real LLN     =  1 `attr(info="Length reduction parameter (dopant diffusion effect)");                        // Length reduction parameter (dopant diffusion effect)
parameter real DLC     =  0 `attr(info="Delta L for C-V model");                        // Delta L for C-V model
parameter real DLCACC  =  0 `attr(info="Delta L for C-V model in accumulation region (CAPMOD=1, BULKMOD=1)");                        // Delta L for C-V model in accumulation region (CAPMOD=1, BULKMOD=1)
parameter real DLBIN   =  0 `attr(info="Delta L for Binning");                        // Delta L for Binning
parameter real LLC     =  0 `attr(info="Length reduction parameter (dopant diffusion effect)");                        // Length reduction parameter (dopant diffusion effect)
parameter real EOT     =  1.0n from [0.1n:inf) `attr(info="equivalent oxide thickness in meters");     // equivalent oxide thickness in meters
parameter real TOXP    =  1.2n from [0.1n:inf) `attr(info="physical oxide thickness in meters");     // physical oxide thickness in meters
parameter real EOTBOX  =  140n from [1n:inf) `attr(info="equivalent oxide thickness of the buried oxide (SOI FinFET) or STI (bulk FinFET) in meters");       // equivalent oxide thickness of the buried oxide (SOI FinFET)
                                                    //   or STI (bulk FinFET) in meters
parameter real HFIN    =  30n from [1n:inf) `attr(info="Fin height in meters");        // Fin height in meters
parameter real FECH    =  1 from [0:inf) `attr(info="End-channel factor, for different orientation/shape");           // End-channel factor, for different orientation/shape
parameter real DELTAW  =  0 `attr(info="change of effective width due to shape of fin/cylinder");                        // change of effective width due to shape of fin/cylinder
parameter real FECHCV  =  1 from [0:inf) `attr(info="CV end-channel factor, for different orientaion/shape");           // CV end-channel factor, for different orientaion/shape
parameter real DELTAWCV=  0 `attr(info="CV change of effective width due to shape of fin/cylinder");                        // CV change of effective width due to shape of fin/cylinder

parameter real NBODY    =  1e22 from [1e18:5e24] `attr(info="channel (body) doping");   // channel (body) doping
parameter real NBODYN1  =  0 from [-0.08:inf) `attr(info="NFIN dependence of channel (body) doping");      // NFIN dependence of channel (body) doping
parameter real NBODYN2  =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of channel (body) doping");  // NFIN dependence of channel (body) doping
parameter real NSD     =  2e26 from [2e25:1e27] `attr(info="Source/drain active doping concentration in m-3");    // Source/drain active doping concentration in m-3

parameter real PHIG    =  4.61 from [0:inf) `attr(info="Gate workfunction, eV");        // Gate workfunction, eV
parameter real PHIGL   =  0 `attr(info="Length dependence of Gate workfunction, eV/m");                        // Length dependence of Gate workfunction, eV/m
parameter real PHIGN1  =  0 from [-0.08:inf) `attr(info="NFIN dependence of Gate workfunction");       // NFIN dependence of Gate workfunction
parameter real PHIGN2  =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of Gate workfunction");   // NFIN dependence of Gate workfunction

parameter real EPSROX  =  3.9 from [1:inf) `attr(info="Relative dielectric constant of the gate dielectric");         // Relative dielectric constant of the gate dielectric
parameter real EPSRSUB =  11.9 from [1:inf) `attr(info="Relative dielectric constant of the channel material");        // Relative dielectric constant of the channel material
parameter real EASUB   =  4.05 from [0:inf) `attr(info="Electron affinity of substrate, eV");        // Electron affinity of substrate, eV
parameter real NI0SUB  =  1.1e16 `attr(info="Intrinsic carrier constant at 300.15K, m-3");                   // Intrinsic carrier constant at 300.15K, m-3
parameter real BG0SUB  =  1.12 `attr(info="Band gap of substrate at 300.15K, eV");                     // Band gap of substrate at 300.15K, eV
parameter real NC0SUB  =  2.86e25 `attr(info="Conduction band density of states, m-3");                  // Conduction band density of states, m-3
parameter real NGATE   =  0.0 `attr(info="Parameter for Poly Gate Doping, for metal gate please set NGATE = 0");                      // Parameter for Poly Gate Doping, for metal gate please set NGATE = 0
parameter real Imin    =  1.0E-15 `attr(info="Parameter for Vgs Clamping for inversion region calc. in accumulation");                  // Parameter for Vgs Clamping for inversion region calc. in accumulation
// Short Channel Effects
parameter real CIT      =  0.0 `attr(info="parameter for interface trap");                     // parameter for interface trap
parameter real CDSC     =  7e-3 `attr(info="coupling capacitance between S/D and channel");                    // coupling capacitance between S/D and channel
parameter real CDSCN1   =  0 from [-0.08:inf) `attr(info="NFIN dependence of CDSC");      // NFIN dependence of CDSC
parameter real CDSCN2   =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of CDSC");  // NFIN dependence of CDSC
parameter real CDSCD    =  7e-3 `attr(info="drain-bias sensitivity of CDSC");                    // drain-bias sensitivity of CDSC
parameter real CDSCDN1  =  0 from [-0.08:inf) `attr(info="NFIN dependence of CDSCD");      // NFIN dependence of CDSCD
parameter real CDSCDN2  =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of CDSCD");  // NFIN dependence of CDSCD
parameter real CDSCDR   =  CDSCD `attr(info="Reverse-mode drain-bais sensitivity of CDSC (Experimental)");                     // Reverse-mode drain-bais sensitivity of CDSC (Experimental)
parameter real CDSCDRN1 =  CDSCDN1 from [-0.08:inf) `attr(info="NFIN dependence of CDSCD");  // NFIN dependence of CDSCD
parameter real CDSCDRN2 =  CDSCDN2 from[1.0e-5:inf) `attr(info="NFIN dependence of CDSCD");  // NFIN dependence of CDSCD
parameter real DVT0     =  0.0 `attr(info="SCE coefficient");                      // SCE coefficient
parameter real DVT1     =  0.60 `attr(info="SCE exponent coefficient, after binning should be in (0:inf)");                     // SCE exponent coefficient, after binning should be in (0:inf)
parameter real DVT1SS   =  DVT1 `attr(info="Subthreshold Swing exponent coefficient, after binning should be in (0:inf)");                     // Subthreshold Swing exponent coefficient, after binning should be in (0:inf)
parameter real PHIN     =  0.05 `attr(info="Nonuniform vertical doping effect on surface potential, V");                     // Nonuniform vertical doping effect on surface potential, V
parameter real ETA0     =  0.60 `attr(info="DIBL coefficient");                     // DIBL coefficient
parameter real ETA0N1   =  0 from [-0.08:inf) `attr(info="NFIN dependence of ETA0");       // NFIN dependence of ETA0
parameter real ETA0N2   =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of ETA0");   // NFIN dependence of ETA0
parameter real TETA0    =  0.0 `attr(info="Temperature dependence of DIBL coefficient, 1/K");                      // Temperature dependence of DIBL coefficient, 1/K
parameter real ETA0R    =  ETA0 `attr(info="Reverse-mode DIBL coefficient (Experimental)");                     // Reverse-mode DIBL coefficient (Experimental)
parameter real TETA0R   =  TETA0 `attr(info="Temperature dependence of Reverse-mode DIBL coefficient, 1/K");                    // Temperature dependence of Reverse-mode DIBL coefficient, 1/K
parameter real DSUB     =  1.06 `attr(info="DIBL exponent coefficient");                     // DIBL exponent coefficient
parameter real DVTP0    =  0 `attr(info="Coefficient for Drain-Induced Vth Shift (DITS)");                        // Coefficient for Drain-Induced Vth Shift (DITS)
parameter real DVTP1    =  0 `attr(info="DITS exponent coefficient");                        // DITS exponent coefficient
parameter real K1RSCE   =  0.0 `attr(info="K1 for reverse short channel effect calculation ");                      // K1 for reverse short channel effect calculation 
parameter real LPE0     =  5.0n `attr(info="Equivalent length of pocket region at zero bias");                     // Equivalent length of pocket region at zero bias
parameter real DVTSHIFT =  0 `attr(info="Vth shift handle");                        // Vth shift handle

// Lateral non-uniform doping effect (IV-CV Vth shift)
parameter real K0      =  0.0 `attr(info="Lateral NUD voltage parameter, V");                      // Lateral NUD voltage parameter, V
parameter real K01     =  0.0 `attr(info="Temperature dependence of lateral NUD voltage parameter, V/K");                      // Temperature dependence of lateral NUD voltage parameter, V/K
parameter real K0SI    =  1.0 `attr(info="Correction factor for strong inversion, used in Mnud, after binnig should be from (0:inf)");                      // Correction factor for strong inversion, used in Mnud, after binnig should be from (0:inf)
parameter real K0SI1   =  0.0 `attr(info="Temperature dependence of K0SI, 1/K");                      // Temperature dependence of K0SI, 1/K
parameter real K1SI    =  K0SI `attr(info="Correction factor for strong inversion, used in Mob");                     // Correction factor for strong inversion, used in Mob
parameter real K1SI1   =  K0SI1 `attr(info="Temperature dependence of K1SI, 1/K");                    // Temperature dependence of K1SI, 1/K

// Body Effect for MG Devices on Bulk Substrate (ex: FinFETs on BULK)
parameter real PHIBE   =  0.7 `attr(info="Body effect voltage parameter, V, after binnig should be from [0.2:1.2]");                      // Body effect voltage parameter, V, after binnig should be from [0.2:1.2]
parameter real K1      =  0.0 `attr(info="Body effect coefficient for sub-threshold region");                      // Body effect coefficient for sub-threshold region
parameter real K11     =  0.0 `attr(info="Temperature dependence of K1");                      // Temperature dependence of K1
parameter real K1SAT   =  0.0 `attr(info="Correction factor for K1 in saturation (high Vds)		");                      // Correction factor for K1 in saturation (high Vds)		
parameter real K1SAT1  =  0.0 `attr(info="Temperature dependence of K1SAT1	");                      // Temperature dependence of K1SAT1	

// Quantum Mechanical Effect
parameter real QMFACTOR  =  0.0 `attr(info="Prefactor + switch for QM Vth correction");                    // Prefactor + switch for QM Vth correction
parameter real QMTCENIV  =  0.0 `attr(info="Prefactor + switch for QM Width correction for IV");                    // Prefactor + switch for QM Width correction for IV
parameter real QMTCENCV  =  0.0 `attr(info="Prefactor + switch for QM Width and Toxeff correction for CV");                    // Prefactor + switch for QM Width and Toxeff correction for CV
parameter real QMTCENCVA =  0.0 `attr(info="Prefactor + switch for QM Width and Toxeff correction for CV (accumulation region)");                    // Prefactor + switch for QM Width and Toxeff correction for CV (accumulation region)
parameter real AQMTCEN   =  0.0 `attr(info="Parameter for Geometric dependence of Tcen on R/TFIN/HFIN");                    // Parameter for Geometric dependence of Tcen on R/TFIN/HFIN
parameter real BQMTCEN   =  12.0e-9 `attr(info="Parameter for Geometric dependence of Tcen on R/TFIN/HFIN");                // Parameter for Geometric dependence of Tcen on R/TFIN/HFIN
parameter real ETAQM     =  0.54 `attr(info="Bulk charge coefficient for Tcen");                   // Bulk charge coefficient for Tcen
parameter real QM0       =  1.00e-3 `attr(info="Knee-Point for Tcen in inversion (Charge normalized to Cox)");                // Knee-Point for Tcen in inversion (Charge normalized to Cox)
parameter real PQM       =  0.66 `attr(info="Slope of normalized Tcen in inversion");                   // Slope of normalized Tcen in inversion
parameter real QM0ACC    =  1.00e-3 `attr(info="Knee-Point for Tcen in accumulation (Charge normalized to Cox)");                // Knee-Point for Tcen in accumulation (Charge normalized to Cox)
parameter real PQMACC    =  0.66 `attr(info="Slope of normalized Tcen in accumulation");                   // Slope of normalized Tcen in accumulation

// Velocity Saturation Model
parameter real VSAT        =  85000; 
parameter real VSATN1      =  0 from [-0.08:inf) `attr(info="NFIN dependence of VSAT ");     // NFIN dependence of VSAT 
parameter real VSATN2      =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of VSAT "); // NFIN dependence of VSAT 
parameter real AVSAT       =  0.0; 
parameter real BVSAT       =  100.0e-9; 
parameter real VSAT1       =  VSAT `attr(info="Velocity Saturation parameter for I_on degradation - forward mode");                      // Velocity Saturation parameter for I_on degradation - forward mode
parameter real VSAT1N1     =  VSATN1 from [-0.08:inf) `attr(info="NFIN dependence of VSAT1 ");   // NFIN dependence of VSAT1 
parameter real VSAT1N2     =  VSATN2 from[1.0e-5:inf) `attr(info="NFIN dependence of VSAT1 ");   // NFIN dependence of VSAT1 
parameter real VSAT1R      =  VSAT1 `attr(info="Velocity Saturation parameter for I_on degradation - reverse mode");                     // Velocity Saturation parameter for I_on degradation - reverse mode
parameter real VSAT1RN1    =  VSAT1N1 from [-0.08:inf) `attr(info="NFIN dependence of VSAT1R ");  // NFIN dependence of VSAT1R 
parameter real VSAT1RN2    =  VSAT1N2 from[1.0e-5:inf) `attr(info="NFIN dependence of VSAT1R ");  // NFIN dependence of VSAT1R 
parameter real AVSAT1      =  AVSAT;	 
parameter real BVSAT1      =  BVSAT; 
parameter real DELTAVSAT   =  1.0;
parameter real PSAT        =  2.0 `attr(info="Velocity saturation exponent, after binnig should be from [2.0:inf)");                    // Velocity saturation exponent, after binnig should be from [2.0:inf)
parameter real APSAT       =  0.0;
parameter real BPSAT       =  1.0; 
parameter real KSATIV      =  1.0; 
parameter real VSATCV      =  VSAT `attr(info="Velocity Saturation parameter for CV");					  // Velocity Saturation parameter for CV
parameter real AVSATCV     =  AVSAT;	 
parameter real BVSATCV     =  BVSAT; 
parameter real DELTAVSATCV =  DELTAVSAT;
parameter real PSATCV      =  PSAT `attr(info="Velocity saturation exponent for C-V");                   // Velocity saturation exponent for C-V
parameter real APSATCV     =  APSAT;
parameter real BPSATCV     =  BPSAT; 
parameter real MEXP        =  4.0; 
parameter real AMEXP       =  0.0; 
parameter real BMEXP       =  1.0; 
parameter real MEXPR       =  MEXP; 
parameter real AMEXPR      =  AMEXP; 
parameter real BMEXPR      =  BMEXP; 
parameter real PTWG        =  0.0 `attr(info="Gmsat degradation parameter - forward mode ");                    // Gmsat degradation parameter - forward mode 
parameter real PTWGR       =  PTWG `attr(info="Gmsat degradation parameter - reverse mode");                   // Gmsat degradation parameter - reverse mode
parameter real APTWG       =  0.0; 
parameter real BPTWG       =  100.0e-9; 
parameter real AT          =  -1.56e-3; 
parameter real TMEXP       =  0.0;
parameter real TMEXPR      =  TMEXP;  
parameter real PTWGT       =  0.004; 

// Mobility Model
parameter real U0       =  0.03; 
parameter real U0N1     =  0 from [-0.08:inf) `attr(info="NFIN dependence of U0 ");       // NFIN dependence of U0 
parameter real U0N2     =  1.0e5 from[1.0e-5:inf) `attr(info="NFIN dependence of U0 ");   // NFIN dependence of U0 
parameter real ETAMOB   =  2.0; 
parameter real UP       =  0; 
parameter real LPA      =  1.0; 
parameter real UA       =  0.3; 
parameter real AUA      =  0.0; 
parameter real BUA      =  100.0e-9; 
parameter real UC       =  0.0 `attr(info="Body effect for mobility degradation parameter - BULKMOD=1");                      // Body effect for mobility degradation parameter - BULKMOD=1
parameter real EU       =  2.5; 
parameter real AEU      =  0.0; 
parameter real BEU      =  100.0e-9; 
parameter real UD       =  0.0; 
parameter real AUD      =  0.0; 
parameter real BUD      =  50.0e-9; 
parameter real UCS      =  1.0; 
parameter real UTE      =  0.0; 
parameter real UTL      =  -1.5e-3;
parameter real EMOBT    =  0.0; 
parameter real UA1      =  1.032e-3;
parameter real UC1      =  0.056e-9; 
parameter real UD1      =  0.0; 
parameter real UCSTE    =  -4.775e-3;
parameter real CHARGEWF =  0 from [-1:1] `attr(info="Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side  ");           // Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side  

// Access Resistance Model
parameter real RDSWMIN =  0.0; 
parameter real RDSW    =  100.0; 
parameter real ARDSW   =  0.0; 
parameter real BRDSW   =  100.0e-9; 
parameter real RSWMIN  =  0.0; 
parameter real RSW     =  50.0; 
parameter real ARSW    =  0.0; 
parameter real BRSW    =  100.0e-9; 
parameter real RDWMIN  =  0.0; 
parameter real RDW     =  50.0; 
parameter real ARDW    =  0.0; 
parameter real BRDW    =  100.0e-9;
parameter real RSDR    =  0.0    from[0:inf) `attr(info="Source side drift resistance parameter - forward mode");       // Source side drift resistance parameter - forward mode
parameter real RSDRR   =  RSDR   from[0:inf) `attr(info="Source side drift resistance parameter - reverse mode");       // Source side drift resistance parameter - reverse mode
parameter real RDDR    =  RSDR   from[0:inf) `attr(info="Drain side drift resistance parameter - forward mode");       // Drain side drift resistance parameter - forward mode
parameter real RDDRR   =  RDDR   from[0:inf) `attr(info="Drain side drift resistance parameter - reverse mode");       // Drain side drift resistance parameter - reverse mode
parameter real PRSDR   =  1.0 `attr(info="Source side quasi-saturation parameter");                      // Source side quasi-saturation parameter
parameter real PRDDR   =  PRSDR `attr(info="Drain side quasi-saturation parameter");                    // Drain side quasi-saturation parameter
parameter real PRWGS   =  0.0 `attr(info="Gate bias dependence of source extension resistance" xyceUnit="U_VOLTM1");                      // Gate bias dependence of source extension resistance, Units:V^-1
parameter real PRWGD   =  PRWGS `attr(info="Gate bias dependence of drain extension resistance" xyceUnit="U_VOLTM1");                    // Gate bias dependence of drain extension resistance, Units:V^-1
parameter real WR      =  1.0; 
parameter real PRT     =  0.001;
parameter real TRSDR   =  0.0;
parameter real TRDDR   =  TRSDR;
//parameter real RCVFAC  = 1.0;                     // Series resistance correction factor for CV  Navid_added
// DIBL Model
parameter real PDIBL1  =  1.30 `attr(info="DIBL Output Conductance parameter - forward mode");                     // DIBL Output Conductance parameter - forward mode
parameter real PDIBL1R =  PDIBL1 `attr(info="DIBL Output Conductance parameter - reverse mode ");                   // DIBL Output Conductance parameter - reverse mode 
parameter real PDIBL2  =  2.0e-4 `attr(info="DIBL Output Conductance parameter ");                   // DIBL Output Conductance parameter 
parameter real DROUT   =  1.06; 
parameter real PVAG    =  1.0; 

// Channel Length Modulation Effect
parameter real PCLM    =  0.013; 
parameter real APCLM   =  0.0; 
parameter real BPCLM   =  100.0e-9; 
parameter real PCLMG   =  0.0; 
parameter real PCLMCV  =  PCLM `attr(info="CLM parameter for Short Channel CV ");                     // CLM parameter for Short Channel CV 

// Non-saturation Effect
parameter real A1      =  0.0 `attr(info="Non-saturation effect parameter for strong inversion region");                      // Non-saturation effect parameter for strong inversion region
parameter real A11     =  0.0 `attr(info="Temperature dependence of A1");                      // Temperature dependence of A1
parameter real A2      =  0.0 `attr(info="Non-saturation effect parameter for moderate inversion region");                      // Non-saturation effect parameter for moderate inversion region
parameter real A21     =  0.0 `attr(info="Temperature dependence of A2");                      // Temperature dependence of A2

// Gate Electrode Resistance
parameter real RGEXT   =  0.0 from [0:inf) `attr(info="Effective gate electrode external resistance");         // Effective gate electrode external resistance
parameter real RGFIN   =  1.0e-3 from [1.0e-3:inf) `attr(info="Effective gate electrode per finger per fin resistance"); // Effective gate electrode per finger per fin resistance

// Geometry dependent Source/Drain Resistance RGEOMOD=0
parameter real RSHS    =  0.0 `attr(info="Source-side sheet resistance");                      // Source-side sheet resistance
parameter real RSHD    =  RSHS `attr(info="Drain-side sheet resistance");                     // Drain-side sheet resistance

// Geometry dependent Source/Drain Resistance RGEOMOD=1 for variability modeling
// These parameters are shared with CGEOMOD = 2
parameter real HEPI      =  10.0n `attr(info="Height of the raised source/drain on top of the fin");                  // Height of the raised source/drain on top of the fin
parameter real TSILI     =  10.0n `attr(info="Thickness of the silicide on top of the raised source/drain");                  // Thickness of the silicide on top of the raised source/drain
parameter real RHOC      =  1.0e-12 from [1.0e-18:1.0e-9];
parameter real RHORSD    =  1.0 from (0:inf);
//parameter real RHOEXT    =  1.0 from (0:inf);
parameter real CRATIO    =  0.5 from [0:1];
parameter real DELTAPRSD =  0.0 from (-FPITCH:inf);
parameter integer SDTERM =  0 from [0:1];
parameter real LSP       =  0.2 * (L + XL) from (0:inf);
//parameter real LDG       =  5.0e-9 from [0:inf);
parameter real EPSRSP    =  3.9 from [1:inf) `attr(info="Relative dielectric constant of the spacer");       // Relative dielectric constant of the spacer
parameter real TGATE     =  30.0n from (0:inf) `attr(info="Gate height on top of the hard mask");     // Gate height on top of the hard mask
parameter real TMASK     =  30.0n from [0:inf) `attr(info="Height of hard mask on top of the fin");     // Height of hard mask on top of the fin
parameter real ASILIEND  =  0.0 from [0:inf);
parameter real ARSDEND   =  0.0 from [0:inf);
parameter real PRSDEND   =  0.0 from [0:inf);
parameter real NSDE      =  2e25 from [1e25:1e26] `attr(info="Source/drain active doping concentration at Leff edge");  // Source/drain active doping concentration at Leff edge
parameter real RGEOA     =  1.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOB     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOC     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOD     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real RGEOE     =  0.0 `attr(info="Fitting parameter for RGEOMOD=1");                    // Fitting parameter for RGEOMOD=1
parameter real CGEOA     =  1.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOB     =  0.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOC     =  0.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOD     =  0.0 `attr(info="Fitting parameter for CGEOMOD=2");                    // Fitting parameter for CGEOMOD=2
parameter real CGEOE     =  1.0 from [0:inf) `attr(info="Fitting parameter for CGEOMOD=2");       // Fitting parameter for CGEOMOD=2

// Gate Current
parameter real AIGBINV  =  1.11e-2 `attr(info="parameter for Igb in inversion");                  // parameter for Igb in inversion
parameter real AIGBINV1 =  0 `attr(info="parameter for Igb in inversion");                        // parameter for Igb in inversion
parameter real BIGBINV  =  9.49e-4 `attr(info="parameter for Igb in inversion");                  // parameter for Igb in inversion
parameter real CIGBINV  =  6.00e-3 `attr(info="parameter for Igb in inversion");                  // parameter for Igb in inversion
parameter real EIGBINV  =  1.1 `attr(info="parameter for Igb in inversion");                      // parameter for Igb in inversion
parameter real NIGBINV  =  3.0 `attr(info="parameter for Igb in inversion");                      // parameter for Igb in inversion
parameter real AIGBACC  =  1.36e-2 `attr(info="parameter for Igb in accumulation");                  // parameter for Igb in accumulation
parameter real AIGBACC1 =  0 `attr(info="parameter for Igb in accumulation");                        // parameter for Igb in accumulation
parameter real BIGBACC  =  1.71e-3 `attr(info="parameter for Igb in accumulation");                  // parameter for Igb in accumulation
parameter real CIGBACC  =  7.5e-2 `attr(info="parameter for Igb in accumulation");                   // parameter for Igb in accumulation
parameter real NIGBACC  =  1.0 `attr(info="parameter for Igb in accumulation");                      // parameter for Igb in accumulation
parameter real AIGC     =  1.36e-2 `attr(info="parameter for Igc in inversion");                  // parameter for Igc in inversion
parameter real AIGC1    =  0 `attr(info="parameter for Igc in inversion");                        // parameter for Igc in inversion
parameter real BIGC     =  1.71e-3 `attr(info="parameter for Igc in inversion");                  // parameter for Igc in inversion
parameter real CIGC     =  0.075 `attr(info="parameter for Igc in inversion");                    // parameter for Igc in inversion
parameter real PIGCD    =  1.0 `attr(info="parameter for Igc partition");                      // parameter for Igc partition
parameter real DLCIGS   =  0 `attr(info="Delta L for Igs model");                        // Delta L for Igs model
parameter real AIGS     =  1.36e-2 `attr(info="parameter for Igs in inversion");                  // parameter for Igs in inversion
parameter real AIGS1    =  0 `attr(info="parameter for Igs in inversion");                        // parameter for Igs in inversion
parameter real BIGS     =  1.71e-3 `attr(info="parameter for Igs in inversion");                  // parameter for Igs in inversion
parameter real CIGS     =  0.075 `attr(info="parameter for Igs in inversion");                    // parameter for Igs in inversion
parameter real DLCIGD   =  DLCIGS `attr(info="Delta L for Igd model");                   // Delta L for Igd model
parameter real AIGD     =  AIGS `attr(info="parameter for Igd in inversion");                     // parameter for Igd in inversion
parameter real AIGD1    =  AIGS1 `attr(info="parameter for Igd in inversion");                    // parameter for Igd in inversion
parameter real BIGD     =  BIGS `attr(info="parameter for Igd in inversion");                     // parameter for Igd in inversion
parameter real CIGD     =  CIGS `attr(info="parameter for Igd in inversion");                     // parameter for Igd in inversion
parameter real TOXREF   =  1.2n from (0:inf) `attr(info="Target tox value [m]");        // Target tox value [m]
parameter real TOXG     =  TOXP `attr(info="oxide thickness for gate current model in meters, Introduced in BSIM-CMG106.1.0" xyceUnit="U_METER");                     // oxide thickness for gate current model in meters, Introduced in BSIM-CMG106.1.0
parameter real NTOX     =  1.0 `attr(info="Exponent for Tox ratio");                      // Exponent for Tox ratio
parameter real POXEDGE  =  1.0 `attr(info="Factor for the gate edge Tox");                      // Factor for the gate edge Tox

// GIDL/GISL Current
parameter real AGISL   =  6.055p `attr(info="pre-exponential coeff. for GISL in mho");                   // pre-exponential coeff. for GISL in mho
parameter real BGISL   =  0.3e9 `attr(info="exponential coeff. for GISL" xyceUnit="U_VMM1");                    // exponential coeff. for GISL in V/m
parameter real CGISL   =  0.5 `attr(info="parameter for body-effect of GISL" xyceUnit="U_VOLT3");                      // parameter for body-effect of GISL in V^3
parameter real EGISL   =  0.2 `attr(info="band bending parameter for GISL" xyceUnit="U_VOLT");                      // band bending parameter for GISL in V
parameter real PGISL   =  1.0 `attr(info="parameter for body-bias effect on GISL");                      // parameter for body-bias effect on GISL
parameter real AGIDL   =  AGISL `attr(info="pre-exponential coeff. for GIDL in mho");                    // pre-exponential coeff. for GIDL in mho
parameter real BGIDL   =  BGISL `attr(info="exponential coeff. for GIDL" xyceUnit="U_VMM1");                    // exponential coeff. for GIDL in V/m
parameter real CGIDL   =  CGISL `attr(info="parameter for body-effect of GIDL" xyceUnit="U_VOLT3");                    // parameter for body-effect of GIDL in V^3
parameter real EGIDL   =  EGISL `attr(info="band bending parameter for GIDL" xyceUnit="U_VOLT");                    // band bending parameter for GIDL in V
parameter real PGIDL   =  PGISL `attr(info="parameter for body-bias effect on GIDL");                    // parameter for body-bias effect on GIDL

// Impact Ionization Current
// IIMOD=1	
parameter real ALPHA0  =  0.0 `attr(info="first parameter of Iii" xyceUnit="U_MVM1");                      // first parameter of Iii, m/V
parameter real ALPHA01 =  0.0 `attr(info="Temperature dependence of ALPHA0, m/V/degrees");                      // Temperature dependence of ALPHA0, m/V/degrees
parameter real ALPHA1  =  0.0 `attr(info="L scaling parameter of Iii" xyceUnit="U_VOLTM1");                      // L scaling parameter of Iii, 1/V
parameter real ALPHA11 =  0.0 `attr(info="Temperature dependence ALPHA1, 1/V/degree");                      // Temperature dependence ALPHA1, 1/V/degree
parameter real BETA0   =  0.0 `attr(info="Vds dependent parameter of Iii" xyceUnit="U_VOLTM1");                      // Vds dependent parameter of Iii, 1/V
// IIMOD=2
parameter real ALPHAII0  =  0.0 `attr(info="first parameter of Iii for IIMOD=2, m/V												"); 					// first parameter of Iii for IIMOD=2, m/V												
parameter real ALPHAII01 =  0.0 `attr(info="Temperature dependence of ALPHAII0, m/V/degrees"); 					// Temperature dependence of ALPHAII0, m/V/degrees
parameter real ALPHAII1  =  0.0 `attr(info="L scaling parameter of Iii for IIMOD=2" xyceUnit="U_VOLTM1");					// L scaling parameter of Iii for IIMOD=2, 1/V
parameter real ALPHAII11 =  0.0 `attr(info="Temperature dependence of ALPHAII1, 1/V/degrees");					// Temperature dependence of ALPHAII1, 1/V/degrees

parameter real BETAII0 	=  0.0 `attr(info="Vds dependent parameter of Iii" xyceUnit="U_VOLTM1");                      // Vds dependent parameter of Iii, 1/V
parameter real BETAII1 	=  0.0 `attr(info="Vds dependent parameter of Iii");                      // Vds dependent parameter of Iii
parameter real BETAII2 	=  0.1 `attr(info="Vds dependent parameter of Iii, V");                      // Vds dependent parameter of Iii, V
parameter real ESATII  	=  1.0e7 `attr(info="Saturation channel E-Field for Iii" xyceUnit="U_VMM1");                    // Saturation channel E-Field for Iii, V/m
parameter real LII     	=  0.5E-9 `attr(info="Channel length dependent parameter of Iii" xyceUnit="U_VM");                   // Channel length dependent parameter of Iii, V-m
parameter real SII0    	=  0.5 `attr(info="Vgs dependent parameter of Iii" xyceUnit="U_VOLTM1");                      // Vgs dependent parameter of Iii, 1/V
parameter real SII1    	=  0.1 `attr(info="1st Vgs dependent parameter of Iii" xyceUnit="U_VOLTM1");                      // 1st Vgs dependent parameter of Iii, 1/V
parameter real SII2    	=  0.0 `attr(info="2nd Vgs dependent parameter of Iii");                      // 2nd Vgs dependent parameter of Iii
parameter real SIID    	=  0.0 `attr(info="3rd Vds dependent parameter of Iii" xyceUnit="U_VOLTM1");                      // 3rd Vds dependent parameter of Iii, 1/V

// Accumulation Capacitance (CAPMOD=1)
parameter real EOTACC    =  EOT from [0.1n:inf) `attr(info="equivalent oxide thickness for accumulation region in meters" xyceUnit="U_METER");    // equivalent oxide thickness for accumulation region in meters
parameter real DELVFBACC =  0.0 `attr(info="Change in Flatband Voltage; Vfb_accumulation-Vfb_inversion");                    // Change in Flatband Voltage; Vfb_accumulation-Vfb_inversion

// Fringe capacitance
// CGEOMOD=0
parameter real CFS =  2.5e-11 from [0:inf) `attr(info="Outer Fringe Cap (source side)");         // Outer Fringe Cap (source side)
parameter real CFD =  CFS from [0:inf) `attr(info="Outer Fringe Cap (drain side)");             // Outer Fringe Cap (drain side)

// Overlap capacitance (CGEOMOD=0 and 2)
parameter real CGSO    =  0.0 from [0:inf) `attr(info="Non LDD region source-gate overlap capacitance per unit channel width");         // Non LDD region source-gate overlap capacitance per unit channel width
parameter real CGDO    =  CGSO from [0:inf) `attr(info="Non LDD region drain-gate overlap capacitance per unit channel width");        // Non LDD region drain-gate overlap capacitance per unit channel width
parameter real CGSL    =  0.0 from [0:inf);
parameter real CGDL    =  CGSL from [0:inf);
parameter real CKAPPAS =  0.6 from [0.02:inf);
parameter real CKAPPAD =  CKAPPAS from [0.02:inf);
parameter real CGBO    =  0.0 from [0:inf) `attr(info="Gate to substrate overlap cap per unit channel length per finger per NGCON	");         // Gate to substrate overlap cap per unit channel length per finger per NGCON	
parameter real CGBN    =  0.0 from [0:inf) `attr(info="Gate to substrate overlap cap per unit channel length per fin per finger");         // Gate to substrate overlap cap per unit channel length per fin per finger
parameter real CGBL    =  0.0 from [0:inf) `attr(info="Bias dependent component of Gate to substrate overlap cap ");         // Bias dependent component of Gate to substrate overlap cap 
                                                    //   per unit channel length per fin per finger 
parameter real CKAPPAB =  0.6 from [0.02:inf);

// Source/drain to substrate sidewall capacitance
parameter real CSDESW  =  0.0 from [0:inf) `attr(info="Coefficient for source/drain to substrate sidewall cap");         // Coefficient for source/drain to substrate sidewall cap

// Junction current and capacitance
// Junction Capacitance
parameter real CJS    =  5.0e-4 `attr(info="Unit area source-side junction capacitance at zero bias");                    // Unit area source-side junction capacitance at zero bias
parameter real CJD    =  CJS `attr(info="Unit area drain-side junction capacitance at zero bias");                       // Unit area drain-side junction capacitance at zero bias
parameter real CJSWS  =  5.0e-10 `attr(info="Unit length source-side sidewall junction capacitance at zero bias");                   // Unit length source-side sidewall junction capacitance at zero bias
parameter real CJSWD  =  CJSWS `attr(info="Unit length drain-side sidewall junction capacitance at zero bias");                     // Unit length drain-side sidewall junction capacitance at zero bias
parameter real CJSWGS =  0.0 `attr(info="Unit length source-side gate sidewall junction capacitance at zero bias");                       // Unit length source-side gate sidewall junction capacitance at zero bias
parameter real CJSWGD =  CJSWGS `attr(info="Unit length drain-side gate sidewall junction capacitance at zero bias");                    // Unit length drain-side gate sidewall junction capacitance at zero bias
parameter real PBS    =  1.0 `attr(info="Source-side bulk junction built-in potential");                       // Source-side bulk junction built-in potential
parameter real PBD    =  PBS `attr(info="Drain-side bulk junction built-in potential");                       // Drain-side bulk junction built-in potential
parameter real PBSWS  =  1.0 `attr(info="Built-in potential for Source-side sidewall junction capacitance");                       // Built-in potential for Source-side sidewall junction capacitance
parameter real PBSWD  =  PBSWS `attr(info="Built-in potential for Drain-side sidewall junction capacitance");                     // Built-in potential for Drain-side sidewall junction capacitance
parameter real PBSWGS =  PBSWS `attr(info="Built-in potential for Source-side gate sidewall junction capacitance");                     // Built-in potential for Source-side gate sidewall junction capacitance
parameter real PBSWGD =  PBSWGS `attr(info="Built-in potential for Drain-side gate sidewall junction capacitance");                    // Built-in potential for Drain-side gate sidewall junction capacitance
parameter real MJS    =  0.5 `attr(info="Source bottom junction capacitance grading coefficient");                       // Source bottom junction capacitance grading coefficient
parameter real MJD    =  MJS `attr(info="Drain bottom junction capacitance grading coefficient");                       // Drain bottom junction capacitance grading coefficient
parameter real MJSWS  =  0.33 `attr(info="Source sidewall junction capacitance grading coefficient");                      // Source sidewall junction capacitance grading coefficient
parameter real MJSWD  =  MJSWS `attr(info="Drain sidewall junction capacitance grading coefficient");                     // Drain sidewall junction capacitance grading coefficient
parameter real MJSWGS =  MJSWS `attr(info="Source-side gate sidewall junction capacitance grading coefficient");                     // Source-side gate sidewall junction capacitance grading coefficient
parameter real MJSWGD =  MJSWGS `attr(info="Drain-side gate sidewall junction capacitance grading coefficient");                    // Drain-side gate sidewall junction capacitance grading coefficient

// Second junction for the Two-Step junction cap 
parameter real SJS     =  0.0 from [0:inf) `attr(info="Constant for source-side two-step second junction");         // Constant for source-side two-step second junction
parameter real SJD     =  SJS from [0:inf) `attr(info="Constant for drain-side two-step second junction");         // Constant for drain-side two-step second junction
parameter real SJSWS   =  0.0 from [0:inf) `attr(info="Constant for source-side sidewall two-step second junction");         // Constant for source-side sidewall two-step second junction
parameter real SJSWD   =  SJSWS from [0:inf) `attr(info="Constant for drain-side sidewall two-step second junction");       // Constant for drain-side sidewall two-step second junction
parameter real SJSWGS  =  0.0 from [0:inf) `attr(info="Constant for source-side gate sidewall two-step second junction");         // Constant for source-side gate sidewall two-step second junction
parameter real SJSWGD  =  SJSWGS from [0:inf) `attr(info="Constant for source-side gate sidewall two-step second junction");      // Constant for source-side gate sidewall two-step second junction
parameter real MJS2    =  0.125 `attr(info="Source bottom two-step second junction capacitance grading coefficient");                    // Source bottom two-step second junction capacitance grading coefficient
parameter real MJD2    =  MJS2 `attr(info="Drain bottom two-step second junction capacitance grading coefficient		");                     // Drain bottom two-step second junction capacitance grading coefficient		
parameter real MJSWS2  =  0.083 `attr(info="Source sidewall two-step second junction capacitance grading coefficient");                    // Source sidewall two-step second junction capacitance grading coefficient
parameter real MJSWD2  =  MJSWS2 `attr(info="Drain sidewall two-step second junction capacitance grading coefficient");                   // Drain sidewall two-step second junction capacitance grading coefficient
parameter real MJSWGS2 =  MJSWS2 `attr(info="Source-side gate sidewall two-step");                   // Source-side gate sidewall two-step
                                                    //       second junction capacitance grading coefficient
parameter real MJSWGD2 =  MJSWGS2 `attr(info="Drain-side gate sidewall two-step");                  // Drain-side gate sidewall two-step
                                                    //       second junction capacitance grading coefficient
// Junction Current
parameter real JSS =  1.0e-4 `attr(info="Bottom source junction reverse saturation current density");                       // Bottom source junction reverse saturation current density
parameter real JSD =  JSS `attr(info="Bottom drain junction reverse saturation current density");                          // Bottom drain junction reverse saturation current density
parameter real JSWS  =  0.0 `attr(info="Unit length reverse saturation current for sidewall source junction");                        // Unit length reverse saturation current for sidewall source junction
parameter real JSWD  =  JSWS `attr(info="Unit length reverse saturation current for sidewall drain junction");                       // Unit length reverse saturation current for sidewall drain junction
parameter real JSWGS =  0.0 `attr(info="Unit length reverse saturation current for gate-edge sidewall source junction");                        // Unit length reverse saturation current for gate-edge sidewall source junction
parameter real JSWGD =  JSWGS `attr(info="Unit length reverse saturation current for gate-edge sidewall drain junction");                      // Unit length reverse saturation current for gate-edge sidewall drain junction
parameter real NJS   =  1.0 `attr(info="Source junction emission coefficient");                        // Source junction emission coefficient
parameter real NJD   =  NJS `attr(info="Drain junction emission coefficient");                        // Drain junction emission coefficient
parameter real IJTHSFWD  =  0.1 `attr(info="Forward source diode breakdown limiting current");                    // Forward source diode breakdown limiting current
parameter real IJTHDFWD  =  IJTHSFWD `attr(info="Forward drain diode breakdown limiting current");               // Forward drain diode breakdown limiting current
parameter real IJTHSREV  =  0.1 `attr(info="Reverse source diode breakdown limiting current");                    // Reverse source diode breakdown limiting current
parameter real IJTHDREV  =  IJTHSREV `attr(info="Reverse drain diode breakdown limiting current");               // Reverse drain diode breakdown limiting current
parameter real BVS =  10.0 `attr(info="Source diode breakdown voltage");                         // Source diode breakdown voltage
parameter real BVD =  BVS `attr(info="Drain diode breakdown voltage");                          // Drain diode breakdown voltage
parameter real XJBVS =  1.0 `attr(info="Fitting parameter for source diode breakdown current");                        // Fitting parameter for source diode breakdown current
parameter real XJBVD =  XJBVS `attr(info="Fitting parameter for drain diode breakdown current");                      // Fitting parameter for drain diode breakdown current

// Tunneling Component of Junction Current
parameter real JTSS    =  0.0 `attr(info="Bottom source junction trap-assisted saturation current density");                      // Bottom source junction trap-assisted saturation current density
parameter real JTSD    =  JTSS `attr(info="Bottom drain junction trap-assisted saturation current density");                     // Bottom drain junction trap-assisted saturation current density
parameter real JTSSWS  =  0.0 `attr(info="Unit length trap-assisted saturation current for sidewall source junction");                      // Unit length trap-assisted saturation current for sidewall source junction
parameter real JTSSWD  =  JTSSWS `attr(info="Unit length trap-assisted saturation current for sidewall drain junction");                   // Unit length trap-assisted saturation current for sidewall drain junction
parameter real JTSSWGS =  0.0 `attr(info="Unit length trap-assisted saturation current for gate-edge sidewall source junction");
                                                    // Unit length trap-assisted saturation current for 
                                                    //      gate-edge sidewall source junction
parameter real JTSSWGD =  JTSSWGS `attr(info="Unit length trap-assisted saturation current for gate-edge sidewall drain junction"); 
                                                    // Unit length trap-assisted saturation current for 
                                                    //      gate-edge sidewall drain junction
parameter real JTWEFF  =  0.0 `attr(info="Trap assisted tunneling current width dependence");                      // Trap assisted tunneling current width dependence
parameter real NJTS    =  20.0 `attr(info="Non-ideality factor for JTSS");                     // Non-ideality factor for JTSS
parameter real NJTSD   =  NJTS `attr(info="Non-ideality factor for JTSD");                     // Non-ideality factor for JTSD
parameter real NJTSSW  =  20.0 `attr(info="Non-ideality factor for JTSSWS");                     // Non-ideality factor for JTSSWS
parameter real NJTSSWD =  NJTSSW `attr(info="Non-ideality factor for JTSSWD");                   // Non-ideality factor for JTSSWD
parameter real NJTSSWG =  20.0 `attr(info="Non-ideality factor for JTSSWGS");                     // Non-ideality factor for JTSSWGS
parameter real NJTSSWGD=  NJTSSWG `attr(info="Non-ideality factor for JTSSWGD");                  // Non-ideality factor for JTSSWGD
parameter real VTSS    =  10.0 `attr(info="Bottom source junction trap-assisted current voltage dependent parameter");                     // Bottom source junction trap-assisted current voltage dependent parameter
parameter real VTSD    =  VTSS `attr(info="Bottom drain junction trap-assisted current voltage dependent parameter");                     // Bottom drain junction trap-assisted current voltage dependent parameter
parameter real VTSSWS  =  10.0 `attr(info="Unit length trap-assisted current voltage dependent parameter for sidewall source junction ");
                                                    // Unit length trap-assisted current voltage dependent parameter 
                                                    //		for sidewall source junction
parameter real VTSSWD  =  VTSSWS `attr(info="Unit length trap-assisted current voltage dependent parameter for sidewall drain junction"); 
                                                    // Unit length trap-assisted current voltage dependent parameter 
                                                    //		for sidewall drain junction
parameter real VTSSWGS =  10.0 `attr(info="Unit length trap-assisted current voltage dependent parameter for gate-edge sidewall source junction");
                                                    // Unit length trap-assisted current voltage dependent parameter for 
                                                    //      gate-edge sidewall source junction
parameter real VTSSWGD =  VTSSWGS `attr(info="Unit length trap-assisted current voltage dependent parameter for gate-edge sidewall drain junction ");
                                                    // Unit length trap-assisted current voltage dependent parameter for 
                                                    //      gate-edge sidewall drain junction

// Recombination-Generation Current
parameter real LINTIGEN  =  0 `attr(info="Lint for Thermal Generation Current");                      // Lint for Thermal Generation Current
parameter real NTGEN     =  1.0 `attr(info="Thermal Generation Current Parameter");                    // Thermal Generation Current Parameter
parameter real AIGEN     =  0 `attr(info="Thermal Generation Current Parameter");                      // Thermal Generation Current Parameter
parameter real BIGEN     =  0 `attr(info="Thermal Generation Current Parameter");                      // Thermal Generation Current Parameter

// NQS Gate Resistance Model & NQS Charge Deficit Model
// For NQSMOD=1, Set XRCRG1=0 to turn off NQS gate resistance
parameter real XRCRG1  =  12.0;
parameter real XRCRG2  =  1.0;

// NQS Charge Segzmentation Model
parameter integer NSEG =  4 from [4:10] `attr(info="Number of segments for NQSMOD=3 (3,5 and 10 supported)");            // Number of segments for NQSMOD=3 (3,5 & 10 supported)

// Flicker Noise
parameter real EF    =  1.0;                        // Flicker Noise frequency exponent
parameter real EM    =  4.1e7;
parameter real NOIA  =  6.250e+39;
parameter real NOIB  =  3.125e+24;
parameter real NOIC  =  8.750e+07;

// Thermal Noise
parameter real NTNOI =  1.0 from [0:inf);

// Temperature Effects;
parameter real TNOM      =  27.0 from [ -`P_CELSIUS0:inf) `attr(info="Temperature at which the model is extracted (degrees)");      // Temperature at which the model is extracted (degrees)
parameter real TBGASUB   =  7.02e-4 `attr(info="Bandgap Temperature Coefficient (eV / degrees)");                // Bandgap Temperature Coefficient (eV / degrees)
parameter real TBGBSUB   =  1108.0 `attr(info="Bandgap Temperature Coefficient (degrees)");                 // Bandgap Temperature Coefficient (degrees)
parameter real KT1       =  0.0 `attr(info="Vth Temperature Coefficient (V)");                    // Vth Temperature Coefficient (V)
parameter real KT1L      =  0.0 `attr(info="Vth Temperature L Coefficient (m-V)");                    // Vth Temperature L Coefficient (m-V)
parameter real TSS       =  0.0 `attr(info="SSwing Temperature Coefficient (/ degrees)");                    // SSwing Temperature Coefficient (/ degrees)
parameter real IIT       =  -0.5 `attr(info="Impact Ionization Temperature Dependence, IIMOD=1");                   // Impact Ionization Temperature Dependence, IIMOD=1
parameter real TII       =  0.0 `attr(info="Impact Ionization Temperature Dependence, IIMOD=2");                    // Impact Ionization Temperature Dependence, IIMOD=2
parameter real TGIDL     =  -0.003 `attr(info="GIDL/GISL Temperature Dependence");                 // GIDL/GISL Temperature Dependence
parameter real IGT       =  2.5 `attr(info="Gate Current Temperature Dependence");                    // Gate Current Temperature Dependence
parameter real TCJ       =  0.0 `attr(info="Temperature coefficient for CJS/CJD");                    // Temperature coefficient for CJS/CJD
parameter real TCJSW     =  0.0 `attr(info="Temperature coefficient for CJSWS/CJSWD");                    // Temperature coefficient for CJSWS/CJSWD
parameter real TCJSWG    =  0.0 `attr(info="Temperature coefficient for CJSWGS/CJSWGD");                    // Temperature coefficient for CJSWGS/CJSWGD
parameter real TPB       =  0.0 `attr(info="Temperature coefficient for PBS/PBD");                    // Temperature coefficient for PBS/PBD
parameter real TPBSW     =  0.0 `attr(info="Temperature coefficient for PBSWS/PBSWD");                    // Temperature coefficient for PBSWS/PBSWD
parameter real TPBSWG    =  0.0 `attr(info="Temperature coefficient for PBSWGS/PBSWGD");                    // Temperature coefficient for PBSWGS/PBSWGD
parameter real XTIS      =  3.0 `attr(info="Source junction current temperature exponent");                    // Source junction current temperature exponent
parameter real XTID      =  XTIS `attr(info="Drain junction current temperature exponent");                   // Drain junction current temperature exponent
parameter real XTSS      =  0.02 `attr(info="Power dependence of JTSS on temperature");                   // Power dependence of JTSS on temperature
parameter real XTSD      =  XTSS `attr(info="Power dependence of JTSD on temperature");                   // Power dependence of JTSD on temperature
parameter real XTSSWS    =  0.02 `attr(info="Power dependence of JTSSWS on temperature");                   // Power dependence of JTSSWS on temperature
parameter real XTSSWD    =  XTSSWS `attr(info="Power dependence of JTSSWD on temperature");                 // Power dependence of JTSSWD on temperature
parameter real XTSSWGS   =  0.02 `attr(info="Power dependence of JTSSWGS on temperature");                   // Power dependence of JTSSWGS on temperature
parameter real XTSSWGD   =  XTSSWGS `attr(info="Power dependence of JTSSWGD on temperature");                // Power dependence of JTSSWGD on temperature
parameter real TNJTS     =  0.0 `attr(info="Temperature coefficient for NJTS");                    // Temperature coefficient for NJTS
parameter real TNJTSD    =  TNJTS `attr(info="Temperature coefficient for NJTSD");                  // Temperature coefficient for NJTSD
parameter real TNJTSSW   =  0.0 `attr(info="Temperature coefficient for NJTSSW");                    // Temperature coefficient for NJTSSW
parameter real TNJTSSWD  =  TNJTSSW `attr(info="NTemperature coefficient for NJTSSWD");                // NTemperature coefficient for NJTSSWD
parameter real TNJTSSWG  =  0.0 `attr(info="Temperature coefficient for NJTSSWG");                    // Temperature coefficient for NJTSSWG
parameter real TNJTSSWGD =  TNJTSSWG `attr(info="Temperature coefficient for NJTSSWGD");               // Temperature coefficient for NJTSSWGD

// Self Heating
parameter real RTH0  =  0.01 from [0:inf) `attr(info="Thermal resistance");  		// Thermal resistance
parameter real CTH0  =  1.0E-05 from [0:inf) `attr(info="Thermal capacitance");   	// Thermal capacitance
parameter real WTH0  =  0.0 from [0:inf) `attr(info="Width dependence coefficient for Rth and Cth");       	// Width dependence coefficient for Rth and Cth

// dummy parameters for binning
parameter real LMIN = 0 from [0:inf) `attr(info="Minimum length for which this model should be used.");
parameter real LMAX = 100 from [0:inf) `attr(info="Maximum length for which this model should be used.");
parameter real NFINMIN = 0 from [0:inf) `attr(info="Minimum NFIN for which this model should be used.");
parameter real NFINMAX = 100 from [0:inf) `attr(info="Maximum NFIN for which this model should be used.");

//Binning Parameters
`include "bsimcmg_binning_parameters.include"

// Output variables
`ifdef __OPINFO__
	(* desc=  "WEFF" *)     real WEFF;
	(* desc=  "LEFF" *)     real LEFF;
	(* desc=  "WEFFCV" *)   real WEFFCV;
	(* desc=  "LEFFCV" *)   real LEFFCV;
	(* desc=  "IDS" *)      real IDS;
	(* desc=  "IDEFF" *)    real IDEFF;
	(* desc=  "ISEFF" *)    real ISEFF;
	(* desc=  "IGTOT" *)    real IGTOT;
	(* desc=  "IDSGEN" *)   real IDSGEN;
	(* desc=  "III" *)      real III;
	(* desc=  "IGIDL" *)    real IGIDL;
	(* desc=  "IGISL" *)    real IGISL;
	(* desc=  "IJSB" *)     real IJSB;
	(* desc=  "IJDB" *)     real IJDB;
	(* desc=  "ISUB" *)     real ISUB;
	(* desc=  "BETA" *)     real BETA;
	(* desc=  "VTH" *)      real VTH;
	(* desc=  "VDSSAT" *)   real VDSSAT;
	(* desc=  "VFB" *)      real VFB;
	(* desc=  "GM" *)       real GM;
	(* desc=  "GDS" *)      real GDS;
	(* desc=  "GMBS" *)     real GMBS;
	(* desc=  "QGI" *)      real QGI;
	(* desc=  "QDI" *)      real QDI;
	(* desc=  "QSI" *)      real QSI;
	(* desc=  "QBI" *)      real QBI;
	(* desc=  "QG" *)       real QG;
	(* desc=  "QD" *)       real QD;
	(* desc=  "QS" *)       real QS;
	(* desc=  "QB" *)       real QB;
	(* desc=  "CGGI" *)     real CGGI;
	(* desc=  "CGSI" *)     real CGSI;
	(* desc=  "CGDI" *)     real CGDI;
	(* desc=  "CGEI" *)     real CGEI;
	(* desc=  "CDGI" *)     real CDGI;
	(* desc=  "CDDI" *)     real CDDI;
	(* desc=  "CDSI" *)     real CDSI;
	(* desc=  "CDEI" *)     real CDEI;
	(* desc=  "CSGI" *)     real CSGI;
	(* desc=  "CSDI" *)     real CSDI;
	(* desc=  "CSSI" *)     real CSSI;
	(* desc=  "CSEI" *)     real CSEI;
	(* desc=  "CEGI" *)     real CEGI;
	(* desc=  "CEDI" *)     real CEDI;
	(* desc=  "CESI" *)     real CESI;
	(* desc=  "CEEI" *)     real CEEI;
	(* desc=  "CGG" *)      real CGG;
	(* desc=  "CGS" *)      real CGS;
	(* desc=  "CGD" *)      real CGD;
	(* desc=  "CGE" *)      real CGE;
	(* desc=  "CDG" *)      real CDG;
	(* desc=  "CDD" *)      real CDD;
	(* desc=  "CDS" *)      real CDS;
	(* desc=  "CDE" *)      real CDE;
	(* desc=  "CSG" *)      real CSG;
	(* desc=  "CSD" *)      real CSD;
	(* desc=  "CSS" *)      real CSS;
	(* desc=  "CSE" *)      real CSE;
	(* desc=  "CEG" *)      real CEG;
	(* desc=  "CED" *)      real CED;
	(* desc=  "CES" *)      real CES;
	(* desc=  "CEE" *)      real CEE;
	(* desc=  "CGSEXT" *)   real CGSEXT;
	(* desc=  "CGDEXT" *)   real CGDEXT;
	(* desc=  "CGBOV" *)    real CGBOV;
	(* desc=  "CJST" *)     real CJST;
	(* desc=  "CJDT" *)     real CJDT;
	(* desc=  "RSGEO" *)    real RSGEO;
	(* desc=  "RDGEO" *)    real RDGEO;
	(* desc=  "CFGEO" *)    real CFGEO;
	`ifdef __DEBUG__
		(* desc=  "IGS" *)      real IGS;
		(* desc=  "IGD" *) 		real IGD;
		(* desc=  "IGCS" *)     real IGCS;
		(* desc=  "IGCD" *)     real IGCD;
		(* desc=  "IGBS" *)     real IGBS;
		(* desc=  "IGBD" *)     real IGBD;
		(* desc=  "IGBACC" *)   real IGBACC;
		(* desc=  "IGBINV" *)   real IGBINV;

		(* desc=  "DIDSDVG" *)   real DIDSDVG;
		(* desc=  "DIDSDVS" *) 	 real DIDSDVS;
		(* desc=  "DIDSDVD" *) 	 real DIDSDVD;
		(* desc=  "DIGSDVG" *) 	 real DIGSDVG;
		(* desc=  "DIGSDVS" *) 	 real DIGSDVS;
		(* desc=  "DIGSDVD" *) 	 real DIGSDVD;
		(* desc=  "DIGDDVG" *) 	 real DIGDDVG;
		(* desc=  "DIGDDVS" *) 	 real DIGDDVS;
		(* desc=  "DIGDDVD" *) 	 real DIGDDVD;
		(* desc=  "DIIIDVG" *) 	 real DIIIDVG;
		(* desc=  "DIIIDVS" *) 	 real DIIIDVS;
		(* desc=  "DIIIDVD" *) 	 real DIIIDVD;
		(* desc=  "DIGIDLDVG" *) real DIGIDLDVG;
		(* desc=  "DIGIDLDVS" *) real DIGIDLDVS;
		(* desc=  "DIGIDLDVD" *) real DIGIDLDVD;
		(* desc=  "DIGISLDVG" *) real DIGISLDVG;
		(* desc=  "DIGISLDVS" *) real DIGISLDVS;
		(* desc=  "DIGISLDVD" *) real DIGISLDVD;

		`ifdef __SHMOD__
			(* desc=  "CGT" *)        real CGT;
			(* desc=  "CST" *)        real CST;
			(* desc=  "CDT" *)        real CDT;
			(* desc=  "DIDSDVTH" *)   real DIDSDVTH;
			(* desc=  "DIGSDVTH" *)   real DIGSDVTH;
			(* desc=  "DIGDDVTH" *)   real DIGDDVTH;
			(* desc=  "DIIIDVTH" *)   real DIIIDVTH;
			(* desc=  "DIGIDLDVTH" *) real DIGIDLDVTH;
			(* desc=  "DIGISLDVTH" *) real DIGISLDVTH;
			(* desc=  "DITHDVTH" *)   real DITHDVTH;
		`endif
		(* desc=  "ITH" *)      real ITH;
		(* desc=  "DITHDVG" *)  real DITHDVG;
		(* desc=  "DITHDVS" *)  real DITHDVS;
		(* desc=  "DITHDVD" *)  real DITHDVD;
	`endif
`endif

// Variables inside the model
integer initialized;
integer devsign;

real NFINtotal;
real DevTemp;
real R, ids0, ids0_ov_dqi, ids, idscv, dqi_idscv, vgs, vds, vdsx, vgd, sigvds, vch, etaiv;
real vgs_noswap, vds_noswap, vgd_noswap;
real qd, qg, qs, qb, Qbul;
real ni, epssub, epssp, epsratio, Eg, Eg0, Nc;
real Lg, deltaL, deltaLCV, Leff, LeffCV, LeffCV_acc, Weff0, WeffCV0, Weff, WeffCV;
real cox, csi, cdsc, cbox;
real nbody, phib, deltaPhi;
real T0, T1, T2, T3, T4, T4a, T5, T6, T7, T8, T9, TA, Tcom;
real Vtm, Vtm0, nVtm;
real beta, beta0, beta_cv;
real wf, wr;

// Temperature Effects
real Tnom, TRatio, dvth_temp, delTemp, ThetaSS;
real K0_t, K0SI_t, K1SI_t, K1_t, K1SAT_t, A1_t, A2_t;
real AIGBINV_t, AIGBACC_t, AIGC_t, AIGS_t, AIGD_t;
real BETA0_t, SII0_t, BGISL_t, BGIDL_t, igtemp, PTWG_t, PTWGR_t;
real ALPHA0_t, ALPHA1_t, ALPHAII0_t, ALPHAII1_t;
real CJS_t, CJSWS_t, CJSWGD_t, CJD_t, CJSWD_t, CJSWGS_t;
real PBS_t, PBSWS_t, PBSWGS_t, PBD_t, PBSWD_t, PBSWGD_t;
real JSS_t, JSWS_t, JSWGS_t, JSD_t, JSWD_t, JSWGD_t;
real JTSS_t, JTSD_t, JTSSWS_t, JTSSWD_t, JTSSWGS_t, JTSSWGD_t;
real NJTS_t, NJTSD_t, NJTSSW_t, NJTSSWD_t, NJTSSWG_t, NJTSSWGD_t;

// Variables for analytical surface potential
real phibulk, phipert;
real r1, r2, F0, z1, z2, cdop, vtdop, q0, guessA, guessB;
real g0, tang0, cosg0, secg0, secg0sq, lng0, tang0s, tang0d;
real F1, F2, Inv_r1pi, aab, g0s, g0d;
real phis, phid, g0max, g0min;
real T10, T11, T12, T13, T14;
real expff, lncosg0, inv_g0, inv_g0sq, e0, e1, e2, e3;

// Accumulation Model
real vgsfb, vgsfbeff, vt0;

// Short Channel Effect
real ETA0_t, ETA0R_t;
real scl, vbi, heff, phist, dvth_vtroll, dvth_dibl, dvth_rsce, dvth_all;
real tmp, Theta_SCE, Theta_SW, Theta_DIBL, Theta_RSCE;

//Lateral Non-uniform Doping Effect
real Mnud;

// Body Effect for BULKMOD=1
real ves, vesx, vesmax, veseff, Mob;

// Quantum mechanical correction [units are MKS]
real coxeff, Tcen0, Tcen, dvch_qm, MTcen;
real E0, E0prime, E1, E1prime, mx, mxprime, md, mdprime;
real gprime, gfactor, gam0, gam1, kT;

// Polysilicon Depletion
real vpoly0, vpolys, vpolyd, cpoly, kpoly;

// Drain Saturation Voltage
real Vdseff, qis, qid, qbs, Dmobs;

// Midpoint Potential and Charge
real qia, qia2, qba, dqi;
real qb0;
real eta_mu, eta_mu_cv, Eeffm, Eeffm_cv, Dmob, Dmob_cv, u0, ueff; 
real UA_t, UC_t, UCS_t, UD_t, U0_t, ETAMOB_t, Eeffs, EeffFactor;

real Dr, WeffWRFactor;    //real DrCV;  Navid_commented out
real RSourceGeo, RDrainGeo; 
real RDSWMIN_i, RDWMIN_i, RSWMIN_i; 
real Rdrain, Rsource; 

real rdstemp, Rdsi, Rdss;
real RSDR_t, RSDRR_t, RDDR_t, RDDRR_t;

real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm; 
real MclmCV, inv_MclmCV;

real Dvsat, Vdsat, inv_MEXP, DvsatCV, Nsat; 
real VSAT_t, VSAT1_t, VSAT1R_t, VSATCV_t, MEXP_t, MEXPR_t, Esat, EsatL, Esat1, Esat1L, EsatCV, EsatCVL; 
real WVCox, Ta, Tb, Tc; 

// Asymmetry Model
real VSAT1_a, MEXP_a, PTWG_a, RSDR_a, RDDR_a, PDIBL1_a;

// Geometry dependent Source/Drain Resistance
real mu_max, mu_rsd, rhorsd, afin, thetarsp;
real Rsp, lt, arsd_total, prsd_total, alpha;
real eta, RrsdTML, Rrsdside, Rrsd;
real Rdsgeo, Arsd, Prsd;

// Geometry dependent fringing capacitance
real Hg, Wg, Trsd, Hrsd, Cgg_top, Cgg_side, Cfr_geo, Acorner, Ccorner;

// Gate Electrode Resistance
`ifdef __RGATEMOD__
	real ggeltd, Rgeltd;
`endif

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, igs, igd, vgs_eff, vgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;

// Impact Ionization current
real Iii, Vdiff, Vdsatii, VgsStep, Ratio, ALPHAII;

// Accumulation Capacitance
real cox_acc, vgsfbeff_acc, r1_acc, Inv_r1pi_acc;
real g0a, tang0a, qi_acc, q0_acc, qg_acc, qb_acc;
real F1_acc, cdop_acc, vtdop_acc, vt0_acc, vge;

// Parasitic Capacitance
real qgs_ov, qgd_ov, qgs_fr, qgd_fr, qds_fr;
real qgs_parasitic, qgd_parasitic, Qes, Qed, Qeg;
real vgs_overlap, vgd_overlap, vge_overlap;
real cgsp, cgdp, csbox, cdbox, cgbox;

// Junction Current and Capacitance
real Ies, Ied, ves_jct, ved_jct, vec;
real Czbs, Czbssw, Czbsswg, Czbd, Czbdsw, Czbdswg;
real pb2, arg, sarg, Qec;
real Qesj, Qesj1, Qesj2, Qesj3, Qedj, Qedj1, Qedj2, Qedj3;
real Isbs, Isbd, Nvtms, Nvtmd;
real SslpRev, IVjsmRev, VjsmRev, SslpFwd, IVjsmFwd, VjsmFwd, XExpBVS;
real DslpRev, IVjdmRev, VjdmRev, DslpFwd, IVjdmFwd, VjdmFwd, XExpBVD;
real igentemp, idsgen, LINTIGEN_i;

// NQS Gate Resistance
`ifdef __NQSMOD1__
	real gcrg, XRCRG1_i, XRCRG2_i;
`endif

// NQS Charge Deficit Model
`ifdef __NQSMOD2__
	real xdpart, gtau, gcrg, XRCRG1_i, XRCRG2_i;
`endif

real IdovVds;

// NQS Charge Deficit Model
`ifdef __NQSMOD3__
	real qil, qir, qiarl, dqirl, Tcomrl;
	real ids1, ids2, ids3, ids4, ids5, ids6, ids7, ids8, ids9, ids10, idsN;
	real qg1, qg2, qg3, qg4, qg5, qg6, qg7, qg8, qg9, qg10;
	real qd1, qd2, qd3, qd4, qd5, qd6, qd7, qd8, qd9, qd10;
`endif

// Flicker Noise
real LINTNOI_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real NTNOI_i, qinv;
real Gtnoi, sid;
real gspr, gdpr;

// Self Heating
`ifdef __SHMOD__
	real gth, cth;
`endif

// Operating Point Vth
real qith;

// Binning
real Inv_L, Inv_NFIN, Inv_LNFIN;
real NBODY_i, PHIG_i, CFD_i, CFS_i, COVS_i, COVD_i, CGSO_i, CGDO_i;
real CGSL_i, CGDL_i, CGBL_i, CKAPPAS_i, CKAPPAD_i, CKAPPAB_i;
real QMFACTOR_i, QMTCENIV_i, QMTCENCV_i, QMTCENCVA_i, KSATIV_i;
real CDSC_i, CDSCD_i, CDSCD_a, CDSCDR_i, CIT_i, DVT0_i;
real DVT1_i, DVT1SS_i, PHIN_i, ETA0_i, ETA0_a, ETA0R_i, DSUB_i, VSAT_i;
real K0_i, K01_i, K0SI_i, K0SI1_i, K1SI_i, K1SI1_i, PHIBE_i, K1_i, K11_i, K1SAT_i, K1SAT1_i;
real DELTAVSAT_i, PSAT_i, DELTAVSATCV_i, PSATCV_i, VSAT1_i, VSAT1R_i, PTWG_i, PTWGR_i, VSATCV_i;
real UP_i, U0_i, ETAMOB_i, NGATE_i, RDSW_i;
real PRWGS_i, PRWGD_i, WR_i, PDIBL1_i, PDIBL1R_i, PDIBL2_i;
real DROUT_i, PVAG_i;
real AIGBINV_i, AIGBINV1_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, AIGBACC1_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real AIGC_i, AIGC1_i, BIGC_i, CIGC_i, PIGCD_i;
real AIGS_i, AIGS1_i, BIGS_i, CIGS_i, NTOX_i, POXEDGE_i;
real AIGD_i, AIGD1_i, BIGD_i, CIGD_i;
real AGIDL_i, BGIDL_i, CGIDL_i, EGIDL_i, PGIDL_i;
real AGISL_i, BGISL_i, CGISL_i, EGISL_i, PGISL_i;
real ALPHA0_i, ALPHA1_i, ALPHAII0_i, ALPHAII1_i, BETA0_i;
real BETAII0_i, BETAII1_i, BETAII2_i, ESATII_i;
real LII_i, SII0_i, SII1_i, SII2_i, SIID_i, TII_i;
real MEXP_i, MEXPR_i;
real PCLM_i, PCLMG_i, PCLMCV_i;
real A1_i, A2_i, A11_i, A21_i;
real K1RSCE_i, LPE0_i, DVTSHIFT_i;
real UA_i, UC_i, EU_i, UD_i, UCS_i; 
real UA1_i, UC1_i, UD1_i, UCSTE_i, UTE_i, UTL_i, EMOBT_i;
real PTWGT_i;
real AT_i;
real RDW_i, RSW_i;
real PRT_i, KT1_i, TSS_i, IIT_i, IGT_i, TGIDL_i;
real NTGEN_i, AIGEN_i, BIGEN_i;

//===================================================
//               analog block begins
//===================================================
analog begin
	
	/************************************************/
	/*      Geometry dependent calculations         */
	/************************************************/
	begin : CMGBiasIndepCalc
		initialized  =  1;
		
		// Variable initialization to prevent hidden states
		R = 0;
		vgsfbeff_acc = 0; vt0 = 0; vt0_acc = 0;
		F1 = 0; F1_acc = 0; cdop_acc = 0;
		qid = 0; qis = 0; tang0d = 0; tang0s = 0;
		T11 = 0; T12 = 0; T13 = 0; T14 = 0;
		ids = 0; sigvds = 0; Iii = 0;
		qd = 0; qg = 0; qs = 0; qb = 0;
		Qbul = 0; aab = 0;
		Weff0 = 0; WeffCV0 = 0; Weff = 0; WeffCV = 0;
		CJS_t = 0; CJSWS_t = 0; CJSWGS_t = 0;
		CJD_t = 0; CJSWD_t = 0; CJSWGD_t = 0;
		PBS_t = 0; PBSWS_t = 0; PBSWGS_t = 0;
		PBD_t = 0; PBSWD_t = 0; PBSWGD_t = 0;
		JSS_t = 0; JSWS_t = 0; JSWGS_t = 0;
		JSD_t = 0; JSWD_t = 0; JSWGD_t = 0;
		JTSS_t = 0; JTSSWS_t = 0; JTSSWGS_t = 0;
		JTSD_t = 0; JTSSWD_t = 0; JTSSWGD_t = 0;
		NJTS_t = 0; NJTSSW_t = 0; NJTSSWG_t = 0;
		NJTSD_t = 0; NJTSSWD_t = 0; NJTSSWGD_t = 0;
		Ies = 0; Ied = 0;
		Czbs = 0; Czbssw = 0; Czbsswg = 0;
		Czbd = 0; Czbdsw = 0; Czbdswg = 0;
		Qes = 0; Qed = 0; Qeg = 0;
		Isbs = 0; Isbd = 0; Nvtms = 0; Nvtmd = 0;
		SslpRev = 0; IVjsmRev = 0; VjsmRev = 0;
		SslpFwd = 0; IVjsmFwd = 0; VjsmFwd = 0;	
		DslpRev = 0; IVjdmRev = 0; VjdmRev = 0;
		DslpFwd = 0; IVjdmFwd = 0; VjdmFwd = 0;	
		XExpBVS = 0; XExpBVD = 0; idsgen = 0;
		phibulk = 0; phipert = 0; g0s = 0; g0d = 0;
		r1 = 0; q0 = 0; F2 = 0; Inv_r1pi = 0;
		Tcen = 0; MTcen = 0;
		Rdrain = 0; Rsource = 0; Cfr_geo = 0;
		igbinv = 0; igbs = 0; igbd = 0;
		igbacc = 0; igcs = 0; igcd = 0;
		igidl = 0; igisl = 0; igs = 0; igd = 0;
		cox_acc = 0; r1_acc = 0; Inv_r1pi_acc = 0;
		CGSO_i = 0; CGDO_i = 0;
		q0_acc = 0; qb_acc = 0; qg_acc = 0; qi_acc = 0;
		qgs_fr = 0; qgd_fr = 0; qds_fr = 0;
		qgs_parasitic = 0; qgd_parasitic = 0;
		FNPowerAt1Hz = 0; Gtnoi = 0;
		gspr = 0; gdpr = 0;
		`ifdef __RGATEMOD__
			ggeltd = 0;
		`endif
		`ifdef __NQSMOD3__
			ids1 = 0; ids2 = 0; ids3 = 0; ids4 = 0; ids5 = 0;
			ids6 = 0; ids7 = 0; ids8 = 0; ids9 = 0; ids10 = 0;
			idsN = 0;
			qg1 = 0; qg2 = 0; qg3 = 0; qg4 = 0; qg5 = 0;
			qg6 = 0; qg7 = 0; qg8 = 0; qg9 = 0; qg10 = 0;
			qd1 = 0; qd2 = 0; qd3 = 0; qd4 = 0; qd5 = 0;
			qd6 = 0; qd7 = 0; qd8 = 0; qd9 = 0; qd10 = 0;
		`endif
		

		// Effective Width Calculation
		case(GEOMOD)
		0: begin
			Weff0    =  2 * HFIN - DELTAW;
			WeffCV0  =  2 * HFIN - DELTAWCV;
		end
		1: begin
			Weff0    =  2 * HFIN + FECH * TFIN - DELTAW;
			WeffCV0  =  2 * HFIN + FECHCV * TFIN - DELTAWCV;
		end
		2: begin
			Weff0    =  2 * HFIN + 2 * FECH * TFIN - DELTAW;
			WeffCV0  =  2 * HFIN + 2 * FECHCV * TFIN - DELTAWCV;
		end
		3: begin
			R        =  D / 2.0;
			Weff0    =  `M_PI * D - DELTAW;
			WeffCV0  =  `M_PI * D - DELTAWCV;
		end
		endcase
		
		
		// Constants
		if( DEVTYPE == `ntype ) devsign  =  1;
		else devsign =  -1;
		epssub =  EPSRSUB * `EPS0;
		epssp  =  EPSRSP * `EPS0;
		cox    =  3.9 * `EPS0 / EOT;
		csi    =  epssub / TFIN;
		cbox   =  3.9 * `EPS0 / EOTBOX;
		epsratio =  EPSRSUB / 3.9;  // for terms with EOT
		if (CAPMOD != 0 && BULKMOD != 0) cox_acc =  3.9 * `EPS0 / EOTACC;
		
		// SCE scaling length
		scl  =  sqrt(0.5 * epsratio * TFIN * EOT * (1.0 + TFIN/(4.0*epsratio*EOT)));
		heff =  sqrt(HFIN * (HFIN + 2 * epsratio * EOT) / 8.0);
		case(GEOMOD)
		1: begin
			scl  =  1.0 / sqrt(1.0 / (scl*scl) + 0.25 / (heff*heff));
		end
		2: begin
			scl  =  0.5 / sqrt(1.0 / (scl*scl) + 0.25 / (heff*heff));
		end
		3: begin
			scl  =  sqrt(0.5 * epsratio * R * EOT * (1.0 + R/(2.0*epsratio*EOT)));
		end
		endcase
		
		// Constants for quantum mechanical effects
		mx         =  0.916 * `MEL;
		mxprime    =  0.190 * `MEL;
		md         =  0.190 * `MEL;
		mdprime    =  0.417 * `MEL;
		gprime     =  4.0;
		gfactor    =  2.0;
		
		// Effective Channel Length for I-V / C-V
		Lg       =  L + XL;
		deltaL   =  LINT + LL * pow(Lg, -LLN);
		deltaLCV =  DLC + LLC * pow(Lg, -LLN);
		Leff     =  Lg - 2.0 * deltaL;
		LeffCV   =  Lg - 2.0 * deltaLCV;
		if(CAPMOD != 0 && BULKMOD != 0) LeffCV_acc = LeffCV - DLCACC;

		// Total Fins
		NFINtotal  =  NFIN * NF;
		
		// Binning
		Inv_L     =  1.0e-6 / (Leff + DLBIN);
		Inv_NFIN  =  1.0 / NFIN;
		Inv_LNFIN =  1.0e-6 / ((Leff + DLBIN) * NFIN);
		
		// Binning Equations (process parameters)
		NBODY_i  =  NBODY + Inv_L * LNBODY + Inv_NFIN * NNBODY + Inv_LNFIN * PNBODY;
		PHIG_i   =  PHIG + Inv_L * LPHIG + Inv_NFIN * NPHIG + Inv_LNFIN * PPHIG;
		NGATE_i  =  NGATE + Inv_L * LNGATE + Inv_NFIN * NNGATE + Inv_LNFIN * PNGATE;
		
		// Binning Equations (model parameters)
		CIT_i    =  CIT    + Inv_L * LCIT    + Inv_NFIN * NCIT    + Inv_LNFIN * PCIT;
		CDSC_i   =  CDSC   + Inv_L * LCDSC   + Inv_NFIN * NCDSC   + Inv_LNFIN * PCDSC;
		CDSCD_i  =  CDSCD  + Inv_L * LCDSCD  + Inv_NFIN * NCDSCD  + Inv_LNFIN * PCDSCD;
		DVT0_i   =  DVT0   + Inv_L * LDVT0   + Inv_NFIN * NDVT0   + Inv_LNFIN * PDVT0;
		DVT1_i   =  DVT1   + Inv_L * LDVT1   + Inv_NFIN * NDVT1   + Inv_LNFIN * PDVT1;
		DVT1SS_i =  DVT1SS + Inv_L * LDVT1SS + Inv_NFIN * NDVT1SS + Inv_LNFIN * PDVT1SS;
		PHIN_i   =  PHIN   + Inv_L * LPHIN   + Inv_NFIN * NPHIN   + Inv_LNFIN * PPHIN;
		ETA0_i   =  ETA0   + Inv_L * LETA0   + Inv_NFIN * NETA0   + Inv_LNFIN * PETA0;
		DSUB_i   =  DSUB   + Inv_L * LDSUB   + Inv_NFIN * NDSUB   + Inv_LNFIN * PDSUB;
		K1RSCE_i =  K1RSCE + Inv_L * LK1RSCE + Inv_NFIN * NK1RSCE + Inv_LNFIN * PK1RSCE;
		LPE0_i   =  LPE0   + Inv_L * LLPE0   + Inv_NFIN * NLPE0   + Inv_LNFIN * PLPE0;
		DVTSHIFT_i    =  DVTSHIFT + Inv_L * LDVTSHIFT + Inv_NFIN * NDVTSHIFT + Inv_LNFIN * PDVTSHIFT;
		K0_i          =  K0  + Inv_L * LK0  + Inv_NFIN * NK0  + Inv_LNFIN * PK0;
		K01_i         =  K01 + Inv_L * LK01  + Inv_NFIN * NK01 + Inv_LNFIN * PK01;
		K0SI_i        =  K0SI  + Inv_L * LK0SI  + Inv_NFIN * NK0SI  + Inv_LNFIN * PK0SI;
		K0SI1_i       =  K0SI1 + Inv_L * LK0SI1 + Inv_NFIN * NK0SI1 + Inv_LNFIN * PK0SI1;
		K1SI_i        =  K1SI  + Inv_L * LK1SI  + Inv_NFIN * NK1SI  + Inv_LNFIN * PK1SI;
		K1SI1_i       =  K1SI1 + Inv_L * LK1SI1 + Inv_NFIN * NK1SI1 + Inv_LNFIN * PK1SI1;
		
		if(BULKMOD != 0) begin
			PHIBE_i       =  PHIBE + Inv_L * LPHIBE + Inv_NFIN * NPHIBE + Inv_LNFIN * PPHIBE;
			K1_i          =  K1  + Inv_L * LK1  + Inv_NFIN * NK1  + Inv_LNFIN * PK1;
			K11_i         =  K11 + Inv_L * LK11 + Inv_NFIN * NK11 + Inv_LNFIN * PK11;
			K1SAT_i       =  K1SAT  + Inv_L * LK1SAT  + Inv_NFIN * NK1SAT  + Inv_LNFIN * PK1SAT;
			K1SAT1_i      =  K1SAT1 + Inv_L * LK1SAT1 + Inv_NFIN * NK1SAT1 + Inv_LNFIN * PK1SAT1;
		end
		QMFACTOR_i    =  QMFACTOR + Inv_L * LQMFACTOR + Inv_NFIN * NQMFACTOR + Inv_LNFIN * PQMFACTOR;
		QMTCENIV_i    =  QMTCENIV + Inv_L * LQMTCENIV + Inv_NFIN * NQMTCENIV + Inv_LNFIN * PQMTCENIV;
		QMTCENCV_i    =  QMTCENCV + Inv_L * LQMTCENCV + Inv_NFIN * NQMTCENCV + Inv_LNFIN * PQMTCENCV;
		QMTCENCVA_i   =  QMTCENCVA + Inv_L * LQMTCENCVA + Inv_NFIN * NQMTCENCVA + Inv_LNFIN * PQMTCENCVA;
		VSAT_i        =  VSAT + Inv_L * LVSAT + Inv_NFIN * NVSAT + Inv_LNFIN * PVSAT;
		VSAT1_i       =  VSAT1 + Inv_L * LVSAT1 + Inv_NFIN * NVSAT1 + Inv_LNFIN * PVSAT1;
		VSATCV_i      =  VSATCV + Inv_L * LVSATCV + Inv_NFIN * NVSATCV + Inv_LNFIN * PVSATCV;
		DELTAVSAT_i   =  DELTAVSAT + Inv_L * LDELTAVSAT + Inv_NFIN * NDELTAVSAT + Inv_LNFIN * PDELTAVSAT;
		PSAT_i        =  PSAT   + Inv_L * LPSAT   + Inv_NFIN * NPSAT   + Inv_LNFIN * PPSAT;
		DELTAVSATCV_i =  DELTAVSATCV + Inv_L * LDELTAVSATCV + Inv_NFIN * NDELTAVSATCV + Inv_LNFIN * PDELTAVSATCV;
		PSATCV_i =  PSATCV + Inv_L * LPSATCV + Inv_NFIN * NPSATCV + Inv_LNFIN * PPSATCV;
		KSATIV_i =  KSATIV + Inv_L * LKSATIV + Inv_NFIN * NKSATIV + Inv_LNFIN * PKSATIV;
		MEXP_i   =  MEXP  + Inv_L  * LMEXP  + Inv_NFIN * NMEXP  + Inv_LNFIN * PMEXP;
		PTWG_i   =  PTWG  + Inv_L  * LPTWG  + Inv_NFIN * NPTWG  + Inv_LNFIN * PPTWG;
		U0_i 	 =  U0 + Inv_L * LU0 + Inv_NFIN * NU0 + Inv_LNFIN * PU0;
		ETAMOB_i =  ETAMOB + Inv_L * LETAMOB + Inv_NFIN * NETAMOB + Inv_LNFIN * PETAMOB;
		UP_i 	 =  UP + Inv_L * LUP + Inv_NFIN * NUP + Inv_LNFIN * PUP;
		UA_i 	 =  UA + Inv_L * LUA + Inv_NFIN * NUA + Inv_LNFIN * PUA;
		if(BULKMOD != 0) UC_i  =  UC + Inv_L * LUC + Inv_NFIN * NUC + Inv_LNFIN * PUC;
		EU_i 	 =  EU + Inv_L * LEU + Inv_NFIN * NEU + Inv_LNFIN * PEU;
		UD_i 	 =  UD + Inv_L * LUD + Inv_NFIN * NUD + Inv_LNFIN * PUD;
		UCS_i    =  UCS + Inv_L * LUCS + Inv_NFIN * NUCS + Inv_LNFIN * PUCS;
		PCLM_i   =  PCLM + Inv_L * LPCLM + Inv_NFIN * NPCLM + Inv_LNFIN * PPCLM;
		PCLMG_i  =  PCLMG + Inv_L * LPCLMG + Inv_NFIN * NPCLMG + Inv_LNFIN * PPCLMG;
		PCLMCV_i =  PCLMCV + Inv_L * LPCLMCV + Inv_NFIN * NPCLMCV + Inv_LNFIN * PPCLMCV;
		A1_i	 =  A1  + Inv_L * LA1  + Inv_NFIN * NA1  + Inv_LNFIN * PA1;
		A11_i	 =  A11 + Inv_L * LA11 + Inv_NFIN * NA11 + Inv_LNFIN * PA11;
		A2_i 	 =  A2  + Inv_L * LA2  + Inv_NFIN * NA2  + Inv_LNFIN * PA2;
		A21_i 	 =  A21 + Inv_L * LA21 + Inv_NFIN * NA21 + Inv_LNFIN * PA21;
		RDSW_i   =  RDSW + Inv_L * LRDSW + Inv_NFIN * NRDSW + Inv_LNFIN * PRDSW;
		RSW_i    =  RSW + Inv_L * LRSW + Inv_NFIN * NRSW + Inv_LNFIN * PRSW;
		RDW_i    =  RDW + Inv_L * LRDW + Inv_NFIN * NRDW + Inv_LNFIN * PRDW;
		PRWGD_i  =  PRWGD + Inv_L * LPRWGD + Inv_NFIN * NPRWGD + Inv_LNFIN * PPRWGD;
		PRWGS_i  =  PRWGS + Inv_L * LPRWGS + Inv_NFIN * NPRWGS + Inv_LNFIN * PPRWGS;
		WR_i 	 =  WR + Inv_L * LWR + Inv_NFIN * NWR + Inv_LNFIN * PWR;
		PDIBL1_i =  PDIBL1 + Inv_L * LPDIBL1 + Inv_NFIN * NPDIBL1 + Inv_LNFIN * PPDIBL1;
		PDIBL2_i =  PDIBL2 + Inv_L * LPDIBL2 + Inv_NFIN * NPDIBL2 + Inv_LNFIN * PPDIBL2;
		DROUT_i  =  DROUT + Inv_L * LDROUT + Inv_NFIN * NDROUT + Inv_LNFIN * PDROUT;
		PVAG_i   =  PVAG + Inv_L * LPVAG + Inv_NFIN * NPVAG + Inv_LNFIN * PPVAG;
		AIGBINV_i  =  AIGBINV  + Inv_L * LAIGBINV  + Inv_NFIN * NAIGBINV  + Inv_LNFIN * PAIGBINV;
		AIGBINV1_i =  AIGBINV1 + Inv_L * LAIGBINV1 + Inv_NFIN * NAIGBINV1 + Inv_LNFIN * PAIGBINV1;
		BIGBINV_i  =  BIGBINV  + Inv_L * LBIGBINV  + Inv_NFIN * NBIGBINV  + Inv_LNFIN * PBIGBINV;
		CIGBINV_i  =  CIGBINV  + Inv_L * LCIGBINV  + Inv_NFIN * NCIGBINV  + Inv_LNFIN * PCIGBINV;
		EIGBINV_i  =  EIGBINV  + Inv_L * LEIGBINV  + Inv_NFIN * NEIGBINV  + Inv_LNFIN * PEIGBINV;
		NIGBINV_i  =  NIGBINV  + Inv_L * LNIGBINV  + Inv_NFIN * NNIGBINV  + Inv_LNFIN * PNIGBINV;
		AIGBACC_i  =  AIGBACC  + Inv_L * LAIGBACC  + Inv_NFIN * NAIGBACC  + Inv_LNFIN * PAIGBACC;
		AIGBACC1_i =  AIGBACC1 + Inv_L * LAIGBACC1 + Inv_NFIN * NAIGBACC1 + Inv_LNFIN * PAIGBACC1;
		BIGBACC_i  =  BIGBACC  + Inv_L * LBIGBACC  + Inv_NFIN * NBIGBACC  + Inv_LNFIN * PBIGBACC;
		CIGBACC_i  =  CIGBACC  + Inv_L * LCIGBACC  + Inv_NFIN * NCIGBACC  + Inv_LNFIN * PCIGBACC;
		NIGBACC_i  =  NIGBACC  + Inv_L * LNIGBACC  + Inv_NFIN * NNIGBACC  + Inv_LNFIN * PNIGBACC;
		AIGC_i 	 =  AIGC  + Inv_L * LAIGC  + Inv_NFIN * NAIGC  + Inv_LNFIN * PAIGC;
		AIGC1_i  =  AIGC1 + Inv_L * LAIGC1 + Inv_NFIN * NAIGC1 + Inv_LNFIN * PAIGC1;
		BIGC_i   =  BIGC  + Inv_L * LBIGC  + Inv_NFIN * NBIGC  + Inv_LNFIN * PBIGC;
		CIGC_i   =  CIGC  + Inv_L * LCIGC  + Inv_NFIN * NCIGC  + Inv_LNFIN * PCIGC;
		PIGCD_i  =  PIGCD + Inv_L * LPIGCD + Inv_NFIN * NPIGCD + Inv_LNFIN * PPIGCD;
		AIGS_i   =  AIGS  + Inv_L * LAIGS  + Inv_NFIN * NAIGS  + Inv_LNFIN * PAIGS;
		AIGS1_i  =  AIGS1 + Inv_L * LAIGS1 + Inv_NFIN * NAIGS1 + Inv_LNFIN * PAIGS1;
		BIGS_i   =  BIGS  + Inv_L * LBIGS  + Inv_NFIN * NBIGS  + Inv_LNFIN * PBIGS;
		CIGS_i   =  CIGS  + Inv_L * LCIGS  + Inv_NFIN * NCIGS  + Inv_LNFIN * PCIGS;
		AIGD_i   =  AIGD  + Inv_L * LAIGD  + Inv_NFIN * NAIGD  + Inv_LNFIN * PAIGD;
		AIGD1_i  =  AIGD1 + Inv_L * LAIGD1 + Inv_NFIN * NAIGD1 + Inv_LNFIN * PAIGD1;
		BIGD_i   =  BIGD  + Inv_L * LBIGD  + Inv_NFIN * NBIGD  + Inv_LNFIN * PBIGD;
		CIGD_i   =  CIGD  + Inv_L * LCIGD  + Inv_NFIN * NCIGD  + Inv_LNFIN * PCIGD;
		NTOX_i   =  NTOX  + Inv_L * LNTOX  + Inv_NFIN * NNTOX  + Inv_LNFIN * PNTOX;
		POXEDGE_i  =  POXEDGE + Inv_L * LPOXEDGE + Inv_NFIN * NPOXEDGE + Inv_LNFIN * PPOXEDGE;
		AGIDL_i    =  AGIDL + Inv_L * LAGIDL + Inv_NFIN * NAGIDL + Inv_LNFIN * PAGIDL;
		BGIDL_i    =  BGIDL + Inv_L * LBGIDL + Inv_NFIN * NBGIDL + Inv_LNFIN * PBGIDL;
		CGIDL_i    =  CGIDL + Inv_L * LCGIDL + Inv_NFIN * NCGIDL + Inv_LNFIN * PCGIDL;
		EGIDL_i    =  EGIDL + Inv_L * LEGIDL + Inv_NFIN * NEGIDL + Inv_LNFIN * PEGIDL;
		PGIDL_i    =  PGIDL + Inv_L * LPGIDL + Inv_NFIN * NPGIDL + Inv_LNFIN * PPGIDL;
		AGISL_i    =  AGISL + Inv_L * LAGISL + Inv_NFIN * NAGISL + Inv_LNFIN * PAGISL;
		BGISL_i    =  BGISL + Inv_L * LBGISL + Inv_NFIN * NBGISL + Inv_LNFIN * PBGISL;
		CGISL_i    =  CGISL + Inv_L * LCGISL + Inv_NFIN * NCGISL + Inv_LNFIN * PCGISL;
		EGISL_i    =  EGISL + Inv_L * LEGISL + Inv_NFIN * NEGISL + Inv_LNFIN * PEGISL;
		PGISL_i    =  PGISL + Inv_L * LPGISL + Inv_NFIN * NPGISL + Inv_LNFIN * PPGISL;
		ALPHA0_i   =  ALPHA0 + Inv_L * LALPHA0 + Inv_NFIN * NALPHA0 + Inv_LNFIN * PALPHA0;
		ALPHA1_i   =  ALPHA1 + Inv_L * LALPHA1 + Inv_NFIN * NALPHA1 + Inv_LNFIN * PALPHA1;
		
		ALPHAII0_i =  ALPHAII0 + Inv_L * LALPHAII0 + Inv_NFIN * NALPHAII0 + Inv_LNFIN * PALPHAII0;
		ALPHAII1_i =  ALPHAII1 + Inv_L * LALPHAII1 + Inv_NFIN * NALPHAII1 + Inv_LNFIN * PALPHAII1;
		
		BETA0_i    =  BETA0 + Inv_L * LBETA0 + Inv_NFIN * NBETA0 + Inv_LNFIN * PBETA0;
		BETAII0_i  =  BETAII0 + Inv_L * LBETAII0 + Inv_NFIN * NBETAII0 + Inv_LNFIN * PBETAII0;
		BETAII1_i  =  BETAII1 + Inv_L * LBETAII1 + Inv_NFIN * NBETAII1 + Inv_LNFIN * PBETAII1;
		BETAII2_i  =  BETAII2 + Inv_L * LBETAII2 + Inv_NFIN * NBETAII2 + Inv_LNFIN * PBETAII2;
		ESATII_i   =  ESATII + Inv_L * LESATII + Inv_NFIN * NESATII + Inv_LNFIN * PESATII;
		LII_i  =  LII + Inv_L * LLII + Inv_NFIN * NLII + Inv_LNFIN * PLII;
		SII0_i =  SII0 + Inv_L * LSII0 + Inv_NFIN * NSII0 + Inv_LNFIN * PSII0;
		SII1_i =  SII1 + Inv_L * LSII1 + Inv_NFIN * NSII1 + Inv_LNFIN * PSII1;
		SII2_i =  SII2 + Inv_L * LSII2 + Inv_NFIN * NSII2 + Inv_LNFIN * PSII2;
		SIID_i =  SIID + Inv_L * LSIID + Inv_NFIN * NSIID + Inv_LNFIN * PSIID;
		TII_i  =  TII + Inv_L * LTII + Inv_NFIN * NTII + Inv_LNFIN * PTII;
		CFS_i  =  CFS + Inv_L * LCFS + Inv_NFIN * NCFS + Inv_LNFIN * PCFS;
		CFD_i  =  CFD + Inv_L * LCFD + Inv_NFIN * NCFD + Inv_LNFIN * PCFD;
		COVS_i =  COVS + Inv_L * LCOVS + Inv_NFIN * NCOVS + Inv_LNFIN * PCOVS;
		COVD_i =  COVD + Inv_L * LCOVD + Inv_NFIN * NCOVD + Inv_LNFIN * PCOVD;
		CGSL_i =  CGSL + Inv_L * LCGSL + Inv_NFIN * NCGSL + Inv_LNFIN * PCGSL;
		CGDL_i =  CGDL + Inv_L * LCGDL + Inv_NFIN * NCGDL + Inv_LNFIN * PCGDL;
		CGBL_i =  CGBL + Inv_L * LCGBL + Inv_NFIN * NCGBL + Inv_LNFIN * PCGBL;
		CKAPPAS_i  =  CKAPPAS + Inv_L * LCKAPPAS + Inv_NFIN * NCKAPPAS + Inv_LNFIN * PCKAPPAS;
		CKAPPAD_i  =  CKAPPAD + Inv_L * LCKAPPAD + Inv_NFIN * NCKAPPAD + Inv_LNFIN * PCKAPPAD;
		CKAPPAB_i  =  CKAPPAB + Inv_L * LCKAPPAB + Inv_NFIN * NCKAPPAB + Inv_LNFIN * PCKAPPAB;
		NTGEN_i    =  NTGEN + Inv_L * LNTGEN + Inv_NFIN * NNTGEN + Inv_LNFIN * PNTGEN;
		AIGEN_i    =  AIGEN + Inv_L * LAIGEN + Inv_NFIN * NAIGEN + Inv_LNFIN * PAIGEN;
		BIGEN_i    =  BIGEN + Inv_L * LBIGEN + Inv_NFIN * NBIGEN + Inv_LNFIN * PBIGEN;

		if(ASYMMOD != 0) begin
			CDSCDR_i =  CDSCDR + Inv_L * LCDSCDR + Inv_NFIN * NCDSCDR + Inv_LNFIN * PCDSCDR;
			ETA0R_i  =  ETA0R + Inv_L * LETA0R + Inv_NFIN * NETA0R + Inv_LNFIN * PETA0R;
			VSAT1R_i =  VSAT1R + Inv_L * LVSAT1R + Inv_NFIN * NVSAT1R + Inv_LNFIN * PVSAT1R;
			MEXPR_i  =  MEXPR + Inv_L  * LMEXPR + Inv_NFIN * NMEXPR + Inv_LNFIN * PMEXPR;
			PTWGR_i  =  PTWGR + Inv_L * LPTWGR + Inv_NFIN * NPTWGR + Inv_LNFIN * PPTWGR;
			PDIBL1R_i=  PDIBL1R + Inv_L * LPDIBL1R + Inv_NFIN * NPDIBL1R + Inv_LNFIN * PPDIBL1R;
		end

		`ifdef __NQSMOD1__
			if(NQSMOD == 1 && XRCRG1 != 0) begin
				XRCRG1_i =  XRCRG1 + Inv_L * LXRCRG1 + Inv_NFIN * NXRCRG1 + Inv_LNFIN * PXRCRG1;
				XRCRG2_i =  XRCRG2 + Inv_L * LXRCRG2 + Inv_NFIN * NXRCRG2 + Inv_LNFIN * PXRCRG2;
			end else begin
				XRCRG1_i =  0.0;
				XRCRG2_i =  0.0;
			end
		`else
			if(NQSMOD == 1)
				$strobe("[bsimcmg] Although the model selector NQSMOD is set to 1, the NQS gate resistance model is not activated in the Verilog-A code. Please uncomment `define __NQSMOD1__ in bsimcmg.va to activate it.");
		`endif

		`ifdef __NQSMOD2__
			if(NQSMOD == 2 && XRCRG1 != 0) begin
				XRCRG1_i =  XRCRG1 + Inv_L * LXRCRG1 + Inv_NFIN * NXRCRG1 + Inv_LNFIN * PXRCRG1;
				XRCRG2_i =  XRCRG2 + Inv_L * LXRCRG2 + Inv_NFIN * NXRCRG2 + Inv_LNFIN * PXRCRG2;
			end else begin
				XRCRG1_i =  0.0;
				XRCRG2_i =  0.0;
			end
		`else
			if(NQSMOD == 2)
				$strobe("[bsimcmg] Although the model selector NQSMOD is set to 2, the NQS gate resistance model is not activated in the Verilog-A code. Please uncomment `define __NQSMOD2__ in bsimcmg.va to activate it.");
		`endif

		UTE_i    =  UTE + Inv_L * LUTE + Inv_NFIN * NUTE + Inv_LNFIN * PUTE;
		UTL_i    =  UTL + Inv_L * LUTL + Inv_NFIN * NUTL + Inv_LNFIN * PUTL;
		EMOBT_i  =  EMOBT + Inv_L * LEMOBT + Inv_NFIN * NEMOBT + Inv_LNFIN * PEMOBT;
		UA1_i    =  UA1 + Inv_L * LUA1 + Inv_NFIN * NUA1 + Inv_LNFIN * PUA1;
		if(BULKMOD != 0)  UC1_i  =  UC1 + Inv_L * LUC1 + Inv_NFIN * NUC1 + Inv_LNFIN * PUC1;
		UD1_i    =  UD1 + Inv_L * LUD1 + Inv_NFIN * NUD1 + Inv_LNFIN * PUD1;
		UCSTE_i  =  UCSTE + Inv_L * LUCSTE + Inv_NFIN * NUCSTE + Inv_LNFIN * PUCSTE;
		PTWGT_i  =  PTWGT + Inv_L * LPTWGT + Inv_NFIN * NPTWGT + Inv_LNFIN * PPTWGT;
		AT_i     =  AT + Inv_L * LAT + Inv_NFIN * NAT + Inv_LNFIN * PAT;
		PRT_i    =  PRT + Inv_L * LPRT + Inv_NFIN * NPRT + Inv_LNFIN * PPRT;
		KT1_i    =  KT1 + Inv_L * LKT1 + Inv_NFIN * NKT1 + Inv_LNFIN * PKT1;
		TSS_i    =  TSS + Inv_L * LTSS + Inv_NFIN * NTSS + Inv_LNFIN * PTSS;
		IIT_i    =  IIT + Inv_L * LIIT + Inv_NFIN * NIIT + Inv_LNFIN * PIIT;
		TGIDL_i  =  TGIDL + Inv_L * LTGIDL + Inv_NFIN * NTGIDL + Inv_LNFIN * PTGIDL;
		IGT_i    =  IGT + Inv_L * LIGT + Inv_NFIN * NIGT + Inv_LNFIN * PIGT;
		
		// Geometrical scaling
		// NFIN Scaling
		if(PHIGN1 !=0)
			PHIG_i  =  PHIG_i * (1.0 + PHIGN1/NFIN * lln(1.0 + NFIN/PHIGN2));
		
		if(ETA0N1 !=0)
			ETA0_i  =  ETA0_i * (1.0 + ETA0N1/NFIN * lln(1.0 + NFIN/ETA0N2));
	
		if(CDSCN1 !=0)
			CDSC_i  =  CDSC_i * (1.0 + CDSCN1/NFIN * lln(1.0 + NFIN/CDSCN2));

		if(CDSCDN1 !=0)
			CDSCD_i  =  CDSCD_i * (1.0 + CDSCDN1/NFIN * lln(1.0 + NFIN/CDSCDN2));

		if(CDSCDRN1 !=0)
			CDSCDR_i  =  CDSCDR_i * (1.0 + CDSCDRN1/NFIN * lln(1.0 + NFIN/CDSCDRN2));
		
		if(NBODYN1 !=0)
			NBODY_i  =  NBODY_i * (1.0 + NBODYN1/NFIN * lln(1.0 + NFIN/NBODYN2));
	
		if(VSATN1 !=0)
			VSAT_i  =  VSAT_i * (1.0 + VSATN1/NFIN * lln(1.0 + NFIN/VSATN2));
		
		if(VSAT1N1 !=0)
			VSAT1_i  =  VSAT1_i * (1.0 + VSAT1N1/NFIN * lln(1.0 + NFIN/VSAT1N2));
	
		if(VSAT1RN1 !=0)
			VSAT1R_i  =  VSAT1R_i * (1.0 + VSAT1RN1/NFIN * lln(1.0 + NFIN/VSAT1RN2));
	
		if(U0N1 !=0)
			U0_i  =  U0_i * (1.0 + U0N1/NFIN * lln(1.0 + NFIN/U0N2));
		
		// Length Scaling
		PHIG_i = PHIG_i + PHIGL * Leff;
		if(LPA > 0) U0_i =  U0_i * (1 - UP_i * pow(Leff, -LPA)); 
		else U0_i  =  U0_i * (1 - UP_i); 
		UA_i =  UA_i + AUA * lexp(-Leff / BUA); 
		UD_i =  UD_i + AUD * lexp(-Leff / BUD); 
		EU_i =  EU_i + AEU * lexp(-Leff / BEU);
		
		if(RDSMOD == 1) begin 
			RSW_i  =  RSW_i + ARSW * lexp(-Leff / BRSW); 
			RDW_i  =  RDW_i + ARDW * lexp(-Leff / BRDW); 
		end else begin 
			RDSW_i =  RDSW_i + ARDSW * lexp(-Leff / BRDSW); 
		end 
		
		PCLM_i   =  PCLM_i  + APCLM  * lexp(-Leff / BPCLM);
		MEXP_i   =  MEXP_i  + AMEXP  * pow(Leff, -BMEXP);
		if(ASYMMOD != 0) MEXPR_i  =  MEXPR_i + AMEXPR * pow(Leff, -BMEXPR);
		PTWG_i   =  PTWG_i + APTWG * lexp(-Leff / BPTWG); 
		if(ASYMMOD != 0)  PTWGR_i  =  PTWGR_i + APTWG * lexp(-Leff / BPTWG); 
		VSAT_i   =  VSAT_i + AVSAT * lexp(-Leff / BVSAT); 
		VSAT1_i  =  VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1);
		if(ASYMMOD != 0)  VSAT1R_i =  VSAT1R_i + AVSAT1 * lexp(-Leff / BVSAT1);
		PSAT_i   =  PSAT_i   + APSAT   * lexp(-Leff / BPSAT);
		PSATCV_i =  PSATCV_i + APSATCV * lexp(-Leff / BPSATCV); 
		VSATCV_i =  VSATCV_i + AVSATCV * lexp(-LeffCV / BVSATCV);
		
		// Geometrical Scaling for Toxeff / Charge Centroid Tcen
		if(QMTCENIV_i > 0.0 || QMTCENCV_i > 0.0 || QMTCENCVA_i > 0.0) begin
			case(GEOMOD)
			0 : begin
				MTcen  =  1.0 + AQMTCEN * lexp(- TFIN / BQMTCEN);
				Tcen0  =  TFIN * MTcen;
			end
			1 : begin
				MTcen  =  1.0 + AQMTCEN * lexp(- min(HFIN,TFIN) / BQMTCEN);
				Tcen0  =  min(TFIN,HFIN) * MTcen ;
			end
			2: begin
				MTcen  =  1.0 + AQMTCEN * lexp(- min(HFIN,TFIN) / BQMTCEN);
				Tcen0  =  min(TFIN,HFIN) * MTcen ;
			end
			3 : begin
				MTcen  =  1.0 + AQMTCEN * lexp(- R / BQMTCEN);
				Tcen0  =  R * MTcen;
			end
			endcase
		end
		
		// **************************************
		//           Parameter checking
		// **************************************
		if(Leff <= 0) begin
			$strobe("Fatal: Leff = %e is not positive.", Leff);
		end else if(Leff <= 1e-9) begin
			$strobe("Warning: Leff = %e <= 1.0e-9.", Leff);
		end
		if(LeffCV <= 1e-9) begin
			$strobe("Warning: LeffCV = %e <= 1.0e-9.", LeffCV);
		end
		if(CAPMOD != 0 && BULKMOD != 0) begin
			if(LeffCV_acc <= 1e-9) begin
				$strobe("Warning: LeffCV_acc = %e <= 1.0e-9.", LeffCV_acc);
			end
		end
		if(Weff0 <= 1e-9) begin
			$strobe("Warning: Weff0 = %e <= 1.0e-9.", Weff0);
		end
		if(WeffCV0 <= 1e-9) begin
			$strobe("Warning: WeffCV0 = %e <= 1.0e-9.", WeffCV0);
		end
		if(NBODY_i <= 0) begin
			$strobe("Fatal: NBODY_i = %e is not positive.", NBODY_i);
		end else if(NBODY_i <= 1e18) begin
			$strobe("Warning: NBODY_i = %e m^-3 may be too small.", NBODY_i);
		end /*else if(NBODY_i >= 5e24) begin
			$strobe("Warning: We recommend the use of BSIM4 or BSIM4SOI for NBODY_i = > 5e24 m^-3.");
		end*/
		if(NGATE_i < 0) begin
			$strobe("Fatal: NGATE_i = %e is negative.", NGATE_i);
		end else if(NGATE_i != 0 && NGATE_i <= 1e24) begin
			$strobe("Warning: NGATE_i = %e may be too small.", NGATE_i);
		end else if(NGATE_i > 1e31) begin
			$strobe("Fatal: NGATE_i = %e is too high.", NGATE_i);
		end
		if(DVT0_i < 0) begin
			$strobe("Warning: DVT0_i = %e is negative.", DVT0_i);
		end
		if(DVT1_i <= 0) begin
			$strobe("Fatal: DVT1_i = %e is not positive.", DVT1_i);
		end
		if(DVT1SS_i <= 0) begin
			$strobe("Fatal: DVT1SS_i = %e is not positive.", DVT1SS_i);
		end
		if(CDSC_i < 0) begin
			$strobe("Warning: CDSC_i = %e is negative.", CDSC_i);
		end
		if(CDSCD_i < 0) begin
			$strobe("Warning: CDSCD_i = %e is negative.", CDSCD_i);
		end
		if(DSUB_i <= 0) begin
			$strobe("Fatal: DSUB_i = %e is not positive.", DSUB_i);
		end
		if(ETA0_i < 0) begin
			$strobe("Warning: ETA0_i = %e is negative.", ETA0_i);
		end
		if(LPE0_i < -Leff) begin
			$strobe("Warning: LPE0_i = %e is less than -Leff. Clipping LPE0_i to 0", LPE0_i);
			LPE0_i =  0;
		end

		if(K0SI_i <= 0) begin
			$strobe("Warning: K0SI_i = %e is not positive, setting it to 0.", K0SI_i);
			K0SI_i = 0;
		end

		if(K1SI_i <= 0) begin
			$strobe("Warning: K1SI_i = %e is not positive, setting it to 0.", K1SI_i);
			K1SI_i = 0;
		end

		if(PHIBE_i < 0.2 && BULKMOD != 0) begin
			$strobe("Warning: PHIBE_i = %e is less than 0.2, setting it to 0.2.", PHIBE_i);
			PHIBE_i = 0.2;
		end

		if(PHIBE_i > 1.2 && BULKMOD != 0) begin
			$strobe("Warning: PHIBE_i = %e is larger than 1.2, setting it to 1.2.", PHIBE_i);
			PHIBE_i = 1.2;
		end

		if(PSAT_i < 2.0) begin
			$strobe("Warning: PSAT_i = %e is less than 2.0, setting it to 2.0.", PSAT_i);
			PSAT_i = 2.0; 
		end
		if(PSATCV_i < 2.0) begin
			$strobe("Warning: PSATCV_i = %e is less than 2.0, setting it to 2.0.", PSATCV_i);
			PSATCV_i = 2.0; 
		end

		if(U0_i < 0) begin 
			$strobe("Warning: U0_i = %e is negative, setting it to 0.", U0_i); 
			U0_i   =  0; 
		end 
		if(UA_i < 0) begin 
			$strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i); 
			UA_i   =  0; 
		end 
		if(EU_i < 0) begin 
			$strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i); 
			EU_i   =  0; 
		end 
		if(UD_i < 0) begin 
			$strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i); 
			UD_i   =  0; 
		end 
		if(UCS_i < 0) begin 
			$strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i); 
			UCS_i  =  0; 
		end
		
		RDSWMIN_i  =  RDSWMIN; 
		if(RDSWMIN_i < 0) begin 
			$strobe("Warning: RDSWMIN = %e is negative.  Set to zero", RDSWMIN_i); 
			RDSWMIN_i  =  0; 
		end 
		if(RDSW_i < 0) begin 
			$strobe("Warning: RDSW_i = %e is negative.  Set to zero", RDSW_i); 
			RDSW_i =  0; 
		end 
		RSWMIN_i   =  RSWMIN; 
		if(RSWMIN_i < 0) begin 
			$strobe("Warning: RSWMIN = %e is negative.  Set to zero", RSWMIN_i); 
			RSWMIN_i =  0; 
		end 
		if(RSW_i < 0) begin 
			$strobe("Warning: RSW_i = %e is negative.  Set to zero", RSW_i); 
			RSW_i    =  0; 
		end 
		RDWMIN_i =  RDWMIN; 
		if(RDWMIN_i < 0) begin 
			$strobe("Warning: RDWMIN = %e is negative.  Set to zero", RDWMIN_i); 
			RDWMIN_i =  0; 
		end 
		if(RDW_i < 0) begin 
			$strobe("Warning: RDW_i = %e is negative.  Set to zero", RDW_i); 
			RDW_i    =  0; 
		end 
		if(PRWGD_i < 0) begin 
			$strobe("Warning: PRWGD_i = %e is negative.  Set to zero", PRWGD_i); 
			PRWGD_i   =  0; 
		end
		if(PRWGS_i < 0) begin 
			$strobe("Warning: PRWGS_i = %e is negative.  Set to zero", PRWGS_i); 
			PRWGS_i   =  0; 
		end
		
		if(PCLM_i < 0) begin 
			$strobe("Warning: PCLM_i = %e is negative.", PCLM_i); 
		end
		if(PDIBL1_i < 0) begin 
			$strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i); 
		end

		if(ASYMMOD != 0) begin
			if(PDIBL1R_i < 0) begin 
				$strobe("Warning: PDIBL1R_i = %e is negative.", PDIBL1R_i); 
			end 
		end
		if(PDIBL2_i < 0) begin 
			$strobe("Fatal: PDIBL2_i = %e is negative.", PDIBL2_i); 
		end 
		if(DROUT_i <= 0) begin 
			$strobe("Fatal: DROUT_i = %e is non-positive.", DROUT_i); 
		end
		
		if(MEXP_i < 2.0) begin 
			$strobe("Warning: MEXP_i = %e < 2.  Setting MEXP_i = 2.", MEXP_i); 
			MEXP_i   =  2.0; 
		end
		if(ASYMMOD != 0) begin
			if(MEXPR_i < 2.0) begin 
				$strobe("Warning: MEXPR_i = %e < 2.  Setting MEXPR_i = 2.", MEXPR_i); 
				MEXPR_i   =  2.0; 
			end
		end
		if (PTWG_i < 0) begin
			$strobe("Warning: PTWG_i = %e is negative, setting it to 0.", PTWG_i );
			PTWG_i = 0;
		end
		if(QMTCENIV_i >0 || QMTCENCV_i >0) begin
			if(QM0 <= 0) begin
				$strobe("Fatal: QM0 = %e is non-positive.", QM0);
			end
		end
		if(CAPMOD != 0 && BULKMOD != 0 && QMTCENCVA_i >0) begin
			if(QM0ACC <= 0) begin
				$strobe("Fatal: QM0ACC = %e is non-positive.", QM0ACC);
			end
		end
		if(CGIDL_i < 0.0) begin
			$strobe("Warning: CGIDL_i = %e < 0.  Setting CGIDL_i = 0.", CGIDL_i); 
			CGIDL_i   =  0.0; 
		end
		if(CGISL_i < 0.0) begin
			$strobe("Warning: CGISL_i = %e < 0.  Setting CGISL_i = 0.", CGISL_i); 
			CGISL_i   =  0.0; 
		end
		if(IGBMOD != 0) begin
			if(NIGBINV_i <= 0) begin
				$strobe("Fatal: NIGBINV_i = %e is non-positive.", NIGBINV_i);
			end
			if(NIGBACC_i <= 0) begin
				$strobe("Fatal: NIGBACC_i = %e is non-positive.", NIGBACC_i);
			end
		end
		if(IGCMOD != 0) begin
			if(POXEDGE_i <= 0) begin
				$strobe("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i);
			end
			if(PIGCD_i <= 0) begin
				$strobe("Fatal: PIGCD_i = %e is non-positive.", PIGCD_i);
			end
		end
		if(IGCMOD != 0 || IGBMOD != 0) begin
			if(TOXREF <= 0) begin
				$strobe("Fatal: TOXREF = %e is non-positive.", TOXREF);
			end
		end
		if(LINTIGEN >= Leff/2) begin
			$strobe("Warning: LINTIGEN = %e is too large - Leff for r/g current is negative.  Re-setting LINTIGEN = 0.", LINTIGEN);
			LINTIGEN_i =  0;
		end else begin
			LINTIGEN_i =  LINTIGEN;
		end
		if(NTGEN_i <= 0) begin
			$strobe("Fatal: NTGEN_i = %e is non-positive.", NTGEN_i);
		end
		`ifdef __NQSMOD1__
		if(NQSMOD == 1 && XRCRG1_i != 0 && XRCRG1_i < 1.0e-3) begin
			$strobe("Warning: XRCRG1_i = %e.  Gate resistance may be too large. Disabling NQS Gate Resistance.", XRCRG1_i);
			XRCRG1_i   =  0;
		end
		`endif
		if(IIMOD==2) begin
			if (BETAII0_i < 0.0)
				$strobe("Warning:  BETAII0_i = %e is negative.",BETAII0_i);
			if (BETAII1_i < 0.0)
				$strobe("Warning:  BETAII1_i = %e is negative.", BETAII1_i);
			if (BETAII2_i < 0.0)
				$strobe("Warning:  BETAII2_i = %e is negative.", BETAII2_i);
			if (ESATII_i < 0.0)
				$strobe("Warning:  ESATII_i = %e is negative.", ESATII_i);
			if (LII_i < 0.0)
				$strobe("Warning:  LII_i = %e is negative.", LII_i);
			if (SII1_i < 0.0)
				$strobe("Warning:  SII1_i = %e is negative.", SII1);
			if (SII2_i < 0.0)
				$strobe("Warning:  SII2_i = %e is negative.", SII2_i);
			if (SIID_i < 0.0)
				$strobe("Warning:  SIID_i = %e is negative.", SIID_i);
		end
		if(EF <= 0) begin
			$strobe("Fatal: EF = %e is non-positive.", EF);
		end else if(EF > 2.0) begin
			$strobe("Fatal: EF = %e > 2.0.", EF);
		end
		if(LINTNOI >= Leff/2) begin
			$strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
			LINTNOI_i  =  0;
		end else begin
			LINTNOI_i  =  LINTNOI;
		end
		if(NTNOI < 0) begin
			$strobe("Warning: NTNOI = %e is negative. Set to zero.", NTNOI);
			NTNOI_i    =  0;
		end else begin
			NTNOI_i    =  NTNOI;
		end
		
		// Self-heating
		`ifdef __SHMOD__
			if(SHMOD != 0 && RTH0 > 0) begin
				gth  =  NF * (WTH0 + NFIN * FPITCH) / RTH0;
				cth  =  CTH0 * NF* (WTH0 + NFIN * FPITCH);
			end else begin
				gth  =  1.0;    // set gth to some value to prevent a singular G matrix
				cth  =  0.0;
			end
		`else
			if(SHMOD != 0)
				$strobe("[bsimcmg] Although the model selector SHMOD is set to 1, the self heating model is not activated in the Verilog-A code.  Please uncomment `define __SHMOD__ in bsimcmg.va to activate it.");
		`endif
		
		// Gate Electrode Resistance
		`ifdef __RGATEMOD__
			if(RGATEMOD != 0) begin
                                Rgeltd =  (RGEXT/NGCON + (RGFIN * NFIN) / (NGCON == 2 ? 12.0 : 3.0)) / NF;
				ggeltd =  1.0 / max(Rgeltd, 1.0e-3);
			end
		`else
			if(RGATEMOD != 0)
				$strobe("[bsimcmg] Although the model selector RGATEMOD is set to 1, the gate electrode resistance model is not activated in the Verilog-A code.  Please uncomment `define __RGATEMOD__ in bsimcmg.va to activate it.");
		`endif
		
		// Geometry dependent Source/Drain Resistance
		if(RGEOMOD == 0) begin
			RSourceGeo =  RSHS * NRS;
			RDrainGeo  =  RSHD * NRD;
		end else begin
			// Area and perimeter calculation
			if(HEPI > 0) begin
				Arsd   =  FPITCH * HFIN + (TFIN + (FPITCH - TFIN) * CRATIO) * HEPI;
			end else begin
				Arsd   =  FPITCH * max(HFIN + HEPI, 1.0e-9);
			end
			Prsd =  FPITCH + DELTAPRSD;
			
			// Resistivity calculation
			if($param_given(RHORSD)) begin
				rhorsd =  RHORSD;
			end else begin
                               mu_max =  (DEVTYPE == `ntype) ? 1417 : 470.5;    // cm^2/V-s
				if(DEVTYPE == `ntype) begin
					mu_rsd =  (52.2 + (mu_max - 52.2) / (1 + pow(NSD / 9.68e22, 0.680)) - 43.4 / (1.0 + pow(3.43e26 / NSD, 2))) * 1.0e-4;
				end else begin
					mu_rsd =  (44.9 + (mu_max - 44.9) / (1 + pow(NSD / 2.23e22, 0.719)) - 29.0 / (1.0 + pow(6.10e26 / NSD, 2))) * 1.0e-4;
				end
				rhorsd =  1 / (`q * NSD * mu_rsd);
			end
			
			// Component 1: Extension Resistance
			/*T0   =  LDG * log(NSD / NSDE);			
			T1   =  max(0.0, LSP + deltaL - T0);
			if($param_given(RHOEXT)) begin
				Rext =  (rhorsd * T1 + RHOEXT * T0)/ (HFIN * TFIN * NFIN);	
			end else begin
				T2   =  T1 + LDG / ln(10) * (NSD / NSDE - 1.0);
				Rext =  rhorsd / (HFIN * TFIN * NFIN) * T2;				
			end*/
						
			// Component 2: Spreading Resistance (extension -> hdd)
			thetarsp =  55 * `M_PI / 180;
			afin     =  min(max(TFIN * (HFIN + min(HEPI, 0.0)), 1.0e-18), Arsd);
			T1       =  `COT(thetarsp);
			Rsp      =  rhorsd * T1 / (sqrt(`M_PI) * NFIN) * (1.0 / sqrt(afin) - 2.0 / sqrt(Arsd) + sqrt(afin / (Arsd*Arsd)));
			
			// Component 3: Contact Resistance
			arsd_total =  Arsd * NFIN + ARSDEND;
			prsd_total =  Prsd * NFIN + PRSDEND;
			lt         =  sqrt(RHOC * arsd_total / (rhorsd * prsd_total));
			alpha      =  LRSD / lt;
			T0         =  lexp(alpha + alpha);
			if(SDTERM == 1) begin
				eta  =  rhorsd * lt / RHOC;
				T1   =  T0 * (1.0 + eta);
				T2   =  T1 + 1.0 - eta;
				T3   =  T1 - 1.0 + eta;
			end else begin
				T2   =  T0 + 1.0;
				T3   =  T0 - 1.0;
			end
			RrsdTML  =  rhorsd * lt * T2 / (arsd_total * T3);
			
			if(HEPI < -1.0e-10) begin
				Rrsdside =  RHOC / (-HEPI * TFIN * NFIN);
				Rrsd =  (RrsdTML + Rsp) * Rrsdside / ((RrsdTML + Rsp) + Rrsdside);
			end else begin
				Rrsd =  RrsdTML + Rsp;
			end
			//Rdsgeo   =  (Rrsd + Rext) / NF * max(RGEOA + RGEOB * TFIN + RGEOC * FPITCH + RGEOD * LRSD + RGEOE * HEPI, 0);
			Rdsgeo   =  Rrsd / NF * max(RGEOA + RGEOB * TFIN + RGEOC * FPITCH + RGEOD * LRSD + RGEOE * HEPI, 0.0);
			RSourceGeo =  Rdsgeo;
			RDrainGeo  =  Rdsgeo;
		end

		// Clamping of Source/Drain Resistances
		if(RSourceGeo <= 1.0e-3) RSourceGeo = 1.0e-3;
		if(RDrainGeo  <= 1.0e-3) RDrainGeo  = 1.0e-3;

		if(RDSMOD != 0) begin
			if (RSWMIN_i <= 0) RSWMIN_i = 0;
			if (RDWMIN_i <= 0) RDWMIN_i = 0;
			if (RSW_i <= 0) RSW_i = 0;
			if (RDW_i <= 0) RDW_i = 0;
		end else begin
			if (RDSWMIN_i <= 0) RDSWMIN_i = 0;
			if (RDSW_i <= 0) RDSW_i = 0;
		end
		// End - Clamping of Source/Drain Resistances
		
		if(CGEOMOD != 1) begin
			if($param_given(CGSO))
				CGSO_i =  CGSO;
			else begin
				if($param_given(DLC) && DLC > 0)
					CGSO_i =  max(0.0, DLC * cox - CGSL_i);
				else
					CGSO_i =  0.3 * TFIN * cox;
			end
			if($param_given(CGDO))
				CGDO_i =  CGDO;
			else begin
				if($param_given(DLC) && DLC > 0)
					CGDO_i =  max(0.0, DLC * cox - CGDL_i);
				else
					CGDO_i =  0.3 * TFIN * cox;
			end
		end
		
		// Parasitic source/drain to gate fringe capacitance model
		if(CGEOMOD == 2) begin
			Hg =  TGATE + TMASK;
			Trsd =  0.5 * (FPITCH - TFIN);
			Wg   =  max(Trsd - TOXP, 0.0);
			Hrsd =  max(HEPI + TSILI, 0.0);
			
			// Top component
			if(TMASK > 0) begin
				// Capacitance model developed by Chung-Hsun Lin (IBM)
				T0 =  3.467e-11 * lln(1.0e-7 * EPSRSP / (3.9 * LSP));
				T1 =  0.942 * Hrsd * epssp / LSP;
				Cgg_top  =  (T0 + T1) * (TFIN + (FPITCH - TFIN) * CRATIO);
			end else begin
				`Cfringe_2d(cfr_top_trigate, Hg, Hrsd, LSP, TFIN, LRSD, Lg, TOXP, 0.85, Cgg_top)
			end
			
			// Side component
			if(TMASK > 0) begin
				`Cfringe_2d(cfr_side_dblgate, Wg, Trsd, LSP, HFIN, LRSD, Lg, TOXP, 0.70, Cgg_side)
			end else begin
				`Cfringe_2d(cfr_side_trigate, Wg, Trsd, LSP, HFIN, LRSD, Lg, TOXP, 0.85, Cgg_side)
			end
			
			// Corner component
			if(TMASK > 0) begin
				Acorner  =  0.0;
			end else begin
				if(HEPI > 0) begin
					Acorner  =  (FPITCH - TFIN) * (HEPI * CRATIO + TSILI);
				end else begin
					Acorner  =  (FPITCH - TFIN) * Hrsd;
				end
			end
			Ccorner  =  (NFIN * Acorner + ARSDEND + ASILIEND) * epssp / LSP;
			
			Cfr_geo  =  (Ccorner + Cgg_top * NFIN + CGEOE * Cgg_side * NFIN * 2.0) * NF;
			Cfr_geo  =  Cfr_geo * max(CGEOA + CGEOB * TFIN + CGEOC * FPITCH + CGEOD * LRSD, 0.0);
		end
		
		// Source/gate/drain to substrate parasitic capacitances
		T0     =  CSDESW * lln(1.0 + HFIN / EOTBOX);
		csbox  =  cbox * ASEO + T0 * max(0.0, PSEO - FPITCH * NFINtotal);
		cdbox  =  cbox * ADEO + T0 * max(0.0, PDEO - FPITCH * NFINtotal);
		cgbox  =  (CGBO * NF * NGCON + CGBN * NFINtotal) * LeffCV;
		
		// Mobility Degradation
		EeffFactor   =  1.0e-8 / (epsratio * (EOT));

		WeffWRFactor =  1.0 / (pow((Weff0)*1.0e6, WR_i) * (NFINtotal));
		litl         =  sqrt(epsratio * EOT * 0.5 * TFIN);
		

		tmp = DVT1_i * Leff / scl + 1.0e-6;
		if (tmp < 40.0)
			Theta_SCE    =  0.5 / (cosh(tmp) - 1.0);
		else
			Theta_SCE    =  exp(-tmp);


		tmp = DVT1SS_i * Leff / scl + 1.0e-6;
		if (tmp < 40.0)
			Theta_SW    =  0.5 / (cosh(tmp) - 1.0);
		else
			Theta_SW    =  exp(-tmp);

		
		tmp = DSUB_i * Leff / scl + 1.0e-6;
		if (tmp < 40.0)
			Theta_DIBL   =  0.5 / (cosh(tmp) - 1.0);
		else
			Theta_DIBL   =  exp(-tmp);
			
		Theta_RSCE   =  sqrt(1.0 + LPE0_i / Leff) - 1.0;

		// Body doping correction
		if(COREMOD != 0 && NBODY_i > 1e23) nbody =  1e23;   // Limit doping to 1e17 cm^-3 in the simplified analytical surface potential case
		else                               nbody =  NBODY_i;
		if(GEOMOD != 3) qbs =  `q * nbody * TFIN / (2 * cox);
		else            qbs =  `q * nbody * R / (2 * cox);
		/*	nbody =  1.8/(`q * TFIN / 2 / cox);
			qbs =  `q * nbody * TFIN / (2 * cox);
		end else
			nbody =  NBODY_i;*/   
		// Variables for the core model
		
		if( GEOMOD != 3) begin
			phibulk =  `q/(2*epssub) * nbody * (TFIN/2) * (TFIN/2);
			//phipert =  min(phibulk , 0.4);
			//phipert =  phibulk;			
                        Qbul    =  (COREMOD != 0) ? 0 : (sqrt(2* `q * nbody * epssub * phibulk));
			F2      =  lln(2.0/TFIN);
		end else begin
			r1      =  2 * epssub / (R * cox);
			if(CAPMOD != 0 && BULKMOD != 0) r1_acc =  2.0 * epssub / (R * cox_acc);
		end
		
		// Gate current
		if(DEVTYPE == `ntype) Aechvb = 4.97232e-7; //NMOS
		else                  Aechvb = 3.42537e-7; //PMOS 
		if(DEVTYPE == `ntype) Bechvb = 7.45669e11; //NMOS
		else                  Bechvb = 1.16645e12; //PMOS

		T0 		     = TOXG * TOXG;
		T1 		     = TOXG * POXEDGE_i;
		T2 			 = T1 * T1;
		Toxratio 	 = lexp(NTOX_i * lln(TOXREF / TOXG)) / T0;
		Toxratioedge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
		igsd_mult0   = Weff0 * Aechvb * Toxratioedge;

		if(TNOM < -`P_CELSIUS0) begin 
			$strobe("Warning: (TNOM=%e) < -`P_CELSIUS0. Set to 27 C.", TNOM); 
			Tnom = `REFTEMP; //`REFTEMP is in Kelvin i.e. 300.15 K
		end else begin 
			Tnom = TNOM + `CONSTCtoK; 
		end
		
	end // initial_step
	
	/************************************************/
	/*      Temperature dependent calculations      */
	/************************************************/
	`ifdef __SHMOD__
		if(SHMOD != 0 && RTH0 > 0) begin
			DevTemp  =  $temperature + Temp(rth_branch) + DTEMP;
		end else begin
			`endif
			DevTemp  =  $temperature + DTEMP;
			`ifdef __SHMOD__
		end
	`endif
	
	begin : CMGTempDepCalc
		TRatio  = DevTemp / Tnom;
		delTemp = DevTemp - Tnom;
		Vtm     = `KboQ * DevTemp;
		Vtm0    = `KboQ * Tnom;
		Eg      = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
		Eg0     = BG0SUB - TBGASUB * Tnom * Tnom / (Tnom + TBGBSUB);
		T1      = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
		ni      = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
		Nc      = NC0SUB * T1;
		ThetaSS = hypsmooth(1.0 + TSS_i*delTemp - 1.0E-6, 1.0E-3); 
		
		// Quantum Mechanical Vth Correction
		// Ref: Trivedi et al., EDL 2005
		// TODO: account for 110-orientation and pFET
		if(GEOMOD != 3) begin
			kT 		=  Vtm * `q;
			T0 		=  `HBAR * `M_PI / TFIN;
			E0 		=  T0 * T0 / (2.0 * mx);
			E0prime =  T0 * T0 / (2.0 * mxprime);
			E1 		=  4.0 * E0;
			E1prime =  4.0 * E0prime;
			T1 		=  gprime * mdprime / (gfactor * md);
			gam0 	=  1.0 + T1 * lexp((E0 - E0prime) / kT);
			gam1 	=  gam0 + lexp((E0 - E1) / kT) + T1 * lexp((E0 - E1prime) / kT);
			T2   	=  -Vtm * lln(gfactor * md / (`M_PI * `HBAR * `HBAR * Nc) * kT / TFIN * gam1);
			dvch_qm =  QMFACTOR_i * (E0 / `q + T2);
		end else begin
			T0 		=  `HBAR * 2.4048 / R;
			E0 		=  T0 * T0 / (2.0 * mx);
			dvch_qm =  QMFACTOR_i * E0 / `q;
		end
		
		// Temperature Dependence
		ETA0_t   =  ETA0_i  * (1.0 + hypmax( TETA0  *delTemp, -0.9, 1e-4));
		ETA0R_t  =  ETA0R_i * (1.0 + hypmax( TETA0R *delTemp, -0.9, 1e-4));

	    T1       =  U0_i * pow(TRatio, UTE_i);
		U0_t     =  T1 + hypmax(UTL_i*delTemp, -0.9 * T1, 1e-4); 
		u0       =  U0_t; 
		ETAMOB_t =  ETAMOB_i * hypsmooth(1.0 + EMOBT_i*delTemp - 1.0E-6, 1.0E-3);  
		UA_t     =  UA_i + hypmax(UA1_i*delTemp, -UA_i, 1.0e-6);
		if(BULKMOD != 0)  UC_t  =  UC_i * hypsmooth(1.0 + UC1_i*delTemp - 1.0E-6, 1.0E-3); 
		UD_t     =  UD_i * pow(TRatio, UD1_i); 
		UCS_t    =  UCS_i * pow(TRatio, UCSTE_i);
		
		rdstemp  =  hypsmooth(1.0 + PRT_i * delTemp - 1.0E-6, 1.0E-3);
	    RSDR_t   =  RSDR * hypsmooth(1.0 + TRSDR * delTemp - 1.0E-6, 1.0E-3);
	    if(ASYMMOD != 0)  RSDRR_t  =  RSDRR * hypsmooth(1.0 + TRSDR * delTemp - 1.0E-6, 1.0E-3);
	    RDDR_t   =  RDDR * hypsmooth(1.0 + TRDDR * delTemp - 1.0E-6, 1.0E-3);
	    if(ASYMMOD != 0)  RDDRR_t  =  RDDRR * hypsmooth(1.0 + TRDDR * delTemp - 1.0E-6, 1.0E-3);
		
		VSAT_t   =  VSAT_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
		if(VSAT_t < 1000) begin 
			$strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT_t); 
			VSAT_t =  1000; 
		end 
		
		VSAT1_t    =  VSAT1_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
		if(VSAT1_t < 1000) begin 
			$strobe("Warning: VSAT1(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1_t); 
			VSAT1_t  =  1000; 
		end
		if(ASYMMOD != 0) begin
			VSAT1R_t   =  VSAT1R_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
			if(VSAT1R_t < 1000) begin 
				$strobe("Warning: VSAT1R(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1R_t); 
				VSAT1R_t  =  1000; 
			end
		end

		VSATCV_t    =  VSATCV_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
		if(VSATCV_t < 1000) begin 
			$strobe("Warning: VSATCV(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATCV_t); 
			VSATCV_t  =  1000; 
		end  
		
		MEXP_t      =  hypsmooth(MEXP_i  * (1.0 + TMEXP  * delTemp)-2.0 , 1.0E-3) + 2.0;
		if(ASYMMOD != 0) MEXPR_t     =  hypsmooth(MEXPR_i * (1.0 + TMEXPR * delTemp)-2.0 , 1.0E-3) + 2.0;
		PTWG_t      =  PTWG_i * hypsmooth(1.0 - PTWGT_i*delTemp - 1.0E-6, 1.0E-3);
		if(ASYMMOD != 0)  PTWGR_t     =  PTWGR_i * hypsmooth(1.0 - PTWGT_i*delTemp - 1.0E-6, 1.0E-3);
		dvth_temp   =  (KT1_i + KT1L / Leff) * (TRatio - 1.0);
		BETA0_t     =  BETA0_i * pow(TRatio, IIT_i);
		SII0_t      =  SII0_i * (hypsmooth(1 + TII_i * (TRatio -1) - 0.01, 1.0E-3) + 0.01);
		
		K0_t		=  K0_i    + K01_i * delTemp;
		K0SI_t		=  K0SI_i  + hypmax(K0SI1_i  * delTemp, -K0SI_i,  1E-6);
		K1SI_t		=  K1SI_i  + hypmax(K1SI1_i  * delTemp, -K1SI_i,  1E-6);
		K1_t		=  K1_i    + hypmax(K11_i    * delTemp, -K1_i,    1E-6);
		K1SAT_t		=  K1SAT_i + K1SAT1_i * delTemp;
		A1_t		=  A1_i    + A11_i    * delTemp;
		A2_t		=  A2_i    + A21_i    * delTemp;

		AIGBINV_t	=  AIGBINV_i + hypmax(AIGBINV1_i * delTemp, -AIGBINV_i, 1.0E-6);
		AIGBACC_t	=  AIGBACC_i + hypmax(AIGBACC1_i * delTemp, -AIGBACC_i, 1.0E-6);
		AIGC_t		=  AIGC_i    + hypmax(AIGC1_i    * delTemp, -AIGC_i,    1.0E-6);
		AIGS_t		=  AIGS_i    + hypmax(AIGS1_i    * delTemp, -AIGS_i,    1.0E-6);
		AIGD_t		=  AIGD_i    + hypmax(AIGD1_i    * delTemp, -AIGD_i,    1.0E-6);

		BGIDL_t     =  BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
		BGISL_t     =  BGISL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
		
		ALPHA0_t	=  ALPHA0_i + hypmax(ALPHA01 * delTemp, -ALPHA0_i, 1.0E-6);
		ALPHA1_t	=  ALPHA1_i + hypmax(ALPHA11 * delTemp, -ALPHA1_i, 1.0E-6);
		
		ALPHAII0_t	=  ALPHAII0_i + hypmax(ALPHAII01 * delTemp, -ALPHAII0_i, 1.0E-6);  
		ALPHAII1_t	=  ALPHAII1_i + hypmax(ALPHAII11 * delTemp, -ALPHAII1_i, 1.0E-6);	

		igtemp      =  lexp(IGT_i * lln(TRatio));  //pow(TRatio, IGT_i);
		igsd_mult   =  igsd_mult0 * igtemp;
		if(BULKMOD != 0) begin
			CJS_t  =  CJS * hypsmooth(1.0 + TCJ * delTemp - 1.0E-6, 1.0E-3);
			CJD_t  =  CJD * hypsmooth(1.0 + TCJ * delTemp - 1.0E-6, 1.0E-3);
			CJSWS_t  =  CJSWS * hypsmooth(1.0 + TCJSW * delTemp - 1.0E-6, 1.0E-3);
			CJSWD_t  =  CJSWD * hypsmooth(1.0 + TCJSW * delTemp - 1.0E-6, 1.0E-3);
			CJSWGS_t =  CJSWGS * hypsmooth(1.0 + TCJSWG * delTemp - 1.0E-6, 1.0E-3);
			CJSWGD_t =  CJSWGD * hypsmooth(1.0 + TCJSWG * delTemp - 1.0E-6, 1.0E-3);
			PBS_t    =  hypsmooth(PBS - TPB * delTemp - 0.01, 1.0E-3) + 0.01;
			PBD_t    =  hypsmooth(PBD - TPB * delTemp - 0.01, 1.0E-3) + 0.01;
			PBSWS_t  =  hypsmooth(PBSWS - TPBSW * delTemp - 0.01, 1.0E-3) + 0.01;
			PBSWD_t  =  hypsmooth(PBSWD - TPBSW * delTemp - 0.01, 1.0E-3) + 0.01;
			PBSWGS_t =  hypsmooth(PBSWGS - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
			PBSWGD_t =  hypsmooth(PBSWGD - TPBSWG * delTemp - 0.01, 1.0E-3) + 0.01;
			
			T0 		 =  Eg0 / Vtm0 - Eg / Vtm;
			T1 		 =  lln(TRatio);
			T3 		 =  lexp((T0 + XTIS * T1) / NJS);
			JSS_t    =  JSS * T3;
			JSWS_t   =  JSWS * T3;
			JSWGS_t  =  JSWGS * T3;
			T3 		 =  lexp((T0 + XTID * T1) / NJD);
			JSD_t    =  JSD * T3;
			JSWD_t   =  JSWD * T3;
			JSWGD_t  =  JSWGD * T3;
			
			JTSS_t     =  JTSS * lexp(Eg0 * XTSS * (TRatio - 1) / Vtm);
			JTSD_t     =  JTSD * lexp(Eg0 * XTSD * (TRatio - 1) / Vtm);
			JTSSWS_t   =  JTSSWS * lexp(Eg0 * XTSSWS * (TRatio - 1) / Vtm);
			JTSSWD_t   =  JTSSWD * lexp(Eg0 * XTSSWD * (TRatio - 1) / Vtm);
			JTSSWGS_t  =  JTSSWGS * (sqrt(JTWEFF / Weff0) + 1.0) * lexp(Eg0 * XTSSWGS * (TRatio - 1) / Vtm);
			JTSSWGD_t  =  JTSSWGD * (sqrt(JTWEFF / Weff0) + 1.0) * lexp(Eg0 * XTSSWGD * (TRatio - 1) / Vtm);
			
			//All NJT*'s smoothed to 0.01 to prevent divide by zero / negative values
			NJTS_t 		=  hypsmooth(NJTS * (1.0 + TNJTS * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
			NJTSD_t  	=  hypsmooth(NJTSD * (1.0 + TNJTSD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
			NJTSSW_t 	=  hypsmooth(NJTSSW * (1.0 + TNJTSSW * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
			NJTSSWD_t  	=  hypsmooth(NJTSSWD * (1.0 + TNJTSSWD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
			NJTSSWG_t  	=  hypsmooth(NJTSSWG * (1.0 + TNJTSSWG * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
			NJTSSWGD_t 	=  hypsmooth(NJTSSWGD * (1.0 + TNJTSSWGD * (TRatio-1.0)) - 0.01, 1.0E-3) + 0.01;
			
		end
		
		beta0  =  u0 * cox * Weff0 / Leff;
		if (NGATE > 0) begin
			vfbsd  =  devsign*(hypsmooth(0.5*Eg-Vtm*lln(NGATE/ni),1.0E-4) - (0.5*Eg - devsign * (0.5*Eg-hypsmooth(0.5*Eg-Vtm*lln(NSD/ni),1.0E-4))));  
		end else begin
			vfbsd  =  devsign*(PHIG_i - (EASUB + 0.5*Eg - devsign * (0.5*Eg-hypsmooth(0.5*Eg-Vtm*lln(NSD/ni),1.0E-4))));
		end
		
		`ifdef __SHMOD__
			if(SHMOD != 0 && RTH0 > 0) begin
				T0    =  Vtm * lln(nbody/ni);
				phib  =  sqrt(T0 * T0 + 1.0E-6);
			end else begin
				phib  =  Vtm * lln(nbody/ni);
			end
		`else
			phib  =  Vtm * lln(nbody/ni);
		`endif

		`ifdef __SHMOD__
			if(SHMOD != 0 && RTH0 > 0) begin
				T0    =  Vtm * lln(nbody*NSD/(ni*ni));
				vbi   =  sqrt(T0 * T0 + 1.0E-6);
			end else begin
				vbi   =  Vtm * lln(nbody*NSD/(ni*ni));
			end
		`else
			vbi   =  Vtm * lln(nbody*NSD/(ni*ni));
		`endif

		// deltaPhi definition and Polysilicon Depletion
		// deltaPhi: workfunction difference between the gate and the n+ source.
		if(NGATE_i > 0) begin
			deltaPhi =  hypsmooth(0.5 * Eg - Vtm*lln(NGATE_i/ni),1.0E-4);
			if(GEOMOD != 3) begin
				vpoly0 =  `q * NGATE_i * epssub / (2.0 * cox * cox);
				cpoly  =  1.0 / (4.0 * vpoly0) ;
			end else begin
				T0 	   =  (R + EOT) / R ;
				vpoly0 =  `q * NGATE_i * epssub * T0 * T0 / (2.0 * cox * cox);
				cpoly  =  1.0 / (4.0 * vpoly0) ;
			end
			kpoly  =  (1.0 + 2.0 * cpoly * qbs);
		end else begin
                        deltaPhi =  devsign*(PHIG_i - (EASUB + (DEVTYPE == `ntype ? 0 : Eg)));
			cpoly    =  0.0;
			vpoly0   =  0.0;
			kpoly    =  0.0;
		end
		
		
		// Analytical Surface Potential
		// TODO: move up
		if(GEOMOD != 3) begin
			r1 =  2.0*epssub/(cox*TFIN);
			g0max  =  1.57079;
			g0min  =  1e-37;
			Inv_r1pi =  1.0 / (r1 * `M_PI);
			if(CAPMOD != 0 && BULKMOD != 0) begin
				r1_acc =  2.0*epssub/(cox_acc*TFIN);
				Inv_r1pi_acc =  1.0 / (r1_acc * `M_PI);
			end
		end else begin
			g0max  =  700;
			g0min  =  1e-37;
		end

		// Calculating Poly Depletion term for all GEOMOD's
		if(NGATE_i>0) begin
			if(GEOMOD != 3) r2 =  4.0 * Vtm * epssub / (`q * TFIN * TFIN * NGATE_i);
			else            r2 =  2.0 * cpoly * r1 * r1 * Vtm;
		end else begin
			r2 =  0.0;
		end

		// Mobility Degradation
		eta_mu    =  0.5 * ETAMOB_t;
		eta_mu_cv =  0.5; 
		if( DEVTYPE != `ntype ) begin 
			eta_mu    =  1.0 / 3.0 * ETAMOB_t; 
			eta_mu_cv =  1.0 / 3.0; 
		end 
		
	
		// Junction Current and Capacitance
		if(BULKMOD != 0) begin
			// Source-side junction current
			Isbs   =  ASEJ * JSS_t + PSEJ * JSWS_t + Weff0 * NFINtotal * JSWGS_t;
			if(Isbs > 0.0) begin
				Nvtms  	 =  Vtm * NJS;
				XExpBVS  =  lexp(-BVS / Nvtms) * XJBVS;
				T2 		 =  max(IJTHSFWD / Isbs, 10.0);
				Tb 		 =  1.0 + T2 - XExpBVS;
				VjsmFwd  =  Nvtms * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVS)));
				T0 		 =  lexp(VjsmFwd / Nvtms);
				IVjsmFwd =  Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
				SslpFwd  =  Isbs * (T0 + XExpBVS / T0) / Nvtms;
				T2 		 =  hypsmooth(IJTHSREV / Isbs - 10.0, 1.0E-3) + 10.0;
				VjsmRev  =  -BVS - Nvtms * lln((T2 - 1.0) / XJBVS);
				T1 		 =  XJBVS * lexp(-(BVS + VjsmRev) / Nvtms);
				IVjsmRev =  Isbs * (1.0 + T1);
				SslpRev  =  -Isbs * T1 / Nvtms;
			end
			
			// Drain-side junction current
			Isbd =  ADEJ * JSD_t + PDEJ * JSWD_t + Weff0 * NFINtotal * JSWGD_t;
			if(Isbd > 0.0) begin
				Nvtmd  	 =  Vtm * NJD;
				XExpBVD  =  lexp(-BVD / Nvtmd) * XJBVD;
				T2 		 =  max(IJTHDFWD / Isbd, 10.0);
				Tb 		 =  1.0 + T2 - XExpBVD;
				VjdmFwd  =  Nvtmd * lln(0.5 * (Tb + sqrt(Tb * Tb + 4 * XExpBVD)));
				T0 		 =  lexp(VjdmFwd / Nvtmd);
				IVjdmFwd =  Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
				DslpFwd  =  Isbd * (T0 + XExpBVD / T0) / Nvtmd;
				T2 		 =  hypsmooth(IJTHDREV / Isbd - 10.0, 1.0E-3) + 10.0;
				VjdmRev  =  -BVD - Nvtmd * lln((T2 - 1.0) / XJBVD);
				T1 		 =  XJBVD * lexp(-(BVD + VjdmRev) / Nvtmd);
				IVjdmRev =  Isbd * (1.0 + T1);
				DslpRev  =  -Isbd * T1 / Nvtmd;
			end
			
			// Junction Capacitance
			Czbs 	=  CJS_t * ASEJ;
			Czbssw 	=  CJSWS_t * PSEJ;
			Czbsswg =  CJSWGS_t * Weff0 * NFINtotal;
			Czbd 	=  CJD_t * ADEJ;
			Czbdsw 	=  CJSWD_t * PDEJ;
			Czbdswg =  CJSWGD_t * Weff0 * NFINtotal;
		end
		
		// Generation / recombination current
		T0 		 =  Eg / Vtm * (TRatio - 1.0);
		T1 		 =  T0 / NTGEN_i;
		igentemp =  lexp(T1);
		
	end     // end of temperature dependent calculations
	
	
	/************************************************/
	/*     Bias dependent calculations follow       */
	/************************************************/
	if(!initialized) begin
		$strobe("Warning: initial_step is not triggered at the first execution of this code.  As a result, bias-independent variables may not be initialized.  Check your simulator for Verilog-A language compatibility.");
	end else begin
		
		// *** Load Terminal Voltages ***
		vgs_noswap = devsign * V(`IntrinsicGate, si);
		vds_noswap = devsign * V(di, si);
		vgd_noswap = devsign * V(`IntrinsicGate, di);
		ves_jct    = devsign * V(e, si);
		ved_jct    = devsign * V(e, di);
		vge        = devsign * V(`IntrinsicGate, e);
		
		// *** Source-drain interchange ***
		sigvds =  1.0;
		if (vds_noswap < 0.0) begin
			sigvds = -1.0;
			vgs    =  vgs_noswap - vds_noswap;
			vds    =  -1.0 * vds_noswap;
			vgd    =  vgd_noswap + vds_noswap;
			ves    =  ved_jct;
		end else begin
			vgs    =  vgs_noswap;
			vds    =  vds_noswap;
			vgd    =  vgd_noswap;
			ves    =  ves_jct;
		end
		vgsfb  =  vgs - deltaPhi;
		
		//Initialize certain variables to zero to prevent unnecessary update
		etaiv  =  0.0;
		Qes    =  0.0;    Qesj   =  0.0;
		Qeg    =  0.0;
		Qed    =  0.0;    Qedj   =  0.0;
		
		// *** Vds smoothing ***
		vdsx   =  sqrt (vds * vds + 0.01) - 0.1;
		
		// *** Ves smoothing ***
		if(BULKMOD != 0) begin
			vesx    =  ves - 0.5 * (vds - vdsx);
			vesmax  =  0.95 * PHIBE_i;
			T2      =  vesmax - vesx - 1.0E-3;
			veseff  =  vesmax - 0.5 * (T2 + sqrt(T2 * T2 + 0.004 * vesmax));
		end

		// Asymmetry Model
		T0         =  tanh(0.6 * vds_noswap / Vtm);
		wf         =  0.5 + 0.5 * T0;
		wr         =  1.0 - wf;
		if(ASYMMOD != 0) begin
			CDSCD_a    =  CDSCDR_i * wr + CDSCD_i * wf;
			ETA0_a     =  ETA0R_t * wr + ETA0_t * wf;
		    PDIBL1_a   =  PDIBL1R_i * wr + PDIBL1_i * wf; 
		    MEXP_a     =  MEXPR_t * wr + MEXP_t * wf;
			PTWG_a     =  PTWGR_t * wr + PTWG_t * wf;
		    VSAT1_a    =  VSAT1R_t * wr + VSAT1_t * wf;	    
		    RSDR_a     =  RSDRR_t * wr + RSDR_t * wf;
		    RDDR_a     =  RDDRR_t * wr + RDDR_t * wf;
		end else begin
			CDSCD_a    =  CDSCD_i;
			ETA0_a     =  ETA0_t;
		    PDIBL1_a   =  PDIBL1_i; 
		    MEXP_a     =  MEXP_t;
			PTWG_a     =  PTWG_t;
		    VSAT1_a    =  VSAT1_t;	    
		    RSDR_a     =  RSDR_t;
		    RDDR_a     =  RDDR_t;
		end
		// Drain Saturation Voltage
		inv_MEXP   =  1.0 / MEXP_a;
		
		// *** SCE, DIBL, SS degradation effects *** Ref: BSIM4 Model
		phist       =  0.4 + phib + PHIN_i;
		if(GEOMOD !=3) T1 =  2*cox*csi/(2*csi + cox);
		else           T1 =  cox;
		cdsc        =  Theta_SW * (CDSC_i + CDSCD_a * vdsx);
		nVtm        =  Vtm * ThetaSS * (1.0 + (CIT_i / TRatio + cdsc) / T1);
				
		dvth_vtroll =  -DVT0_i * Theta_SCE * (vbi - phist);
		dvth_dibl   =  -ETA0_a * Theta_DIBL * vdsx + DVTP0 * pow(vdsx, DVTP1);
		dvth_rsce   =  K1RSCE_i * Theta_RSCE * sqrt(phist);
		dvth_all    =  dvth_vtroll + dvth_dibl + dvth_rsce + dvth_temp + DVTSHIFT_i;
		vgsfb       =  vgsfb - dvth_all;
		
		// *** Threshold voltage shift for doped multi-gate FET ***
		if(GEOMOD !=3) begin
			F1 =  0.5*lln(2*epssub*nVtm/(`q*Nc)) + F2;
			if(COREMOD != 0) vgsfb =  vgsfb - 0.5 * `q * nbody * TFIN / cox;
			else q0  =  (5.0 * nVtm * (epssub/TFIN) + 2.0 * Qbul) / cox;
			if(CAPMOD != 0 && BULKMOD != 0) F1_acc =  0.5*lln(2*epssub*Vtm/(`q*Nc)) + F2;
			cdop =  1.0;
		end else begin
			q0    =  2.0 * nVtm * r1;
			T0    =  `q * nbody * R / cox ;
			vtdop =  - nVtm * lln(nVtm / T0) - nVtm * lln(1 - lexp(-T0/(2.0*r1*nVtm)));
			cdop  =  2.0 * r1 * lexp(-vtdop / nVtm);
			vt0   =  0.5 * T0 + 2.0*phib*nVtm/Vtm - nVtm * lln(0.5*T0/nVtm) + vtdop;
			if(CAPMOD != 0 && BULKMOD != 0) begin
				q0_acc 	  =  2.0 * Vtm * r1_acc;
				T0 		  =  `q * ni * R / cox_acc ;
				vtdop_acc =  - Vtm * lln(Vtm / T0) - Vtm * lln(1 - lexp(-T0/(2.0*r1_acc*Vtm)));
				cdop_acc  =  2.0 * r1_acc * lexp(-vtdop_acc / Vtm);
				vt0_acc   =  0.5 * T0 - Vtm * lln(0.5*T0/Vtm) + vtdop_acc;
			end
		end
		
		// *** Vgs Clamping for inversion region calc. in accumulation ***
		if(GEOMOD != 3) begin
			T0       =  -(dvch_qm + nVtm * lln(2.0 * cox * Imin / (beta0 * nVtm * `q * Nc * TFIN)));
			T1       =  vgsfb + T0 + DELVTRAND;
			vgsfbeff =  hypsmooth(T1 , 1.0E-4) - T0;
		end else begin
			T0       =  -(dvch_qm + nVtm * lln(2.0 * cox * Imin / (beta0 * nVtm * `q * ni * R)));
			T1       =  vgsfb + DELVTRAND + T0 + 0.5 * Eg + phib*nVtm/Vtm;
			vgsfbeff =  hypsmooth(T1 , 1.0E-4) - T0 - vt0;
		end
		
		// *** Vgs Clamping for accumulation region calc. in inversion ***
		if(CAPMOD != 0 && BULKMOD != 0) begin
			T1 =  - vge + deltaPhi - 0.5*Eg + DELVFBACC;
			if(GEOMOD != 3) vgsfbeff_acc =  hypsmooth(T1 , 1.0E-4) - 0.5 * Eg;
			else            vgsfbeff_acc =  hypsmooth(T1 , 1.0E-4) - vt0_acc;
		end
		
		// *** Surface potential calculations shared by source & drain ***
		if(GEOMOD != 3) begin
			// T1x are temporary variables needs to be used for both
			//    source and drain surface potential calculations.
			T14  =  2.0*nVtm;
			if(COREMOD == 0) begin
				aab  =  phibulk/(nVtm*nVtm);
				T0   =  phibulk*aab;
				T11  =  r1 * phibulk / nVtm + r2 * T0;
				T12  =  lexp(phibulk/(2.0*nVtm));
				T13  =  T12*T12;
			end
		end
		
		//***********************************************************************************************
		// *** Surface Potential Calculation for Accumulation region operation, CAPMOD=1 && BULKMOD=1 ***
		if(CAPMOD != 0 && BULKMOD != 0) begin
			if(GEOMOD != 3) begin
				F0     =  (vgsfbeff_acc)/(2.0*Vtm) - F1_acc;
				expff  =  lexp(F0);
				
				// Initial guess for sub-threshold
				z1 =  atan(expff);
				
				// Initial guess for strong inversion
				if (F0 > `EXPL_THRESHOLD) T0 =  F0;
				else T0  =  lln(1.0 + expff);
				z2 =  atan(2*T0*Inv_r1pi_acc);
				
				// initial guess
				g0 =  min(z1, max(z2, 1e-15));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else           g0  =  g0min;
				end
				
				tang0    =  tan(g0);
				lng0     =  lln(g0);
				secg0sq  =  tang0*tang0 + 1.0;
				lncosg0  =  -0.5 * lln(secg0sq);
				inv_g0   =  1.0 / g0;
				
				T0 =  g0 * tang0;
				
				e0 =  lng0 - lncosg0 + r1_acc*T0 - F0;
				e1 =  inv_g0 + secg0sq*g0*r1_acc + tang0*(1.0 + r1_acc);
				e2 =  secg0sq*(1.0 + 2.0*(r1_acc + T0*r1_acc)) - inv_g0*inv_g0;
				e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*r1_acc
							+ 2.0*secg0sq*tang0*(1.0 + 3.0*r1_acc + 2.0*r1_acc*T0);
				
				// 1st stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				tang0    =  tan(g0);
				lng0     =  lln(g0);
				secg0sq  =  tang0*tang0 + 1.0;
				lncosg0  =  -0.5 * lln(secg0sq);
				inv_g0   =  1.0/g0;
				
				T0 =  g0 * tang0;
				
				e0 =  lng0 - lncosg0 + r1_acc*T0 - F0;
				e1 =  inv_g0 + secg0sq*g0*r1_acc + tang0*(1.0 + r1_acc);
				e2 =  secg0sq*(1.0 + 2.0*(r1_acc + T0*r1_acc)) - inv_g0*inv_g0;
				e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*r1_acc
							+ 2.0*secg0sq*tang0*(1.0 + 3.0*r1_acc + 2.0*r1_acc*T0);
				
				// 2nd stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				// Calculate accumulation charge
				g0a  =  g0;
				tang0a =  tan(g0a);
				qi_acc =  vgsfbeff_acc - 2.0 * Vtm * (lln(g0a) + 0.5 * lln(1.0 + tang0a * tang0a) + F1_acc);
			end else begin
				//GEOMOD=3 case
				F0 =  (vgsfbeff_acc)/(2.0*Vtm);
				
				if(F0 > `EXPL_THRESHOLD) T0  =  F0;
				else T0  =  lln(1 + lexp(F0));
				
				if(F0 < -10) g0  =  lexp(2*F0);
				else if(F0 > 10) g0  =  F0 / r1_acc;
				else g0  =  (sqrt(0.25 + r1_acc * r1_acc * T0 * T0) - 0.5) / (r1_acc * r1_acc);
				
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				if(F0 < -50) g0a =  g0;
				else begin
					
					inv_g0   =  1.0 / g0;
					inv_g0sq =  inv_g0 * inv_g0;
					T0 		 =  1 + cdop_acc*g0;
					T1 		 =  cdop_acc / T0 ;
					T2 		 =  T1 * T1;
					
					e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1_acc*g0 - F0;
					e1 =  0.5*inv_g0 + 0.5 * T1 + r1_acc;
					e2 =  -0.5*inv_g0sq - 0.5 * T2;
					e3 =  inv_g0*inv_g0sq + T2*T1;
					
					// 1st stage correction
					g0 =  g0 - (e0/e1)*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
					if (g0 > g0max || g0 < g0min) begin
						if(g0 > g0max) g0  =  g0max;
						else g0  =  g0min;
					end
					
					inv_g0   =  1.0 / g0;
					inv_g0sq =  inv_g0 * inv_g0;
					T0 		 =  1 + cdop_acc*g0;
					T1 		 =  cdop_acc / T0 ;
					T2 		 =  T1 * T1;
					
					e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1_acc*g0 - F0;
					e1 =  0.5*inv_g0 + 0.5 * T1 + r1_acc;
					e2 =  -0.5*inv_g0sq - 0.5 * T2;
					e3 =  inv_g0*inv_g0sq + T2*T1;
					
					// 2nd stage correction
					g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
					if (g0 > g0max || g0 < g0min) begin
						if(g0 > g0max) g0  =  g0max;
						else g0  =  g0min;
					end
					g0a = g0;
					
				end
				    // Calculate accumulation charge
				qi_acc = q0_acc * g0a;
			end
		end
		//*************************************************************************
		// *** Surface Potential at the source-end (Normal region of operation) ***
		// Householder's cubic iteration
		vch  =  0.0 + dvch_qm;
		if(GEOMOD != 3) begin
			if(COREMOD != 0) begin
				
				//*************************************************************************
				// ** Surface potential calculation for lightly-doped double gate MOSFET **
				F0     =  (vgsfbeff - vch)/(2.0*nVtm) - F1;
				expff  =  lexp(F0);
				
				// Initial guess for sub-threshold
				z1 =  atan(expff);
				
				// Initial guess for strong inversion
				if (F0 > `EXPL_THRESHOLD) T0 =  F0;
				else T0  =  lln(1.0 + expff);
				z2 =  atan(2*T0*Inv_r1pi);
				
				// initial guess
				g0 =  min(z1, max(z2, 1e-15));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				tang0    =  tan(g0);
				lng0     =  lln(g0);
				secg0sq  =  tang0*tang0 + 1.0;
				lncosg0  =  -0.5 * lln(secg0sq);
				inv_g0   =  1.0 / g0;
				
				T0 =  g0 * tang0;
				T1 =  T0 * T0;
				
				e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
				e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
				e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
				e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
							+ 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 +2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
				
				// 1st stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				tang0  	 =  tan(g0);
				lng0     =  lln(g0);
				secg0sq  =  tang0*tang0 + 1.0;
				lncosg0  =  -0.5 * lln(secg0sq);
				inv_g0   =  1.0/g0;
				
				T0 =  g0 * tang0;
				T1 =  T0 * T0;
				
				e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
				e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
				e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
				e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
							+ 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
				
				// 2nd stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				// Calculate surface potential
				g0s    =  g0;
				tang0s =  tan(g0s);
				phis   =  vch + 2.0 * nVtm * (lln(g0s) + 0.5 * lln(1.0 + tang0s * tang0s) + F1);
				
			end else begin
				
				//*************************************************************************
				// ** Surface potential calculation for heavily-doped double gate MOSFET **
				//Juan and Navid's Initial Guess 3/2013--------------------------------------
				F0  = (vgsfbeff - phibulk - vch)/T14 - F1;
				T0  =  phibulk*aab;				
				T1  =  phibulk/T14;
				z1  =  (2.0*r1-1.0) * T1 + r2 * T0; 			
				guessA = 2.0 * r1 * T1;
				guessA = guessA/(1.0-exp(-guessA));	
				                                    
        		z2  = z1 + ln((sqrt(guessA)/r1));
				if((F0-z2)>-0.3/T14) begin
					if ((F0-z2)< 20)
							T2 = (0.5/guessA)* ln(1.0 + exp(2.0*(F0-z2))) + 1.0;
					else
							T2 = (0.5/guessA)*(2.0*(F0-z2)) + 1.0;

					T3 = pow(T2, 2.0);
					guessB = (guessA/r1) * sqrt(T3-1.0) * exp(-T1);
				end else
					guessB =  exp(F0-z1-T1);
				
				g0=guessB;
				if (g0>1e-60) begin	
					g0 = 1.0/((1.0/g0)+(1.0/(0.5*`M_PI)));
					
				//----------------------------------------------------									
					tang0    =  tan(g0);
					cosg0    =  cos(g0);  // TODO: calculate cos() from tan()
					secg0    =  1.0/cosg0;
					secg0sq  =  secg0*secg0;			
					lng0     =  -ln(1.0/g0);
				
					T0 =  1.0 + g0*tang0;
					T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
					T2 =  sqrt(T1);
					T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
					T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
					T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);
					T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
					T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
					T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
					TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
			
					// 1st stage correction 
					g0 =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
		
					tang0    =  tan(g0);
					cosg0    =  cos(g0);
					secg0    =  1.0/cosg0;
					secg0sq  =  secg0*secg0;
					lng0     = -ln(1.0/g0);
				
					T0 =  1.0 + g0*tang0;
					T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
					T2 =  sqrt(T1);
					T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
					T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
					T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);				
					T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
					T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
					T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
					TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
				
					// 2nd stage correction 
					g0    =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
					lng0  = -ln(1.0/g0);
					
				end else begin
					if (g0>=1e-300)
						lng0 = -ln(1.0/g0);
					else begin
						if((F0-z2)>-0.3/T14) 
							lng0 = -ln(1.0/((guessA/r1) * sqrt(T3-1.0)))-T1;
				 		else
							lng0 = F0-z1-T1;
					end	
				end

				phis =  vch + T14*(lng0-lln(cos(g0))+F1) + phibulk;
				
			end // Surface Potential Model Switch
		end else begin  //GEOMOD 3 switchd
			
			//***********************************************************
			// ** Surface potential calculation for cylindrical MOSFET **
			F0 =  (vgsfbeff - vch)/(2.0*nVtm);
			
			if(F0 < -10) g0  =  lexp(2.0*F0);
			else if(F0 > 10) g0  =  F0 / r1;
			else begin
				T0 =  lln(1 + lexp(F0));
				g0 =  (sqrt(0.25 + r1 * r1 * T0 * T0) - 0.5) / (r1 * r1);
			end
			
			if (g0 > g0max || g0 < g0min) begin
				if(g0 > g0max) g0  =  g0max;
				else g0  =  g0min;
			end
			
			if(F0 < -50) g0s =  g0;
			else begin
				
				inv_g0   =  1.0 / g0;
				inv_g0sq =  inv_g0 * inv_g0;
				T0 		 =  1 + cdop*g0;
				T1 		 =  cdop / T0 ;
				T2 		 =  T1 * T1;
				
				e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
				e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
				e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2*r2;
				e3 =  inv_g0*inv_g0sq + T2*T1;
				
				// 1st stage correction
				g0 =  g0 - (e0/e1)*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				inv_g0   =  1.0 / g0;
				inv_g0sq =  inv_g0 * inv_g0;
				T0 		 =  1 + cdop*g0;
				T1 		 =  cdop / T0 ;
				T2 		 =  T1 * T1;
				
				e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
				e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
				e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2.0 * r2;
				e3 =  inv_g0*inv_g0sq + T2*T1;
				
				// 2nd stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				g0s  =  g0;
				
			end
			
			// Calculate surface potential
			vpolys   =  2.0 * nVtm * r2 * g0s * g0s;
			phis   =  vgsfbeff - 2.0 * nVtm * r1 * g0s - vpolys;
			qis      =  q0 * g0s;
		end     //End of GEOMOD SPE source-end
		//******************************************************
		
		// *** Drain Saturation Voltage ***
		if(GEOMOD != 3) begin
			if(NGATE_i > 0) begin
				T0     =  sqrt(1.0 + (vgsfbeff-phis)/vpoly0) - 1.0;
				vpolys =  vpoly0 * T0 * T0;
			end else vpolys  =  0;
                        qis  =  (COREMOD != 0) ? (vgsfbeff - phis - vpolys) : (vgsfbeff - phis - qbs - vpolys);
		end
		
		Eeffs  =  EeffFactor * (qbs + eta_mu * qis);  // in the unit of MV/cm
		qb0    =  1.0e-2 / cox;
		T2     =  pow(0.5 * (1.0 + abs((qis) / qb0)), UCS_t); 	//Changed in BSIM-CMG106.1.0
		if(BULKMOD != 0) begin
			T3     =  (UA_t + UC_t * veseff) * pow(abs(Eeffs), EU_i) + UD_t / T2;
		end else begin
			T3     =  UA_t * pow(abs(Eeffs), EU_i) + UD_t / T2;
		end
		Dmobs  =  1.0 + T3; 
		Dmobs  =  Dmobs / U0MULT; 

		if(RDSMOD != 0)  Rdss  =  0.0; 
		else begin
			T4       =  1.0 + PRWGS_i * qis; 
			T1       =  1.0 / T4; 
			T0       =  0.5 * (T1 + sqrt(T1 * T1 + 0.01)); 
            Rdss     =  (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NFINtotal * rdstemp;
		end
		
		Esat  =  2 * VSAT_t / u0 * Dmobs; 
		EsatL =  Esat * Leff; 
		T6    =  KSATIV_i * (vgsfbeff - phis + 2*Vtm); 
		
		if (Rdss == 0) begin 
			Vdsat  =  EsatL * T6 / (EsatL + T6); 
		end else begin 
			WVCox  =  Weff0 * VSAT_t * cox; 
			T0 	   =  WVCox * Rdss; 
			Ta 	   =  2 * T0; 
			Tb 	   =  T6 + EsatL + 3*T6*T0; 
			Tc 	   =  T6 * (EsatL + 2*T6*T0); 
			Vdsat  =  (Tb - sqrt(Tb*Tb - 2*Ta*Tc)) / Ta; 
		end 
		Vdsat  =  hypsmooth(Vdsat-1.0E-3 , 1.0E-5) + 1.0E-3; 
		T7     =  pow(vds/Vdsat , MEXP_a); 
		T8     =  pow(1.0+T7, inv_MEXP); 
		Vdseff =  vds / T8; 
		if (Vdseff > vds) Vdseff =  vds;	
		//********************************************
		// *** Surface Potential at the drain-end  ***
		vch  =  Vdseff + dvch_qm;
		
		if(GEOMOD != 3) begin
			if(COREMOD != 0) begin
				
				//*************************************************************************
				// ** Surface potential calculation for lightly-doped double gate MOSFET **
				F0 	   =  (vgsfbeff - vch)/(2.0*nVtm) - F1;
				expff  =  lexp(F0);
				
				// Initial guess for sub-threshold
				z1 =  atan(expff);
				
				// Initial guess for strong inversion
				if (F0 > `EXPL_THRESHOLD) T0 =  F0;
				else T0  =  lln(1.0 + expff);
				z2 =  atan(2*T0*Inv_r1pi);
				
				// initial guess
				g0 =  min(z1, max(z2, 1e-15));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				tang0    =  tan(g0);
				lng0     =  lln(g0);
				secg0sq  =  tang0*tang0 + 1.0;
				lncosg0  =  -0.5 * lln(secg0sq);
				inv_g0   =  1.0 / g0;
				
				T0 =  g0 * tang0;
				T1 =  T0 * T0;
				
				e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
				e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
				e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
				e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
						+ 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 +2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
				
				// 1st stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				tang0    =  tan(g0);
				lng0     =  lln(g0);
				secg0sq  =  tang0*tang0 + 1.0;
				lncosg0  =  -0.5 * lln(secg0sq);
				inv_g0   =  1.0/g0;
				
				T0 =  g0 * tang0;
				T1 =  T0 * T0;
				
				e0 =  lng0 - lncosg0 + r1*T0 + r2*T1 - F0;
				e1 =  inv_g0 + secg0sq*g0*(r1 + 2.0*r2*T0) + tang0*(1.0 + (r1 + 2.0*r2*T0));
				e2 =  secg0sq*(1.0 + 2.0*(r1 + r2*g0*g0*secg0sq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + inv_g0*inv_g0*(2.0*T1*r2 - 1.0);
				e3 =  2.0*inv_g0*inv_g0*inv_g0 + 2.0*g0*secg0sq*secg0sq*(r1 + 2.0*r2*(3.0 + 4.0*T0))
				+ 2.0*secg0sq*tang0*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
				
				// 2nd stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				// Calculate surface potential
				g0d    =  g0;
				tang0d =  tan(g0d);
				phid   =  vch + 2.0 * nVtm * (lln(g0d) + 0.5 * lln(1.0 + tang0d * tang0d) + F1);
			end else begin
				
				//*************************************************************************
				// ** Surface potential calculation for heavily-doped double gate MOSFET **
				//Juan and Navid's Initial Guess 3/2013--------------------------------------
				F0  = (vgsfbeff - phibulk - vch)/T14 - F1;
				T0  =  phibulk*aab;				
				T1  =  phibulk/T14;
				z1  =  (2.0*r1-1.0) * T1 + r2 * T0; 			
				guessA = 2.0 * r1 * T1;
				guessA = guessA/(1.0-exp(-guessA));	
				                                    
        		z2  = z1 + ln((sqrt(guessA)/r1));
				if((F0-z2)>-0.3/T14) begin
					if ((F0-z2)< 20)
							T2 = (0.5/guessA)* ln(1.0 + exp(2.0*(F0-z2))) + 1.0;
					else
							T2 = (0.5/guessA)*(2.0*(F0-z2)) + 1.0;
					T3 = pow(T2, 2.0);
					guessB = (guessA/r1) * sqrt(T3-1.0) * exp(-T1);
				end else
					guessB = exp(F0-z1-T1);
				g0=guessB;
				
				if (g0>1e-60) begin
					g0 = 1.0/((1.0/g0)+(1.0/(0.5*`M_PI)));
				
				//----------------------------------------------------------------			
					tang0    =  tan(g0);
					cosg0    =  cos(g0);
					secg0    =  1.0/cosg0;
					secg0sq  =  secg0*secg0;
					lng0     =  -ln(1.0/g0);
					
					T0 =  1.0 + g0*tang0;
					T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
					T2 =  sqrt(T1);
					T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
					T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
					T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);
					T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
					T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
					T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
					TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
				
					// 1st stage correction 
					g0 =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
				
					tang0  =  tan(g0);
					cosg0  =  cos(g0);
					secg0    =  1.0/cosg0;
					secg0sq  =  secg0*secg0;
					lng0     = -ln(1.0/g0);
				
					T0 =  1.0 + g0*tang0;
					T1 =  g0*g0*(T13*secg0sq-1.0) + aab*(phibulk - T14*lln(cosg0));
					T2 =  sqrt(T1);
					T3 =  -2.0*g0 + aab*T14*tang0 + 2.0*T13*g0*secg0sq*T0;
					T4 =  -2.0 + 2.0*T13*g0*g0*secg0sq*secg0sq + secg0sq*(2*T13 + aab*T14 + 8.0*T13*g0*tang0 + 4.0*T13*g0*g0*tang0*tang0);
					T5 =  2.0*tang0*T4 + 4.0*(3.0*T13*g0*secg0sq*secg0sq*T0 + tang0 + 2.0*T13*secg0sq*T0*tang0);
				
					T7 =  lng0 - lln(cosg0) + r2*T1 + r1*T2 - F0;
					T8 =  1.0/g0 + tang0 + r2*T3 + r1*T3/(2.0*T2);
					T9 =  -1.0/(g0*g0) + secg0sq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
					TA =  2.0/(g0*g0*g0) + 2.0*secg0sq*tang0 + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4) + r1*T5/(2.0*T2) + r2*T5;
				
					// 2nd stage correction 
					g0 =  g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));
					lng0  = -ln(1.0/g0);					

				end else begin
					if (g0>=1e-300)
						lng0 = -ln(1.0/g0);
					else begin
						if((F0-z2)>-0.3/T14) 
							lng0 = -ln(1.0/((guessA/r1) * sqrt(T3-1.0)))-T1;
				 		else
							lng0 = F0-z1-T1;
					end	
				end

				phid =  vch + T14 * (lng0-lln(cos(g0)) + F1) + phibulk;
				
			end // Surface Potential Model Switch
		end else begin  //GEOMOD 3 switch
			
			//***********************************************************
			// ** Surface potential calculation for cylindrical MOSFET **
			F0 =  (vgsfbeff - vch)/(2.0*nVtm);
			
			if(F0 < -10) g0  =  lexp(2.0*F0);
			else if(F0 > 10) g0  =  F0 / r1;
			else begin
				T0 =  lln(1.0 + lexp(F0));
				g0 =  (sqrt(0.25 + r1 * r1 * T0 * T0)- 0.5) / (r1 * r1);
			end
			
			if (g0 > g0max || g0 < g0min) begin
				if(g0 > g0max) g0  =  g0max;
				else g0  =  g0min;
			end
			
			if(F0 < -50) g0d =  g0;
			else begin
				
				inv_g0   =  1.0 / g0;
				inv_g0sq =  inv_g0 * inv_g0;
				T0 		 =  1 + cdop*g0;
				T1 		 =  cdop / T0 ;
				T2 		 =  T1 * T1;
				
				e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
				e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
				e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2*r2;
				e3 =  inv_g0*inv_g0sq + T2*T1;
				
				// 1st stage correction
				g0 =  g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				
				inv_g0 =  1.0 / g0;
				inv_g0sq =  inv_g0 * inv_g0;
				T0 =  1 + cdop*g0;
				T1 =  cdop / T0 ;
				T2 =  T1 * T1;
				
				e0 =  0.5*lln(g0) + 0.5*lln(T0) + r1*g0+ r2*g0*g0 - F0;
				e1 =  0.5*inv_g0 + 0.5 * T1 + r1 + 2*r2*g0;
				e2 =  -0.5*inv_g0sq - 0.5 * T2 + 2*r2;
				e3 =  inv_g0*inv_g0sq + T2*T1;
				
				// 2nd stage correction
				g0 =  g0 - (e0/e1)*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
				if (g0 > g0max || g0 < g0min) begin
					if(g0 > g0max) g0  =  g0max;
					else g0  =  g0min;
				end
				g0d  =  g0;
			end
			
			// Calculate surface potential
			vpolyd   =  2 * nVtm * r2 * g0d * g0d;
			phid   =  vgsfbeff - 2 * nVtm * r1 * g0d - vpolyd;
			qid      =  q0 * g0d;
		end     //End of all GEOMOD SPE drain-end
		//****************************************************
		
		// *** Drain Side and Average Potential/ Charge ***
		qba  =  qbs;
		if(GEOMOD != 3) begin
			if(NGATE_i > 0) begin
				T0 =  sqrt(1 + (vgsfbeff-phid)/vpoly0) - 1;
				vpolyd =  vpoly0 * T0 * T0;
			end else vpolyd  =  0;
                         qid  =  (COREMOD != 0) ? (vgsfbeff - phid - vpolyd) : (vgsfbeff - phid - qbs - vpolyd);
		end
		qia  =  0.5 * (qis + qid);
		dqi  =  qis - qid;

		T0 = pow(Vdseff,2.0) / 6.25e-4;   //pow(Vdseff,2.0) / pow(25e-3, 2.0)
		if(CHARGEWF != 0)  		
			qia2 = 0.5 * (qis + qid) + CHARGEWF * (1.0-lexp(-T0))* 0.5 * dqi;	
		else
			qia2 = 0.5 * (qis + qid);

		`ifdef __DEBUG__
			if(qis < 0) $strobe("Warning: negative source-side inversion carrier density.  Vgs=%f  Vds=%f  Vbs=%f qis=%e", V(g, s), V(d, s), V(e, s), qis);
			if(qid < 0) $strobe("Warning: negative drain-side inversion carrier density.  Vgs=%f  Vds=%f  Vbs=%f qid=%e", V(g, s), V(d, s), V(e, s), qid);
		`endif
		
		// *** Toxeff model for quantum mechanical effects ***
		// ** Normal operation (Vgs > Vfb) **
		if(QMTCENIV_i > 0.0 || QMTCENCV_i > 0.0) begin
			T4     =  (qia + ETAQM * qba) / QM0;
			T5     =  1.0 + pow(T4 , PQM);
			Tcen   =  Tcen0 / T5;
			case(GEOMOD)
			0: begin
				Weff   =  Weff0;
				WeffCV =  WeffCV0;
			end
			1: begin
				Weff   =  Weff0 - 4.0 * QMTCENIV_i * Tcen;
				WeffCV =  WeffCV0 - 4.0 * QMTCENCV_i * Tcen;
			end
			2: begin
				Weff   =  Weff0 - 8.0 * QMTCENIV_i * Tcen;
				WeffCV =  WeffCV0 - 8.0 * QMTCENCV_i * Tcen;
			end
			3: begin
				Weff   =  Weff0 - 2.0 * `M_PI * QMTCENIV_i * Tcen;
				WeffCV =  WeffCV0 - 2.0 * `M_PI * QMTCENCV_i * Tcen;
			end
			endcase
			//TOXP will be used with 'Tcen' added for coxeff
			if(GEOMOD !=3) coxeff  =  3.9 * `EPS0 / (TOXP * 3.9 / EPSROX + Tcen * QMTCENCV_i / epsratio);
			else coxeff  =  3.9 * `EPS0 / (R *(lln(R / (R - Tcen * QMTCENCV_i)) / epsratio + lln(1 + TOXP/R) * 3.9 / EPSROX));
		end else begin
			Weff   =  Weff0;
			WeffCV =  WeffCV0;
			coxeff =  cox;  //EOT will continue to be used for coxeff
		end
					
		//** Quantum Mechanical effect Correction for  Accumulation Side Cap (Vgs < Vfb) **		
		if(CAPMOD != 0 && BULKMOD != 0 && QMTCENCVA_i != 0) begin
			T6    =  1.0 + pow(qi_acc / QM0ACC, PQMACC);
			Tcen  =  Tcen0 / T6;
			//TOXP will be used with 'Tcen' added for cox_acc
			if(GEOMOD !=3) cox_acc =  3.9 * `EPS0 / (TOXP * 3.9 / EPSROX + Tcen * QMTCENCVA_i / epsratio);
			else cox_acc =  3.9 * `EPS0 / (R *(lln(R / (R - Tcen * QMTCENCVA_i)) / epsratio + lln(1 + TOXP/R) * 3.9 / EPSROX));
		end //cox_acc already defined above with EOTACC

		//*** Multiplication factor for I-V ***
		beta =  u0 * cox * Weff / Leff;
		
		// *** Mobility Degradation ***
		Eeffm =  EeffFactor * (qba + eta_mu * qia2);    // in the unit of MV/cm
		T2    =  pow(0.5 * (1.0 + abs((qia2) / qb0)), UCS_t);  //Changed in BSIM-CMG106.1.0
		if(BULKMOD != 0) begin
			T3    =  (UA_t + UC_t * veseff) * pow(abs(Eeffm), EU_i) + UD_t / T2; 
		end else begin
			T3    =  UA_t * pow(abs(Eeffm), EU_i) + UD_t / T2; 
		end	
		Dmob  =  1.0 + T3; 
		Dmob  =  Dmob / U0MULT; 
		ueff  =  u0 / Dmob; 

		// *** Mobility Degradation for C-V ***
		Eeffm_cv =  EeffFactor * (qba + eta_mu_cv * qia2);    // in the unit of MV/cm
		T3       =  UA_t * pow(abs(Eeffm_cv), EU_i) + UD_t / T2; 
		Dmob_cv  =  1.0 + T3; 
		Dmob_cv  =  Dmob_cv / U0MULT; 

		// *** Calculate current and capacitance enhancement factors due to CLM and DIBL ***
		tmp = DROUT_i * Leff / scl + 1.0e-6;
		if (tmp < 40.0)
			DIBLfactor   =  0.5 * PDIBL1_a / (cosh(tmp) - 1.0) + PDIBL2_i;
		else
			DIBLfactor   =  PDIBL1_a * exp(-tmp) + PDIBL2_i;

		if(PVAG_i > 0) PVAGfactor  =  1.0 + PVAG_i * qia / EsatL; 
		else PVAGfactor  =  1.0 / (1.0 - PVAG_i * qia / EsatL); 
		
		if (Vdseff > vds) Vdseff =  vds; 
		diffVds  =  vds - Vdseff; 
		Vgst2Vtm =  qia + 2.0 * Vtm; 
		if (DIBLfactor > 0) begin 
			T1     =  Vgst2Vtm; 
			T3     =  T1 / (Vdsat + T1); 
			VaDIBL =  T1 / DIBLfactor * T3 * PVAGfactor; 
			Moc    =  1.0 + diffVds / VaDIBL; 
		end else begin 
			Moc    =  1.0; 
		end 
		
		if(PCLM_i > 0) begin 
			if(PCLMG_i < 0.0) 
				T1 =  1.0 / (1.0 / PCLM_i - PCLMG_i * qia); 
			else 
				T1 =  PCLM_i + PCLMG_i * qia; 
			Mclm   =  1.0 + T1 * lln(1.0 + (vds - Vdseff) / T1 / (Vdsat + EsatL)); 
		end else 
			Mclm   =  1.0; 
		
		Moc  =  Moc * Mclm; 
		
		// *** Current degradation factor due to velocity saturation ***
		Esat1  =  2.0 * VSAT1_a / ueff; 
		Esat1L =  Esat1 * Leff; 
		T0 	   =  lexp(PSAT_i * lln(dqi / Esat1L));
		Ta     =  (1.0 + lexp(1.0/PSAT_i * lln(DELTAVSAT_i))); 
		Dvsat  =  (1.0 + lexp(1.0/PSAT_i * lln(DELTAVSAT_i + T0))) / Ta; 
		Dvsat  =  Dvsat + 0.5 * PTWG_a * qia * dqi * dqi;

		// ** Non-saturation effect **
		T0     =  A1_t + A2_t / (qia + 2.0 * nVtm);
		T1     =  T0 * dqi * dqi;
		T2     =  T1 + 1.0 - 0.001;
		T3     =  -1.0 + 0.5 * (T2 + sqrt(T2*T2 + 0.004));   //max(T1,-1.0)
		Nsat   =  0.5 * (1.0 + sqrt(1.0 + T3));
		Dvsat  =  Dvsat * Nsat;		
		
		
		// *** Lateral Non-uniform doping effect (IV-CV Vth shift) factor ***
		if(K0_t != 0) begin
			T1      =  K0_t / (K0SI_t * qia + 2.0 * nVtm);
			Mnud    =  lexp(-T1);
		end else
			Mnud    =  1.0;

		// *** Body- effect factor for BULKMOD = 1 ***
		if(BULKMOD != 0) begin
			T0      =  hypsmooth((K1_t + K1SAT_t * vdsx),1.0E-6);
			T1      =  T0 / (K1SI_t * qia + 2.0 * nVtm);
			T3      =  sqrt(PHIBE_i - veseff) - sqrt(PHIBE_i);
 			Mob     =  lexp(- T1 * T3);
		end else
			Mob = 1.0;

		// *** Velocity Saturation factor for C-V ***
		EsatCV  =  2.0 * VSATCV_t * Dmob_cv / u0; 
		EsatCVL =  EsatCV * LeffCV; 
		T0 	    =  lexp(PSATCV_i * lln(dqi / EsatCVL)); 
		Ta      =  (1.0 + lexp(1.0/PSATCV_i * lln(DELTAVSATCV_i))); 
		DvsatCV =  (1.0 + lexp(1.0/PSATCV_i * lln(DELTAVSATCV_i + T0))) / Ta; 

		// *** Channel Length Modulation factor for C-V ***
		if(PCLMCV_i != 0)
			MclmCV =  1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL)); 
		else 
			MclmCV =  1.0;

		//Calculating fixed body charge qb with sign (Here to avoid multiple calculation in NQSMOD=3 case)
		if(GEOMOD != 3) qb =  -`q * nbody * HFIN * TFIN * LeffCV;
		else qb  =  -`q * nbody * `M_PI * R * R * LeffCV;
		
		//******************************************
		// ***   Drain Current & Charge Model    ***
		
		if(GEOMOD !=3 && COREMOD != 0) begin
			
			//*************************************************
			// **   I-V model for lightly-doped MuGFETs     **
			T0   =  2.0 * csi / cox;
			T1   =  g0s * tang0s;
			T2   =  g0d * tang0d;
			if(NGATE_i > 0.0)
				T3 =  4.0 * r2 * (T1 * T1 + T1 * T2 + T2 * T2) / 3.0 + T0 * (T1 + T2);
			else
				T3 =  T0 * (T1 + T2);
			T6 			 =  g0s * g0s - g0d * g0d;
			ids0 		 =  2.0 * T0 * nVtm * nVtm * ((T3 + 2.0) * (T1 - T2) - T6);
			ids0_ov_dqi  =  0.5 * nVtm * (T3 + 1.0);
			
			// S/D series resistance
			`include "bsimcmg_rdsmod.include"
				
			ids  =  NFINtotal * beta * ids0 * Moc * Mob * Mnud / (Dmob * Dvsat * Dr);
			ids  =  ids * IDS0MULT;
			
			// Quasi Static C-V Model
			if(NGATE_i >0.0) Tcom  =  qis*qis + qis * qid + qid*qid;
			else Tcom  =  0.0;
			`include "bsimcmg_quasi_static_cv.include"
			
		end else begin
			//*************************************************************************
			// ** I-V model for GEOMOD=3 || Heavily-doped MuGFETs (NQSMOD=3 allowed) **	
			`ifdef __NQSMOD3__
			
				// Common Factor in I-V and C-V for Poly Gate case
				if(NGATE_i >0.0) Tcom  =  qis*qis + qis * qid + qid*qid;
				else Tcom  =  0.0;
				// Quasi Static I-V Model	
				if(NGATE_i > 0) begin
					T0 =  2.0 * cpoly * Tcom / 3;
					T1 =  kpoly * qia;
				end else begin
					T0 =  0;
					T1 =  qia;
				end
				etaiv  =  q0 / (q0 + cdop *qia);
				T2 =  (2.0 - etaiv) * nVtm;
				ids0_ov_dqi  =  T0 + T1 + T2;
				
				// S/D series resistance
				`include "bsimcmg_rdsmod.include"				

				
				if(NQSMOD == 3) begin
					$strobe("[bsimcmg] You sure you wanted the NQS Charge Segmentation model! Proceed with absolute caution!");
					`include "bsimcmg_nqsmod3_iv_cv.include"
				end else begin

					$strobe("[bsimcmg] Although NQS charge segmentation model is activated, the model selector NQSMOD is not set to 3. Quasi-static calculations being performed instead.");
					ids0 =  ids0_ov_dqi * dqi;
					ids  =  NFINtotal * beta * ids0 * Moc * Mob * Mnud / (Dmob * Dvsat * Dr);
					ids  =  ids * IDS0MULT;
					
					// Quasi Static C-V Model
					`include "bsimcmg_quasi_static_cv.include"

				end //End of NQSMOD=3 check in `ifdef __NQSMOD3__
				
			`else
				
				if(NQSMOD == 3) begin
					$strobe("[bsimcmg] Although the model selector NQSMOD is set to 3, the NQS charge segmentation model is not activated in the Verilog-A code.  Please uncomment `define __NQSMOD3__ in bsimcmg.va to activate it. Quasi-static calculations being performed instead");
				end //End of NQSMOD=3 check in `else
				
				// Common Factor in I-V and C-V for Poly Gate case
				if(NGATE_i >0.0) Tcom  =  qis*qis + qis * qid + qid*qid;
				else Tcom  =  0.0;
				// Quasi Static I-V Model	
				if(NGATE_i > 0) begin
					T0 =  2.0 * cpoly * Tcom / 3;
					T1 =  kpoly * qia;
				end else begin
					T0 =  0;
					T1 =  qia;
				end
				etaiv  =  q0 / (q0 + cdop *qia);                   
				T2 =  (2.0 - etaiv) * nVtm;
				ids0_ov_dqi  =  T0 + T1 + T2;
				ids0 =  ids0_ov_dqi * dqi;
				
				// S/D series resistance
				`include "bsimcmg_rdsmod.include"
				
				ids  =  NFINtotal * beta * ids0 * Moc * Mob * Mnud / (Dmob * Dvsat * Dr);
				ids  =  ids * IDS0MULT;
				
				// Quasi Static C-V Model
				`include "bsimcmg_quasi_static_cv.include"
				
			`endif  //End of `ifdef __NQSMOD3__
			
		end //End of all I-V & C-V Models
		//*******************************************************
				
		// *** Accumulation Capacitance ***
		if(CAPMOD != 0 && BULKMOD != 0) begin
			T1     =  NFINtotal * WeffCV0 * LeffCV_acc * cox_acc;
			qg_acc =  - qi_acc * T1;
			qb_acc =  + qi_acc * T1;
		end
		
		// *** Parasitic Capacitances ***
	    // ** Bias-dependent overlap capacitances (CGEOMOD=0 and 2) **
		qgs_ov =  0.0;
		qgd_ov =  0.0;
		if(CGEOMOD != 1) begin
			T1           =  NFINtotal * WeffCV * devsign;
			T2           =  devsign * V(`GateEdgeNode, si);
			T0           =  T2 - vfbsd + `DELTA_1;
			vgs_overlap  =  0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
			qgs_ov       =  T1 * (CGSL_i * (T2 - vfbsd - vgs_overlap
			                - 0.5 * CKAPPAS_i * (sqrt(1.0 - 4.0 * vgs_overlap / CKAPPAS_i)
			                - 1.0)) + CGSO_i * T2);
			
			T2           =  devsign * V(`GateEdgeNode, di);
			T0           =  T2 - vfbsd + `DELTA_1;
			vgd_overlap  =  0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
			qgd_ov       =  T1 * (CGDL_i * (T2 - vfbsd - vgd_overlap
			                - 0.5 * CKAPPAD_i * (sqrt(1.0 - 4.0 * vgd_overlap / CKAPPAD_i)
			                - 1.0)) + CGDO_i * T2);
		end
		
		if(CGEOMOD == 0) begin
			T1 			   =  NFINtotal * WeffCV0;			// Fringe caps dont see QM effects
			qgs_fr 		   =  T1 * CFS_i * V(`GateEdgeNode, si);
			qgd_fr 		   =  T1 * CFD_i * V(`GateEdgeNode, di);
			qgs_parasitic  =  qgs_ov + qgs_fr;
			qgd_parasitic  =  qgd_ov + qgd_fr;
		end else if(CGEOMOD == 1) begin // CGEO1SW=1 enables parameters to be in F per fin, per gate-finger, per unit channel width 
			if (CGEO1SW == 1) begin
				T0     = NFINtotal * WeffCV0;				
				COVS_i = T0 * COVS_i;
				COVD_i = T0 * COVD_i;
				cgsp   = T0 * CGSP;
				cgdp   = T0 * CGDP;
			end else begin
				cgsp   = CGSP;
				cgdp   = CGDP;
  			end	
			qgs_ov         =  COVS_i * V(`GateEdgeNode, si);
			qgd_ov         =  COVD_i * V(`GateEdgeNode, di);
			qgs_parasitic  =  qgs_ov;
			qgd_parasitic  =  qgd_ov;
			qgs_fr         =  cgsp * V(`GateEdgeNode, s);
			qgd_fr         =  cgdp * V(`GateEdgeNode, d);
		end else begin
			qgs_fr         =  Cfr_geo * V(`GateEdgeNode, si);
			qgd_fr         =  Cfr_geo * V(`GateEdgeNode, di);
			qgs_parasitic  =  qgs_ov + qgs_fr;
			qgd_parasitic  =  qgd_ov + qgd_fr;
		end
		// ** Drain to Source Fringe Cap available for all CGEOMOD **
		qds_fr =  CDSP * V(d, s);
		
		// *** Impact Ionization Current ***
		// Ref: IIMOD=1 - BSIM4 Model, IIMOD=2 - BSIMSOI Model
		Iii = 0;
		if (IIMOD==1) begin
			T0 =  (ALPHA0_t + ALPHA1_t * Leff) / Leff;
			if ((T0 <= 0.0) || (BETA0_t <= 0.0))
				Iii  =  0.0;
			else begin
				T1   =  - BETA0_t / (diffVds + 1.0e-30);
				`ifdef __NQSMOD3__
					if(GEOMOD !=3 && COREMOD !=0) begin
						Iii  =  T0 * diffVds * ids * lexp(T1);
					end else begin 
						if(NQSMOD==3)
							Iii  =  T0 * diffVds * idsN * lexp(T1);
						else
							Iii  =  T0 * diffVds * ids * lexp(T1);
					end
				`else
					Iii  =  T0 * diffVds * ids * lexp(T1);
				`endif
			end
		end else if (IIMOD==2) begin    //End of IIMOD=1
			ALPHAII	=  (ALPHAII0_t + ALPHAII1_t * Leff) / Leff;
			if (ALPHAII <= 0.0) begin
				Iii  =  0.0;
			end else begin
				T0       =  ESATII_i * Leff;
				T1       =  SII0_t * T0 / (1.0 + T0);
				T0       =  1.0 / (1.0 + hypsmooth(SII1_i * vgsfbeff, 1.0e-3)); // T0 = 1 / (1 + SII1_i * vgsfbeff)
				T3       =  T0 + SII2_i;
				T2       =  hypsmooth(vgsfbeff * T3, 1.0e-3);  //T2 = vgsfbeff * T3
				T3       =  1.0 / (1.0 + SIID_i * vds);
				VgsStep  =  T1 * T2 * T3;
				Vdsatii  =  VgsStep * (1.0 - LII_i / Leff);
				Vdiff    =  vds - Vdsatii;
				T0       =  BETAII2_i + BETAII1_i * Vdiff + BETAII0_i * Vdiff * Vdiff;
				T1       =  sqrt(T0*T0 + 1.0E-10);
				T2       =  10.0 - ALPHAII* lexp(Vdiff / T1) - 0.01; 				/* Avoid too high ratio */
				Ratio    =  10.0 - 0.5 * (T2 + sqrt(T2*T2 + 4.0*10.0*0.01)); //min(10,ALPHAII* lexp(Vdiff / T1))
				`ifdef __NQSMOD3__
					if(GEOMOD !=3 && COREMOD !=0) begin
						Iii    =  Ratio * ids;
					end else begin
						if(NQSMOD==3)
							Iii    =  Ratio * idsN;
						else
							Iii    =  Ratio * ids;
					end
				`else
					Iii  =  Ratio * ids;
				`endif
			end
		end  //End of IIMOD=2		
		
		// *** Gate Current ***
		// Ref: BSIM4 Model
		igbinv   =  0.0;
		igbacc   =  0.0;
		igcs 	 =  0.0;
		igcd 	 =  0.0;
		igs  	 =  0.0;
		igd  	 =  0.0;
		
		// ** Igb **
		if (IGBMOD != 0) begin
			//Igbinv
			T1 			 =  (qia - EIGBINV_i) / NIGBINV_i / Vtm;
			Vaux_Igbinv  =  NIGBINV_i * Vtm * lln(1 + lexp(T1));
			T2 			 =  AIGBINV_t - BIGBINV_i * qia;
			T3 			 =  1 + CIGBINV_i * qia;
			T4 			 =  -9.82222e11 * TOXG * T2 * T3;
			T5 			 =  lexp(T4);
			T6 			 =  3.75956e-7;
			igbinv 		 =  Weff0 * Leff * T6 * Toxratio * vge * Vaux_Igbinv * T5;
			igbinv 		 =  igbinv * igtemp;
			
			// ** Igbacc **
			vfbzb  		 =  deltaPhi -Eg/2.0 - phib;
			T0 			 =  vfbzb - vge;
			T1 			 =  T0 / NIGBACC_i / Vtm;
			Vaux_Igbacc  =  NIGBACC_i * Vtm * lln(1 + lexp(T1));
			if(CAPMOD != 0 && BULKMOD != 0)
				Voxacc   =  qi_acc;
			else begin
				if(vfbzb <=0)
					Voxacc =  0.5 * (T0 - 0.02 + sqrt((T0 - 0.02)*(T0 - 0.02) - 0.08 * vfbzb));
				else
					Voxacc =  0.5 * (T0 - 0.02 + sqrt((T0 - 0.02)*(T0 - 0.02) + 0.08 * vfbzb));
			end
			T2 			 =  AIGBACC_t - BIGBACC_i * Voxacc;
			T3 			 =  1 + CIGBACC_i * Voxacc;
			T4 			 =  -7.45669e11 * TOXG * T2 * T3;
			T5 			 =  lexp(T4);
			T6 			 =  4.97232e-7;
			igbacc 		 =  Weff0 * Leff * T6 * Toxratio * vge * Vaux_Igbacc * T5;
			igbacc 		 =  igbacc * igtemp;
			
		end
		
		if(IGCMOD != 0) begin
			
			// ** Igcinv **
			T1   =  AIGC_t - BIGC_i * qia;
			T2   =  1.0 + CIGC_i * qia;
			T3   =  -Bechvb * TOXG * T1 * T2;
			T4   =  qia * lexp(T3);
			T5   =  (vge + 0.5 *vdsx + 0.5*(ves_jct+ ved_jct));
			igc0 =  Weff0 * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;
			
			// Gate-current partitioning
			Vdseffx  =  sqrt(Vdseff*Vdseff + 0.01) - 0.1;
			T1 		 =  PIGCD_i * Vdseffx;
			T1_exp   =  lexp(-T1);
			T3 		 =  T1 + T1_exp -1.0 + 1.0E-4;
			T4 		 =  1.0 - (T1 + 1.0) * T1_exp + 1.0E-4;
			T5 		 =  T1 * T1 + 2.0E-4;
			igcd 	 =  igc0 * T4 / T5;
			igcs 	 =  igc0 * T3 / T5;
			
			// ** Igs **
			T0   	 =  vgs_noswap;
			vgs_eff  =  sqrt(T0 * T0 + 1.0e-4);
			T1 		 =  AIGS_t - BIGS_i * vgs_eff;
			T2 		 =  1.0 + CIGS_i * vgs_eff;
			T3 		 =  -Bechvb * TOXG * POXEDGE_i * T1 * T2;
			T4 		 =  lexp(T3);
			if(sigvds > 0) igs  =  igsd_mult * DLCIGS * vgs_noswap * vgs_eff * T4;
			else           igd  =  igsd_mult * DLCIGS * vgs_noswap * vgs_eff * T4;
			
			// ** Igd **
			T0 		 =  vgd_noswap;
			vgd_eff  =  sqrt(T0 * T0 + 1.0e-4);
			T1 		 =  AIGD_t - BIGD_i * vgd_eff;
			T2 		 =  1.0 + CIGD_i * vgd_eff;
			T3 		 =  -Bechvb * TOXG * POXEDGE_i * T1 * T2;
			T4 		 =  lexp(T3);
			if(sigvds > 0) igd  =  igsd_mult * DLCIGD * vgd_noswap * vgd_eff * T4;
			else           igs  =  igsd_mult * DLCIGD * vgd_noswap * vgd_eff * T4;
			
		end
		
		// *** GIDL/GISL current ***
		// Ref: BSIM4 Model
		igisl  =  0.0;
		igidl  =  0.0;
		if (GIDLMOD != 0) begin
			
			T0 =  epsratio * EOT;
			
			// ** GIDL **
			if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
				T6 =  0.0;
			end else begin
				T1 =  (- vgd_noswap - EGIDL_i + vfbsd) / T0;
				T1 =  hypsmooth(T1, 1.0E-2);
				T2 =  BGIDL_t / (T1 + 1.0E-3);
				T3 =  lexp(PGIDL_i * lln(T1));
				if(BULKMOD != 0) begin
					T4  =  - ved_jct*ved_jct*ved_jct;
					T4a =  CGIDL_i + abs(T4) + 1.0E-9;
					T5  =  hypsmooth(T4/T4a, 1.0E-6) - 1.0E-6;
					T6  =  AGIDL_i * Weff0 * T3 * lexp(-T2) * T5;
				end else
					T6  =  AGIDL_i * Weff0 * T3 * lexp(-T2) * vds_noswap;
			end
			if(sigvds > 0.0) igidl =  T6;
			else igisl =  T6;
			
			// ** GISL **
			if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
				T6 =  0.0;
			end else begin
				T1 =  (- vgs_noswap - EGISL_i + vfbsd) / T0;
				T1 =  hypsmooth(T1, 1.0E-2);
				T2 =  BGISL_t / (T1 + 1.0E-3);
				T3 =  lexp(PGISL_i * lln(T1));
				if(BULKMOD != 0) begin
					T4 =  - ves_jct*ves_jct*ves_jct;
					T4a =  CGISL_i + abs(T4) + 1.0E-9;
					T5  =  hypsmooth(T4/T4a, 1.0E-6) - 1.0E-6;
					T6 =  AGISL_i * Weff0 * T3 * lexp(-T2) * T5;
				end else
					T6 =  AGISL_i * Weff0 * T3 * lexp(-T2) * (- vds_noswap);
			end
			if(sigvds > 0.0) igisl =  T6;
			else igidl =  T6;
			
		end // GIDLMOD
		
		// *** Junction current ***
		if(BULKMOD != 0) begin
			// ** Source-side junction current **
			if(Isbs > 0.0) begin
				if (ves_jct < VjsmRev) begin
					T0   =  ves_jct / Nvtms;
					T1   =  lexp(T0) - 1.0;
					T2   =  IVjsmRev + SslpRev * (ves_jct - VjsmRev);
					Ies  =  T1 * T2;
				end else if (ves_jct <= VjsmFwd) begin
					T0   =  ves_jct / Nvtms;
					T1   =  (BVS + ves_jct) / Nvtms;
					T2   =  lexp(-T1);
					Ies  =  Isbs * (lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
				end else
					Ies  =  IVjsmFwd + SslpFwd * (ves_jct - VjsmFwd);
			end else
				Ies  =  0.0;
			
			//** Source-side junction tunneling current **
			if(JTSS_t > 0.0) begin
				if((VTSS - ves_jct) < (VTSS * 1.0e-3)) begin
					T0 =  -ves_jct / Vtm0 / NJTS_t;
					T1 =  lexp(T0 * 1.0e+3) - 1.0;
					Ies  =  Ies - ASEJ * JTSS_t * T1;
				end else begin
					T0   =  -ves_jct / Vtm0 / NJTS_t;
					T1   =  lexp(T0 * VTSS / (VTSS - ves_jct)) - 1.0;
					Ies  =  Ies - ASEJ * JTSS_t * T1;
				end
			end
			if(JTSSWS_t > 0.0) begin
				if((VTSSWS - ves_jct) < (VTSSWS * 1.0e-3)) begin
					T0   =  -ves_jct / Vtm0 / NJTSSW_t;
					T1   =  lexp(T0 * 1.0e+3) - 1.0;
					Ies  =  Ies - PSEJ * JTSSWS_t * T1;
				end else begin
					T0   =  -ves_jct / Vtm0 / NJTSSW_t;
					T1   =  lexp(T0 * VTSSWS / (VTSSWS - ves_jct)) - 1.0;
					Ies  =  Ies - PSEJ * JTSSWS_t * T1;
				end
			end
			if(JTSSWGS_t > 0.0) begin
				if((VTSSWGS - ves_jct) < (VTSSWGS * 1.0e-3)) begin
					T0   =  -ves_jct / Vtm0 / NJTSSWG_t;
					T1   =  lexp(T0 * 1.0e+3) - 1.0;
					Ies  =  Ies - Weff0 * NFINtotal * JTSSWGS_t * T1;
				end else begin
					T0   =  -ves_jct / Vtm0 / NJTSSWG_t;
					T1   =  lexp(T0 * VTSSWGS / (VTSSWGS - ves_jct)) - 1.0;
					Ies  =  Ies - Weff0 * NFINtotal * JTSSWGS_t * T1;
				end
			end
			
			// ** Drain-side junction current **
			if(Isbd > 0.0) begin
				if (ved_jct < VjdmRev) begin
					T0   =  ved_jct / Nvtmd;
					T1   =  lexp(T0) - 1.0;
					T2   =  IVjdmRev + DslpRev * (ved_jct - VjdmRev);
					Ied  =  T1 * T2;
				end else if (ved_jct <= VjdmFwd) begin
					T0   =  ved_jct / Nvtmd;
					T1   =  (BVD + ved_jct) / Nvtmd;
					T2   =  lexp(-T1);
					Ied  =  Isbd * (lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
				end else
					Ied  =  IVjdmFwd + DslpFwd * (ved_jct - VjdmFwd);
			end else
				Ied  =  0.0;
			
			//** Drain-side junction tunneling current **
			if(JTSD_t > 0.0) begin
				if((VTSD - ved_jct) < (VTSD * 1.0e-3)) begin
					T0 =  -ved_jct / Vtm0 / NJTSD_t;
					T1 =  lexp(T0 * 1.0e+3) - 1.0;
					Ied  =  Ied - ADEJ * JTSD_t * T1;
				end else begin
					T0   =  -ved_jct / Vtm0 / NJTSD_t;
					T1   =  lexp(T0 * VTSD/ (VTSD - ved_jct)) - 1.0;
					Ied  =  Ied - ADEJ * JTSD_t * T1;
				end
			end
			if(JTSSWD_t > 0.0) begin
				if((VTSSWD - ved_jct) < (VTSSWD * 1.0e-3)) begin
					T0   =  -ved_jct / Vtm0 / NJTSSWD_t;
					T1   =  lexp(T0 * 1.0e+3) - 1.0;
					Ied  =  Ied - PDEJ * JTSSWD_t * T1;
				end else begin
					T0   =  -ved_jct / Vtm0 / NJTSSWD_t;
					T1   =  lexp(T0 * VTSSWD / (VTSSWD - ved_jct)) - 1.0;
					Ied  =  Ied - PDEJ * JTSSWD_t * T1;
				end
			end
			if(JTSSWGD_t > 0.0) begin
				if((VTSSWGD - ved_jct) < (VTSSWGD * 1.0e-3)) begin
					T0   =  -ved_jct / Vtm0 / NJTSSWGD_t;
					T1   =  lexp(T0 * 1.0e+3) - 1.0;
					Ied  =  Ied - Weff0 * NFINtotal * JTSSWGD_t * T1;
				end else begin
					T0   =  -ved_jct / Vtm0 / NJTSSWGD_t;
					T1   =  lexp(T0 * VTSSWGD / (VTSSWGD - ved_jct)) - 1.0;
					Ied  =  Ied - Weff0 * NFINtotal * JTSSWGD_t * T1;
				end
			end
	
			// *** Junction capacitance (no swapping !!) ***
			// ** Source-Substrate Junction **
			`BSIM6JunctnCap(ves_jct, Czbs, PBS_t, SJS, MJS, MJS2, Qesj1)
			`BSIM6JunctnCap(ves_jct, Czbssw, PBSWS_t, SJSWS, MJSWS, MJSWS2, Qesj2)
			`BSIM6JunctnCap(ves_jct, Czbsswg, PBSWGS_t, SJSWGS, MJSWGS, MJSWGS2, Qesj3)
			Qesj = Qesj1 + Qesj2 + Qesj3;
			
			// ** Drain-Substrate Junction **
			`BSIM6JunctnCap(ved_jct, Czbd, PBD_t, SJD, MJD, MJD2, Qedj1)
			`BSIM6JunctnCap(ved_jct, Czbdsw, PBSWD_t, SJSWD, MJSWD, MJSWD2, Qedj2)
			`BSIM6JunctnCap(ved_jct, Czbdswg, PBSWGD_t, SJSWGD, MJSWGD, MJSWGD2, Qedj3)
			Qedj = Qedj1 + Qedj2 + Qedj3;

		end //BULKMOD=0

		Qes  =  Qesj + csbox * ves_jct;
		Qed  =  Qedj + cdbox * ved_jct;
		
		// *** Gate to Substrate Parasitic Capacitance *** 
		// ** Bias Independent Component **
		Qeg  =  cgbox * devsign * V(e, `GateEdgeNode);
		if(BULKMOD != 0) begin
			//Bias Dependent Component
			T2 =  devsign * V(`GateEdgeNode, e);
			T3 =  T2 - deltaPhi + Eg/2.0 + phib - DELVFBACC;
			T0 =  T3 + `DELTA_1;
			vge_overlap  =  0.5 * (T0 + sqrt(T0 * T0 + 4.0 * `DELTA_1));
			Qeg  =  Qeg - NFINtotal * LeffCV * (CGBL_i * (T3 - vge_overlap
						+ 0.5 * CKAPPAB_i * ( sqrt(1.0 + 4.0 * vge_overlap / CKAPPAB_i) - 1.0 )));
		end
		
		// *** Generation/recombination component ***
		T0 	   =  vds;
		T1 	   =  T0 * (AIGEN_i + BIGEN_i * T0 * T0);
		idsgen =  HFIN * TFIN * (Leff - 2.0 * LINTIGEN_i) * igentemp * T1;
		
		
		// *** NQS Gate Resistance ***
		// Ref: BSIM4 Model
		IdovVds  =  beta * ids0_ov_dqi * Moc / (Dmob * Dvsat * Dr);
		T0       =  ueff * coxeff * Weff / Leff;
		`ifdef __NQSMOD1__
			if(NQSMOD == 1 && XRCRG1_i != 0) begin
				gcrg =  NF * XRCRG1_i * (IdovVds + XRCRG2_i * Vtm * T0) / NFIN;
			end
		`endif
		`ifdef __NQSMOD2__
			if(NQSMOD == 2) begin
				gcrg =  NF * XRCRG1_i * (IdovVds + XRCRG2_i * Vtm * T0) / NFIN;
				gtau =  gcrg / (cox * Weff * Leff);
			end
		`endif
		
		
		// *** Multiply all current and charge components by NFINtotal ***
		// Note: Do not multiply ids, qg, qs, qd, qb, Ies, Ied, Qbs, Qbd with NFINtotal
		//       since it is already considered.
		
		igidl    =  NFINtotal * igidl;
		igisl    =  NFINtotal * igisl;
		igcd 	 =  NFINtotal * igcd;
		igcs 	 =  NFINtotal * igcs;
		igs  	 =  NFINtotal * igs;
		igd  	 =  NFINtotal * igd;
		igbinv   =  NFINtotal * igbinv;
		igbacc   =  NFINtotal * igbacc;
		idsgen   =  NFINtotal * idsgen;
		Iii      =  NFINtotal * Iii;

		// Gate to Body Tunneling current empirical partition for BULKMOD=0		
		igbs = 0.0;
		igbd = 0.0;
		if(BULKMOD == 0) begin
			igbs   =  (igbinv + igbacc) * wf;
			igbd   =  (igbinv + igbacc) * wr;
		end
		
		//********************************
		// ***      Noise Models       ***
		
		Esatnoi    =  2.0 * VSAT_t / ueff;  // Thermal noise and flicker noise
				
		// ** Flicker Noise **
		// Ref: BSIM4 Model; K. K. Hung et al., TED 1990 
		if(NOIA > 0 || NOIB > 0 || NOIC > 0) begin
			Leffnoi    =  Leff - 2.0 * LINTNOI_i;
			Leffnoisq  =  Leffnoi * Leffnoi;
			if(EM <= 0.0) DelClm =  0.0;
			else begin
				T0     =  (diffVds / litl + EM) / Esatnoi;
				DelClm =  litl * lln(T0);
				if (DelClm < 0.0) DelClm =  0.0;
			end
			`ifdef __NQSMOD3__
				if(GEOMOD !=3 && COREMOD !=0) begin
					T1 =  `q * `q * `q * Vtm * abs(ids) * ueff;
				end else begin 
					if(NQSMOD==3)
						T1 =  `q * `q * `q * Vtm * abs(ids1) * ueff;
					else
						T1 =  `q * `q * `q * Vtm * abs(ids) * ueff;
				end
			`else
				T1 =  `q * `q * `q * Vtm * abs(ids) * ueff;
			`endif
			T2     =  1.0e10 * coxeff * Leffnoisq;
			N0     =  coxeff * qis / `q;
			Nl     =  coxeff * qid / `q;
			// Note: Cdep ~ 0 in a fully-depleted device
			Nstar  =  Vtm / `q * (coxeff + CIT_i);
			T3 	   =  NOIA * lln((N0 + Nstar) / (Nl + Nstar));
			T4 	   =  NOIB * (N0 - Nl);
			T5     =  0.5 * NOIC * (N0 * N0 - Nl * Nl);
			
			`ifdef __NQSMOD3__
				if(GEOMOD !=3 && COREMOD !=0) begin
					T6 =  `q * Vtm * ids * ids;
				end else begin 
					if(NQSMOD==3)
						T6 =  `q * Vtm * ids1 * ids1;
					else
						T6 =  `q * Vtm * ids * ids;
				end
			`else
				T6 =  `q * Vtm * ids * ids;
			`endif

			T7 =  1.0e10 * Leffnoisq * Weff * NFINtotal;
			T8 =  NOIA + NOIB * Nl + NOIC * Nl * Nl;
			T9 =  (Nl + Nstar) * (Nl + Nstar);
			Ssi  =  T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
			
			T10  =  NOIA * `q * Vtm;
			T11  =  Weff * NFINtotal * Leffnoi * 1.0e10 * Nstar * Nstar;
			`ifdef __NQSMOD3__
				if(GEOMOD !=3 && COREMOD !=0) begin
					Swi  =  T10 / T11 * ids * ids;
				end else begin
					if(NQSMOD==3)
						Swi  =  T10 / T11 * ids1 * ids1;
					else
						Swi  =  T10 / T11 * ids * ids;
				end
			`else
				Swi  =  T10 / T11 * ids * ids;
			`endif
			
			T1   =  Swi + Ssi;
			if (T1 > 0.0) FNPowerAt1Hz =  (Ssi * Swi) / T1;
			else FNPowerAt1Hz  =  0.0;
		end else begin
			FNPowerAt1Hz =  0.0;
		end
		
		
		// ** Thermal Noise **
		// Charge-based model (BSIM4 - TNOIMOD=0)
		`ifdef __NQSMOD3__
			if((NQSMOD==3)&&(!(GEOMOD !=3 && COREMOD !=0)))
				qinv  =  qg1 + qg2 + qg3 + qg4 + qg5 + qg6 + qg7 + qg8 + qg9 + qg10;
		`endif
		T0     =  ueff * qinv;
		T1     =  T0 * Rdsi + Leff * Leff;
		Gtnoi  =  (T0 / T1) * NTNOI_i;
		sid    =  4 * Vtm * `q * Gtnoi;

		// Source and Drain conductance for thermal noise contribution
		gspr =  1 / Rsource;    /* Note: gspr considers all fins */
		gdpr =  1 / Rdrain;     /* Note: gdpr considers all fins */
		
	end // End of Bias dependent calculation
	//********************************************************************************
		
	if(!initialized) begin
		devsign  =  0.0;
		Rsource  =  1.0;
		Rdrain   =  1.0;
		`ifdef __RGATEMOD__
			ggeltd =  1.0;
		`endif
		`ifdef __NQSMOD1__
			XRCRG1_i =  0.0;
		`endif
		`ifdef __SHMOD__
			gth  =  1.0;    // set gth to some value to prevent a singular G matrix
			cth  =  0.0;
		`endif
		$strobe("uninitialized");
	end //End of !initialized
	
	//Loading Ids, Gate and Drain charges
	`ifdef __NQSMOD2__
		if(sigvds > 0.0) I(di, si) <+  devsign * ids;
		else             I(si, di) <+  devsign * ids;
		
		if(NQSMOD == 2) begin
			I(`IntrinsicGate, si)  <+  devsign * gtau * -V(q);
			I(di, si)              <+  devsign * xdpart * gtau * V(q);
		end else begin  //Quasi-static stamping (Normal case)
			I(di, si)              <+  devsign * ddt(qd);
			I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
		end
	`else
		`ifdef __NQSMOD3__
			if(GEOMOD !=3 && COREMOD != 0) begin    //Case not supported for NQSMOD=3
				if(sigvds > 0.0) I(di, si) <+  devsign * ids;
				else             I(si, di) <+  devsign * ids;
				I(di, si)              <+  devsign * ddt(qd);
				I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
			end else begin
				if(NQSMOD == 3) begin
					`include "bsimcmg_load_nqsmod3_segments.include"
				end else begin  //Quasi-static stamping (Normal case)
					if(sigvds > 0.0) I(di, si) <+  devsign * ids;
					else             I(si, di) <+  devsign * ids;
					I(di, si)              <+  devsign * ddt(qd);
					I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
				end
			end
		`else   //Quasi-static stamping (Normal case)
			if(sigvds > 0.0) I(di, si) <+  devsign * ids;
			else             I(si, di) <+  devsign * ids;
			I(di, si)              <+  devsign * ddt(qd);
			I(`IntrinsicGate, si)  <+  devsign * ddt(qg);
		`endif
	`endif
	
	// Loading other currents
	if (sigvds > 0) begin
		I(di, si) <+  devsign * idsgen;
		I(`IntrinsicGate, si)   <+  devsign * (igcs + igs);
		I(`IntrinsicGate, di)   <+  devsign * (igcd + igd);
		if(BULKMOD != 0) begin
			I(di, e)               <+  devsign * (igidl + Iii);
			I(si, e)               <+  devsign * igisl;
			I(`IntrinsicGate, e)   <+  devsign * (igbinv + igbacc) ;
		end else begin
			I(di, si) <+  devsign * (igidl + Iii);
			I(si, di) <+  devsign * igisl;
		end
	end else begin
		I(si, di)               <+  devsign * idsgen;
		I(`IntrinsicGate, di)   <+  devsign * (igcs + igs);
		I(`IntrinsicGate, si)   <+  devsign * (igcd + igd);
		if(BULKMOD != 0) begin
			I(si, e)               <+  devsign * (igidl + Iii);
			I(di, e)               <+  devsign * igisl;
			I(`IntrinsicGate, e)   <+  devsign * (igbinv + igbacc);
		end else begin
			I(si, di) <+  devsign * (igidl + Iii);
			I(di, si) <+  devsign * igisl;
		end
	end
	if(BULKMOD == 0) begin
		I(`IntrinsicGate, si)  <+  devsign * igbs;
		I(`IntrinsicGate, di)  <+  devsign * igbd;
	end
	
	if(BULKMOD != 0) begin
		I(e, si)  <+  devsign * Ies;
		I(e, di)  <+  devsign * Ied;
	end
	I(e, si)               <+  devsign * ddt(Qes);
	I(e, di)               <+  devsign * ddt(Qed);
	I(e, `GateEdgeNode)    <+  devsign * ddt(Qeg);
	
	// Gmin for convergence - removed on consensus among EDA vendors.
	// Kindly use GMIN=1E-18 if at all required by the simulator
	// if(BULKMOD != 0) begin
	//    I(e, si)  <+  `GMIN * V(e, si);
	//    I(e, di)  <+  `GMIN * V(e, di);
	// end
	
	//Loading other charges     
	I(`GateEdgeNode, si)  <+  ddt(qgs_parasitic);
	I(`GateEdgeNode, di)  <+  ddt(qgd_parasitic);
	I(d, s) <+ ddt(qds_fr);
	if(CGEOMOD == 1) begin
		I(`GateEdgeNode, s) <+  ddt(qgs_fr);
		I(`GateEdgeNode, d) <+  ddt(qgd_fr);
	end
	// Accumulation charge for bulk FET
	if(CAPMOD != 0 && BULKMOD != 0) begin
		I(`IntrinsicGate, si) <+ devsign * ddt(qg_acc);
		I(e, si)              <+ devsign * ddt(qb_acc);
	end
	
	// External S/D Resistance
	I(d, di)  <+  V(d, di) / Rdrain; 
	I(s, si)  <+  V(s, si) / Rsource; 
	
	// NQSMOD1 Gate Resistance Model
	`ifdef __NQSMOD1__
		if(NQSMOD == 1 && XRCRG1_i != 0)
			I(`GateEdgeNode, gi) <+  V(`GateEdgeNode, gi) * gcrg;
		else
			V(`GateEdgeNode, gi) <+  0;
	`endif
	
	// NQSMOD2 BSIM4 Charge Deficit Model
	`ifdef __NQSMOD2__
		if(NQSMOD ==2) begin
			I(q) <+  ddt(qg - qb);
			I(q) <+  V(q) * gtau;
			I(q) <+  ddt(V(q));
		end else
			V(q) <+  0;
	`endif
	
	// Gate Electrode Resistance
	`ifdef __RGATEMOD__
		if(RGATEMOD != 0)
			I(g, ge) <+  V(g, ge) * ggeltd;
		else
			V(g, ge) <+  0;
	`endif
	
	// Flicker Noise
	I(di,si) <+  flicker_noise(FNPowerAt1Hz, EF, "flicker");
	
	// Thermal noise for parasitics
	I(d, di) <+ white_noise(4 * Vtm * `q * gdpr, "thermal");
	I(s, si) <+ white_noise(4 * Vtm * `q * gspr, "thermal");

	`ifdef __RGATEMOD__
		if(RGATEMOD != 0)
			I(g, ge) <+  white_noise(4 * Vtm * `q * ggeltd, "thermal");
	`endif
	
	// Channel thermal noise and induced gate noise stamping
	//    Implementation of correlated noise follows C. C. McAndrew, WCM 2005
	I(di, si) <+ white_noise(sid, "thermal");
	
	// Gate current shot noise
	if(IGCMOD != 0) begin
		if(sigvds > 0) begin
			I(`IntrinsicGate, si)  <+  white_noise(2 * `q * abs(igcs + igs), "shot");
			I(`IntrinsicGate, di)  <+  white_noise(2 * `q * abs(igcd + igd), "shot");
		end else begin
			I(`IntrinsicGate, di)  <+  white_noise(2 * `q * abs(igcs + igs), "shot");
			I(`IntrinsicGate, si)  <+  white_noise(2 * `q * abs(igcd + igd), "shot");
		end
	end
	if(IGBMOD != 0) begin
		if(BULKMOD != 0) begin
			I(`IntrinsicGate, e)   <+  white_noise(2 * `q * abs(igbinv + igbacc), "shot");
		end else begin
			I(`IntrinsicGate, si)  <+  white_noise(2 * `q * abs(igbs), "shot");
			I(`IntrinsicGate, di)  <+  white_noise(2 * `q * abs(igbd), "shot");
		end
	end
			
	// Self Heating
	`ifdef __SHMOD__
		`ifdef __NQSMOD3__
			if(GEOMOD !=3 && COREMOD !=0) begin  //case not supported for NQSMOD=3
				if (SHMOD != 0 && RTH0 > 0) begin
					Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
				end
				Pwr(rth_branch) <+  Temp(rth_branch) * gth;
				Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
			end else begin
				if(NQSMOD==3) begin
					if (SHMOD != 0 && RTH0 > 0) begin
						Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * idsN + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
					end
					Pwr(rth_branch) <+  Temp(rth_branch) * gth;
					Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
				end else begin
					if (SHMOD != 0 && RTH0 > 0) begin
						Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
					end
					Pwr(rth_branch) <+  Temp(rth_branch) * gth;
					Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
				end
			end
		`else
			if(SHMOD != 0 && RTH0 > 0) begin
				Pwr(ith_branch) <+  -(devsign * sigvds * V(di,si) * ids + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource);
			end
				Pwr(rth_branch) <+  Temp(rth_branch) * gth;
				Pwr(rth_branch) <+  ddt(Temp(rth_branch) * cth);
		`endif
	`endif
	
	// Operating-Point information
	`ifdef __OPINFO__
		//W & L
		WEFF	=  Weff;                              // Effective width for IV
		LEFF	=  Leff;                              // Effective length for IV
		WEFFCV	=  WeffCV;                            // Effective width for CV
		LEFFCV	=  LeffCV;                            // Effective length for CV

		// Currents
		IDS    =  devsign * ids;                      // Intrinsic Drain Current (Electrical)
		if(sigvds > 0) begin                          // Total Source/Drain Currents (Physical)
			if(BULKMOD != 0) begin
				IDEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl) - devsign * Ied;
				ISEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * (igisl) - devsign * Ies; 
			end else begin
				IDEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd + igbd) + devsign * (Iii + igidl - igisl);    
				ISEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs + igbs) + devsign* (igisl - igidl);
			end
		end else begin
			if(BULKMOD != 0) begin
				IDEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs) + devsign * (igisl) - devsign * Ied;
				ISEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd) + devsign * (Iii + igidl) - - devsign * Ies;
			end else begin
				IDEFF  =  - IDS - devsign * idsgen - devsign * (igs + igcs + igbd) + devsign * (igisl - igidl);
				ISEFF  =  IDS + devsign * idsgen - devsign * (igd + igcd + igbs) + devsign * (Iii + igidl - igisl);
			end
		end

		if(BULKMOD == 0) begin                        // Total Gate Current
			IGTOT  =  devsign * (igs + igd + igcs + igcd + igbs + igbd);
		end else begin
			IGTOT  =  devsign * (igs + igd + igcs + igcd + igbacc + igbinv);
		end

		IDSGEN =  sigvds * devsign * idsgen;          // Generation-Recombination Current (Physical)
		III    =  devsign * Iii;                      // Impact Ionization Current
		if(sigvds > 0) begin
			IGIDL  =  devsign * igidl;                    // GIDL Current (Physical)
			IGISL  =  devsign * igisl;                    // GISL Current (Physical)
		end else begin
			IGIDL  =  devsign * igisl;                    // GIDL Current (Physical)
			IGISL  =  devsign * igidl;                    // GISL Current (Physical)
		end

		if(BULKMOD != 0) begin
			IJSB   =  - devsign * Ies;                // Source-Body Junction Current (Physical)
			IJDB   =  - devsign * Ied;                // Drain-Body Junction Current (Physical)
		end	else begin
			IJSB   =  0.0;
			IJDB   =  0.0;
		end
			

		if(BULKMOD != 0) begin
			ISUB   =  - III - IGIDL - IGISL - IJSB - IJDB - devsign*(igbinv + igbacc);                // Substrate Current
		end else begin
			ISUB   =  0.0;
		end
		
		// Misc Variables
		BETA   =  beta;                               // Drain Current prefactor per fin per finger
		VDSSAT =  Vdsat;                              // Drain-Source saturation Voltage
		if(NGATE_i > 0)                               // Flatband Voltage
			VFB  =  - devsign * (phib + Vtm*lln(NGATE_i/ni));
		else
			VFB  =  PHIG_i - (EASUB + 0.5*Eg + devsign * phib);

		// Threshold Voltage Calculation
		
		if(GEOMOD != 3) begin
			q0      =  (5.0 * Vtm * (epssub/TFIN) + 2.0 * Qbul) / cox;
			T1		=  Vtm * (Vtm + q0);
			T2		=  cox * cox * T1;
  			T3		=  2.0 * `q * ni * epssub * Vtm;
			VTH     =  VFB + devsign*(Vtm * lln(T2/T3) + dvch_qm + phib + qbs + Vtm + dvth_all - DELVTRAND);
			
		end else begin
			T1     =  Vtm * r1 / cdop;
			qith   =  sqrt(T1*T1 + 2.0 * T1 * Vtm) - T1;    //Charge in channel at half of (Gm/Id)_max
			g0     =  qith / q0;
			F0     =  0.5 * lln(g0) + 0.5 * lln(1.0 + cdop * g0) + r1 * g0 + r2 * g0 * g0;
			VTH    =  2.0 * Vtm * F0 + vt0 * Vtm/nVtm + deltaPhi - 0.5 * Eg - phib + dvth_all + dvch_qm - DELVTRAND;
		end
		

		// Conductances
		GM     =  ddx(IDS,V(`IntrinsicGate));         // Transconductance
		GDS    =  ddx(IDS,V(di));                     // Output conductance
		if(BULKMOD != 0)
			GMBS   =  ddx(IDS,V(e));                  // Body transconductance
		else   
			GMBS   =  0.0;

		// Intrinsic Charges (Physical) (Sriram: Not accurate for NQSMOD= 2 and 3)
		`ifdef __NQSMOD3__
			if(GEOMOD !=3 && COREMOD !=0) begin
				QGI =  devsign * qg + (CAPMOD == 1 ? devsign * qg_acc : 0);
				QDI =  devsign * qd;
				QSI =  devsign * qs;
			end else begin
				if(NQSMOD == 3) begin
					qg  =  qg1 + qg2 + qg3 + qg4 + qg5 + qg6 + qg7 + qg8 + qg9 + qg10;
					QGI =  devsign * (qg - qb) + (CAPMOD == 1 ? devsign * qg_acc : 0);
					QDI =  0.0;  // Yet to do - Drain charge 
					QSI =  0.0;  // Yet to do - Source charge
				end else begin
					QGI =  devsign * qg + (CAPMOD == 1 ? devsign * qg_acc : 0);
					QDI =  devsign * qd;
					QSI =  devsign * qs;
				end
			end
		`else
			QGI =  devsign * qg + (CAPMOD == 1 ? devsign * qg_acc : 0);
			QDI =  devsign * qd;
			QSI =  devsign * qs;
		`endif

		QBI =  devsign * (qb + (CAPMOD == 1 ? qb_acc : 0));

		// Total Charges (Sriram: Not accurate for NQSMOD= 2 and 3)
		`ifdef __NQSMOD3__
			if(GEOMOD !=3 && COREMOD !=0) begin  //Case not supported for NQSMOD=3
				QG =  devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
						 + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
				QD =  devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0) - devsign * Qed + qds_fr;
				QS =  devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0) - devsign * Qes - qds_fr;
			end else begin
				if(NQSMOD == 3) begin
					qg =  qg1 + qg2 + qg3 + qg4 + qg5 + qg6 + qg7 + qg8 + qg9 + qg10;
					QG =  devsign * (qg - qb) + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
							 + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
					QD =  0.0;  // Yet to do - Drain charge 
					QS =  0.0;  // Yet to do - Source charge
				end else begin
					QG =  devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
							 + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
					QD =  devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0) - devsign * Qed;
					QS =  devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0) - devsign * Qes;
				end
			end
		`else
			QG =  devsign * qg + qgs_parasitic + qgd_parasitic + (CGEOMOD == 1 ? qgs_fr + qgd_fr : 0)
					 + (CAPMOD == 1 ? devsign * qg_acc : 0) - devsign * Qeg;
			QD =  devsign * qd - qgd_parasitic - (CGEOMOD == 1 ? qgd_fr : 0) - devsign * Qed;
			QS =  devsign * qs - qgs_parasitic - (CGEOMOD == 1 ? qgs_fr : 0) - devsign * Qes;
		`endif

		QB =  devsign * (qb + (CAPMOD == 1 ? qb_acc : 0)) + devsign * (Qeg + Qes + Qed);

		// Intrinsic Capacitances (Physical)
		CGGI  =  ddx(QGI, V(`IntrinsicGate));
		CGSI  =  - ddx(QGI, V(si));
		CGDI  =  - ddx(QGI, V(di));
		CGEI  =  - ddx(QGI, V(e));                    

		CSGI  =  - ddx(QSI, V(`IntrinsicGate));
		CSDI  =  - ddx(QSI, V(di));
		CSSI  =  ddx(QSI, V(si));
		CSEI  =  - ddx(QSI, V(e));                    // Should be zero everywhere

		CDGI  =  - ddx(QDI, V(`IntrinsicGate));
		CDDI  =  ddx(QDI, V(di));
		CDSI  =  - ddx(QDI, V(si));
		CDEI  =  - ddx(QDI, V(e));

		CEGI  =  - ddx(QBI, V(`IntrinsicGate));       
		CEDI  =  - ddx(QBI, V(di));                   // Should be zero everywhere
		CESI  =  - ddx(QBI, V(si));                   // Should be zero everywhere
		CEEI  =  ddx(QBI, V(e));

		// Total Capacitances
		CGG  =  ddx(QG, V(`IntrinsicGate));
		CGS  =  - ddx(QG, V(si));
		CGD  =  - ddx(QG, V(di));
		CGE  =  - ddx(QG, V(e));

		CSG  =  - ddx(QS, V(`IntrinsicGate));
		CSD  =  - ddx(QS, V(di));
		CSS  =  ddx(QS, V(si));
		CSE  =  - ddx(QS, V(e));

		CDG  =  - ddx(QD, V(`IntrinsicGate));
		CDD  =  ddx(QD, V(di));
		CDS  =  - ddx(QD, V(si));
		CDE  =  - ddx(QD, V(e));

		CEG  =  - ddx(QB, V(`IntrinsicGate));
		CED  =  - ddx(QB, V(di));
		CES  =  - ddx(QB, V(si));
		CEE  =  ddx(QB, V(e));

		//Total extrinsic capacitance
                CGSEXT  =  - ddx(qgs_parasitic + (CGEOMOD == 1 ? qgs_fr : 0),V(si));  //Gate-Source Overlap + outer fringing 
                CGDEXT  =  - ddx(qgd_parasitic + (CGEOMOD == 1 ? qgd_fr : 0),V(di));  //Gate-Drain Overlap + outer fringing
		CGBOV	=  - devsign * ddx(Qeg,V(e));                     //Gate-Body Overlap

		// Total of Junction Capacitance and Source/Drain-Body Overlap Capacitance
		CJST    =  - devsign * ddx(Qes, V(si));
		CJDT    =  - devsign * ddx(Qed, V(di));

		RSGEO  =  RSourceGeo;                                                 // External bias independent Source Resistance
		RDGEO  =  RDrainGeo;                                                  // External bias independent Drain Resistance
		CFGEO  =  Cfr_geo;                                                    //Geometric Parasitic Cap for CGEOMOD=1
		
		`ifdef __DEBUG__
			// Individual Gate Current Components
			IGS    =  devsign * igs;
			IGD    =  devsign * igd;
			IGCS   =  devsign * igcs;
			IGCD   =  devsign * igcd;
			if(BULKMOD == 0) begin
				IGBS   =  devsign * igbs;
				IGBD   =  devsign * igbd;
			end else begin
				IGBINV =  devsign * igbinv;
				IGBACC =  devsign * igbacc;
			end

			DIDSDVG  =  devsign * sigvds * ddx(ids, V(`IntrinsicGate));
			DIDSDVS  =  devsign * sigvds * ddx(ids, V(si));
			DIDSDVD  =  devsign * sigvds * ddx(ids, V(di));
			`ifdef __SHMOD__
				DIDSDVTH =  devsign * sigvds * ddx(ids, Temp(rth_branch));
			`endif
			DIGSDVG  =  devsign * ddx(igs + igcs, V(`IntrinsicGate));
			DIGSDVS  =  devsign * ddx(igs + igcs, V(si));
			DIGSDVD  =  devsign * ddx(igs + igcs, V(di));
			`ifdef __SHMOD__
				DIGSDVTH =  devsign * ddx(igs + igcs, Temp(rth_branch));
			`endif
			DIGDDVG  =  devsign * ddx(igd + igcd, V(`IntrinsicGate));
			DIGDDVS  =  devsign * ddx(igd + igcd, V(si));
			DIGDDVD  =  devsign * ddx(igd + igcd, V(di));
			`ifdef __SHMOD__
				DIGDDVTH =  devsign * ddx(igd + igcd, Temp(rth_branch));
			`endif
			DIIIDVG  =  devsign * ddx(Iii, V(`IntrinsicGate));
			DIIIDVS  =  devsign * ddx(Iii, V(si));
			DIIIDVD  =  devsign * ddx(Iii, V(di));
			`ifdef __SHMOD__
				DIIIDVTH =  devsign * ddx(Iii, Temp(rth_branch));
			`endif
			DIGIDLDVG  =  devsign * ddx(igidl, V(`IntrinsicGate));
			DIGIDLDVS  =  devsign * ddx(igidl, V(si));
			DIGIDLDVD  =  devsign * ddx(igidl, V(di));
			`ifdef __SHMOD__
				DIGIDLDVTH =  devsign * ddx(igidl, Temp(rth_branch));
			`endif
			DIGISLDVG  =  devsign * ddx(igisl, V(`IntrinsicGate));
			DIGISLDVS  =  devsign * ddx(igisl, V(si));
			DIGISLDVD  =  devsign * ddx(igisl, V(di));
			`ifdef __SHMOD__
				DIGISLDVTH =  devsign * ddx(igisl, Temp(rth_branch));
			`endif

			`ifdef __SHMOD__
				CGT  =  ddx(QG, Temp(rth_branch));
				CST  =  ddx(QS, Temp(rth_branch));
				CDT  =  ddx(QD, Temp(rth_branch));
			`endif
			ITH  =  ids*vds;
			`ifdef __SHMOD__
				DITHDVTH =  ddx(ITH, Temp(rth_branch));
			`endif	
			DITHDVG  =  ddx(ITH, V(`IntrinsicGate));
			DITHDVS  =  ddx(ITH, V(si));
			DITHDVD  =  ddx(ITH, V(di));
		`endif // __DEBUG__
	`endif // __OPINFO__
end //           analog block ends
//================================================
