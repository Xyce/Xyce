<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">


  <!--
      Purpose:       Generate the .h file for a Xyce implementation of a
                     verilog model.
      Special Notes: You must include "xyceBasicTemplates.xml" to use this
                     script
      Creator:       Tom Russo, SNL, Electrical and Microsystems Modeling
      Creation Date: 13 May 2008


     Copyright 2002-2020 National Technology & Engineering Solutions of
     Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
     NTESS, the U.S. Government retains certain rights in this software.

     This file is part of the Xyce(TM) Parallel Electrical Simulator.

     Xyce(TM) is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     Xyce(TM) is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Xyce(TM).
     If not, see <http://www.gnu.org/licenses/>.
  -->

<!-- this shouldn't really be needed, but makes sure this template can be
     used in any order, even with the non-sacado version of the basic
     templates, forcing it to fall back to the version that doesn't
     try to insert precomputed function variables -->
<admst:variable name="skipFunctionPrecomp" select="y"/>

<admst:for-each select="/module">
  <admst:variable name="thisModule" select="%(.)"/>
  <!-- Set up some useful variables: the N_DEV_(foo) class, and its
       related Instance and Model classes -->
  <admst:apply-templates select="." match="xyceClassBaseName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="classname" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceDeviceNamespace">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="nameSpace" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceModelClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="modelName" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="xyceInstanceClassName">
    <admst:value-of select="returned('classname')/value"/>
    <admst:variable name="instanceName" select="%s"/>
  </admst:apply-templates>

  <admst:apply-templates select="." match="collectLimiters"/>
  <admst:apply-templates select="." match="collectCollapsibles"/>
  <admst:apply-templates select="." match="collectExtraUnknowns"/>

  <admst:open file="$classname.h">
// -*-c++-*-
//-------------------------------------------------------------------------
//   Copyright 2002-2020 National Technology &amp; Engineering Solutions of
//   Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
//   NTESS, the U.S. Government retains certain rights in this software.
//
//   This file is part of the Xyce(TM) Parallel Electrical Simulator.
//
//   Xyce(TM) is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   Xyce(TM) is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with Xyce(TM).
//   If not, see &lt;http://www.gnu.org/licenses/&gt;.
//-------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Purpose        :
//
// Special Notes  : Generated from verilog file %(/filename) with ADMS
//                  interface for %(/simulator/package_string)
//                  DO NOT EDIT THIS FILE DIRECTLY!  It may be overwritten!
//
// Creator        : %(/simulator/fullname)
//
// Creation Date  : %(/simulator/currentdate)
//
//-----------------------------------------------------------------------------

  <admst:apply-templates select="." match="xyceGuardSymbol">
    <admst:value-of select="returned('symbolname')/value"/>
    <admst:variable name="guardSymbol" select="%s"/>
  </admst:apply-templates>
  <admst:text format="#ifndef $guardSymbol\n#define $guardSymbol\n"/>

#include &lt;Sacado_No_Kokkos.hpp&gt;

#include &lt;N_DEV_Configuration.h&gt;
#include &lt;N_DEV_Const.h&gt;
#include &lt;N_DEV_DeviceBlock.h&gt;
#include &lt;N_DEV_DeviceInstance.h&gt;
#include &lt;N_DEV_DeviceModel.h&gt;

<admst:apply-templates select="." match="xyceIncludeModelBaseHeader"/>

namespace Xyce {
namespace Device {
namespace <admst:text format="%($nameSpace)"/> {

// This typedef is for our automatic differentiation:
  typedef Sacado::Fad::SFad&lt;double,%(xyceNumberProbes(.))&gt; AdmsFadType;
  typedef Sacado::Fad::SFad&lt;double,1&gt; AdmsSensFadType;

class Model;
class Instance;
class InstanceSensitivity;

#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------

  <admst:text format="// Class         : InstanceSensitivity"/>
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

<admst:text format="class InstanceSensitivity : public baseSensitivity"/>
{
public:
InstanceSensitivity() :
baseSensitivity() {};

virtual ~InstanceSensitivity() {};

virtual void operator()(
const ParameterBase &amp;entity,
const std::string &amp;param,
std::vector&lt;double&gt; &amp; dfdp,
std::vector&lt;double&gt; &amp; dqdp,
std::vector&lt;double&gt; &amp; dbdp,
std::vector&lt;int&gt; &amp; Findices,
std::vector&lt;int&gt; &amp; Qindices,
std::vector&lt;int&gt; &amp; Bindices
) const ;
};

static InstanceSensitivity instSens;


//-----------------------------------------------------------------------------

  <admst:text format="// Class         : ModelSensitivity"/>
//
// Purpose       : This class is a functor for sensitivity
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

<admst:text format="class ModelSensitivity : public baseSensitivity"/>
{
public:
ModelSensitivity() :
baseSensitivity() {};

virtual ~ModelSensitivity() {};

virtual void operator()(
const ParameterBase &amp;entity,
const std::string &amp;param,
std::vector&lt;double&gt; &amp; dfdp,
std::vector&lt;double&gt; &amp; dqdp,
std::vector&lt;double&gt; &amp; dbdp,
std::vector&lt;int&gt; &amp; Findices,
std::vector&lt;int&gt; &amp; Qindices,
std::vector&lt;int&gt; &amp; Bindices
) const ;
};

static ModelSensitivity modSens;
#endif // Xyce_ADMS_SENSITIVITIES

// general purpose free functions
// thermal voltage at kelvin temperature temp)
template &lt;typename T&gt; static inline T adms_vt(const T temp) {return(CONSTKoverQ*temp);};

// Figure out how to template this shiznit!
//-----------------------------------------------------------------------------


template&lt;typename Tin&gt;
static Tin adms_ternary_op(const bool cond, const Tin &amp;ifTrue, const Tin &amp;ifFalse)
{
if (cond)
return ifTrue;
else
return ifFalse;
}

template&lt;typename Tin&gt;
static Tin adms_ternary_op(const bool cond, const Tin &amp;ifTrue, const double &amp;ifFalse)
{
if (cond)
return ifTrue;
else
return Tin(ifFalse);
}

template&lt;typename Tin&gt;
static Tin adms_ternary_op(const bool cond, const double &amp;ifTrue, const Tin &amp;ifFalse)
{
if (cond)
return Tin(ifTrue);
else
return ifFalse;
}




#ifdef Xyce_ADMS_SENSITIVITIES
//-----------------------------------------------------------------------------
// Free functions used by sensitivity
//
//-----------------------------------------------------------------------------

<admst:text format="void evaluateModelEquations(\n"/>
<admst:variable name="globalDeclareVars" select="yes"/>
<admst:apply-templates select="." match="generateEvaluateModelEquationsArgs"/>
<admst:text format=");\n\n"/>

<admst:text format="void evaluateInitialInstance(\n"/>
<admst:variable name="globalDeclareVars" select="yes"/>
<admst:apply-templates select="." match="generateInstanceAndModelArgs"/>
<admst:text format=" double admsTemperature,double adms_vt_nom, double ADMSgmin_arg, const Instance &amp; theInstance);\n\n"/>

<admst:text format="void evaluateInitialModel(\n"/>
<admst:variable name="globalDeclareVars" select="yes"/>
<admst:apply-templates select="." match="generateModelArgs">
  <admst:if test="[returned('iGeneratedArgs')/value = 'yes']">
    <admst:text format=",\n"/>
  </admst:if>
</admst:apply-templates>
<admst:text format=" double admsTemperature, double ADMSgmin_arg, const Instance &amp; theInstance);\n"/>
#endif // Xyce_ADMS_SENSITIVITIES


// Limited exponential --- NOT what verilog LRM says, but what qucs,
// ng-spice, and zspice do.

template &lt;typename T&gt;
T limexp(const T &amp;x)
{
  if ((x) &lt; 80.0)
  return (exp(x));
  else
  return (exp(80.0)*(x-79.0));
}

// Maybe this will do as a substitute for a sacado-provided "floor" and "ceil"?
// It is wrong to try to propagate the Sacado derivatives to the return
// value, as the floor and ceil functions have zero derivative w.r.t. any
// of the variables in the argument, except when X is an integer at which
// point the derivative is undefined.
template &lt;typename T&gt;
double ADMSfloor(const T &amp; x)
{
return (floor(x.val()));
}

template &lt;typename T&gt;
double ADMSceil(const T &amp; x)
{
return (ceil(x.val()));
}


  <admst:apply-templates select="." match="xyceDeclareTraits"/>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="instance"/>

//-----------------------------------------------------------------------------

  <admst:text format="// Class         : Instance\n"/>
//
// Purpose       : This class represents a single instance  of the
//                 device.  It mainly contains indices and pointers into
//                 the matrix equation (see the resistor instance class for
//                 more details).
//
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

  <admst:text format="class Instance : public DeviceInstance"/>
{
  friend class ParametricData&lt;Instance&gt;;
  friend class Model;
#ifdef Xyce_ADMS_SENSITIVITIES
  friend class InstanceSensitivity;
  friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
  friend struct Traits;

  public:
    Instance(
      const Configuration &amp;       configuration,
      const InstanceBlock &amp;       instance_block,
      Model &amp;                     model,
      const FactoryBlock &amp;        factory_block);

    ~Instance();

private:
    Instance(const Instance &amp;);
    Instance &amp;operator=(const Instance &amp;);

public:
    void registerLIDs( const LocalIdVector &amp; intLIDVecRef,
                       const LocalIdVector &amp; extLIDVecRef );
    void registerStoreLIDs( const LocalIdVector &amp; stoLIDVecRef );
    void setupPointers();

    void loadNodeSymbols(Util::SymbolTable &amp;symbol_table) const;

    const JacobianStamp &amp; jacobianStamp() const;
    void registerJacLIDs( const JacobianStamp &amp; jacLIDVec );

    void registerBranchDataLIDs(const std::vector&lt;int&gt; &amp; branchLIDVecRef);

    bool processParams();
    bool updateTemperature ( const double &amp; temp = -999.0 );
    bool updateIntermediateVars ();
    bool updatePrimaryState ();
    bool updateSecondaryState ();

    // load functions, residual:
    bool loadDAEQVector ();
    bool loadDAEFVector ();

    // load functions, Jacobian:
    bool loadDAEdQdx ();
    bool loadDAEdFdx ();

    <admst:if test="[count(node[#collapsible='yes'])>0]">
      void collapseNodes();
    </admst:if>

    <admst:if test="[count(/module/contribution[whitenoise='yes' or flickernoise='yes'])>0]">
      int getNumNoiseSources () const;  // %(count(/module/contribution[whitenoise='yes' or flickernoise='yes']))
      void setupNoiseSources (Xyce::Analysis::NoiseData &amp; noiseData);
      void getNoiseSources (Xyce::Analysis::NoiseData &amp; noiseData);
    </admst:if>

  private:

  public:
    // iterator reference to the %(name) model which owns this instance.
    // Getters and setters
    Model &amp;getModel()
    {
      return model_;
    }

  private:

    Model &amp; model_;   //&lt; Owning Model

    <admst:apply-templates select="." match="xyceDeclareInstanceVariables"/>
    <admst:apply-templates select="." match="xyceDeclareNodeLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareBranchLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareLeadBranchLIDVariables"/>
    <admst:apply-templates select="." match="xyceDeclareJacobianOffsets"/>
    <admst:apply-templates select="." match="xyceDeclareNodeConstants"/>
    <admst:apply-templates select="." match="xyceDeclareBranchConstants"/>
    <admst:apply-templates select="." match="xyceDeclareProbeConstants"/>
    <admst:apply-templates select="." match="xyceDeclareLimitedProbeStoreLIDs"/>
    <admst:apply-templates select="." match="declareCollapsibleBools"/>
    <admst:apply-templates select="." match="xyceDeclareFadArrays"/>

    <admst:if test="[count(contribution/[whitenoise='yes' or flickernoise='yes'])>0]">
      <admst:text format="//vectors to hold noise information for communication between methods\n"/>
      <admst:text format="std::vector&lt;double&gt; noiseContribsPower;\n"/>
      <admst:text format="std::vector&lt;double&gt; noiseContribsExponent;\n"/>
    </admst:if>

    <admst:if test="[count(@limitedProbes)>0]">
    // This array stores the differences between original and limited variables.
    std::vector&lt;double&gt; probeDiffs;
    // These store the Jdxp's for F and Q, respectively
    std::vector&lt;double&gt; Jdxp_static;
    std::vector&lt;double&gt; Jdxp_dynamic;
    </admst:if>

    // this is what we'll use when any model uses \$temperature.  We'll
    // set it in updateTemperature, and initialize it to whatever
    // is in devOptions when the instance is constructed.
    double admsTemperature;

    // vt at \$temperature;
    double adms_vt_nom;


    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" parameter to use
    double admsInstTemp;


    <admst:choose>
      <admst:when test="[count(node[#collapsible='yes'])=0]">
    static JacobianStamp jacStamp;
    static IdVector nodeMap;
    static PairMap pairToJacStampMap;
      </admst:when>
      <admst:otherwise>
    JacobianStamp jacStamp;
    IdVector nodeMap;
    PairMap pairToJacStampMap;
      </admst:otherwise>
    </admst:choose>

    // These instance-owned vectors are for storage of lead current data
    std::vector&lt;double&gt; leadCurrentF;
    std::vector&lt;double&gt; leadCurrentQ;
    };


<admst:if test="[exists(analogfunction)]">
  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="AF"/>

namespace AnalogFunctions
{
    <admst:variable name="globalMustUseTemplate" select="no"/>
    <admst:variable name="globalMustForceScalar" select="no"/>
    <admst:for-each select="analogfunction">

      // Analog Function %(name)

      <admst:variable name="skipFunctionPrecomp" select="y"/>
      <admst:apply-templates select="." match="xyceTemplatedAnalogFunctionDeclaration"/>
      <admst:apply-templates select="." match="xyceAnalogFunctions:Declaration"/>
      <admst:apply-templates select="." match="xyceAnalogFunctions:ClassDeclaration"/>
    </admst:for-each>
}


</admst:if>

  <!-- this GLOBAL VARIABLE (ugh) used in templates to figure out how to access
     certain class members (e.g. how to get at model variables from an instance
     -->
  <admst:variable name="globalCurrentScope" select="model"/>
//-----------------------------------------------------------------------------

    <admst:text format="// Class         : Model\n"/>
// Purpose       :
// Special Notes :
// Creator       :
// Creation Date :
//-----------------------------------------------------------------------------

    <admst:text format="class Model : public DeviceModel"/>
{
    typedef std::vector&lt;Instance *&gt; InstanceVector;

    friend class ParametricData&lt;Model&gt;;
    friend class Instance;
#ifdef Xyce_ADMS_SENSITIVITIES
    friend class InstanceSensitivity;
    friend class ModelSensitivity;
#endif // Xyce_ADMS_SENSITIVITIES
    friend struct Traits;

  public:
    Model(
      const Configuration &amp;       configuration,
      const ModelBlock &amp;          model_block,
      const FactoryBlock &amp;        factory_block);

    ~Model();

private:
    Model(const Model &amp;);
    Model &amp;operator=(const Model &amp;);

public:
    virtual void forEachInstance(DeviceInstanceOp &amp;op) const /* override */;
    virtual std::ostream &amp;printOutInstances(std::ostream &amp;os) const;
    bool processParams();
    bool processInstanceParams();

  private:

  public:
    void addInstance(Instance *instance)
    {
      instanceContainer.push_back(instance);
    }

    void setupBaseInstanceContainer()
    {
      std::vector&lt;Instance*&gt;::iterator iter = instanceContainer.begin();
      std::vector&lt;Instance*&gt;::iterator end   = instanceContainer.end();
      for ( ; iter!=end; ++iter)
      {
      Xyce::Device::DeviceModel::baseInstanceContainer.push_back( static_cast&lt;Xyce::Device::DeviceInstance *&gt;(*iter) );
    }
  }

  private:
    std::vector&lt;Instance*&gt; instanceContainer;

  private:

    // This one is for the annoying bogus "XyceADMSInstTemp" parameter
    // that we need so we can set it from the device manager when there's no
    // "TEMP" model parameter to use
    double admsModTemp;

    <admst:apply-templates select="." match="xyceDeclareModelVariables"/>
};

void registerDevice(const DeviceCountMap&amp; deviceMap = DeviceCountMap(),
                    const std::set&lt;int&gt;&amp; levelSet = std::set&lt;int&gt;());


<admst:text format="} // namespace %($nameSpace)"/>
} // namespace Device
} // namespace Xyce

<admst:text format="#endif //$guardSymbol\n"/>
  </admst:open>


</admst:for-each>
</admst>
